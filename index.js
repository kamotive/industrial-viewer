(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 253);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "C", function() { return /* reexport */ look_Look; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ core_Core; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* reexport */ InternalFormat; });
__webpack_require__.d(__webpack_exports__, "N", function() { return /* reexport */ PixelDataFormat; });
__webpack_require__.d(__webpack_exports__, "O", function() { return /* reexport */ PrimitiveType; });
__webpack_require__.d(__webpack_exports__, "R", function() { return /* reexport */ RenderQueueGroup; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ AttributeSemantic; });
__webpack_require__.d(__webpack_exports__, "B", function() { return /* reexport */ Loader; });
__webpack_require__.d(__webpack_exports__, "X", function() { return /* reexport */ resource_Resource; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ ClearMask; });
__webpack_require__.d(__webpack_exports__, "L", function() { return /* reexport */ OutputLayoutSemantic; });
__webpack_require__.d(__webpack_exports__, "Q", function() { return /* reexport */ RenderPassStatistics; });
__webpack_require__.d(__webpack_exports__, "S", function() { return /* reexport */ render_request_RenderRequest; });
__webpack_require__.d(__webpack_exports__, "V", function() { return /* reexport */ renderable_Renderable; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ dotScene_DotScene; });
__webpack_require__.d(__webpack_exports__, "Y", function() { return /* reexport */ scene_Scene; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ disposeableUsageCounter_DisposableUsageCounter; });
__webpack_require__.d(__webpack_exports__, "pb", function() { return /* reexport */ vertexBufferView_VertexBufferView; });
__webpack_require__.d(__webpack_exports__, "mb", function() { return /* reexport */ vertexAttribute_VertexAttribute; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ dataTypes_DataType; });
__webpack_require__.d(__webpack_exports__, "ub", function() { return /* reexport */ getDataTypeSize; });
__webpack_require__.d(__webpack_exports__, "tb", function() { return /* reexport */ getArrayTypeForDataType; });
__webpack_require__.d(__webpack_exports__, "nb", function() { return /* reexport */ VertexAttributeType; });
__webpack_require__.d(__webpack_exports__, "P", function() { return /* reexport */ renderBuffer_RenderBuffer; });
__webpack_require__.d(__webpack_exports__, "U", function() { return /* reexport */ renderTargetFramebuffer_RenderTargetFramebuffer; });
__webpack_require__.d(__webpack_exports__, "T", function() { return /* reexport */ renderTargetCube_RenderTargetCube; });
__webpack_require__.d(__webpack_exports__, "vb", function() { return /* reexport */ renderQueueSort; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ CustomImageData; });
__webpack_require__.d(__webpack_exports__, "hb", function() { return /* reexport */ texture_resource_TextureLevelData; });
__webpack_require__.d(__webpack_exports__, "gb", function() { return /* reexport */ texture_resource_Texture; });
__webpack_require__.d(__webpack_exports__, "ab", function() { return /* reexport */ ShaderChunks; });
__webpack_require__.d(__webpack_exports__, "W", function() { return /* reexport */ renderer_Renderer; });
__webpack_require__.d(__webpack_exports__, "sb", function() { return /* reexport */ webGLBaseMaterial_WebGLBaseMaterial; });
__webpack_require__.d(__webpack_exports__, "M", function() { return /* reexport */ pbrMeshMaterial_PbrMeshMaterial; });
__webpack_require__.d(__webpack_exports__, "lb", function() { return /* reexport */ unlitMeshMaterial_UnlitMeshMaterial; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* reexport */ environmentMaterial_EnvironmentMaterial; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ convolutionMaterial_ConvolutionMaterial; });
__webpack_require__.d(__webpack_exports__, "db", function() { return /* reexport */ spriteMaterial_SpriteMaterial; });
__webpack_require__.d(__webpack_exports__, "z", function() { return /* reexport */ lineMaterial_LineMaterial; });
__webpack_require__.d(__webpack_exports__, "E", function() { return /* reexport */ materialFactory_MaterialFactory; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ animation_system_AnimationSystem; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ camera_system_CameraSystem; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ cube_camera_system_CubeCameraSystem; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ draw_system_DrawSystem; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* reexport */ input_system_InputSystem; });
__webpack_require__.d(__webpack_exports__, "x", function() { return /* reexport */ light_system_LightSystem; });
__webpack_require__.d(__webpack_exports__, "A", function() { return /* reexport */ line_system_LineSystem; });
__webpack_require__.d(__webpack_exports__, "G", function() { return /* reexport */ mesh_system_MeshSystem; });
__webpack_require__.d(__webpack_exports__, "K", function() { return /* reexport */ orbit_system_OrbitSystem; });
__webpack_require__.d(__webpack_exports__, "Z", function() { return /* reexport */ screen_system_ScreenSystem; });
__webpack_require__.d(__webpack_exports__, "eb", function() { return /* reexport */ sprite_system_SpriteSystem; });
__webpack_require__.d(__webpack_exports__, "ib", function() { return /* reexport */ time_system_TimeSystem; });
__webpack_require__.d(__webpack_exports__, "kb", function() { return /* reexport */ transform_system_TransformSystem; });
__webpack_require__.d(__webpack_exports__, "rb", function() { return /* reexport */ visibility_system_VisibilitySystem; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ bone_Bone; });
__webpack_require__.d(__webpack_exports__, "bb", function() { return /* reexport */ skeleton_Skeleton; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ animation_Animation; });
__webpack_require__.d(__webpack_exports__, "J", function() { return /* reexport */ node_animation_NodeAnimation; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ camera_component_Camera; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ cube_camera_component_CubeCamera; });
__webpack_require__.d(__webpack_exports__, "w", function() { return /* reexport */ light_Light; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ ambient_light_AmbientLight; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ directional_light_DirectionalLight; });
__webpack_require__.d(__webpack_exports__, "y", function() { return /* reexport */ line_component_Line; });
__webpack_require__.d(__webpack_exports__, "fb", function() { return /* reexport */ mesh_component_SubMesh; });
__webpack_require__.d(__webpack_exports__, "F", function() { return /* reexport */ mesh_component_Mesh; });
__webpack_require__.d(__webpack_exports__, "I", function() { return /* reexport */ morph_component_MorphTargetData; });
__webpack_require__.d(__webpack_exports__, "H", function() { return /* reexport */ morph_component_Morph; });
__webpack_require__.d(__webpack_exports__, "cb", function() { return /* reexport */ sprite_component_Sprite; });
__webpack_require__.d(__webpack_exports__, "jb", function() { return /* reexport */ transform_component_Transform; });
__webpack_require__.d(__webpack_exports__, "qb", function() { return /* reexport */ visibility_component_Visibility; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* reexport */ geometry_resource_Geometry; });
__webpack_require__.d(__webpack_exports__, "D", function() { return /* reexport */ material_Material; });
__webpack_require__.d(__webpack_exports__, "ob", function() { return /* reexport */ vertex_buffer_resource_VertexBuffer; });

// UNUSED EXPORTS: BlendEquation, BlendFactor, SystemTaskType, SystemTask, System, Component, InstancedBatch, BaseScene, SceneNode, EntityManager, ComponentStorage, DefaultComponentStorage, getVertexAttributeCountComponents, interpolate, RenderTarget, RenderTargetCanvas, RenderTargetAttachment, getAttributeSemanticName, BatchRenderable, InstanceDataManager, SpatialIndex, spatialIndexFrustumCull, OctreeSpatialIndex, WrappingMode, BindingPoint, Filter, CompareMode, getTextureBindingPointName, WebGLBuffer, WebGLExtensions, WebGLCapabilities, WebGLAttributes, WebGLTextures, WebGLPrograms, UniformsContainer, BasicTypeUniform, ArrayUniform, StructUniform, WebGLUniforms, WebGLRenderBuffers, WebGLFramebuffers, WebGLContextType, hasWebGL2Support, testWebGLContext, WebGLPowerPreferenceType, WebGLBlendingType, DepthFunction, FrontFace, WebGLState, ShaderLib, DepthMaterial, CopyMaterial, ShaderExtensionBehaviour, RenderTechnique, applyClipper, reflect, Pointer, MorphSystem, Interpolation, Channel, CameraProjectionType, temperatureToHue, illuminanceToLuminance, luminousIntensityToScalarIlluminance, computeLightProperties, updateLightPositionAndDirection, SpotLight, PointLight, LightShadowCaster, LineRenderable, Orbit, SpriteRenderable, ImageLoader, JSONLoader, AlphaMode, CullFace, TextureProperties, TextureArrayProperties, NormalMapProperties, NormalMapFromArrayProperties, AOMapProperties, AOMapFromArrayProperties, EnvironmentMapProperties, EmissiveMapProperties, EmissiveMapFromArrayProperties

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var lib = __webpack_require__(1);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/event/index.js
var _wgetemp_event = __webpack_require__(13);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/ECS/componentStorage.js
class ComponentStorage {
  constructor(entityManager, componentClass) {
    this._componentClass = componentClass;
    this._entityManager = entityManager;
    this._entities = [];
  }

  add(entity, component) {
    return 0;
  }

  has(index) {
    return true;
  }

  delete(index) {}

  get(index) {
    return null;
  }

  getEntity(component) {
    return null;
  }

  components() {
    return [];
  }

  entries() {
    return [];
  }

  dispose() {}

  get count() {
    return 0;
  }

  get componentClass() {
    return this._componentClass;
  }

  get entityManager() {
    return this._entityManager;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/ECS/defaultComponentStorage.js


class _ComponentIterator {
  constructor(components, countComponents) {
    this._components = components;
    this._result = {
      done: false,
      value: null
    };
    this._current = 0;
    this._componentCounter = 0;
    this._countComponents = countComponents;
  }

  [Symbol.iterator]() {
    return this;
  }

  next() {
    const _components = this._components,
          _countComponents = this._countComponents,
          _result = this._result,
          _componentCounter = this._componentCounter;
    const len = _components.length;
    if (_result.done = _componentCounter >= _countComponents || this._current >= len) return _result;

    for (let i = this._current; i < len;) {
      const component = _components[i++];

      if (component === null) {
        continue;
      }

      _result.value = component;
      this._current = i;
      break;
    }

    this._componentCounter++;
    return _result;
  }

}

class _EntryIterator {
  constructor(components, countComponents, entities) {
    this._components = components;
    this._result = {
      done: false,
      value: [null, null]
    };
    this._current = 0;
    this._componentCounter = 0;
    this._countComponents = countComponents;
    this._entities = entities;
  }

  [Symbol.iterator]() {
    return this;
  }

  next() {
    const _components = this._components,
          _countComponents = this._countComponents,
          _result = this._result,
          _componentCounter = this._componentCounter,
          _entities = this._entities;
    const len = _components.length;
    if (_result.done = _componentCounter >= _countComponents || this._current >= len) return _result;

    for (let i = this._current; i < len;) {
      const entity = _entities[i];
      const component = _components[i++];

      if (component === null || entity === null) {
        continue;
      }

      _result.value[0] = entity;
      _result.value[1] = component;
      this._current = i;
      break;
    }

    this._componentCounter++;
    return _result;
  }

}

class defaultComponentStorage_DefaultComponentStorage extends ComponentStorage {
  constructor(entityManager, componentClass) {
    super(entityManager, componentClass);
    this._components = [];
    this._freeComponents = [];
    this._countComponents = 0;
  }

  add(entity, component) {
    const _freeComponents = this._freeComponents,
          _components = this._components,
          _entities = this._entities;
    const index = _freeComponents.length > 0 ? _freeComponents.pop() : _components.length;
    _components[index] = component;
    _entities[index] = entity;
    this._countComponents++;
    return index;
  }

  has(index) {
    const _components = this._components,
          _componentClass = this._componentClass;
    return index < _components.length && _components[index] instanceof _componentClass;
  }

  _delete(index) {
    const _freeComponents = this._freeComponents,
          _components = this._components,
          _entities = this._entities;
    _components[index] = null;
    _entities[index] = null;

    _freeComponents.push(index);

    this._countComponents--;
  }

  delete(index) {
    if (false) {}

    this._delete(index);
  }

  get(index) {
    return this._components[index];
  }

  getEntity(component) {
    const _components = this._components,
          _entities = this._entities;

    const index = _components.indexOf(component);

    return index >= 0 ? _entities[index] : null;
  }

  components() {
    return new _ComponentIterator(this._components, this._countComponents);
  }

  entries() {
    return new _EntryIterator(this._components, this._countComponents, this._entities);
  }

  dispose() {
    for (const c of this.components()) {
      c.release();
    }

    this._components.length = 0;
    this._freeComponents.length = 0;
    this._countComponents = 0;
  }

  get count() {
    return this._countComponents;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/disposeableUsageCounter.js

class disposeableUsageCounter_DisposableUsageCounter {
  constructor() {
    this._useCount = 1;
    this._loadCount = 1;
    this._loadRequests = [];
    this._unloadRequestCount = 0;

    this._actuallyLoad = () => {};
  }

  retain() {
    if (false) {}

    ++this._useCount;
    return this;
  }

  release() {
    if (false) {}

    if (--this._useCount === 0) {
      this._dispose();
    }
  }

  _dispose() {
    this._emitDisposeEvent();
  }

  async _loadDependencies() {}

  _actuallyUnload() {
    this._emitUnloadEvent();
  }

  load(amount = 1) {
    return new Promise((resolve, reject) => {
      if (this._loadCount > 0) {
        this._loadCount += amount;
        resolve(this);
        return;
      }

      this._loadRequests.push({
        resolve,
        reject,
        amount
      });

      if (this._loadRequests.length === 1) {
        (async () => {
          await this._loadDependencies();
          await this._actuallyLoad();
        })().then(() => {
          for (const _ref of this._loadRequests) {
            const loadResolve = _ref.resolve;
            const loadAmount = _ref.amount;
            this._loadCount += loadAmount;
            loadResolve(this);
          }

          this._loadRequests.length = 0;

          this._emitLoadEvent();

          this._loadCount -= this._unloadRequestCount;
          this._unloadRequestCount = 0;

          if (this._loadCount === 0) {
            this._actuallyUnload();
          }
        }).catch(error => {
          for (const _ref2 of this._loadRequests) {
            const loadReject = _ref2.reject;
            loadReject(error);
          }

          this._loadRequests.length = 0;
          this._unloadRequestCount = 0;
        });
      }
    });
  }

  unload(amount = 1) {
    if (false) {}

    if (this.loading) {
      this._unloadRequestCount += amount;
    } else {
      this._loadCount -= amount;

      if (this._loadCount === 0) {
        this._actuallyUnload();
      }
    }
  }

  resetEvents() {
    delete this._onLoad;
    delete this._onUnload;
    delete this._onDispose;
  }

  get unloaded() {
    return this._loadCount === 0;
  }

  get loading() {
    return this._loadRequests.length > 0;
  }

  get onUnload() {
    if (this._onUnload === undefined) {
      this._onUnload = new _wgetemp_event["a" /* Event */]();
    }

    return this._onUnload;
  }

  get onLoad() {
    if (this._onLoad === undefined) {
      this._onLoad = new _wgetemp_event["a" /* Event */]();
    }

    return this._onLoad;
  }

  get onDispose() {
    if (this._onDispose === undefined) {
      this._onDispose = new _wgetemp_event["a" /* Event */]();
    }

    return this._onDispose;
  }

  _emitLoadEvent() {
    if (this._onLoad !== undefined) {
      this._onLoad.emit();
    }
  }

  _emitUnloadEvent() {
    if (this._onUnload !== undefined) {
      this._onUnload.emit();
    }
  }

  _emitDisposeEvent() {
    if (this._onDispose !== undefined) {
      this._onDispose.emit();
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/component.js


class component_Component extends disposeableUsageCounter_DisposableUsageCounter {
  constructor() {
    super(...arguments);
    this.state = 1;
    this.enabled = true;
  }

  get mask() {
    return this.constructor.mask;
  }

  get index() {
    return this.constructor.index;
  }

  get maskIndex() {
    return this.constructor.maskIndex;
  }

  static get storageClass() {
    return defaultComponentStorage_DefaultComponentStorage;
  }

}
component_Component.ID = '';
component_Component.ENABLED = 1;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/camera-component/index.js



var CameraProjectionType;

(function (CameraProjectionType) {
  CameraProjectionType[CameraProjectionType["NONE"] = 0] = "NONE";
  CameraProjectionType[CameraProjectionType["ORTHOGRAPHIC"] = 1] = "ORTHOGRAPHIC";
  CameraProjectionType[CameraProjectionType["PERSPECTIVE"] = 2] = "PERSPECTIVE";
  CameraProjectionType[CameraProjectionType["MIXED"] = 3] = "MIXED";
})(CameraProjectionType || (CameraProjectionType = {}));

class camera_component_Camera extends component_Component {
  constructor({
    name = '',
    zfar = 2000.0,
    znear = 1.0,
    clipper = null,
    reflected = false,
    orthographicProjection = {},
    perspectiveProjection = {},
    aperture = 16,
    shutterSpeed = 1 / 125,
    ISO = 100,
    expComp = 0,
    projectionType = camera_component_Camera.ProjectionTypes.PERSPECTIVE
  }) {
    super();
    this.name = name;
    this.viewMatrix = new lib["b" /* AffineMatrix3 */]();
    this.worldMatrix = new lib["b" /* AffineMatrix3 */]();
    this.projectionMatrix = new lib["g" /* HomogeneousMatrix3 */]();
    this.viewProjectionMatrix = new lib["g" /* HomogeneousMatrix3 */]();
    const _perspectiveProjectio = perspectiveProjection.aspect,
          aspect = _perspectiveProjectio === void 0 ? 1.0 : _perspectiveProjectio,
          _perspectiveProjectio2 = perspectiveProjection.yfov,
          yfov = _perspectiveProjectio2 === void 0 ? 0.785 : _perspectiveProjectio2;
    const _orthographicProjecti = orthographicProjection.xmag,
          xmag = _orthographicProjecti === void 0 ? 1.0 : _orthographicProjecti,
          _orthographicProjecti2 = orthographicProjection.ymag,
          ymag = _orthographicProjecti2 === void 0 ? 1.0 : _orthographicProjecti2;
    this.zfar = zfar;
    this.znear = znear;
    this.clipper = clipper === null ? null : clipper.clone();
    this.reflected = reflected;
    this.aspect = aspect;
    this.yfov = yfov;
    this.xmag = xmag;
    this.ymag = ymag;
    this.exposure = 1;
    this.EV100 = 1;
    this.projectionType = projectionType;
    this.needsUpdateProjection = true;
    this.lastFrameUpdate = 0;
    this.setEV100({
      aperture,
      shutterSpeed,
      ISO,
      expComp
    });
    this.aperture = aperture;
    this.shutterSpeed = shutterSpeed;
    this.ISO = ISO;
    this.expComp = expComp;
    this.onEarlyUpdateStart = new _wgetemp_event["a" /* Event */]();
    this.onEarlyUpdateEnd = new _wgetemp_event["a" /* Event */]();
    this.onLateUpdateEnd = new _wgetemp_event["a" /* Event */]();
  }

  setEV100({
    aperture,
    shutterSpeed,
    ISO = 100,
    expComp = 0
  }) {
    this.EV100 = Math.log2(aperture ** 2 / shutterSpeed * 100 / ISO) - expComp;
    const maxLuminance = 2 ** (this.EV100 - 3);
    this.exposure = 1 / maxLuminance;
    this.aperture = aperture;
    this.shutterSpeed = shutterSpeed;
    this.ISO = ISO;
    this.expComp = expComp;
  }

  clone() {
    const name = this.name,
          zfar = this.zfar,
          znear = this.znear,
          clipper = this.clipper,
          reflected = this.reflected,
          aspect = this.aspect,
          yfov = this.yfov,
          xmag = this.xmag,
          ymag = this.ymag,
          projectionType = this.projectionType,
          aperture = this.aperture,
          shutterSpeed = this.shutterSpeed,
          ISO = this.ISO,
          expComp = this.expComp;
    const perspectiveProjection = {
      aspect,
      yfov
    };
    const orthographicProjection = {
      xmag,
      ymag
    };
    return new camera_component_Camera({
      name,
      zfar,
      znear,
      clipper,
      reflected,
      orthographicProjection,
      perspectiveProjection,
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType
    });
  }

}
camera_component_Camera.ID = 'camera';
camera_component_Camera.ProjectionTypes = CameraProjectionType;
camera_component_Camera.prototype.isCamera = true;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/look.js


class look_Look {
  constructor() {
    this.cubeSideIndex = 0;
    this.aspect = 0;
    this.yfov = 0;
    this.zfar = 0;
    this.znear = 0;
    this.exposure = 0;
    this.worldMatrix = new lib["b" /* AffineMatrix3 */]();
    this.projectionMatrix = new lib["g" /* HomogeneousMatrix3 */]();
    this.projectionType = CameraProjectionType.PERSPECTIVE;
    this.viewMatrices = Array(...Array(6)).map(() => {
      return new lib["b" /* AffineMatrix3 */]();
    });
    this.viewProjectionMatrices = Array(...Array(6)).map(() => {
      return new lib["g" /* HomogeneousMatrix3 */]();
    });
    this.isCamera = true;
    this.isCubeCamera = false;
  }

  get viewMatrix() {
    const viewMatrices = this.viewMatrices,
          cubeSideIndex = this.cubeSideIndex;
    return viewMatrices[cubeSideIndex];
  }

  get viewProjectionMatrix() {
    const viewProjectionMatrices = this.viewProjectionMatrices,
          cubeSideIndex = this.cubeSideIndex;
    return viewProjectionMatrices[cubeSideIndex];
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/system.js
var SystemTaskType;

(function (SystemTaskType) {
  SystemTaskType[SystemTaskType["MERGE_COPY"] = 0] = "MERGE_COPY";
  SystemTaskType[SystemTaskType["SPLIT_COPY"] = 1] = "SPLIT_COPY";
})(SystemTaskType || (SystemTaskType = {}));

class SystemTask {
  constructor(type, resolve) {
    this.type = type;
    this.resolve = resolve;
    this.data = {};
    this.output = {};
  }

  static get TaskType() {
    return SystemTaskType;
  }

}
class System {
  constructor() {
    this.state = 0x01;
    this.enabled = true;
  }

  updateScene(task) {}

}
System.ID = '';
System.ENABLED = 0x01;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/core.js

const DEFAULT_EVENTS = ['onStart', 'onUpdate', 'onLateUpdate', 'onDraw', 'onEnd'];
class core_Core {
  constructor(options) {
    this._loopFlag = false;
    this._systems = new Map();
    this._loaders = new Map();
    this._resources = new Map();
    this._components = new Map();
    this._systemEvents = new Map();
    this.time = 0;
    this.frame = 0;
    this.renderRequests = [];

    this.mainLoop = time => {
      if (this._loopFlag) {
        this.drawFrame(time);
      }

      requestAnimationFrame(this.mainLoop);
    };

    this.domContainer = options.domContainer;
    this.renderer = options.renderer;
    this._mainEvents = options.events || DEFAULT_EVENTS;
    this.renderer.canvas.style.outline = 'none';
    this.domContainer.appendChild(this.renderer.canvas);
    this.mainLoop(0);
  }

  regLoader(loader) {
    const ClassConstructor = loader.constructor;
    const id = ClassConstructor.ID;

    if (id === '') {
      throw new Error('Id is empty');
    }

    if (this._loaders.has(id)) {
      throw new Error(`Loader with id: ${id} already registry`);
    }

    this._loaders.set(id, loader);

    this._loaders.set(ClassConstructor, loader);
  }

  getLoader(id) {
    const loader = this._loaders.get(id);

    if (loader === undefined) {
      throw new Error(`Loader: ${id} not found`);
    }

    return loader;
  }

  regResource(type, typeClass) {
    if (this._resources.has(type)) {
      throw new Error(`Resource type: ${type} already used`);
    }

    this._resources.set(type, {
      typeClass,
      map: new Map()
    });
  }

  addResource(type, id, resource) {
    const resType = this._resources.get(type);

    if (resType === undefined) {
      throw new Error(`Resource type: ${type} not exist`);
    }

    if (!(resource instanceof resType.typeClass)) {
      throw new Error('Incorrect resource type');
    }

    resType.map.set(id, resource);
  }

  delResource(type, id) {
    const resType = this._resources.get(type);

    if (resType === undefined) {
      throw new Error(`Resource type: ${type} not exist`);
    }

    resType.map.delete(id);
  }

  hasResource(type, id) {
    const resType = this._resources.get(type);

    if (resType === undefined) {
      throw new Error(`Resource type: ${type} not exist`);
    }

    return resType.map.has(id);
  }

  getResource(type, id) {
    const resType = this._resources.get(type);

    if (resType === undefined) {
      throw new Error(`Resource type: ${type} not exist`);
    }

    const resource = resType.map.get(id);

    if (resource === undefined) {
      throw new Error(`Resource: ${id} not found`);
    }

    return resource;
  }

  getResourceMap(type) {
    const resType = this._resources.get(type);

    if (resType === undefined) {
      throw new Error(`Resource type: ${type} not exist`);
    }

    return resType.map;
  }

  async loadResource(loaderId, id, url, options) {
    const loader = this.getLoader(loaderId);
    const data = await loader.load(url, options);
    const resource = await loader.parse(id, data, options);
    await loader.conf(id, resource, options);
    return resource;
  }

  async parseResource(loaderId, id, data, options) {
    const loader = this.getLoader(loaderId);
    const resource = await loader.parse(id, data, options);
    await loader.conf(id, resource, options);
    return resource;
  }

  regSystem(system) {
    const ClassConstructor = system.constructor;
    const id = ClassConstructor.ID;

    if (id === '') {
      throw new Error('Id is empty');
    }

    if (this._systems.has(id)) {
      throw new Error(`System with id: ${id} already registry`);
    }

    this._systems.set(id, system);

    this._systems.set(ClassConstructor, system);
  }

  getSystem(id) {
    const system = this._systems.get(id);

    if (system === undefined) {
      throw new Error(`System: ${id} not exist`);
    }

    return system;
  }

  getSystemIdList() {
    const returnSet = new Set();

    for (const key of this._systems.keys()) {
      if (typeof key === 'string') {
        returnSet.add(key);
      }
    }

    return returnSet;
  }

  regSystemEvent(event, system, priority = 0) {
    let systemEvents = this._systemEvents.get(event);

    if (systemEvents === undefined) {
      systemEvents = [];

      this._systemEvents.set(event, systemEvents);
    }

    systemEvents.push({
      priority,
      system
    });
    systemEvents.sort((a, b) => a.priority - b.priority);
  }

  fireSystemEvent(event, systems = null) {
    const systemEvents = this._systemEvents.get(event);

    if (systemEvents === undefined) {
      return;
    }

    for (const cell of systemEvents) {
      if (systems && !systems.has(cell.system.constructor.ID)) {
        continue;
      }

      if (cell.system.enabled) {
        cell.system[event](this);
      }
    }
  }

  regComponent(ComponentClass) {
    const id = ComponentClass.ID;

    if (id === '') {
      throw new Error('Id is empty');
    }

    if (this._components.has(id)) {
      throw new Error(`Component with id: ${id} already registry`);
    }

    this._components.set(id, ComponentClass);
  }

  getComponentClassList() {
    return new Set(this._components.values());
  }

  drawFrame(time) {
    this.time = time;
    this.frame++;
    this.fireSystemEvent('onFrameStart');

    for (const request of this.renderRequests) {
      if (!request.enabled) {
        continue;
      }

      this.currentRequest = request;

      if ('isScene' in request.scene) {
        this._updateScene(request.scene);
      }

      for (const event of this._mainEvents) {
        this.fireSystemEvent(event, request.systems);
      }
    }

    this.fireSystemEvent('onFrameEnd');
  }

  start() {
    this._loopFlag = true;
    this.time = performance.now() * 0.001;
    this.fireSystemEvent('onLoopStart');
  }

  stop() {
    this._loopFlag = false;
    this.fireSystemEvent('onLoopStop');
  }

  _updateScene(scene) {
    const _systems = this._systems;
    const _deferredTasks = scene._deferredTasks;

    while (_deferredTasks.length > 0) {
      const task = _deferredTasks.pop();

      if (task.type === SystemTaskType.MERGE_COPY) {
        const data = task.data;
        const srcScene = data.srcScene,
              dstNode = data.dstNode,
              copyContext = data.copyContext;
        const root = srcScene.root;
        const children = root.children;

        for (const child of children) {
          dstNode._adoptForeignNode(child, copyContext);
        }
      }

      for (const system of _systems.values()) {
        system.updateScene(task);
      }

      const resolve = task.resolve,
            output = task.output;
      resolve(output);
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/enums.js
var BlendEquation;

(function (BlendEquation) {
  BlendEquation[BlendEquation["FUNC_ADD"] = 32774] = "FUNC_ADD";
  BlendEquation[BlendEquation["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  BlendEquation[BlendEquation["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
})(BlendEquation || (BlendEquation = {}));

var BlendFactor;

(function (BlendFactor) {
  BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
  BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
  BlendFactor[BlendFactor["SRC_COLOR"] = 768] = "SRC_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  BlendFactor[BlendFactor["DST_COLOR"] = 774] = "DST_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  BlendFactor[BlendFactor["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  BlendFactor[BlendFactor["DST_ALPHA"] = 772] = "DST_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  BlendFactor[BlendFactor["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(BlendFactor || (BlendFactor = {}));

var InternalFormat;

(function (InternalFormat) {
  InternalFormat[InternalFormat["RGB"] = 6407] = "RGB";
  InternalFormat[InternalFormat["RGBA"] = 6408] = "RGBA";
  InternalFormat[InternalFormat["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  InternalFormat[InternalFormat["LUMINANCE"] = 6409] = "LUMINANCE";
  InternalFormat[InternalFormat["ALPHA"] = 6406] = "ALPHA";
  InternalFormat[InternalFormat["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  InternalFormat[InternalFormat["R8"] = 33321] = "R8";
  InternalFormat[InternalFormat["R16F"] = 33325] = "R16F";
  InternalFormat[InternalFormat["R32F"] = 33326] = "R32F";
  InternalFormat[InternalFormat["R8UI"] = 33330] = "R8UI";
  InternalFormat[InternalFormat["RG8"] = 33323] = "RG8";
  InternalFormat[InternalFormat["RG16F"] = 33327] = "RG16F";
  InternalFormat[InternalFormat["RG32F"] = 33328] = "RG32F";
  InternalFormat[InternalFormat["RG8UI"] = 33336] = "RG8UI";
  InternalFormat[InternalFormat["RGB8"] = 32849] = "RGB8";
  InternalFormat[InternalFormat["SRGB8"] = 35905] = "SRGB8";
  InternalFormat[InternalFormat["RGB565"] = 36194] = "RGB565";
  InternalFormat[InternalFormat["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
  InternalFormat[InternalFormat["RGB9_E5"] = 35901] = "RGB9_E5";
  InternalFormat[InternalFormat["RGB16F"] = 34843] = "RGB16F";
  InternalFormat[InternalFormat["RGB32F"] = 34837] = "RGB32F";
  InternalFormat[InternalFormat["RGB8UI"] = 36221] = "RGB8UI";
  InternalFormat[InternalFormat["RGBA8"] = 32856] = "RGBA8";
  InternalFormat[InternalFormat["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  InternalFormat[InternalFormat["RGB5_A1"] = 32855] = "RGB5_A1";
  InternalFormat[InternalFormat["RGB10_A2"] = 32857] = "RGB10_A2";
  InternalFormat[InternalFormat["RGBA4"] = 32854] = "RGBA4";
  InternalFormat[InternalFormat["RGBA16F"] = 34842] = "RGBA16F";
  InternalFormat[InternalFormat["RGBA32F"] = 34836] = "RGBA32F";
  InternalFormat[InternalFormat["RGBA8UI"] = 36220] = "RGBA8UI";
  InternalFormat[InternalFormat["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  InternalFormat[InternalFormat["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  InternalFormat[InternalFormat["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
  InternalFormat[InternalFormat["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
  InternalFormat[InternalFormat["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
  InternalFormat[InternalFormat["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
  InternalFormat[InternalFormat["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
})(InternalFormat || (InternalFormat = {}));

var PixelDataFormat;

(function (PixelDataFormat) {
  PixelDataFormat[PixelDataFormat["RGB"] = 6407] = "RGB";
  PixelDataFormat[PixelDataFormat["RGBA"] = 6408] = "RGBA";
  PixelDataFormat[PixelDataFormat["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  PixelDataFormat[PixelDataFormat["LUMINANCE"] = 6409] = "LUMINANCE";
  PixelDataFormat[PixelDataFormat["ALPHA"] = 6406] = "ALPHA";
  PixelDataFormat[PixelDataFormat["RED"] = 6403] = "RED";
  PixelDataFormat[PixelDataFormat["RED_INTEGER"] = 36244] = "RED_INTEGER";
  PixelDataFormat[PixelDataFormat["RG"] = 33319] = "RG";
  PixelDataFormat[PixelDataFormat["RG_INTEGER"] = 33320] = "RG_INTEGER";
  PixelDataFormat[PixelDataFormat["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  PixelDataFormat[PixelDataFormat["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  PixelDataFormat[PixelDataFormat["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  PixelDataFormat[PixelDataFormat["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(PixelDataFormat || (PixelDataFormat = {}));

var PrimitiveType;

(function (PrimitiveType) {
  PrimitiveType[PrimitiveType["POINTS"] = 0] = "POINTS";
  PrimitiveType[PrimitiveType["LINES"] = 1] = "LINES";
  PrimitiveType[PrimitiveType["LINE_LOOP"] = 2] = "LINE_LOOP";
  PrimitiveType[PrimitiveType["LINE_STRIP"] = 3] = "LINE_STRIP";
  PrimitiveType[PrimitiveType["TRIANGLES"] = 4] = "TRIANGLES";
  PrimitiveType[PrimitiveType["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  PrimitiveType[PrimitiveType["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(PrimitiveType || (PrimitiveType = {}));

var RenderQueueGroup;

(function (RenderQueueGroup) {
  RenderQueueGroup[RenderQueueGroup["EARLIEST"] = 0] = "EARLIEST";
  RenderQueueGroup[RenderQueueGroup["BACKGROUND"] = 100] = "BACKGROUND";
  RenderQueueGroup[RenderQueueGroup["ENV_EARLY"] = 200] = "ENV_EARLY";
  RenderQueueGroup[RenderQueueGroup["MAIN_EARLY"] = 300] = "MAIN_EARLY";
  RenderQueueGroup[RenderQueueGroup["MAIN"] = 400] = "MAIN";
  RenderQueueGroup[RenderQueueGroup["MAIN_LATE"] = 500] = "MAIN_LATE";
  RenderQueueGroup[RenderQueueGroup["ENV_LATE"] = 600] = "ENV_LATE";
  RenderQueueGroup[RenderQueueGroup["LENS_FLARES"] = 700] = "LENS_FLARES";
  RenderQueueGroup[RenderQueueGroup["SPRITES"] = 800] = "SPRITES";
  RenderQueueGroup[RenderQueueGroup["OVERLAYS"] = 900] = "OVERLAYS";
  RenderQueueGroup[RenderQueueGroup["LATEST"] = Infinity] = "LATEST";
})(RenderQueueGroup || (RenderQueueGroup = {}));

var AttributeSemantic;

(function (AttributeSemantic) {
  AttributeSemantic[AttributeSemantic["NONE"] = 0] = "NONE";
  AttributeSemantic[AttributeSemantic["POSITION"] = 1] = "POSITION";
  AttributeSemantic[AttributeSemantic["NORMAL"] = 2] = "NORMAL";
  AttributeSemantic[AttributeSemantic["TANGENT"] = 3] = "TANGENT";
  AttributeSemantic[AttributeSemantic["BITANGENT"] = 4] = "BITANGENT";
  AttributeSemantic[AttributeSemantic["COLOR"] = 5] = "COLOR";
  AttributeSemantic[AttributeSemantic["BONE_INDICES"] = 6] = "BONE_INDICES";
  AttributeSemantic[AttributeSemantic["BONE_WEIGHTS"] = 7] = "BONE_WEIGHTS";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_0"] = 8] = "TEX_COORD_CHANNEL_0";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_1"] = 9] = "TEX_COORD_CHANNEL_1";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_2"] = 10] = "TEX_COORD_CHANNEL_2";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_3"] = 11] = "TEX_COORD_CHANNEL_3";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_4"] = 12] = "TEX_COORD_CHANNEL_4";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_5"] = 13] = "TEX_COORD_CHANNEL_5";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_6"] = 14] = "TEX_COORD_CHANNEL_6";
  AttributeSemantic[AttributeSemantic["TEX_COORD_CHANNEL_7"] = 15] = "TEX_COORD_CHANNEL_7";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_0"] = 16] = "POSITION_MORPH_0";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_1"] = 17] = "POSITION_MORPH_1";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_2"] = 18] = "POSITION_MORPH_2";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_3"] = 19] = "POSITION_MORPH_3";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_4"] = 20] = "POSITION_MORPH_4";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_5"] = 21] = "POSITION_MORPH_5";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_6"] = 22] = "POSITION_MORPH_6";
  AttributeSemantic[AttributeSemantic["POSITION_MORPH_7"] = 23] = "POSITION_MORPH_7";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_0"] = 24] = "NORMAL_MORPH_0";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_1"] = 25] = "NORMAL_MORPH_1";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_2"] = 26] = "NORMAL_MORPH_2";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_3"] = 27] = "NORMAL_MORPH_3";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_4"] = 28] = "NORMAL_MORPH_4";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_5"] = 29] = "NORMAL_MORPH_5";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_6"] = 30] = "NORMAL_MORPH_6";
  AttributeSemantic[AttributeSemantic["NORMAL_MORPH_7"] = 31] = "NORMAL_MORPH_7";
  AttributeSemantic[AttributeSemantic["CUSTOM_0"] = 32] = "CUSTOM_0";
  AttributeSemantic[AttributeSemantic["CUSTOM_1"] = 33] = "CUSTOM_1";
  AttributeSemantic[AttributeSemantic["CUSTOM_2"] = 34] = "CUSTOM_2";
  AttributeSemantic[AttributeSemantic["CUSTOM_3"] = 35] = "CUSTOM_3";
  AttributeSemantic[AttributeSemantic["CUSTOM_4"] = 36] = "CUSTOM_4";
  AttributeSemantic[AttributeSemantic["INSTANCE_IDENTIFIERS"] = 37] = "INSTANCE_IDENTIFIERS";
  AttributeSemantic[AttributeSemantic["INSTANCE_TRANSFORM_1"] = 38] = "INSTANCE_TRANSFORM_1";
  AttributeSemantic[AttributeSemantic["INSTANCE_TRANSFORM_2"] = 39] = "INSTANCE_TRANSFORM_2";
  AttributeSemantic[AttributeSemantic["INSTANCE_TRANSFORM_3"] = 40] = "INSTANCE_TRANSFORM_3";
  AttributeSemantic[AttributeSemantic["INSTANCE_CUSTOM_0"] = 41] = "INSTANCE_CUSTOM_0";
  AttributeSemantic[AttributeSemantic["INSTANCE_CUSTOM_1"] = 42] = "INSTANCE_CUSTOM_1";
  AttributeSemantic[AttributeSemantic["INSTANCE_CUSTOM_2"] = 43] = "INSTANCE_CUSTOM_2";
  AttributeSemantic[AttributeSemantic["INSTANCE_CUSTOM_3"] = 44] = "INSTANCE_CUSTOM_3";
  AttributeSemantic[AttributeSemantic["INSTANCE_CUSTOM_4"] = 45] = "INSTANCE_CUSTOM_4";
})(AttributeSemantic || (AttributeSemantic = {}));
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/loader.js
class Loader {
  constructor(core) {
    this.core = core;
  }

  async load(url, options) {
    const data = await new Promise((response, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.responseType = (options === null || options === void 0 ? void 0 : options.responseType) || 'json';
      xhr.open('GET', url, true);

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          response(xhr.response);
        } else {
          reject(new Error(`Request '${url}' error, status ${xhr.status}`));
        }
      };

      xhr.onerror = error => reject(error);

      xhr.send(null);
    });
    return data;
  }

  async parse(id, object, options) {
    return Promise.resolve(object);
  }

  async conf(id, resource, options) {
    return Promise.resolve(resource);
  }

}
Loader.ID = '';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/resource.js

class resource_Resource extends disposeableUsageCounter_DisposableUsageCounter {
  destructor() {}

  retain() {
    this._useCount++;
    return this;
  }

  release() {
    this._useCount--;

    if (this._useCount === 0) {
      this.destructor();
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLState.js

var WebGLBlendingType;

(function (WebGLBlendingType) {
  WebGLBlendingType[WebGLBlendingType["NoBlending"] = 0] = "NoBlending";
  WebGLBlendingType[WebGLBlendingType["AdditiveBlending"] = 1] = "AdditiveBlending";
  WebGLBlendingType[WebGLBlendingType["SubtractiveBlending"] = 2] = "SubtractiveBlending";
  WebGLBlendingType[WebGLBlendingType["MultiplyBlending"] = 3] = "MultiplyBlending";
  WebGLBlendingType[WebGLBlendingType["NormalBlending"] = 4] = "NormalBlending";
  WebGLBlendingType[WebGLBlendingType["CustomBlending"] = 5] = "CustomBlending";
})(WebGLBlendingType || (WebGLBlendingType = {}));

var DepthFunction;

(function (DepthFunction) {
  DepthFunction[DepthFunction["NEVER"] = 512] = "NEVER";
  DepthFunction[DepthFunction["LESS"] = 513] = "LESS";
  DepthFunction[DepthFunction["EQUAL"] = 514] = "EQUAL";
  DepthFunction[DepthFunction["LEQUAL"] = 515] = "LEQUAL";
  DepthFunction[DepthFunction["GREATER"] = 516] = "GREATER";
  DepthFunction[DepthFunction["NOTEQUAL"] = 517] = "NOTEQUAL";
  DepthFunction[DepthFunction["GEQUAL"] = 518] = "GEQUAL";
  DepthFunction[DepthFunction["ALWAYS"] = 519] = "ALWAYS";
})(DepthFunction || (DepthFunction = {}));

var FrontFace;

(function (FrontFace) {
  FrontFace[FrontFace["CW"] = 2304] = "CW";
  FrontFace[FrontFace["CCW"] = 2305] = "CCW";
})(FrontFace || (FrontFace = {}));

class webGLState_WebGLState {
  constructor(gl, config = {}) {
    this._context = gl;
    this._colorClearValue = new lib["k" /* RGBColor */](0.0, 0.0, 0.0);
    this._currentProgram = null;
    this._currentBlending = WebGLBlendingType.NoBlending;
    this._depthClearValue = 1.0;
    this._stencilClearValue = 0.0;
    this._alphaClearValue = 1.0;
    this._stencilFunc = gl.ALWAYS;
    this._stencilMask = 1;
    this._stencilRef = 0;
    this._stencilFail = gl.KEEP;
    this._stencilZFail = gl.KEEP;
    this._stencilZPass = gl.KEEP;
    this._depthTestEnabled = false;
    this._depthFunc = gl.LESS;
    this._cullFace = gl.BACK;
    this._frontFace = gl.CCW;
    this._redColorMask = true;
    this._greenColorMask = true;
    this._blueColorMask = true;
    this._alphaColorMask = true;
    this._depthMask = true;
    this._premultiplyAlpha = false;
    {
      const _config$premultiplied = config.premultipliedAlpha,
            premultipliedAlpha = _config$premultiplied === void 0 ? false : _config$premultiplied;
      this._premultiplyAlpha = premultipliedAlpha;
    }
    this._viewport = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    };
    this._states = new Map();
    this._programHasChanged = 0;
    this.setDefault();
  }

  setDefault() {
    const _context = this._context,
          _colorClearValue = this._colorClearValue,
          _premultiplyAlpha = this._premultiplyAlpha;
    const gl = _context;

    this._setColorMask({
      red: true,
      green: true,
      blue: true,
      alpha: true
    }, true);

    this._setDepthMask(true, true);

    this._setDepthClearValue(1.0, true);

    this._setClearStencilValue(0, true);

    this._setClearColorValue({
      color: _colorClearValue,
      alpha: 1.0,
      premultipliedAlpha: _premultiplyAlpha
    }, true);

    this._setBlending(WebGLBlendingType.NoBlending, true);

    this.enable(gl.DEPTH_TEST);
    this._depthTestEnabled = true;

    this._setDepthFunc(gl.LESS, true);

    this.disable(gl.SCISSOR_TEST);
    this.disable(gl.STENCIL_TEST);

    this._setFrontFace(gl.CCW, true);

    this._setCullFace(gl.BACK, true);
  }

  get viewport() {
    const _viewport = this._viewport;
    const _viewport$x = _viewport.x,
          x = _viewport$x === void 0 ? 0 : _viewport$x,
          _viewport$y = _viewport.y,
          y = _viewport$y === void 0 ? 0 : _viewport$y,
          _viewport$width = _viewport.width,
          width = _viewport$width === void 0 ? 1 : _viewport$width,
          _viewport$height = _viewport.height,
          height = _viewport$height === void 0 ? 1 : _viewport$height;
    return {
      x,
      y,
      width,
      height
    };
  }

  set viewport(value) {
    const _context = this._context,
          _viewport = this._viewport;
    const gl = _context;
    const _value$x = value.x,
          x = _value$x === void 0 ? 0 : _value$x,
          _value$y = value.y,
          y = _value$y === void 0 ? 0 : _value$y,
          _value$width = value.width,
          width = _value$width === void 0 ? 1 : _value$width,
          _value$height = value.height,
          height = _value$height === void 0 ? 1 : _value$height;

    if (_viewport.x === x && _viewport.y === y && _viewport.width === width && _viewport.height === height) {
      return;
    }

    gl.viewport(x, y, width, height);
    _viewport.x = x;
    _viewport.y = y;
    _viewport.width = width;
    _viewport.height = height;
  }

  _setColorMask(mask = {}, enforce = false) {
    const _context = this._context,
          _redColorMask = this._redColorMask,
          _greenColorMask = this._greenColorMask,
          _blueColorMask = this._blueColorMask,
          _alphaColorMask = this._alphaColorMask;
    const gl = _context;
    const _mask$red = mask.red,
          red = _mask$red === void 0 ? _redColorMask : _mask$red,
          _mask$green = mask.green,
          green = _mask$green === void 0 ? _greenColorMask : _mask$green,
          _mask$blue = mask.blue,
          blue = _mask$blue === void 0 ? _blueColorMask : _mask$blue,
          _mask$alpha = mask.alpha,
          alpha = _mask$alpha === void 0 ? _alphaColorMask : _mask$alpha;

    if (enforce || _redColorMask !== red || _greenColorMask !== green || _blueColorMask !== blue || _alphaColorMask !== alpha) {
      this._redColorMask = red;
      this._greenColorMask = green;
      this._blueColorMask = blue;
      this._alphaColorMask = alpha;
      gl.colorMask(red, green, blue, alpha);
    }
  }

  get colorMask() {
    const _redColorMask = this._redColorMask,
          _greenColorMask = this._greenColorMask,
          _blueColorMask = this._blueColorMask,
          _alphaColorMask = this._alphaColorMask;
    return {
      red: _redColorMask,
      green: _greenColorMask,
      blue: _blueColorMask,
      alpha: _alphaColorMask
    };
  }

  set colorMask(mask) {
    this._setColorMask(mask);
  }

  _setDepthMask(mask, enforce = false) {
    const _context = this._context,
          _depthMask = this._depthMask;
    const gl = _context;

    if (enforce || _depthMask !== mask) {
      this._depthMask = mask;
      gl.depthMask(mask);
    }
  }

  get depthMask() {
    return this._depthMask;
  }

  set depthMask(mask) {
    this._setDepthMask(mask);
  }

  get depthTest() {
    return this._depthTestEnabled;
  }

  set depthTest(value) {
    if (this._depthTestEnabled === value) {
      return;
    }

    const gl = this._context;

    if (value) {
      gl.depthFunc(this._depthFunc);
      this._depthTestEnabled = true;
    } else {
      gl.depthFunc(gl.ALWAYS);
      this._depthTestEnabled = false;
    }
  }

  _setDepthClearValue(value, enforce = false) {
    const _context = this._context,
          _depthClearValue = this._depthClearValue;
    const gl = _context;

    if (enforce || _depthClearValue !== value) {
      this._depthClearValue = value;
      gl.clearDepth(value);
    }
  }

  get clearDepth() {
    return this._depthClearValue;
  }

  set clearDepth(value) {
    this._setDepthClearValue(value);
  }

  _setClearStencilValue(value, enforce = false) {
    const _context = this._context,
          _stencilClearValue = this._stencilClearValue;
    const gl = _context;

    if (enforce || _stencilClearValue !== value) {
      this._stencilClearValue = value;
      gl.clearStencil(value);
    }
  }

  get clearStencil() {
    return this._stencilClearValue;
  }

  set clearStencil(value) {
    this._setClearStencilValue(value);
  }

  _setClearColorValue(value = {}, enforce = false) {
    const _context = this._context,
          _colorClearValue = this._colorClearValue,
          _alphaClearValue = this._alphaClearValue,
          _premultiplyAlpha = this._premultiplyAlpha,
          _currentBlending = this._currentBlending;
    const gl = _context;
    const _value$color = value.color,
          color = _value$color === void 0 ? _colorClearValue : _value$color,
          _value$alpha = value.alpha,
          alpha = _value$alpha === void 0 ? _alphaClearValue : _value$alpha,
          _value$premultipliedA = value.premultipliedAlpha,
          premultipliedAlpha = _value$premultipliedA === void 0 ? _premultiplyAlpha : _value$premultipliedA;

    if (enforce || !_colorClearValue.equals(color) || alpha !== _alphaClearValue || _premultiplyAlpha !== premultipliedAlpha) {
      this._colorClearValue.copy(color);

      this._alphaClearValue = alpha;
      this._premultiplyAlpha = premultipliedAlpha;
      let r = color.r,
          g = color.g,
          b = color.b;

      if (premultipliedAlpha) {
        r *= alpha;
        g *= alpha;
        b *= alpha;
      }

      gl.clearColor(r, g, b, alpha);

      this._setBlending(_currentBlending, true);
    }
  }

  set clearColor(value) {
    this._setClearColorValue(value);
  }

  get clearColor() {
    const _colorClearValue = this._colorClearValue,
          _alphaClearValue = this._alphaClearValue,
          _premultiplyAlpha = this._premultiplyAlpha;
    return {
      color: _colorClearValue.clone(),
      alpha: _alphaClearValue,
      premultipliedAlpha: _premultiplyAlpha
    };
  }

  set blending(value) {
    this._setBlending(value);
  }

  get blending() {
    return this._currentBlending;
  }

  _setDepthFunc(value, enforce = false) {
    const _context = this._context,
          _depthFunc = this._depthFunc;
    const gl = _context;

    if (!this._depthTestEnabled) {
      return;
    }

    if (enforce || _depthFunc !== value) {
      this._depthFunc = value;
      gl.depthFunc(value);
    }
  }

  get depthFunc() {
    return this._depthFunc;
  }

  set depthFunc(value) {
    this._setDepthFunc(value);
  }

  _setFrontFace(value, enforce = false) {
    const _context = this._context,
          _frontFace = this._frontFace;
    const gl = _context;

    if (enforce || _frontFace !== value) {
      this._frontFace = value;
      gl.frontFace(value);
    }
  }

  set frontFace(value) {
    this._setFrontFace(value);
  }

  get frontFace() {
    return this._frontFace;
  }

  _setCullFace(value, enforce = false) {
    const _context = this._context,
          _cullFace = this._cullFace;
    const gl = _context;

    if (enforce || _cullFace !== value) {
      this._cullFace = value;

      if (value === null) {
        this.disable(gl.CULL_FACE);
      } else {
        this.enable(gl.CULL_FACE);
        gl.cullFace(value);
      }
    }
  }

  set cullFace(value) {
    this._setCullFace(value);
  }

  get cullFace() {
    return this._cullFace;
  }

  _setStencilFunc(value = {}, enforce = false) {
    const _context = this._context,
          _stencilFunc = this._stencilFunc,
          _stencilMask = this._stencilMask,
          _stencilRef = this._stencilRef;
    const gl = _context;
    const _value$func = value.func,
          func = _value$func === void 0 ? _stencilFunc : _value$func,
          _value$mask = value.mask,
          mask = _value$mask === void 0 ? _stencilMask : _value$mask,
          _value$ref = value.ref,
          ref = _value$ref === void 0 ? _stencilRef : _value$ref;

    if (enforce || func !== _stencilFunc || mask !== _stencilMask || ref !== _stencilRef) {
      this._stencilFunc = func;
      this._stencilMask = mask;
      this._stencilRef = ref;
      gl.stencilFunc(func, ref, mask);
    }
  }

  get stencilFunc() {
    const _stencilFunc = this._stencilFunc,
          _stencilMask = this._stencilMask,
          _stencilRef = this._stencilRef;
    return {
      func: _stencilFunc,
      mask: _stencilMask,
      ref: _stencilRef
    };
  }

  set stencilFunc(value) {
    this._setStencilFunc(value);
  }

  _setStencilOp(value = {}, enforce = false) {
    const _context = this._context,
          _stencilFail = this._stencilFail,
          _stencilZFail = this._stencilZFail,
          _stencilZPass = this._stencilZPass;
    const gl = _context;
    const _value$fail = value.fail,
          fail = _value$fail === void 0 ? _stencilFail : _value$fail,
          _value$zfail = value.zfail,
          zfail = _value$zfail === void 0 ? _stencilZFail : _value$zfail,
          _value$zpass = value.zpass,
          zpass = _value$zpass === void 0 ? _stencilZPass : _value$zpass;

    if (enforce || fail !== _stencilZFail || zfail !== _stencilZFail || zpass !== _stencilZPass) {
      this._stencilFail = fail;
      this._stencilZFail = zfail;
      this._stencilZPass = zpass;
      gl.stencilOp(fail, zfail, zpass);
    }
  }

  get stencilOp() {
    const _stencilFail = this._stencilFail,
          _stencilZFail = this._stencilZFail,
          _stencilZPass = this._stencilZPass;
    return {
      fail: _stencilFail,
      zfail: _stencilZFail,
      zpass: _stencilZPass
    };
  }

  set stencilOp(value) {
    this._setStencilOp(value);
  }

  _setProgram(value, enforce = false) {
    const _context = this._context,
          _currentProgram = this._currentProgram;
    const gl = _context;

    if (enforce || _currentProgram !== value) {
      this._programHasChanged = 1;
      this._currentProgram = value;
      gl.useProgram(value);
    } else {
      this._programHasChanged = 0;
    }
  }

  get program() {
    return this._currentProgram;
  }

  set program(value) {
    this._setProgram(value);
  }

  get premultipliedAlpha() {
    return this._premultiplyAlpha;
  }

  set premultipliedAlpha(value) {
    this._setPremultipliedAlphaValue(value);
  }

  disable(op) {
    const _context = this._context,
          _states = this._states;
    const gl = _context;

    let state = _states.get(op);

    if (state === undefined) {
      state = !!gl.isEnabled(op);

      _states.set(op, state);
    }

    if (state) {
      gl.disable(op);

      _states.set(op, false);
    }
  }

  enable(op) {
    const _context = this._context,
          _states = this._states;
    const gl = _context;

    let state = _states.get(op);

    if (state === undefined) {
      state = !!gl.isEnabled(op);

      _states.set(op, state);
    }

    if (!state) {
      gl.enable(op);

      _states.set(op, true);
    }
  }

  setCustomBlending(eq, eqAlpha, srcColor, dstColor, srcAlpha, dstAlpha) {
    const gl = this._context;
    gl.enable(gl.BLEND);
    gl.blendEquationSeparate(eq, eqAlpha);
    gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
    this._currentBlending = WebGLBlendingType.CustomBlending;
  }

  _setPremultipliedAlphaValue(value, enforce = false) {
    const _premultiplyAlpha = this._premultiplyAlpha,
          _currentBlending = this._currentBlending;

    if (_premultiplyAlpha === value && !(enforce === true)) {
      return;
    }

    this._premultiplyAlpha = value;

    this._setClearColorValue({
      premultipliedAlpha: value
    }, true);

    this._setBlending(_currentBlending, true);
  }

  _setBlending(value, enforce = false) {
    const _context = this._context,
          _currentBlending = this._currentBlending,
          _premultiplyAlpha = this._premultiplyAlpha;
    const gl = _context;

    if (_currentBlending === value && !(enforce === true)) {
      return;
    }

    this._currentBlending = value;

    if (value !== WebGLBlendingType.NoBlending) {
      gl.enable(gl.BLEND);
    } else {
      gl.disable(gl.BLEND);
      return;
    }

    if (value === WebGLBlendingType.AdditiveBlending) {
      if (_premultiplyAlpha) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.SRC_ALPHA, gl.ONE);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      }
    } else if (value === WebGLBlendingType.SubtractiveBlending) {
      if (_premultiplyAlpha) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
      }
    } else if (value === WebGLBlendingType.MultiplyBlending) {
      if (_premultiplyAlpha) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
      }
    } else if (value === WebGLBlendingType.NormalBlending) {
      if (_premultiplyAlpha) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      }
    } else if (value === WebGLBlendingType.CustomBlending) {
      if (false) {}
    } else {
      if (false) {}
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/webglContext.js
const webglContext = {};

(function getStaticContext() {
  if (typeof WebGLRenderingContext !== 'undefined') {
    Object.assign(webglContext, WebGLRenderingContext);
  }

  if (typeof WebGL2RenderingContext !== 'undefined') {
    Object.assign(webglContext, WebGL2RenderingContext);
  }
})();
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/dataTypes.js

const webglContext2 = webglContext;
var dataTypes_DataType;

(function (DataType) {
  DataType[DataType["BYTE"] = webglContext.BYTE] = "BYTE";
  DataType[DataType["UNSIGNED_BYTE"] = webglContext.UNSIGNED_BYTE] = "UNSIGNED_BYTE";
  DataType[DataType["SHORT"] = webglContext.SHORT] = "SHORT";
  DataType[DataType["UNSIGNED_SHORT"] = webglContext.UNSIGNED_SHORT] = "UNSIGNED_SHORT";
  DataType[DataType["INT"] = webglContext.INT] = "INT";
  DataType[DataType["UNSIGNED_INT"] = webglContext.UNSIGNED_INT] = "UNSIGNED_INT";
  DataType[DataType["FLOAT"] = webglContext.FLOAT] = "FLOAT";
  DataType[DataType["UNSIGNED_SHORT_5_6_5"] = webglContext.UNSIGNED_SHORT_5_6_5] = "UNSIGNED_SHORT_5_6_5";
  DataType[DataType["UNSIGNED_SHORT_4_4_4_4"] = webglContext.UNSIGNED_SHORT_4_4_4_4] = "UNSIGNED_SHORT_4_4_4_4";
  DataType[DataType["UNSIGNED_SHORT_5_5_5_1"] = webglContext.UNSIGNED_SHORT_5_5_5_1] = "UNSIGNED_SHORT_5_5_5_1";
  DataType[DataType["HALF_FLOAT"] = webglContext2.HALF_FLOAT] = "HALF_FLOAT";
  DataType[DataType["UNSIGNED_INT_10F_11F_11F_REV"] = webglContext2.UNSIGNED_INT_10F_11F_11F_REV] = "UNSIGNED_INT_10F_11F_11F_REV";
  DataType[DataType["UNSIGNED_INT_2_10_10_10_REV"] = webglContext2.UNSIGNED_INT_2_10_10_10_REV] = "UNSIGNED_INT_2_10_10_10_REV";
  DataType[DataType["UNSIGNED_INT_5_9_9_9_REV"] = webglContext2.UNSIGNED_INT_5_9_9_9_REV] = "UNSIGNED_INT_5_9_9_9_REV";
  DataType[DataType["UNSIGNED_INT_24_8"] = webglContext2.UNSIGNED_INT_24_8] = "UNSIGNED_INT_24_8";
  DataType[DataType["FLOAT_32_UNSIGNED_INT_24_8_REV"] = webglContext2.FLOAT_32_UNSIGNED_INT_24_8_REV] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
})(dataTypes_DataType || (dataTypes_DataType = {}));

function getDataTypeSize(type) {
  switch (type) {
    case dataTypes_DataType.BYTE:
    case dataTypes_DataType.UNSIGNED_BYTE:
      return 1;

    case dataTypes_DataType.UNSIGNED_SHORT:
    case dataTypes_DataType.SHORT:
    case dataTypes_DataType.HALF_FLOAT:
    case dataTypes_DataType.UNSIGNED_SHORT_5_6_5:
    case dataTypes_DataType.UNSIGNED_SHORT_4_4_4_4:
    case dataTypes_DataType.UNSIGNED_SHORT_5_5_5_1:
      return 2;

    case dataTypes_DataType.UNSIGNED_INT:
    case dataTypes_DataType.FLOAT:
    case dataTypes_DataType.UNSIGNED_INT_10F_11F_11F_REV:
    case dataTypes_DataType.UNSIGNED_INT_2_10_10_10_REV:
    case dataTypes_DataType.UNSIGNED_INT_5_9_9_9_REV:
    case dataTypes_DataType.UNSIGNED_INT_24_8:
    case dataTypes_DataType.FLOAT_32_UNSIGNED_INT_24_8_REV:
      return 4;

    default:
      throw new Error('Unknown scalar type');
  }
}
function getArrayTypeForDataType(type) {
  switch (type) {
    case dataTypes_DataType.BYTE:
      return Int8Array;

    case dataTypes_DataType.UNSIGNED_BYTE:
      return Uint8Array;

    case dataTypes_DataType.HALF_FLOAT:
    case dataTypes_DataType.UNSIGNED_SHORT:
    case dataTypes_DataType.UNSIGNED_SHORT_5_6_5:
    case dataTypes_DataType.UNSIGNED_SHORT_4_4_4_4:
    case dataTypes_DataType.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;

    case dataTypes_DataType.SHORT:
      return Int16Array;

    case dataTypes_DataType.UNSIGNED_INT:
    case dataTypes_DataType.UNSIGNED_INT_10F_11F_11F_REV:
    case dataTypes_DataType.UNSIGNED_INT_2_10_10_10_REV:
    case dataTypes_DataType.UNSIGNED_INT_5_9_9_9_REV:
    case dataTypes_DataType.UNSIGNED_INT_24_8:
      return Uint32Array;

    case dataTypes_DataType.FLOAT:
    case dataTypes_DataType.FLOAT_32_UNSIGNED_INT_24_8_REV:
      return Float32Array;

    default:
      throw new Error('Unknown type');
  }
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/texture-resource/index.js






const webgl2Context = webglContext;
var texture_resource_WrappingMode;

(function (WrappingMode) {
  WrappingMode[WrappingMode["REPEAT"] = webglContext.REPEAT] = "REPEAT";
  WrappingMode[WrappingMode["CLAMP_TO_EDGE"] = webglContext.CLAMP_TO_EDGE] = "CLAMP_TO_EDGE";
  WrappingMode[WrappingMode["MIRRORED_REPEAT"] = webglContext.MIRRORED_REPEAT] = "MIRRORED_REPEAT";
})(texture_resource_WrappingMode || (texture_resource_WrappingMode = {}));

var texture_resource_BindingPoint;

(function (BindingPoint) {
  BindingPoint[BindingPoint["NONE"] = 0] = "NONE";
  BindingPoint[BindingPoint["TEXTURE_2D"] = webglContext.TEXTURE_2D] = "TEXTURE_2D";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP"] = webglContext.TEXTURE_CUBE_MAP] = "TEXTURE_CUBE_MAP";
  BindingPoint[BindingPoint["TEXTURE_3D"] = webgl2Context.TEXTURE_3D] = "TEXTURE_3D";
  BindingPoint[BindingPoint["TEXTURE_2D_ARRAY"] = webgl2Context.TEXTURE_2D_ARRAY] = "TEXTURE_2D_ARRAY";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_POSITIVE_X"] = webglContext.TEXTURE_CUBE_MAP_POSITIVE_X] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_NEGATIVE_X"] = webglContext.TEXTURE_CUBE_MAP_NEGATIVE_X] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_POSITIVE_Y"] = webglContext.TEXTURE_CUBE_MAP_POSITIVE_Y] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = webglContext.TEXTURE_CUBE_MAP_NEGATIVE_Y] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_POSITIVE_Z"] = webglContext.TEXTURE_CUBE_MAP_POSITIVE_Z] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  BindingPoint[BindingPoint["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = webglContext.TEXTURE_CUBE_MAP_NEGATIVE_Z] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(texture_resource_BindingPoint || (texture_resource_BindingPoint = {}));

var texture_resource_Filter;

(function (Filter) {
  Filter[Filter["NEAREST"] = webglContext.NEAREST] = "NEAREST";
  Filter[Filter["LINEAR"] = webglContext.LINEAR] = "LINEAR";
  Filter[Filter["NEAREST_MIPMAP_NEAREST"] = webglContext.NEAREST_MIPMAP_NEAREST] = "NEAREST_MIPMAP_NEAREST";
  Filter[Filter["LINEAR_MIPMAP_NEAREST"] = webglContext.LINEAR_MIPMAP_NEAREST] = "LINEAR_MIPMAP_NEAREST";
  Filter[Filter["NEAREST_MIPMAP_LINEAR"] = webglContext.NEAREST_MIPMAP_LINEAR] = "NEAREST_MIPMAP_LINEAR";
  Filter[Filter["LINEAR_MIPMAP_LINEAR"] = webglContext.LINEAR_MIPMAP_LINEAR] = "LINEAR_MIPMAP_LINEAR";
})(texture_resource_Filter || (texture_resource_Filter = {}));

var texture_resource_CompareMode;

(function (CompareMode) {
  CompareMode[CompareMode["NONE"] = webglContext.NONE] = "NONE";
  CompareMode[CompareMode["COMPARE_REF_TO_TEXTURE"] = webgl2Context.COMPARE_REF_TO_TEXTURE] = "COMPARE_REF_TO_TEXTURE";
})(texture_resource_CompareMode || (texture_resource_CompareMode = {}));

var CustomImageType;

(function (CustomImageType) {
  CustomImageType[CustomImageType["RGBE"] = 1] = "RGBE";
})(CustomImageType || (CustomImageType = {}));

class CustomImageData {
  constructor(imageType, width, height, depth, format, internalFormat, componentType, buffer) {
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.imageType = imageType;
    this.format = format;
    this.internalFormat = internalFormat;
    this.componentType = componentType;
    this.buffer = buffer;
    this.extras = {};
    Object.defineProperty(CustomImageData.prototype, 'isCustomImageData', {
      value: true
    });
  }

  static get Type() {
    return CustomImageType;
  }

}
class texture_resource_TextureLevelData extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    xoffset = 0,
    yoffset = 0,
    zoffset = 0,
    width,
    height,
    depth,
    data
  }) {
    super();
    this.xoffset = xoffset;
    this.yoffset = yoffset;
    this.zoffset = zoffset;

    if (data instanceof CustomImageData) {
      this.width = data.width;
      this.height = data.height;
      this.depth = data.depth;
    } else {
      this.width = width;
      this.height = height;
      this.depth = depth;
    }

    this.data = data;
  }

  clone() {
    return new texture_resource_TextureLevelData(this);
  }

  _actuallyUnload() {
    this.data = null;
    return super._actuallyUnload();
  }

}
function getTextureBindingPointName(bindingPoint) {
  for (const name of Object.getOwnPropertyNames(texture_resource_BindingPoint)) {
    if (name === 'length') {
      continue;
    }

    if (texture_resource_BindingPoint[name] === bindingPoint) {
      return name;
    }
  }

  return '';
}

function _deleteDataFromTextureLevelData(levelData) {
  if (Array.isArray(levelData)) {
    for (const ld of levelData) {
      _deleteDataFromTextureLevelData(ld);
    }
  } else if (levelData !== undefined && levelData !== null) {
    levelData.data = null;
  }
}

let _lastTextureId = 0;
class texture_resource_Texture extends resource_Resource {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$width = properties.width,
          width = _properties$width === void 0 ? 1 : _properties$width,
          _properties$height = properties.height,
          height = _properties$height === void 0 ? 1 : _properties$height,
          _properties$depth = properties.depth,
          depth = _properties$depth === void 0 ? 1 : _properties$depth,
          _properties$bindingPo = properties.bindingPoint,
          bindingPoint = _properties$bindingPo === void 0 ? texture_resource_Texture.BindingPoint.NONE : _properties$bindingPo,
          _properties$wrapS = properties.wrapS,
          wrapS = _properties$wrapS === void 0 ? texture_resource_Texture.WrappingMode.REPEAT : _properties$wrapS,
          _properties$wrapT = properties.wrapT,
          wrapT = _properties$wrapT === void 0 ? texture_resource_Texture.WrappingMode.REPEAT : _properties$wrapT,
          magFilter = properties.magFilter,
          minFilter = properties.minFilter,
          _properties$compareFu = properties.compareFunc,
          compareFunc = _properties$compareFu === void 0 ? texture_resource_Texture.CompareFunc.LEQUAL : _properties$compareFu,
          _properties$compareMo = properties.compareMode,
          compareMode = _properties$compareMo === void 0 ? texture_resource_Texture.CompareMode.NONE : _properties$compareMo,
          _properties$anisotrop = properties.anisotropyDegree,
          anisotropyDegree = _properties$anisotrop === void 0 ? 1 : _properties$anisotrop,
          _properties$baseLevel = properties.baseLevel,
          baseLevel = _properties$baseLevel === void 0 ? 0 : _properties$baseLevel,
          _properties$maxLevel = properties.maxLevel,
          maxLevel = _properties$maxLevel === void 0 ? 0 : _properties$maxLevel,
          _properties$component = properties.componentType,
          componentType = _properties$component === void 0 ? dataTypes_DataType.UNSIGNED_BYTE : _properties$component,
          _properties$format = properties.format,
          format = _properties$format === void 0 ? PixelDataFormat.RGB : _properties$format,
          levels = properties.levels,
          _properties$levelsDat = properties.levelsData,
          levelsData = _properties$levelsDat === void 0 ? [] : _properties$levelsDat,
          _properties$internalF = properties.internalFormat,
          internalFormat = _properties$internalF === void 0 ? null : _properties$internalF,
          _properties$dynamic = properties.dynamic,
          dynamic = _properties$dynamic === void 0 ? false : _properties$dynamic;
    super();
    this._id = ++_lastTextureId;
    this.name = name;
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.bindingPoint = bindingPoint;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.compareFunc = compareFunc;
    this.compareMode = compareMode;
    this.anisotropyDegree = anisotropyDegree;
    this.baseLevel = baseLevel;
    this.maxLevel = maxLevel;
    this.componentType = componentType;
    this.format = format;
    this.internalFormat = internalFormat;
    this._levelsData = [...levelsData];
    this.levels = levels;
    this._gammaDecode = false;
    this._dynamic = dynamic;
    this._needsUpdate = true;
    this._needsUpdateLevels = false;
    this._webGLTexture = null;
    this._webGLTextureSystem = null;
    this.extras = undefined;
  }

  static get BindingPoint() {
    return texture_resource_BindingPoint;
  }

  static get WrappingMode() {
    return texture_resource_WrappingMode;
  }

  static get Filter() {
    return texture_resource_Filter;
  }

  static get CompareFunc() {
    return DepthFunction;
  }

  static get CompareMode() {
    return texture_resource_CompareMode;
  }

  updateLevels(callback) {
    if (false) {}

    const _levelsData = this._levelsData,
          levels = this.levels;
    this._needsUpdateLevels = callback(_levelsData, levels);
  }

  get id() {
    return this._id;
  }

  get needsUpdate() {
    return this._needsUpdate;
  }

  set needsUpdate(value) {
    if (false) {}

    this._needsUpdate = value;
  }

  get dynamic() {
    return this._dynamic;
  }

  get gammaDecode() {
    return this._gammaDecode;
  }

  get webGLTexture() {
    return this._webGLTexture;
  }

  clone(cloneGPUData = false) {
    const name = this.name,
          width = this.width,
          height = this.height,
          depth = this.depth,
          bindingPoint = this.bindingPoint,
          wrapS = this.wrapS,
          wrapT = this.wrapT,
          magFilter = this.magFilter,
          minFilter = this.minFilter,
          componentType = this.componentType,
          format = this.format,
          internalFormat = this.internalFormat,
          _levelsData = this._levelsData,
          levels = this.levels,
          _dynamic = this._dynamic;

    if (false) {}

    const cloned = new texture_resource_Texture({
      name,
      width,
      height,
      depth,
      bindingPoint,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      componentType,
      format,
      internalFormat,
      levelsData: _levelsData.map(x => x.clone()),
      levels,
      dynamic: _dynamic
    });

    if (cloneGPUData) {
      throw new Error('not implemented yet');
    }

    return cloned;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* walk(levelDatas) {
      for (const levelData of levelDatas) {
        if (Array.isArray(levelData)) {
          yield* walk(levelData);
          continue;
        }

        yield levelData.load();
      }
    }.call(this, this._levelsData)]);
  }

  _actuallyUnload() {
    const _webGLTextureSystem = this._webGLTextureSystem,
          _levelsData = this._levelsData;

    if (_webGLTextureSystem !== null) {
      _webGLTextureSystem.disposeTexture(this);

      this._webGLTextureSystem = null;
    }

    _levelsData.forEach(function walk(levelData) {
      if (Array.isArray(levelData)) {
        levelData.forEach(walk, this);
        return;
      }

      levelData.unload();
    }, this);

    super._actuallyUnload();
  }

  destructor() {
    const _webGLTextureSystem = this._webGLTextureSystem,
          _levelsData = this._levelsData;

    if (_webGLTextureSystem !== null) {
      _webGLTextureSystem.disposeTexture(this);

      this._webGLTextureSystem = null;
    }

    _deleteDataFromTextureLevelData(_levelsData);

    super.destructor();
  }

  _dispose() {
    const _webGLTextureSystem = this._webGLTextureSystem,
          _levelsData = this._levelsData;

    if (_webGLTextureSystem !== null) {
      _webGLTextureSystem.disposeTexture(this);

      this._webGLTextureSystem = null;
    }

    _deleteDataFromTextureLevelData(_levelsData);

    super._dispose();
  }

}
Object.defineProperties(texture_resource_Texture.prototype, {
  isTexture: {
    value: true
  }
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderTarget/index.js

class renderTarget_RenderTarget extends disposeableUsageCounter_DisposableUsageCounter {
  constructor() {
    super(...arguments);
    this._lastFrameNumber = 0;
    this._needsUpdate = true;
  }

  get needsUpdate() {
    return this._needsUpdate;
  }

  clone() {
    const cloned = new renderTarget_RenderTarget();
    cloned._lastFrameNumber = this._lastFrameNumber;
    return cloned;
  }

  get webGLFramebuffer() {
    return null;
  }

}
Object.defineProperty(renderTarget_RenderTarget.prototype, 'isRenderTarget', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderBuffer.js


class renderBuffer_RenderBuffer extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    width,
    height,
    samples = 1,
    internalFormat = InternalFormat.RGBA
  }) {
    super();
    this.width = width;
    this.height = height;
    this.samples = samples;
    this.needsUpdate = true;
    this.internalFormat = internalFormat;
    this._webGLRenderBuffer = null;
    this._webGLRenderBufferSystem = null;
  }

  get webGLRenderBuffer() {
    return this._webGLRenderBuffer;
  }

  clone() {
    const width = this.width,
          height = this.height,
          samples = this.samples,
          internalFormat = this.internalFormat;
    return new renderBuffer_RenderBuffer({
      width,
      height,
      samples,
      internalFormat
    });
  }

  unload() {
    const _webGLRenderBufferSystem = this._webGLRenderBufferSystem;

    if (_webGLRenderBufferSystem !== null) {
      _webGLRenderBufferSystem.disposeRenderBuffer(this);

      this._webGLRenderBufferSystem = null;
    }

    super.unload();
  }

  _dispose() {
    const _webGLRenderBufferSystem = this._webGLRenderBufferSystem;

    if (_webGLRenderBufferSystem !== null) {
      _webGLRenderBufferSystem.disposeRenderBuffer(this);

      this._webGLRenderBufferSystem = null;
    }

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderTarget/renderTargetAttachment.js

var renderTargetAttachment_RenderTargetAttachment;

(function (RenderTargetAttachment) {
  RenderTargetAttachment[RenderTargetAttachment["NONE"] = webglContext.NONE] = "NONE";
  RenderTargetAttachment[RenderTargetAttachment["DEPTH_ATTACHMENT"] = webglContext.DEPTH_ATTACHMENT] = "DEPTH_ATTACHMENT";
  RenderTargetAttachment[RenderTargetAttachment["COLOR_ATTACHMENT0"] = webglContext.COLOR_ATTACHMENT0] = "COLOR_ATTACHMENT0";
  RenderTargetAttachment[RenderTargetAttachment["STENCIL_ATTACHMENT"] = webglContext.STENCIL_ATTACHMENT] = "STENCIL_ATTACHMENT";
  RenderTargetAttachment[RenderTargetAttachment["DEPTH_STENCIL_ATTACHMENT"] = webglContext.DEPTH_STENCIL_ATTACHMENT] = "DEPTH_STENCIL_ATTACHMENT";
})(renderTargetAttachment_RenderTargetAttachment || (renderTargetAttachment_RenderTargetAttachment = {}));
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderTarget/renderTargetFramebuffer.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





class renderTargetFramebuffer_RenderTargetFramebuffer extends renderTarget_RenderTarget {
  constructor({
    width,
    height
  }) {
    super();
    this._targetIndex = -1;
    this.width = width;
    this.height = height;
    this._lastFrameNumber = 0;
    this._properties = new Map();
    this._colorAttachments = new Map();
    this._depthStencilAttachments = new Map();
    this._needsUpdate = true;
    this._needsUpdateAttachments = true;
    this._webGLFramebuffer = null;
    this._webGLFramebufferSystem = null;
  }

  static get Attachment() {
    return renderTargetAttachment_RenderTargetAttachment;
  }

  set targetIndex(value) {
    this._targetIndex = value;
  }

  get targetIndex() {
    return this._targetIndex;
  }

  get needsUpdate() {
    return this._needsUpdateAttachments || this._needsUpdate;
  }

  get colorAttachmentCount() {
    return this._colorAttachments.size;
  }

  hasColorAttachment(layoutPosition) {
    return this._colorAttachments.has(layoutPosition);
  }

  hasDepthStencilAttachment(layoutPosition) {
    return this._depthStencilAttachments.has(layoutPosition);
  }

  setColorAttachment(layoutPosition, attachment, level = 0, target, layer = 0) {
    if (false) {}

    const _colorAttachments = this._colorAttachments,
          _properties = this._properties;

    const prevAttachment = _colorAttachments.get(layoutPosition);

    if (prevAttachment === attachment) {
      if (prevAttachment instanceof texture_resource_Texture) {
        const props = _properties.get(prevAttachment);

        let target_ = target;

        if (target_ === undefined) {
          target_ = props.target;
        }

        if (props.target !== target_ || props.level !== level || props.layer !== layer) {
          this._needsUpdateAttachments = true;
          props.needsUpdate = true;

          if (props.level !== level) {
            this._needsUpdate = true;
          }

          props.target = target_;
          props.level = level;
          props.layer = layer;
        }
      }

      return;
    }

    if (prevAttachment !== undefined) {
      if (_properties.has(prevAttachment)) {
        _properties.delete(prevAttachment);
      }

      prevAttachment.release();
    } else {
      this._needsUpdate = true;
    }

    _colorAttachments.set(layoutPosition, attachment);

    {
      const props = {
        needsUpdate: true,
        level,
        target,
        layer
      };

      if (target === undefined) {
        if (attachment instanceof texture_resource_Texture && attachment.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
          props.target = texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
        } else if (attachment instanceof texture_resource_Texture) {
          props.target = attachment.bindingPoint;
        }
      }

      _properties.set(attachment, props);

      attachment.retain();
      this._needsUpdateAttachments = true;
    }
  }

  setDepthStencilAttachment(layoutPosition, attachment, target, layer = 0) {
    if (false) {}

    const _depthStencilAttachments = this._depthStencilAttachments,
          _properties = this._properties;

    const prevAttachment = _depthStencilAttachments.get(layoutPosition);

    if (prevAttachment === attachment) {
      if (prevAttachment instanceof texture_resource_Texture) {
        const props = _properties.get(prevAttachment);

        let target_ = target;

        if (target_ === undefined) {
          target_ = props.target;
        }

        if (props.target !== target_ || props.layer !== layer) {
          this._needsUpdateAttachments = true;
          props.needsUpdate = true;
        }

        props.target = target_;
        props.layer = layer;
      }

      return;
    }

    if (prevAttachment !== undefined) {
      if (_properties.has(prevAttachment)) {
        _properties.delete(prevAttachment);
      }

      prevAttachment.release();
    } else {
      this._needsUpdate = true;
    }

    _depthStencilAttachments.set(layoutPosition, attachment);

    const props = {
      needsUpdate: true,
      layer,
      target
    };

    if (target === undefined) {
      if (attachment instanceof texture_resource_Texture && attachment.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
        props.target = texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
      } else if (attachment instanceof texture_resource_Texture) {
        props.target = attachment.bindingPoint;
      }
    }

    _properties.set(attachment, props);

    attachment.retain();
    this._needsUpdateAttachments = true;
  }

  getColorAttachment(layoutPosition) {
    const _colorAttachments = this._colorAttachments,
          _properties = this._properties;

    const attachment = _colorAttachments.get(layoutPosition);

    const properties = _properties.get(attachment);

    return {
      attachment,
      properties
    };
  }

  getDepthStencilAttachment(layoutPosition) {
    const _depthStencilAttachments = this._depthStencilAttachments,
          _properties = this._properties;

    const attachment = _depthStencilAttachments.get(layoutPosition);

    const properties = _properties.get(attachment);

    return {
      attachment,
      properties
    };
  }

  removeColorAttachment(layoutPosition) {
    const _colorAttachments = this._colorAttachments,
          _properties = this._properties;

    const attachment = _colorAttachments.get(layoutPosition);

    if (attachment !== undefined) {
      attachment.release();

      _colorAttachments.delete(layoutPosition);

      if (_properties.has(attachment)) {
        _properties.delete(attachment);
      }

      this._needsUpdate = true;
    }
  }

  removeDepthStencilAttachment(layoutPosition) {
    const _depthStencilAttachments = this._depthStencilAttachments;

    const attachment = _depthStencilAttachments.get(layoutPosition);

    if (attachment !== undefined) {
      attachment.release();

      _depthStencilAttachments.delete(layoutPosition);

      this._needsUpdate = true;
    }
  }

  resize(width, height) {
    this.width = width;
    this.height = height;
    const _colorAttachments = this._colorAttachments,
          _depthStencilAttachments = this._depthStencilAttachments;

    for (const colorAttachment of _colorAttachments.values()) {
      if (colorAttachment.width === width && colorAttachment.height === height) {
        continue;
      }

      colorAttachment.width = width;
      colorAttachment.height = height;
      colorAttachment.needsUpdate = true;
    }

    for (const depthStencilAttachment of _depthStencilAttachments.values()) {
      if (depthStencilAttachment.width === width && depthStencilAttachment.height === height) {
        continue;
      }

      depthStencilAttachment.width = width;
      depthStencilAttachment.height = height;
      depthStencilAttachment.needsUpdate = true;
    }

    this._needsUpdate = true;
  }

  clone(cloneGPUData = false) {
    const width = this.width,
          height = this.height,
          _colorAttachments = this._colorAttachments,
          _depthStencilAttachments = this._depthStencilAttachments,
          _properties = this._properties;
    const cloned = new renderTargetFramebuffer_RenderTargetFramebuffer({
      width,
      height
    });

    for (const _ref of _colorAttachments.entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const layout = _ref2[0];
      const attachment = _ref2[1];
      let level = 0;
      let target;

      if (_properties.has(attachment)) {
        var _properties$get = _properties.get(attachment);

        level = _properties$get.level;
        target = _properties$get.target;
      }

      cloned.setColorAttachment(layout, attachment, level, target);
    }

    for (const _ref3 of _depthStencilAttachments.entries()) {
      var _ref4 = _slicedToArray(_ref3, 2);

      const layout = _ref4[0];
      const attachment = _ref4[1];
      cloned.setDepthStencilAttachment(layout, attachment);
    }

    if (cloneGPUData) {
      throw new Error('not implemented yet');
    }

    return cloned;
  }

  get webGLFramebuffer() {
    return this._webGLFramebuffer;
  }

  _dispose() {
    const _webGLFramebufferSystem = this._webGLFramebufferSystem,
          _colorAttachments = this._colorAttachments,
          _depthStencilAttachments = this._depthStencilAttachments,
          _properties = this._properties;

    if (_webGLFramebufferSystem !== null) {
      _webGLFramebufferSystem._sync();

      for (const attachment of _colorAttachments.values()) {
        attachment.release();
      }

      _colorAttachments.clear();

      for (const attachment of _depthStencilAttachments.values()) {
        attachment.release();
      }

      _depthStencilAttachments.clear();

      _properties.clear();

      _webGLFramebufferSystem.deleteFramebuffer(this);

      this._webGLFramebufferSystem = null;
    }

    super._dispose();
  }

  unload() {
    const _webGLFramebufferSystem = this._webGLFramebufferSystem,
          _colorAttachments = this._colorAttachments,
          _depthStencilAttachments = this._depthStencilAttachments;

    if (_webGLFramebufferSystem !== null) {
      _webGLFramebufferSystem._sync();
    }

    for (const attachment of _colorAttachments.values()) {
      attachment.unload();
    }

    for (const attachment of _depthStencilAttachments.values()) {
      attachment.unload();
    }

    super.unload();
  }

}
Object.defineProperty(renderTargetFramebuffer_RenderTargetFramebuffer.prototype, 'isRenderTargetFramebuffer', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/instanced-batch.js
const NEEDS_UPDATE_FLAG = 1 << 0;
const EXCLUDED_FLAG = 1 << 1;
class InstancedBatch {
  constructor(instanceId = 0) {
    this.flags = 0;
    this.firstInstance = null;
    this.instanceCount = 0;
    this.capacity = 0;
    this.instanceId = instanceId;
  }

  get needsUpdate() {
    return (this.flags & NEEDS_UPDATE_FLAG) !== 0;
  }

  set needsUpdate(value) {
    this.flags = value ? this.flags | NEEDS_UPDATE_FLAG : this.flags & ~NEEDS_UPDATE_FLAG;
  }

  get excluded() {
    return (this.flags & EXCLUDED_FLAG) !== 0;
  }

  set excluded(value) {
    this.flags = value ? this.flags | EXCLUDED_FLAG : this.flags & ~EXCLUDED_FLAG;
  }

  static get bytesPerBatch() {
    return 20;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/spatialIndexFrustumCull.js

const spatialIndexFrustumCull_batch_ = new InstancedBatch();
const spatialIndexFrustumCull_currentFrameVisibilityFlag = 0x02;
const uncullableFlag = 0x08;
const spatialIndexFrustumCull_survivedCullingFlag = 0x20;
const visibleInstanceKeys = [];
function spatialIndexFrustumCull(scene, camera, frameNumber) {
  const instanceDataManager = scene.instanceDataManager,
        spatialIndex = scene.spatialIndex;
  const _flagBuffers = instanceDataManager._flagBuffers,
        _instancedBatches = instanceDataManager._instancedBatches;
  {
    const batchCount = _instancedBatches.batchCount;
    const flagBuffer = _flagBuffers;

    for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
      _instancedBatches.unpackBatch(batchIdx, spatialIndexFrustumCull_batch_);

      if (spatialIndexFrustumCull_batch_.excluded) {
        continue;
      }

      for (let j = 0, len = spatialIndexFrustumCull_batch_.instanceCount; j < len; j++) {
        const instanceIdx = spatialIndexFrustumCull_batch_.firstInstance + j;
        const flags = flagBuffer[instanceIdx];

        if (flags & spatialIndexFrustumCull_currentFrameVisibilityFlag) {
          const uncullable = !!(flags & uncullableFlag);
          flagBuffer[instanceIdx] = flags ^ (flags ^ -uncullable) & spatialIndexFrustumCull_survivedCullingFlag;
        }
      }
    }
  }
  spatialIndex.webGLFrustumFind(camera.viewProjectionMatrix, visibleInstanceKeys);
  const visibleInstanceCount = visibleInstanceKeys.length;

  for (let i = 0; i < visibleInstanceCount; ++i) {
    const globalIndex = visibleInstanceKeys[i].globalIndex;
    const flagBuffer = _flagBuffers;
    const flags = flagBuffer[globalIndex];

    if (flags & spatialIndexFrustumCull_currentFrameVisibilityFlag) {
      flagBuffer[globalIndex] = flags | spatialIndexFrustumCull_survivedCullingFlag;
    }
  }

  return true;
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/material-resource/enums.js
const WebGLContext = window.WebGL2RenderingContext || window.WebGLRenderingContext || {};
var AlphaMode;

(function (AlphaMode) {
  AlphaMode[AlphaMode["OPAQUE"] = 1] = "OPAQUE";
  AlphaMode[AlphaMode["MASK"] = 2] = "MASK";
  AlphaMode[AlphaMode["BLEND"] = 3] = "BLEND";
  AlphaMode[AlphaMode["ADDITIVE_BLEND"] = 4] = "ADDITIVE_BLEND";
  AlphaMode[AlphaMode["SUBTRACTIVE_BLEND"] = 5] = "SUBTRACTIVE_BLEND";
  AlphaMode[AlphaMode["MULTIPLY_BLEND"] = 6] = "MULTIPLY_BLEND";
  AlphaMode[AlphaMode["CUSTOM_BLEND"] = 7] = "CUSTOM_BLEND";
})(AlphaMode || (AlphaMode = {}));

var CullFace;

(function (CullFace) {
  CullFace[CullFace["NONE"] = 0] = "NONE";
  CullFace[CullFace["FRONT"] = WebGLContext.FRONT] = "FRONT";
  CullFace[CullFace["BACK"] = WebGLContext.BACK] = "BACK";
  CullFace[CullFace["BOTH"] = WebGLContext.FRONT_AND_BACK] = "BOTH";
})(CullFace || (CullFace = {}));
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/material-resource/properties.js

class properties_TextureProperties {
  constructor(texture, transform, channel = 0) {
    this._channel = channel;
    this._texture = texture;
    this.transform = transform instanceof lib["a" /* AffineMatrix2 */] ? transform.clone() : new lib["a" /* AffineMatrix2 */]();
    this.material = null;
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform;
    return new properties_TextureProperties(_texture, transform, _channel);
  }

  retain() {
    return this._texture.retain();
  }

  release() {
    this._texture.release();
  }

  get unloaded() {
    return this._texture.unloaded;
  }

  get loading() {
    return this._texture.loading;
  }

  load() {
    return this._texture.load();
  }

  unload() {
    this._texture.unload();
  }

  get channel() {
    return this._channel;
  }

  set channel(value) {
    this._channel = value;

    if (this.material !== null) {
      this.material.needsUpdate = true;
    }
  }

  get texture() {
    return this._texture;
  }

  set texture(value) {
    if (false) {}

    if (this._texture === value) {
      return;
    }

    if (this._texture.gammaDecode !== value.gammaDecode) {
      this.material.needsUpdate = true;
    }

    value.retain();

    this._texture.release();

    this._texture = value;
  }

  get name() {
    return this._texture.name;
  }

  get width() {
    return this._texture.width;
  }

  get height() {
    return this._texture.height;
  }

  get depth() {
    return this._texture.depth;
  }

  get bindingPoint() {
    return this._texture.bindingPoint;
  }

  get wrapS() {
    return this._texture.wrapS;
  }

  get wrapT() {
    return this._texture.wrapT;
  }

  get magFilter() {
    return this._texture.magFilter;
  }

  get minFilter() {
    return this._texture.minFilter;
  }

  get componentType() {
    return this._texture.componentType;
  }

  get format() {
    return this._texture.format;
  }

  get internalFormat() {
    return this._texture.internalFormat;
  }

  get levelsData() {
    return this._texture._levelsData;
  }

  get levels() {
    return this._texture.levels;
  }

}
class TextureArrayProperties extends properties_TextureProperties {
  constructor(texture, transform, channel = 0, index = 0) {
    super(texture, transform, channel);
    this.index = index;
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform,
          index = this.index;
    return new TextureArrayProperties(_texture, transform, _channel, index);
  }

}
class NormalMapProperties extends properties_TextureProperties {
  constructor(texture, transform, channel = 0, scale = 1) {
    super(texture, transform, channel);
    this.scale = scale;
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform,
          scale = this.scale;
    return new NormalMapProperties(_texture, transform, _channel, scale);
  }

}
class NormalMapFromArrayProperties extends TextureArrayProperties {
  constructor(texture, transform, channel = 0, index = 0, scale = 1) {
    super(texture, transform, channel, index);
    this.scale = scale;
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform,
          index = this.index,
          scale = this.scale;
    return new NormalMapFromArrayProperties(_texture, transform, _channel, index, scale);
  }

}
class AOMapProperties extends properties_TextureProperties {
  constructor(texture, transform, channel = 0, strength = 1) {
    super(texture, transform, channel);
    this._strength = Math.max(Math.min(strength, 1), 0);
  }

  get strength() {
    return this._strength;
  }

  set strength(value) {
    this._strength = Math.max(Math.min(value, 1), 0);
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform,
          _strength = this._strength;
    return new AOMapProperties(_texture, transform, _channel, _strength);
  }

}
class AOMapFromArrayProperties extends TextureArrayProperties {
  constructor(texture, transform, channel = 0, index = 0, strength = 1) {
    super(texture, transform, channel, index);
    this._strength = Math.max(Math.min(strength, 1), 0);
  }

  get strength() {
    return this._strength;
  }

  set strength(value) {
    this._strength = Math.max(Math.min(value, 1), 0);
  }

  clone() {
    const _channel = this._channel,
          _texture = this._texture,
          transform = this.transform,
          index = this.index,
          _strength = this._strength;
    return new AOMapFromArrayProperties(_texture, transform, _channel, index, _strength);
  }

}
class properties_EnvironmentMapProperties extends properties_TextureProperties {
  constructor(luminance, maxEnvLuminance, texture, projectionType = 'equirectangular') {
    super(texture, new lib["a" /* AffineMatrix2 */](1));
    this.luminance = luminance;
    this.maxEnvLuminance = maxEnvLuminance;
    this.projectionType = projectionType;
  }

  clone() {
    const luminance = this.luminance,
          maxEnvLuminance = this.maxEnvLuminance,
          _texture = this._texture,
          projectionType = this.projectionType;
    return new properties_EnvironmentMapProperties(luminance, maxEnvLuminance, _texture, projectionType);
  }

}
class EmissiveMapProperties extends properties_TextureProperties {
  constructor(luminance, texture, transform, channel = 0) {
    super(texture, transform, channel);
    this.luminance = luminance;
  }

  clone() {
    const luminance = this.luminance,
          _texture = this._texture,
          transform = this.transform,
          _channel = this._channel;
    return new EmissiveMapProperties(luminance, _texture, transform, _channel);
  }

}
class EmissiveMapFromArrayProperties extends TextureArrayProperties {
  constructor(luminance, texture, transform, channel = 0, index = 0) {
    super(texture, transform, channel, index);
    this.luminance = luminance;
  }

  clone() {
    const luminance = this.luminance,
          _texture = this._texture,
          transform = this.transform,
          _channel = this._channel,
          index = this.index;
    return new EmissiveMapFromArrayProperties(luminance, _texture, transform, _channel, index);
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/material-resource/material.js




let _lastMaterialId = 0;
class material_Material extends resource_Resource {
  constructor({
    name = '',
    alphaMode = material_Material.AlphaMode.OPAQUE,
    alphaCutoff = 0.0,
    cullFace = material_Material.CullFace.NONE
  }) {
    super();
    this.id = ++_lastMaterialId;
    this.name = name;
    this.alphaMode = alphaMode;
    this.cullFace = cullFace;
    this.depthTest = true;
    this.depthWrite = true;
    this.visible = true;
    this.lit = false;
    this._alphaCutoff = alphaCutoff;
    this._blendEq = BlendEquation.FUNC_ADD;
    this._blendEqAlpha = BlendEquation.FUNC_ADD;
    this._srcRGB = BlendFactor.ONE;
    this._dstRGB = BlendFactor.ZERO;
    this._srcAlpha = BlendFactor.ONE;
    this._dstAlpha = BlendFactor.ZERO;
    this.extras = undefined;
  }

  static get AlphaMode() {
    return AlphaMode;
  }

  static get CullFace() {
    return CullFace;
  }

  static get TextureProperties() {
    return properties_TextureProperties;
  }

  static get TextureArrayProperties() {
    return TextureArrayProperties;
  }

  static get NormalMapProperties() {
    return NormalMapProperties;
  }

  static get NormalMapFromArrayProperties() {
    return NormalMapFromArrayProperties;
  }

  static get AOMapProperties() {
    return AOMapProperties;
  }

  static get AOMapFromArrayProperties() {
    return AOMapFromArrayProperties;
  }

  static get EnvironmentMapProperties() {
    return properties_EnvironmentMapProperties;
  }

  static get EmissiveMapProperties() {
    return EmissiveMapProperties;
  }

  static get EmissiveMapFromArrayProperties() {
    return EmissiveMapFromArrayProperties;
  }

  setCustomAlphaMode(parameters = {}) {
    const _parameters$blendEqua = parameters.blendEquation,
          blendEquation = _parameters$blendEqua === void 0 ? BlendEquation.FUNC_ADD : _parameters$blendEqua,
          blendAlphaEquation = parameters.blendAlphaEquation,
          _parameters$srcColor = parameters.srcColor,
          srcColor = _parameters$srcColor === void 0 ? BlendFactor.ONE : _parameters$srcColor,
          _parameters$dstColor = parameters.dstColor,
          dstColor = _parameters$dstColor === void 0 ? BlendFactor.ZERO : _parameters$dstColor,
          srcAlpha = parameters.srcAlpha,
          dstAlpha = parameters.dstAlpha;
    this._blendEq = blendEquation;
    this._blendEqAlpha = blendAlphaEquation || blendEquation;
    this._srcRGB = srcColor;
    this._dstRGB = dstColor;
    this._srcAlpha = srcAlpha || srcColor;
    this._dstAlpha = dstAlpha || dstColor;
    this.alphaMode = AlphaMode.CUSTOM_BLEND;
  }

  get alphaCutoff() {
    return this._alphaCutoff;
  }

  set alphaCutoff(value) {
    this._alphaCutoff = value;
    this.needsUpdate = true;
  }

  get needsUpdate() {
    return false;
  }

  set needsUpdate(value) {
    if (false) {}
  }

  get shaders() {
    throw new Error('abstract material has no shaders');
  }

  clone() {
    throw new Error(`${this.constructor.name}.clone() is not implemented`);
  }

  getTextures() {
    return new Set();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/material-resource/index.js



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderQueueSort.js


function _sortFunction(lhs, rhs) {
  const lRQG = lhs.renderQueueGroup;
  const rRQG = rhs.renderQueueGroup;
  const lMode = lhs.material.alphaMode;
  const rMode = rhs.material.alphaMode;
  let cmp = 0;

  if (lRQG !== rRQG) {
    cmp = lRQG - rRQG;
  } else if (lMode !== material_Material.AlphaMode.BLEND && rMode === material_Material.AlphaMode.BLEND) {
    cmp = -1;
  } else if (lMode === material_Material.AlphaMode.BLEND && rMode !== material_Material.AlphaMode.BLEND) {
    cmp = 1;
  } else if (lMode === material_Material.AlphaMode.BLEND && rMode === material_Material.AlphaMode.BLEND) {
    const d = lhs.viewZ - rhs.viewZ;
    cmp = d !== 0 ? d : lhs.material.id - rhs.material.id;
  } else if (lMode !== material_Material.AlphaMode.BLEND && rMode !== material_Material.AlphaMode.BLEND) {
    cmp = lhs.material.id - rhs.material.id;
  }

  return cmp;
}

function renderQueueSort(queue) {
  queue.sort(_sortFunction);
  return queue;
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/render-request.js






var ClearMask;

(function (ClearMask) {
  ClearMask[ClearMask["NONE"] = 0] = "NONE";
  ClearMask[ClearMask["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  ClearMask[ClearMask["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  ClearMask[ClearMask["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
})(ClearMask || (ClearMask = {}));

var OutputLayoutSemantic;

(function (OutputLayoutSemantic) {
  OutputLayoutSemantic[OutputLayoutSemantic["DEFAULT"] = 1] = "DEFAULT";
  OutputLayoutSemantic[OutputLayoutSemantic["COLOR_0"] = 2] = "COLOR_0";
  OutputLayoutSemantic[OutputLayoutSemantic["COLOR_1"] = 4] = "COLOR_1";
  OutputLayoutSemantic[OutputLayoutSemantic["COLOR_2"] = 8] = "COLOR_2";
  OutputLayoutSemantic[OutputLayoutSemantic["COLOR_3"] = 16] = "COLOR_3";
  OutputLayoutSemantic[OutputLayoutSemantic["TM_DIFFUSE"] = 32] = "TM_DIFFUSE";
  OutputLayoutSemantic[OutputLayoutSemantic["TM_SPECULAR"] = 64] = "TM_SPECULAR";
  OutputLayoutSemantic[OutputLayoutSemantic["NORMALS"] = 128] = "NORMALS";
  OutputLayoutSemantic[OutputLayoutSemantic["EMISSIVE"] = 256] = "EMISSIVE";
  OutputLayoutSemantic[OutputLayoutSemantic["SPECULAR"] = 512] = "SPECULAR";
  OutputLayoutSemantic[OutputLayoutSemantic["DIFFUSE"] = 1024] = "DIFFUSE";
  OutputLayoutSemantic[OutputLayoutSemantic["DIRECT_SPECULAR"] = 2048] = "DIRECT_SPECULAR";
  OutputLayoutSemantic[OutputLayoutSemantic["INDIRECT_SPECULAR"] = 4096] = "INDIRECT_SPECULAR";
  OutputLayoutSemantic[OutputLayoutSemantic["DIRECT_DIFFUSE"] = 8192] = "DIRECT_DIFFUSE";
  OutputLayoutSemantic[OutputLayoutSemantic["INDIRECT_DIFFUSE"] = 16384] = "INDIRECT_DIFFUSE";
  OutputLayoutSemantic[OutputLayoutSemantic["VIEW_POSITION"] = 32768] = "VIEW_POSITION";
  OutputLayoutSemantic[OutputLayoutSemantic["HYPERBOLIC_DEPTH_RGBA"] = 65536] = "HYPERBOLIC_DEPTH_RGBA";
  OutputLayoutSemantic[OutputLayoutSemantic["INSTANCE_COLOR"] = 131072] = "INSTANCE_COLOR";
  OutputLayoutSemantic[OutputLayoutSemantic["CIE_xyY_COLOR"] = 262144] = "CIE_xyY_COLOR";
  OutputLayoutSemantic[OutputLayoutSemantic["CIE_LUV_COLOR"] = 524288] = "CIE_LUV_COLOR";
  OutputLayoutSemantic[OutputLayoutSemantic["LINEAR_HDR_COLOR"] = 1048576] = "LINEAR_HDR_COLOR";
})(OutputLayoutSemantic || (OutputLayoutSemantic = {}));

let _lastRenderPassId = 0;
class RenderPassStatistics {
  constructor() {
    this.subpassCount = 0;
    this.drawCallCount = 0;
    this.instanceCount = 0;
    this.vertexCount = 0;
    this.materialCount = 0;
    this.programCount = 0;
  }

  reset() {
    this.subpassCount = 0;
    this.drawCallCount = 0;
    this.instanceCount = 0;
    this.vertexCount = 0;
    this.materialCount = 0;
    this.programCount = 0;
  }

  add(statistics) {
    this.subpassCount += statistics.subpassCount;
    this.drawCallCount += statistics.drawCallCount;
    this.instanceCount += statistics.instanceCount;
    this.vertexCount += statistics.vertexCount;
    this.materialCount += statistics.materialCount;
    this.programCount += statistics.programCount;
  }

}
class render_request_RenderRequest {
  constructor(options) {
    const look = options.look,
          scene = options.scene,
          _options$enabled = options.enabled,
          enabled = _options$enabled === void 0 ? true : _options$enabled,
          _options$systems = options.systems,
          systems = _options$systems === void 0 ? null : _options$systems,
          _options$autoResize = options.autoResize,
          autoResize = _options$autoResize === void 0 ? true : _options$autoResize,
          _options$srgbOutput = options.srgbOutput,
          srgbOutput = _options$srgbOutput === void 0 ? false : _options$srgbOutput,
          _options$renderTarget = options.renderTarget,
          renderTarget = _options$renderTarget === void 0 ? null : _options$renderTarget,
          _options$viewportStyl = options.viewportStyle,
          viewportStyle = _options$viewportStyl === void 0 ? {
      pixelMode: 'browser',
      left: '0',
      right: '0',
      top: '0',
      bottom: '0'
    } : _options$viewportStyl,
          _options$extraPixelRa = options.extraPixelRatio,
          extraPixelRatio = _options$extraPixelRa === void 0 ? 1 : _options$extraPixelRa,
          _options$maxResolutio = options.maxResolutionSize,
          maxResolutionSize = _options$maxResolutio === void 0 ? Infinity : _options$maxResolutio;
    this.id = ++_lastRenderPassId;
    this.dt = 0;
    this.scene = scene;
    this.srgbOutput = srgbOutput;
    this.frameNumber = 0;
    this.renderTarget = renderTarget;
    this._queueRangeIndex = 0;
    this.clearMask = ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT | ClearMask.STENCIL_BUFFER_BIT;
    this.statistics = new RenderPassStatistics();
    this._output = 0;
    this._outputLayout = new Map();
    this.frustumCull = spatialIndexFrustumCull;
    this.renderQueueSort = renderQueueSort;
    this.queueRangeSize = 0;
    this._queueRangeOffset = 0;
    this._premultipliedAlpha = false;
    this._viewport = null;
    this._multiplyPixelRatio = true;
    this._events = new Map();

    for (const stage of [100, 200]) {
      this._events.set(stage, new _wgetemp_event["a" /* Event */]());
    }

    this.onEnd = new _wgetemp_event["a" /* Event */]();
    this.onStart = new _wgetemp_event["a" /* Event */]();
    this.onSubpassEnd = new _wgetemp_event["a" /* Event */]();
    this.onRangeStart = new _wgetemp_event["a" /* Event */]();
    this.onSubpassStart = new _wgetemp_event["a" /* Event */]();
    this.renderQueue = [];
    this.computeViewZ = true;
    this.testSurvivedCullingFlag = true;
    this.look = look;
    this.width = 1;
    this.height = 1;
    this.enabled = enabled;
    this.systems = systems ? new Set(options.systems) : null;
    this.autoResize = autoResize;
    this.extraPixelRatio = extraPixelRatio;
    this.maxResolutionSize = maxResolutionSize;
    this.needsViewportUpdate = true;
    this._viewportStyle = {
      pixelMode: 'browser',
      ...viewportStyle
    };
  }

  get queueRangeIndex() {
    return this._queueRangeIndex;
  }

  set queueRangeIndex(value) {
    this._queueRangeIndex = value;
    this._queueRangeOffset = this.queueRangeSize * value;
  }

  set viewportStyle(viewportStyle) {
    this._viewportStyle = {
      pixelMode: 'browser',
      ...viewportStyle
    };
    this.needsViewportUpdate = true;
  }

  get viewportStyle() {
    return this._viewportStyle;
  }

  get rangedPass() {
    return this.queueRangeSize > 0;
  }

  runFrustumCull(subPassIndex) {
    const scene = this.scene,
          look = this.look,
          frameNumber = this.frameNumber,
          frustumCull = this.frustumCull;

    if (look.isCubeCamera) {
      look.cubeSideIndex = subPassIndex;
    }

    if (frustumCull(scene, look, frameNumber)) {
      this.updateRenderQueue();
    }

    return this.renderQueue;
  }

  setOutputLayoutPosition(layoutSemantic, layoutPosition) {
    const _outputLayout = this._outputLayout,
          renderTarget = this.renderTarget;

    if (false) {}

    _outputLayout.set(layoutSemantic, layoutPosition);

    this._output |= layoutSemantic;
  }

  getOutputLayoutPosition(layoutSemantic) {
    const layoutPos = this._outputLayout.get(layoutSemantic);

    return layoutPos !== undefined ? layoutPos : null;
  }

  removeOutputLayout(layoutSemantic) {
    this._outputLayout.delete(layoutSemantic);

    this._output &= ~layoutSemantic;
  }

  get output() {
    return this._output === 0 ? OutputLayoutSemantic.DEFAULT : this._output;
  }

  copy(src) {
    this.scene = src.scene;
    this.frameNumber = src.frameNumber;
    this.renderTarget = src.renderTarget;
    this.srgbOutput = src.srgbOutput;
    this.dt = src.dt;
  }

  setViewport(x, y, width, height, multiplyPixelRatio = true) {
    this._multiplyPixelRatio = multiplyPixelRatio;
    this._viewport = {
      x,
      y,
      width,
      height
    };
  }

  onStageEnd(stage) {
    const event = this._events.get(stage);

    if (event === undefined) {
      throw new Error('Stage not exist');
    }

    return event;
  }

}
render_request_RenderRequest.OutputLayoutSemantic = OutputLayoutSemantic;
Object.assign(render_request_RenderRequest.prototype, {
  updateRenderQueue: function _updateRenderQueue() {
    const prevFrameVisibilityFlag = 0x01;
    const currentFrameVisibilityFlag = 0x02;
    const transformUpdateFlag = 0x04;
    const customAttributeUpdateFlag = 0x10;
    const survivedCullingFlag = 0x20;
    const batch_ = new InstancedBatch();
    const cameraBack = new lib["n" /* Vector3 */]();
    const cameraPosition = new lib["n" /* Vector3 */]();
    const renderableDirection = new lib["n" /* Vector3 */]();

    const _computeViewZ = function (centers, idx, dir, back, pos) {
      dir.fromArrayAt(idx * 3, centers).subtract(pos);
      return dir.dot(back);
    };

    return function updateRenderQueue() {
      const computeViewZ = this.computeViewZ,
            testSurvivedCullingFlag = this.testSurvivedCullingFlag,
            renderQueue = this.renderQueue,
            scene = this.scene,
            look = this.look,
            queueSort = this.renderQueueSort;
      const instanceDataManager = scene.instanceDataManager;
      const _worldTransformsBack = instanceDataManager._worldTransformsBack,
            _worldTransformsFront = instanceDataManager._worldTransformsFront,
            _centers = instanceDataManager._centers,
            _flagBuffers = instanceDataManager._flagBuffers,
            _instancedBatches = instanceDataManager._instancedBatches,
            elementsPerInstance = instanceDataManager.elementsPerInstance,
            bytesPerInstance = instanceDataManager.bytesPerInstance;
      let flushRangeFrom = Infinity;
      let flushRangeTo = 0;

      if (computeViewZ && look.worldMatrix !== undefined) {
        look.worldMatrix.axisZPaste(cameraBack);
        look.worldMatrix.translationPaste(cameraPosition);
      }

      renderQueue.length = 0;
      {
        const batchCount = _instancedBatches.batchCount;
        const flagBuffer = _flagBuffers;
        const centers = _centers;
        let prevBatchChanged = false;

        for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
          _instancedBatches.unpackBatch(batchIndex, batch_);

          let visibleInstanceCount = 0;
          let viewZ = 0;
          let needsUpdate = false;
          const excluded = batch_.excluded;

          for (let j = 0, len = batch_.instanceCount; j < len; j++) {
            const instanceIdx = batch_.firstInstance + j;
            let flags = flagBuffer[instanceIdx];
            const survivedCulling = !!(flags & survivedCullingFlag) || !testSurvivedCullingFlag;
            const inFrame = !!(flags & currentFrameVisibilityFlag);
            const isVisible = inFrame && survivedCulling && !excluded;
            const prevFrameVisibilityStatus = (flags & prevFrameVisibilityFlag) !== 0;

            if (isVisible !== prevFrameVisibilityStatus) {
              needsUpdate = true;
              flags = isVisible ? flags | prevFrameVisibilityFlag : flags & ~prevFrameVisibilityFlag;
            }

            const needsUpdateTransform = (flags & transformUpdateFlag) !== 0;

            if (needsUpdateTransform) {
              needsUpdate = true;
              flags &= ~transformUpdateFlag;
            }

            const needsUpdateCustomAttributes = (flags & customAttributeUpdateFlag) !== 0;

            if (needsUpdateCustomAttributes) {
              needsUpdate = true;
              flags &= ~customAttributeUpdateFlag;
            }

            flagBuffer[instanceIdx] = flags;

            if (isVisible) {
              viewZ = computeViewZ ? _computeViewZ(centers, instanceIdx, renderableDirection, cameraBack, cameraPosition) : 0;
              const srcElementOffset = instanceIdx * elementsPerInstance;
              const srcByteOffset = srcElementOffset * Float32Array.BYTES_PER_ELEMENT;
              const dstElementOffset = (batch_.firstInstance + visibleInstanceCount++) * elementsPerInstance;

              _worldTransformsFront.set(new Float32Array(_worldTransformsBack.buffer, srcByteOffset, elementsPerInstance), dstElementOffset);

              _worldTransformsFront[dstElementOffset + 12] = j;
            }
          }

          if (prevBatchChanged) {
            needsUpdate = true;
          }

          if (!prevBatchChanged && needsUpdate) {
            prevBatchChanged = true;
          }

          if (needsUpdate) {
            flushRangeFrom = Math.min(flushRangeFrom, batch_.firstInstance * bytesPerInstance);
            flushRangeTo = Math.max(flushRangeTo, (batch_.firstInstance + visibleInstanceCount) * bytesPerInstance);
          }

          if (visibleInstanceCount > 0) {
            const instanceId = batch_.instanceId,
                  firstInstance = batch_.firstInstance;
            const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);
            batchRenderable.firstInstance = firstInstance;
            batchRenderable.visibleInstanceCount = visibleInstanceCount;
            batchRenderable.viewZ = viewZ;
            renderQueue.push(batchRenderable);
          }
        }
      }
      queueSort(renderQueue);
      flushRangeFrom = Object(lib["r" /* isFinite */])(flushRangeFrom) ? flushRangeFrom : 0;
      instanceDataManager.setInstancedMemoryFlushRange(flushRangeFrom, flushRangeTo);
    };
  }()
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderable.js



function _defaultReallocStrategy(capacity) {
  return capacity < 16 ? Math.max(1, capacity * 2) : capacity + 1;
}

let _lastRenderableId = 0;
class renderable_Renderable {
  constructor(geometry, material) {
    this.renderQueueGroup = RenderQueueGroup.MAIN;

    if (material !== null) {
      material.retain();
    }

    this._material = material;
    this._depthMaterials = [null, null];

    if (geometry !== null) {
      geometry.retain();
    }

    this._geometry = geometry;
    this._instanceId = null;
    this.instanceIndex = null;
    this.reallocStrategy = _defaultReallocStrategy;
    this._instanceIdentifierExpired = false;
    this._lastUpdateFrameNumber = 0;
    this._customAttributesToRead = [];
    this._customAttributesToWrite = [];
    this._loaded = true;
    this._id = ++_lastRenderableId;
  }

  get unloaded() {
    return !this._loaded;
  }

  getInstancedAttribute(semantic, outVal) {
    return new Promise(resolve => {
      this._customAttributesToRead.push({
        resolve,
        semantic,
        outVal
      });
    });
  }

  setInstancedAttribute(semantic, inVal) {
    this._customAttributesToWrite.push({
      semantic,
      inVal
    });
  }

  get id() {
    return this._id;
  }

  get lastUpdateFrameNumber() {
    return this._lastUpdateFrameNumber;
  }

  get geometry() {
    return this._geometry;
  }

  set geometry(value) {
    if (this._geometry === value) {
      return;
    }

    if (this._instanceId !== null) {
      this._instanceIdentifierExpired = true;
    }

    if (this._geometry !== null) {
      this._geometry.release();
    }

    this._geometry = value;

    if (this._geometry !== null) {
      this._geometry.retain();
    }
  }

  get material() {
    return this._material;
  }

  set material(value) {
    if (false) {}

    if (this._material === value) {
      return;
    }

    if (this._instanceId !== null) {
      this._instanceIdentifierExpired = true;
    }

    if (this._material !== null) {
      this._material.release();
    }

    this._depthMaterials[0] = null;
    this._depthMaterials[1] = null;
    this._material = value;

    if (this._material !== null) {
      this._material.retain();
    }
  }

  get depthMaterials() {
    return this._depthMaterials;
  }

  get needsUpdate() {
    return false;
  }

  get instanceId() {
    return this._instanceId;
  }

  get instanceIdentifierExpired() {
    return this._instanceIdentifierExpired;
  }

  get skeleton() {
    return null;
  }

  clone() {
    const geometry = this.geometry,
          material = this.material,
          _depthMaterials = this._depthMaterials,
          renderQueueGroup = this.renderQueueGroup,
          reallocStrategy = this.reallocStrategy;
    const clone_ = new renderable_Renderable(geometry, material);
    clone_.renderQueueGroup = renderQueueGroup;
    clone_.reallocStrategy = reallocStrategy;
    clone_._depthMaterials = _depthMaterials.slice();
    return clone_;
  }

  async load() {
    await Promise.all(function* () {
      if (this._geometry !== null) {
        yield this._geometry.load();
      }

      if (this._material !== null) {
        yield this._material.load();
      }
    }.call(this));
    this._loaded = true;

    this._emitLoadEvent();
  }

  unload() {
    if (false) {}

    if (this._geometry !== null) {
      this._geometry.unload();
    }

    if (this._material !== null) {
      this._material.unload();
    }

    this._loaded = false;

    this._emitUnloadEvent();
  }

  dispose() {
    if (this._geometry !== null) {
      this._geometry.release();

      this._geometry = null;
    }

    if (this._material !== null) {
      this._material.release();

      this._material = null;
    }

    this._emitDisposeEvent();
  }

  resetEvents() {
    delete this._onLoad;
    delete this._onUnload;
    delete this._onDispose;
  }

  get onUnload() {
    if (this._onUnload === undefined) {
      this._onUnload = new _wgetemp_event["a" /* Event */]();
    }

    return this._onUnload;
  }

  get onLoad() {
    if (this._onLoad === undefined) {
      this._onLoad = new _wgetemp_event["a" /* Event */]();
    }

    return this._onLoad;
  }

  get onDispose() {
    if (this._onDispose === undefined) {
      this._onDispose = new _wgetemp_event["a" /* Event */]();
    }

    return this._onDispose;
  }

  _emitLoadEvent() {
    if (this._onLoad !== undefined) {
      this._onLoad.emit();
    }
  }

  _emitUnloadEvent() {
    if (this._onUnload !== undefined) {
      this._onUnload.emit();
    }
  }

  _emitDisposeEvent() {
    if (this._onDispose !== undefined) {
      this._onDispose.emit();
    }
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/tuple-map.js
var tuple_map = __webpack_require__(395);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/instancedBatches.js
function instancedBatches_slicedToArray(arr, i) { return instancedBatches_arrayWithHoles(arr) || instancedBatches_iterableToArrayLimit(arr, i) || instancedBatches_unsupportedIterableToArray(arr, i) || instancedBatches_nonIterableRest(); }

function instancedBatches_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function instancedBatches_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return instancedBatches_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return instancedBatches_arrayLikeToArray(o, minLen); }

function instancedBatches_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function instancedBatches_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function instancedBatches_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


const instancedBatches_bytesPerBatch = InstancedBatch.bytesPerBatch;
const EXCLUDE_BATCH_FLAG = 0x02;
class InstancedBatches {
  constructor({
    initialBatchCount = 25,
    increaseStep = 5
  }) {
    this.batchBuffer = new Uint8Array(instancedBatches_bytesPerBatch * initialBatchCount);
    this.batchCount = 0;
    this.batchCapacity = initialBatchCount;
    this.increaseStep = increaseStep;
  }

  emplaceBatch(instanceId, capacity = 0) {
    const batchBuffer = this.batchBuffer,
          increaseStep = this.increaseStep;

    if (this.batchCapacity <= this.batchCount) {
      this.batchCapacity += increaseStep;
      const newBatchBuffer = new Uint8Array(this.batchCapacity * instancedBatches_bytesPerBatch);
      newBatchBuffer.set(batchBuffer);
      this.batchBuffer = newBatchBuffer;
    }

    const batchIdx = this.batchCount++;
    {
      const buffer = this.batchBuffer.buffer;
      const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);
      view[0] = 0;
      view[1] = -1;
      view[2] = 0;
      view[3] = capacity;
      view[4] = instanceId;
    }
    return batchIdx;
  }

  packBatch(batchIdx, batch) {
    const batchBuffer = this.batchBuffer;
    const buffer = batchBuffer.buffer;
    const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);
    view[0] = batch.flags;
    view[1] = batch.firstInstance === null ? -1 : batch.firstInstance;
    view[2] = batch.instanceCount;
    view[3] = batch.capacity;
    view[4] = batch.instanceId;
  }

  hasBatch(batchIdx) {
    return this.batchCount > batchIdx;
  }

  unpackBatch(batchIdx, batch) {
    const batchBuffer = this.batchBuffer;
    const buffer = batchBuffer.buffer;
    const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);

    const _view = instancedBatches_slicedToArray(view, 5),
          flags = _view[0],
          firstInstance = _view[1],
          instanceCount = _view[2],
          capacity = _view[3],
          instanceId = _view[4];

    batch.flags = flags;
    batch.firstInstance = firstInstance >= 0 ? firstInstance : null;
    batch.instanceCount = instanceCount;
    batch.capacity = capacity;
    batch.instanceId = instanceId;
  }

  unpackLastBatch(batch) {
    const batchBuffer = this.batchBuffer,
          batchCount = this.batchCount;
    const buffer = batchBuffer.buffer;

    if (false) {}

    const batchIdx = batchCount - 1;
    const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch + 4, 4);

    const _view2 = instancedBatches_slicedToArray(view, 4),
          firstInstance = _view2[0],
          instanceCount = _view2[1],
          capacity = _view2[2],
          instanceId = _view2[3];

    batch.firstInstance = firstInstance >= 0 ? firstInstance : null;
    batch.instanceCount = instanceCount;
    batch.capacity = capacity;
    batch.instanceId = instanceId;
  }

  shiftFirstInstance(batchIdx, shift) {
    const batchBuffer = this.batchBuffer,
          batchCount = this.batchCount;
    const buffer = batchBuffer.buffer;

    for (let i = batchIdx + 1; i < batchCount; i++) {
      new Int32Array(buffer, i * instancedBatches_bytesPerBatch + 4, 1)[0] += shift;
    }
  }

  getBatchGlobalIndex(batchIdx, instanceIndex) {
    const batchBuffer = this.batchBuffer;
    const buffer = batchBuffer.buffer;
    const firstInstance = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch + 4, 1)[0];
    return firstInstance + instanceIndex;
  }

  disableBatch(batchIdx) {
    const batchBuffer = this.batchBuffer;
    return batchBuffer[batchIdx * instancedBatches_bytesPerBatch] |= EXCLUDE_BATCH_FLAG;
  }

  enableBatch(batchIdx) {
    const batchBuffer = this.batchBuffer;
    return batchBuffer[batchIdx * instancedBatches_bytesPerBatch] &= ~EXCLUDE_BATCH_FLAG;
  }

  disableAll() {
    const batchBuffer = this.batchBuffer,
          batchCount = this.batchCount;

    for (let i = 0; i < batchCount; i++) {
      batchBuffer[i * instancedBatches_bytesPerBatch] |= EXCLUDE_BATCH_FLAG;
    }
  }

  enableAll() {
    const batchBuffer = this.batchBuffer,
          batchCount = this.batchCount;

    for (let i = 0; i < batchCount; i++) {
      batchBuffer[i * instancedBatches_bytesPerBatch] &= ~EXCLUDE_BATCH_FLAG;
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/instanceDataManager.js
function instanceDataManager_slicedToArray(arr, i) { return instanceDataManager_arrayWithHoles(arr) || instanceDataManager_iterableToArrayLimit(arr, i) || instanceDataManager_unsupportedIterableToArray(arr, i) || instanceDataManager_nonIterableRest(); }

function instanceDataManager_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function instanceDataManager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return instanceDataManager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return instanceDataManager_arrayLikeToArray(o, minLen); }

function instanceDataManager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function instanceDataManager_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function instanceDataManager_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







let _lastInstanceId = 0;
const transformElementsPerInstance = 14;
const centerElementsPerInstance = 3;

function shiftBuffer(typedArray, firstInstance, shift, elementsPerInstance) {
  const offset = (firstInstance + shift) * elementsPerInstance;
  const move = new typedArray.constructor(typedArray.buffer, firstInstance * elementsPerInstance * typedArray.BYTES_PER_ELEMENT, typedArray.length - offset);
  typedArray.set(move, offset);
}

function getAttributeSemanticName(attributeSemantic) {
  for (const name of Object.getOwnPropertyNames(AttributeSemantic)) {
    if (name === 'length') {
      continue;
    }

    if (AttributeSemantic[name] === attributeSemantic) {
      return name;
    }
  }

  return 'NONE';
}
class instanceDataManager_BatchRenderable extends disposeableUsageCounter_DisposableUsageCounter {
  constructor(instance) {
    super();
    this.renderQueueGroup = instance.renderQueueGroup;
    this.instanceId = instance.instanceId;
    this.material = instance.material;
    this.geometry = instance.geometry;
    this.depthMaterials = [...instance.depthMaterials];
    this.vao = null;
    this.depthVao = null;
    this.vaoLayoutVersion = 0;
    this.depthVaoLayoutVersion = 0;
    this.webGLAttributeSystem = null;
    this.viewZ = 0.0;
    this.visibleInstanceCount = 0;
    this.batchIdx = null;
    this.reallocStrategy = instance.reallocStrategy;
    this.skeletonBuffers = null;
    this.morphWeights = null;
    this.positionMorphTargetCount = 0;
    this.normalMorphTargetCount = 0;
    this._firstInstance = 0;
  }

  get firstInstance() {
    return this._firstInstance;
  }

  set firstInstance(value) {
    if (this._firstInstance !== value) {
      this.vaoLayoutVersion = 0;
      this.depthVaoLayoutVersion = 0;
    }

    this._firstInstance = value;
  }

  get hasMorph() {
    return this.positionMorphTargetCount > 0 || this.normalMorphTargetCount > 0;
  }

  _dispose() {
    const webGLAttributeSystem = this.webGLAttributeSystem;

    if (webGLAttributeSystem !== null) {
      webGLAttributeSystem.deleteRenderable(this);
      this.webGLAttributeSystem = null;
    }
  }

}
class instanceDataManager_InstanceDataManager {
  constructor(config = {}) {
    const _config$batchMap = config.batchMap,
          batchMap = _config$batchMap === void 0 ? null : _config$batchMap,
          _config$initialRangeC = config.initialRangeCount,
          initialRangeCount = _config$initialRangeC === void 0 ? 128 : _config$initialRangeC,
          _config$increaseStep = config.increaseStep,
          increaseStep = _config$increaseStep === void 0 ? 5 : _config$increaseStep,
          _config$initialSceneN = config.initialSceneNodes,
          initialSceneNodes = _config$initialSceneN === void 0 ? 2 : _config$initialSceneN,
          _config$customAttribu = config.customAttributes,
          customAttributes = _config$customAttribu === void 0 ? [] : _config$customAttribu;
    this._batchMap = batchMap || new tuple_map["a" /* TupleMap */]();
    let initialInstanceCount = 0;

    for (const k of this._batchMap.values()) {
      initialInstanceCount += k;
    }

    initialInstanceCount = Math.max(initialInstanceCount, initialSceneNodes);
    const uniqueInstances = new Map();
    this._uniqueInstances = uniqueInstances;
    const freeIndices = new WeakMap();
    this._freeIndices = freeIndices;
    const instanceIdentifiers = new Map();
    this._instanceIdentifiers = instanceIdentifiers;
    this._instanceCount = initialInstanceCount;
    let instancedElementsPerInstance = transformElementsPerInstance;
    let customAttributeByteOffset = transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
    const customInstancedAttributes = new Map();
    this._customInstancedAttributes = customInstancedAttributes;

    for (const customAttribute of customAttributes) {
      const semantic = customAttribute.semantic,
            countComponents = customAttribute.countComponents;
      customInstancedAttributes.set(semantic, {
        byteOffset: customAttributeByteOffset,
        countComponents
      });
      customAttributeByteOffset += countComponents * Float32Array.BYTES_PER_ELEMENT;
      instancedElementsPerInstance += countComponents;
    }

    this._instancedAttributes = new Map(customInstancedAttributes);

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_1, {
      byteOffset: 0,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_2, {
      byteOffset: 16,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_3, {
      byteOffset: 32,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_IDENTIFIERS, {
      byteOffset: 48,
      countComponents: 2
    });

    this._instancedElementsPerInstance = instancedElementsPerInstance;
    this._worldTransformsBack = new Float32Array(instancedElementsPerInstance * initialInstanceCount);
    this._worldTransformsFront = new Float32Array(instancedElementsPerInstance * initialInstanceCount);
    this._centers = new Float32Array(centerElementsPerInstance * initialInstanceCount);
    this._flagBuffers = new Uint8Array(initialInstanceCount);
    const instancedBatches = new InstancedBatches({
      initialBatchCount: this._batchMap.size,
      increaseStep
    });
    this._instancedBatches = instancedBatches;
    this._flushRangeFrom = 0;
    this._flashRangeTo = 0;
    this._gpuInstancedData = null;
  }

  addCustomAttributes(customAttributes) {
    let customAttributeByteOffset = transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
    const _customInstancedAttributes = this._customInstancedAttributes;

    for (const customInstancedAttribute of _customInstancedAttributes.values()) {
      const byteOffset = customInstancedAttribute.byteOffset;
      customAttributeByteOffset += byteOffset;
    }

    for (const customAttribute of customAttributes) {
      const semantic = customAttribute.semantic,
            countComponents = customAttribute.countComponents;

      if (_customInstancedAttributes.has(semantic)) {
        continue;
      }

      _customInstancedAttributes.set(semantic, {
        byteOffset: customAttributeByteOffset,
        countComponents
      });

      customAttributeByteOffset += countComponents * Float32Array.BYTES_PER_ELEMENT;
      this._instancedElementsPerInstance += countComponents;
    }

    this._instancedAttributes = new Map(_customInstancedAttributes);

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_1, {
      byteOffset: 0,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_2, {
      byteOffset: 16,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_3, {
      byteOffset: 32,
      countComponents: 4
    });

    this._instancedAttributes.set(AttributeSemantic.INSTANCE_IDENTIFIERS, {
      byteOffset: 48,
      countComponents: 2
    });

    {
      const _instancedElementsPerInstance = this._instancedElementsPerInstance,
            _instanceCount = this._instanceCount;
      this._worldTransformsBack = new Float32Array(_instancedElementsPerInstance * _instanceCount);
      this._worldTransformsFront = new Float32Array(_instancedElementsPerInstance * _instanceCount);
    }
  }

  getInstanceIdentifier(geometryId, materialId) {
    const _instanceIdentifiers = this._instanceIdentifiers;

    let materialIdentifiers = _instanceIdentifiers.get(geometryId);

    if (materialIdentifiers === undefined) {
      materialIdentifiers = new Map();

      _instanceIdentifiers.set(geometryId, materialIdentifiers);
    }

    let instanceId = materialIdentifiers.get(materialId);

    if (instanceId === undefined) {
      instanceId = ++_lastInstanceId;
      materialIdentifiers.set(materialId, instanceId);
    }

    return instanceId;
  }

  getInstanceRenderable(instanceId) {
    return this._uniqueInstances.get(instanceId);
  }

  getInstanceGlobalIndex(batchIdx, instanceIndex) {
    return this._instancedBatches.getBatchGlobalIndex(batchIdx, instanceIndex);
  }

  getInstancedAttributeStaging() {
    return this._worldTransformsFront;
  }

  storeCenter(center, globalIndex) {
    const _centers = this._centers;
    center.toArrayAt(globalIndex * centerElementsPerInstance, _centers);
  }

  storeRenderableIdentifier(globalIndex, identifier) {
    const buffer = this._worldTransformsBack,
          _instancedElementsPerInstance = this._instancedElementsPerInstance;
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    const uniqueInstanceOffset = 13;
    buffer[baseOffset + uniqueInstanceOffset] = identifier;
  }

  getRenderableIdentifier(globalIndex) {
    const buffer = this._worldTransformsBack,
          _instancedElementsPerInstance = this._instancedElementsPerInstance;
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    const uniqueInstanceOffset = 13;
    return buffer[baseOffset + uniqueInstanceOffset];
  }

  storeWorldTransform(matrix, globalIndex) {
    const buffer = this._worldTransformsBack,
          _flagBuffers = this._flagBuffers,
          _instancedElementsPerInstance = this._instancedElementsPerInstance;
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    matrix.toAffineColumnArrayAt(baseOffset, buffer);
    _flagBuffers[globalIndex] |= 0x04;
  }

  readWorldTransform(matrix, globalIndex) {
    const buffer = this._worldTransformsBack,
          _instancedElementsPerInstance = this._instancedElementsPerInstance;
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    matrix.fromAffineColumnArrayAt(baseOffset, buffer);
  }

  _reallocBuffers(currentBufferUsage) {
    const _instanceCount = this._instanceCount,
          _instancedElementsPerInstance = this._instancedElementsPerInstance,
          _worldTransformsBack = this._worldTransformsBack,
          _worldTransformsFront = this._worldTransformsFront,
          _centers = this._centers,
          _flagBuffers = this._flagBuffers;
    const newNodeCount = Math.ceil(_instanceCount * 1.618);
    const newByteSize = _instancedElementsPerInstance * newNodeCount * Float32Array.BYTES_PER_ELEMENT;
    {
      const newBuffer = new Float32Array(_instancedElementsPerInstance * newNodeCount);
      newBuffer.set(_worldTransformsBack);
      this._worldTransformsBack = newBuffer;
    }
    {
      const newBuffer = new Float32Array(_instancedElementsPerInstance * newNodeCount);
      newBuffer.set(_worldTransformsFront);
      this._worldTransformsFront = newBuffer;
    }
    {
      const newBuffer = new Float32Array(centerElementsPerInstance * newNodeCount);
      newBuffer.set(_centers);
      this._centers = newBuffer;
    }
    {
      const newBuffer = new Uint8Array(newNodeCount);
      newBuffer.set(_flagBuffers);
      this._flagBuffers = newBuffer;
    }
    const countLeft = (newByteSize - currentBufferUsage) / this.bytesPerInstance;
    this._instanceCount = newNodeCount;
    return countLeft;
  }

  _setInstancedAttributeScalar(semantic, offset, value) {
    const _worldTransformsBack = this._worldTransformsBack;
    _worldTransformsBack[offset] = value;
  }

  _setInstancedAttributeVector(semantic, offset, value) {
    const _worldTransformsBack = this._worldTransformsBack;
    value.toArrayAt(offset, _worldTransformsBack);
  }

  _setInstancedAttributeRange(semantic, offset, value) {
    const _worldTransformsBack = this._worldTransformsBack;

    _worldTransformsBack.set(value, offset);
  }

  setInstancedAttribute(instance, semantic, value) {
    const customInstancedAttributeLayout = this.customInstancedAttributeLayout,
          _instancedElementsPerInstance = this._instancedElementsPerInstance,
          _flagBuffers = this._flagBuffers;
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex,
          _instanceIdentifierExpired = instance._instanceIdentifierExpired;

    if (false) {}

    const batchRenderable = this.getInstanceRenderable(instanceId);
    const batchIdx = batchRenderable.batchIdx;

    if (false) {}

    const _customInstancedAttri = customInstancedAttributeLayout.get(semantic),
          byteOffset = _customInstancedAttri.byteOffset;

    const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;
    const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    const offset = baseOffset + elementOffset;

    if (!isNaN(value)) {
      this._setInstancedAttributeScalar(semantic, offset, value);
    } else if (Array.isArray(value) || value instanceof Float32Array) {
      this._setInstancedAttributeRange(semantic, offset, value);
    } else {
      this._setInstancedAttributeVector(semantic, offset, value);
    }

    const customAttributeUpdateFlag = 0x10;
    _flagBuffers[globalIndex] |= customAttributeUpdateFlag;
  }

  _getInstancedAttributeScalar(semantic, offset) {
    const _worldTransformsBack = this._worldTransformsBack;
    return _worldTransformsBack[offset];
  }

  _getInstancedAttributeVector(semantic, offset, vect) {
    const _worldTransformsBack = this._worldTransformsBack;
    vect.fromArrayAt(offset, _worldTransformsBack);
    return vect;
  }

  _getInstancedAttributeRange(semantic, offset, range) {
    const _worldTransformsBack = this._worldTransformsBack;

    for (let i = 0, count = range.length; i < count; i++) {
      range[i] = _worldTransformsBack[offset + i];
    }

    return range;
  }

  getInstancedAttribute(instance, semantic, outVal) {
    const _instancedAttributes = this._instancedAttributes,
          _instancedElementsPerInstance = this._instancedElementsPerInstance;
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex,
          _instanceIdentifierExpired = instance._instanceIdentifierExpired;

    if (false) {}

    const batchRenderable = this.getInstanceRenderable(instanceId);
    const batchIdx = batchRenderable.batchIdx;

    if (false) {}

    const _instancedAttributes$ = _instancedAttributes.get(semantic),
          byteOffset = _instancedAttributes$.byteOffset;

    const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;
    const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);
    const baseOffset = globalIndex * _instancedElementsPerInstance;
    const offset = baseOffset + elementOffset;
    let out = null;

    if (outVal === undefined) {
      out = this._getInstancedAttributeScalar(semantic, offset);
    } else if (Array.isArray(outVal) || outVal instanceof Float32Array) {
      out = this._getInstancedAttributeRange(semantic, offset, outVal);
    } else {
      out = this._getInstancedAttributeVector(semantic, offset, outVal);
    }

    return out;
  }

  _extractInstancedData(instance, savedAttribs, matrix) {
    const _instancedElementsPerInstance = this._instancedElementsPerInstance,
          _customInstancedAttributes = this._customInstancedAttributes;
    const countElements = _instancedElementsPerInstance - transformElementsPerInstance;
    const buffer = new ArrayBuffer(countElements * Float32Array.BYTES_PER_ELEMENT);
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex;

    if (false) {}

    const _this$getInstanceRend = this.getInstanceRenderable(instanceId),
          batchIdx = _this$getInstanceRend.batchIdx;

    const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);
    this.readWorldTransform(matrix, globalIndex);

    if (countElements < 1) {
      return;
    }

    for (const _ref of _customInstancedAttributes.entries()) {
      var _ref2 = instanceDataManager_slicedToArray(_ref, 2);

      const semantic = _ref2[0];
      const attrib = _ref2[1];
      const byteOffset = attrib.byteOffset,
            countComponents = attrib.countComponents;
      const offset = byteOffset - transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
      const outVal = new Float32Array(buffer, offset, countComponents);
      const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;
      const baseOffset = globalIndex * _instancedElementsPerInstance;
      const globalElementOffset = baseOffset + elementOffset;

      this._getInstancedAttributeRange(semantic, globalElementOffset, outVal);

      savedAttribs.set(semantic, outVal);
    }
  }

  _resetCustomInstancedAttribs(instance) {
    const _instancedElementsPerInstance = this._instancedElementsPerInstance,
          _worldTransformsBack = this._worldTransformsBack,
          _flagBuffers = this._flagBuffers;
    const countCustomElements = _instancedElementsPerInstance - transformElementsPerInstance;

    if (countCustomElements === 0) {
      return;
    }

    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex;
    const batchRenderable = this.getInstanceRenderable(instanceId);
    const batchIdx = batchRenderable.batchIdx;
    const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);
    const offset = (globalIndex * _instancedElementsPerInstance + transformElementsPerInstance) * Float32Array.BYTES_PER_ELEMENT;
    const view = new Float32Array(_worldTransformsBack.buffer, offset, countCustomElements);
    view.fill(0);
    const customAttributeUpdateFlag = 0x10;
    _flagBuffers[globalIndex] |= customAttributeUpdateFlag;
  }

  get capacity() {
    return this._instanceCount;
  }

  get customInstancedAttributeLayout() {
    return this._customInstancedAttributes;
  }

  get elementsPerInstance() {
    return this._instancedElementsPerInstance;
  }

  get bytesPerInstance() {
    return this._instancedElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
  }

  get instancesMemorySize() {
    const _instanceCount = this._instanceCount;
    return this.bytesPerInstance * _instanceCount;
  }

  get gpuInstancedData() {
    return this._gpuInstancedData;
  }

  _enableBatches(geometryMaterialPair = {}, value) {
    const _uniqueInstances = this._uniqueInstances,
          _instancedBatches = this._instancedBatches;
    const _geometryMaterialPair = geometryMaterialPair.geometry,
          geometry = _geometryMaterialPair === void 0 ? {} : _geometryMaterialPair,
          _geometryMaterialPair2 = geometryMaterialPair.material,
          material = _geometryMaterialPair2 === void 0 ? {} : _geometryMaterialPair2;
    const _geometry$id = geometry.id,
          geometryId = _geometry$id === void 0 ? null : _geometry$id;
    const _material$id = material.id,
          materialId = _material$id === void 0 ? null : _material$id;

    for (const uniqueInstance of _uniqueInstances.values()) {
      const batchIdx = uniqueInstance.batchIdx,
            batchGeometry = uniqueInstance.geometry,
            batchMaterial = uniqueInstance.material;

      if (batchGeometry.id === geometryId || batchMaterial.id === materialId) {
        if (value && !batchGeometry.unloaded && !batchMaterial.unloaded) {
          _instancedBatches.enableBatch(batchIdx);
        } else {
          uniqueInstance.vaoLayoutVersion = 0;
          uniqueInstance.depthVaoLayoutVersion = 0;

          _instancedBatches.disableBatch(batchIdx);
        }
      }
    }
  }

  generateBatchMap() {
    const _uniqueInstances = this._uniqueInstances,
          _instancedBatches = this._instancedBatches;
    const batchMap = new tuple_map["a" /* TupleMap */]();
    const batch = new InstancedBatch();
    const batchCount = _instancedBatches.batchCount;

    for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
      _instancedBatches.unpackBatch(batchIdx, batch);

      const instanceId = batch.instanceId,
            capacity = batch.capacity;

      const _uniqueInstances$get = _uniqueInstances.get(instanceId),
            geometry = _uniqueInstances$get.geometry,
            material = _uniqueInstances$get.material;

      batchMap.set([geometry.id, material.id], capacity);
    }

    return batchMap;
  }

  setInstancedMemoryFlushRange(from, to) {
    this._flushRangeFrom = from;
    this._flashRangeTo = to;
  }

  flushInstancedMemory(ctx, allocator) {
    const _this$_flushRangeFrom = this._flushRangeFrom,
          _flushRangeFrom = _this$_flushRangeFrom === void 0 ? 0 : _this$_flushRangeFrom,
          _this$_flashRangeTo = this._flashRangeTo,
          _flashRangeTo = _this$_flashRangeTo === void 0 ? 0 : _this$_flashRangeTo,
          instancesMemorySize = this.instancesMemorySize,
          _worldTransformsFront = this._worldTransformsFront;

    const byteLength = _flashRangeTo - _flushRangeFrom;

    if (byteLength <= 0) {
      return;
    }

    if (this._gpuInstancedData === null) {
      this._gpuInstancedData = allocator(ctx, instancesMemorySize, ctx.ARRAY_BUFFER, ctx.DYNAMIC_DRAW);

      this._gpuInstancedData.subdata(_worldTransformsFront, 0);
    } else if (this._gpuInstancedData.size < instancesMemorySize) {
      this._gpuInstancedData.dispose();

      this._gpuInstancedData = allocator(ctx, instancesMemorySize, ctx.ARRAY_BUFFER, ctx.DYNAMIC_DRAW);

      this._gpuInstancedData.subdata(_worldTransformsFront, 0);

      this.invalidateBatchRenderables();
    } else {
      const elementCount = byteLength / _worldTransformsFront.BYTES_PER_ELEMENT;
      const offset = _flushRangeFrom;
      const view = new Float32Array(_worldTransformsFront.buffer, offset, elementCount);

      this._gpuInstancedData.subdata(view, offset);
    }

    this._flushRangeFrom = 0;
    this._flashRangeTo = 0;
  }

  invalidateBatchRenderables() {
    const _uniqueInstances = this._uniqueInstances;

    for (const r of _uniqueInstances.values()) {
      r.vaoLayoutVersion = 0;
      r.depthVaoLayoutVersion = 0;
    }
  }

  disableBatches(geometryMaterialPair) {
    this._enableBatches(geometryMaterialPair, false);
  }

  enableBatches(geometryMaterialPair) {
    this._enableBatches(geometryMaterialPair, true);
  }

}
Object.assign(instanceDataManager_InstanceDataManager.prototype, {
  _saveInstancedData: function __saveInstanceData() {
    const worldBoundingBox = new lib["e" /* Box */]();
    const center = new lib["n" /* Vector3 */]();
    return function _saveInstancedData(instance, batchIdx, instanceIndex, savedAttribs, matrix, restoreTransform) {
      if (restoreTransform) {
        const geometry = instance.geometry,
              id = instance.id;
        const boundingBox = geometry.boundingBox;
        const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);
        this.storeWorldTransform(matrix, globalIndex);
        this.storeRenderableIdentifier(globalIndex, id);
        worldBoundingBox.copy(boundingBox).applyAffineMatrix(matrix);
        worldBoundingBox.centerPaste(center);
        this.storeCenter(center, globalIndex);
      }

      for (const _ref3 of savedAttribs.entries()) {
        var _ref4 = instanceDataManager_slicedToArray(_ref3, 2);

        const semantic = _ref4[0];
        const val = _ref4[1];
        this.setInstancedAttribute(instance, semantic, val);
      }

      savedAttribs.clear();
    };
  }(),
  shrinkToFit: function _shrinkToFit() {
    const batch_ = new InstancedBatch();
    return function shrinkToFit(emptyBatchesOnly = true, byteCountThreshold = 0) {
      const _uniqueInstances = this._uniqueInstances,
            _instancedBatches = this._instancedBatches,
            _freeIndices = this._freeIndices,
            _instancedElementsPerInstance = this._instancedElementsPerInstance,
            bytesPerInstance = this.bytesPerInstance;
      const batchCount = _instancedBatches.batchCount;
      const batchMap = new Map();
      const allBytesPerInstance = 2 * bytesPerInstance + centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT + 1;
      const bytesPerBatch = InstancedBatch.bytesPerBatch;
      let instanceCapacity = 0;
      let estimatedReleaseAmount = 0;
      const emptyRenderables = [];

      for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
        _instancedBatches.unpackBatch(batchIdx, batch_);

        const instanceCount = batch_.instanceCount,
              capacity = batch_.capacity,
              instanceId = batch_.instanceId;

        const batchRenderable = _uniqueInstances.get(instanceId);

        const freeIndices = _freeIndices.get(batchRenderable) || [];

        if (freeIndices.length === instanceCount) {
          emptyRenderables.push(batchRenderable);
          estimatedReleaseAmount += capacity * allBytesPerInstance;
          estimatedReleaseAmount += bytesPerBatch;
        } else if (emptyBatchesOnly) {
          batchMap.set(batchIdx, capacity);
          instanceCapacity += capacity;
        } else if (!emptyBatchesOnly && instanceCount <= capacity) {
          batchMap.set(batchIdx, instanceCount - freeIndices.length);
          instanceCapacity += instanceCount - freeIndices.length;
          estimatedReleaseAmount += (capacity - instanceCount + freeIndices.length) * allBytesPerInstance;
        }
      }

      if (estimatedReleaseAmount < byteCountThreshold) {
        return estimatedReleaseAmount;
      }

      for (const emptyRenderable of emptyRenderables) {
        _freeIndices.delete(emptyRenderable);
      }

      let prevMemoryUsage = 0;
      let newMemoryUsage = 0;
      prevMemoryUsage += this._worldTransformsBack.byteLength;
      prevMemoryUsage += this._worldTransformsFront.byteLength;
      prevMemoryUsage += this._centers.byteLength;
      prevMemoryUsage += this._flagBuffers.byteLength;
      prevMemoryUsage += _instancedBatches.batchBuffer.byteLength;
      {
        const worldTransformsBack = new Float32Array(_instancedElementsPerInstance * instanceCapacity);
        const worldTransformsFront = new Float32Array(_instancedElementsPerInstance * instanceCapacity);
        const centers = new Float32Array(centerElementsPerInstance * instanceCapacity);
        const flagBuffers = new Uint8Array(instanceCapacity);
        const batchCapacity = batchMap.size;
        const batchBuffer = new Uint8Array(batchCapacity * bytesPerBatch);
        const buffer = batchBuffer.buffer;
        let firstInstance = 0;
        let batchIdx = 0;

        for (const _ref5 of batchMap.entries()) {
          var _ref6 = instanceDataManager_slicedToArray(_ref5, 2);

          const oldBatchIdx = _ref6[0];
          const capacity = _ref6[1];

          _instancedBatches.unpackBatch(oldBatchIdx, batch_);

          const view = new Int32Array(buffer, batchIdx * bytesPerBatch, 5);
          const oldFirstInstance = batch_.firstInstance;
          const oldCapavity = batch_.capacity;
          batch_.firstInstance = firstInstance;
          batch_.instanceCount = capacity;
          batch_.capacity = capacity;
          view[0] = batch_.flags;
          view[1] = batch_.firstInstance;
          view[2] = batch_.instanceCount;
          view[3] = batch_.capacity;
          view[4] = batch_.instanceId;

          const batchRenderable = _uniqueInstances.get(batch_.instanceId);

          batchRenderable.batchIdx = batchIdx++;

          if (emptyBatchesOnly) {
            worldTransformsBack.set(new Float32Array(this._worldTransformsBack.buffer, oldFirstInstance * bytesPerInstance, oldCapavity * _instancedElementsPerInstance), firstInstance * bytesPerInstance);
            worldTransformsFront.set(new Float32Array(this._worldTransformsFront.buffer, oldFirstInstance * bytesPerInstance, oldCapavity * _instancedElementsPerInstance), firstInstance * bytesPerInstance);
            centers.set(new Float32Array(this._centers.buffer, oldFirstInstance * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT, oldCapavity * centerElementsPerInstance), firstInstance * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT);
            flagBuffers.set(new Uint8Array(this._flagBuffers.buffer, oldFirstInstance, oldCapavity), firstInstance);
          } else {
            const freeIndices = _freeIndices.get(batchRenderable) || [];

            for (let instanceIdx = 0, validInstanceIdx = 0; instanceIdx < oldCapavity && validInstanceIdx < capacity; instanceIdx++) {
              if (freeIndices.includes(instanceIdx)) {
                continue;
              }

              worldTransformsBack.set(new Float32Array(this._worldTransformsBack.buffer, bytesPerInstance * (oldFirstInstance + instanceIdx), _instancedElementsPerInstance), firstInstance + validInstanceIdx);
              worldTransformsFront.set(new Float32Array(this._worldTransformsFront.buffer, bytesPerInstance * (oldFirstInstance + instanceIdx), _instancedElementsPerInstance), firstInstance + validInstanceIdx);
              centers.set(new Float32Array(this._centers.buffer, (oldFirstInstance + instanceIdx) * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT, centerElementsPerInstance), firstInstance + validInstanceIdx);
              flagBuffers[firstInstance + validInstanceIdx] = this._flagBuffers[oldFirstInstance + instanceIdx];
              validInstanceIdx++;
            }

            freeIndices.length = 0;
          }

          firstInstance += capacity;
        }

        _instancedBatches.batchBuffer = batchBuffer;
        _instancedBatches.batchCount = batchCapacity;
        _instancedBatches.batchCapacity = batchCapacity;
        this._worldTransformsBack = worldTransformsBack;
        this._worldTransformsFront = worldTransformsFront;
        this._centers = centers;
        this._flagBuffers = flagBuffers;
        this._instanceCount = instanceCapacity;
      }
      newMemoryUsage += this._worldTransformsBack.byteLength;
      newMemoryUsage += this._worldTransformsFront.byteLength;
      newMemoryUsage += this._centers.byteLength;
      newMemoryUsage += this._flagBuffers.byteLength;
      newMemoryUsage += _instancedBatches.batchBuffer.byteLength;

      this._batchMap.clear();

      return prevMemoryUsage - newMemoryUsage;
    };
  }(),
  getInstanceCount: function __getInstanceCount() {
    const batch_ = new InstancedBatch();
    return function getInstanceCount(instanceId) {
      const batch = this.getInstanceRenderable(instanceId);
      const batchIdx = batch.batchIdx;

      this._instancedBatches.unpackBatch(batchIdx, batch_);

      return batch_.instanceCount;
    };
  }(),
  addInstance: function _addInstance() {
    const batch_ = new InstancedBatch();
    const lastBatch_ = new InstancedBatch();
    const prevBatch_ = new InstancedBatch();
    const nextBatch_ = new InstancedBatch();

    const _updateSkeleton = function (batch, instance) {
      const skeleton = instance.skeleton,
            instanceIndex = instance.instanceIndex;

      if (skeleton === null) {
        return;
      }

      const skeletonBuffers = skeleton.getSkeletonBuffersByInstanceIndex(instanceIndex);
      const batchSkeletonBuffers = batch.skeletonBuffers;

      if (skeletonBuffers === null && batchSkeletonBuffers === null) {
        batch.skeletonBuffers = skeleton.addSkeletonBuffers(instanceIndex);
        return;
      }

      if (skeletonBuffers === batchSkeletonBuffers) {
        return;
      }

      const skeletonId = skeleton.id;

      if (batchSkeletonBuffers == null) {
        const owner = skeletonBuffers.getLineOwner(instanceIndex);

        if (skeletonId === owner || owner === -1) {
          if (false) {}

          batch.skeletonBuffers = skeletonBuffers;
        } else {
          batch.skeletonBuffers = skeleton.setSkeletonBuffers(instanceIndex);
          batch.skeletonBuffers.setLineOwner(instanceIndex, skeletonId);
        }
      } else if (skeletonBuffers === null) {
        const owner = batchSkeletonBuffers.getLineOwner(instanceIndex);

        if (skeletonId === owner || owner === -1) {
          skeleton.addSkeletonBuffers(instanceIndex, batchSkeletonBuffers);
        } else {
          batch.skeletonBuffers = skeleton.addSkeletonBuffers(instanceIndex);
        }
      } else {
        const owner = batchSkeletonBuffers.getLineOwner(instanceIndex);

        if (owner === skeletonId || owner === -1) {
          skeleton.setSkeletonBuffers(instanceIndex, batchSkeletonBuffers);
          batchSkeletonBuffers.setLineOwner(instanceIndex, skeletonId);
        }

        if (false) {}
      }
    };

    const savedCustomInstancedAttribs = new Map();
    const worldMatrix = new lib["b" /* AffineMatrix3 */]();
    return function addInstance(instance) {
      let restoreTransform = false;
      {
        const _instanceIdentifierExpired = instance._instanceIdentifierExpired;

        if (_instanceIdentifierExpired) {
          this._extractInstancedData(instance, savedCustomInstancedAttribs, worldMatrix);

          this.deleteInstance(instance);
          restoreTransform = true;
        }
      }

      if (instance.instanceId === null) {
        const geometry = instance.geometry,
              material = instance.material;
        instance._instanceId = this.getInstanceIdentifier(geometry.id, material.id);
      }

      const instanceId = instance.instanceId;
      const _instancedElementsPerInstance = this._instancedElementsPerInstance,
            _uniqueInstances = this._uniqueInstances,
            _freeIndices = this._freeIndices,
            _instancedBatches = this._instancedBatches,
            _batchMap = this._batchMap;
      let _centers = this._centers,
          _worldTransformsBack = this._worldTransformsBack,
          _flagBuffers = this._flagBuffers;

      let batchRenderable = _uniqueInstances.get(instanceId);

      if (batchRenderable === undefined) {
        batchRenderable = new instanceDataManager_BatchRenderable(instance);
        const capacity = _batchMap.size > 0 ? _batchMap.get([instance.geometry.id, instance.material.id]) || 0 : 0;
        batchRenderable.batchIdx = _instancedBatches.emplaceBatch(instanceId, capacity);

        _uniqueInstances.set(instanceId, batchRenderable);

        if (capacity > 0) {
          _batchMap.delete([instance.geometry.id, instance.material.id]);
        }
      }

      if (!_freeIndices.has(batchRenderable)) {
        _freeIndices.set(batchRenderable, []);
      }

      batchRenderable.retain();
      {
        const _batchRenderable = batchRenderable,
              batchIdx = _batchRenderable.batchIdx;

        const freeIndices = _freeIndices.get(batchRenderable);

        _instancedBatches.unpackBatch(batchIdx, batch_);

        _instancedBatches.unpackLastBatch(lastBatch_);

        const lastBatch = lastBatch_.instanceId === batch_.instanceId ? batch_ : lastBatch_;
        let prevBatch = null;
        let nextBatch = null;

        if (batchIdx > 0) {
          _instancedBatches.unpackBatch(batchIdx - 1, prevBatch_);

          prevBatch = prevBatch_;
        }

        if (_instancedBatches.hasBatch(batchIdx + 1)) {
          _instancedBatches.unpackBatch(batchIdx + 1, nextBatch_);

          nextBatch = nextBatch_;
        }

        if (batch_.firstInstance === null) {
          batch_.firstInstance = prevBatch === null ? 0 : prevBatch.firstInstance + prevBatch.capacity;
        }

        if (batch_.instanceCount < batch_.capacity || freeIndices.length > 0) {
          const resetCustomAttribs = freeIndices.length > 0 && savedCustomInstancedAttribs.size < 1;
          const instanceIndex = freeIndices.length > 0 ? freeIndices.pop() : batch_.instanceCount++;

          _instancedBatches.packBatch(batchIdx, batch_);

          instance.instanceIndex = instanceIndex;

          if (resetCustomAttribs) {
            this._resetCustomInstancedAttribs(instance);
          }

          this._saveInstancedData(instance, batchIdx, instanceIndex, savedCustomInstancedAttribs, worldMatrix, restoreTransform);

          _updateSkeleton(batchRenderable, instance);

          return;
        }

        const bufferUsage = (lastBatch.firstInstance + lastBatch.capacity) * this.bytesPerInstance;
        const bufferSize = _worldTransformsBack.byteLength;
        let countLeft = (bufferSize - bufferUsage) / this.bytesPerInstance;

        if (countLeft < 1) {
          countLeft = this._reallocBuffers(bufferUsage);
          _worldTransformsBack = this._worldTransformsBack;
          _centers = this._centers;
          _flagBuffers = this._flagBuffers;

          if (false) {}
        }

        const _batchRenderable2 = batchRenderable,
              reallocStrategy = _batchRenderable2.reallocStrategy;
        const newCapacity = Math.min(reallocStrategy(batch_.capacity), batch_.capacity + countLeft);

        if (nextBatch === null) {
          batch_.capacity = newCapacity;
        } else {
          const shift = newCapacity - batch_.capacity;
          batch_.capacity = newCapacity;
          shiftBuffer(_worldTransformsBack, nextBatch.firstInstance, shift, _instancedElementsPerInstance);
          shiftBuffer(_centers, nextBatch.firstInstance, shift, centerElementsPerInstance);
          shiftBuffer(_flagBuffers, nextBatch.firstInstance, shift, 1);

          _instancedBatches.shiftFirstInstance(batchIdx, shift);
        }

        {
          const instanceIndex = batch_.instanceCount++;

          _instancedBatches.packBatch(batchIdx, batch_);

          instance.instanceIndex = instanceIndex;

          this._saveInstancedData(instance, batchIdx, instanceIndex, savedCustomInstancedAttribs, worldMatrix, restoreTransform);

          _updateSkeleton(batchRenderable, instance);
        }
      }
    };
  }(),
  deleteInstance: function _deleteInstance() {
    const batch_ = new InstancedBatch();
    return function deleteInstance(instance) {
      const instanceId = instance.instanceId,
            instanceIndex = instance.instanceIndex;

      if (false) {}

      if (false) {}

      const _instancedBatches = this._instancedBatches,
            _uniqueInstances = this._uniqueInstances,
            _freeIndices = this._freeIndices;

      const batchRenderable = _uniqueInstances.get(instanceId);

      const batchIdx = batchRenderable.batchIdx;

      _instancedBatches.unpackBatch(batchIdx, batch_);

      const freeIndices = _freeIndices.get(batchRenderable);

      this.setInstanceVisibility(instance, false, false);
      batchRenderable.release();
      freeIndices.push(instanceIndex);
      instance._instanceId = null;
      instance.instanceIndex = null;
      instance._instanceIdentifierExpired = false;
    };
  }(),
  setInstanceVisibility: function _setInstanceVisibility() {
    const currentFrameVisibilityFlag = 0x02;
    const frustumCullingDisabledFlag = 0x08;
    const batch_ = new InstancedBatch();
    return function setInstanceVisibility(instance, visibility, cullingEnabled) {
      const _instancedBatches = this._instancedBatches,
            _flagBuffers = this._flagBuffers,
            _uniqueInstances = this._uniqueInstances;
      const instanceIndex = instance.instanceIndex,
            instanceId = instance.instanceId;

      const _uniqueInstances$get2 = _uniqueInstances.get(instanceId),
            batchIdx = _uniqueInstances$get2.batchIdx;

      _instancedBatches.unpackBatch(batchIdx, batch_);

      const firstInstance = batch_.firstInstance;
      {
        const globalIndex = firstInstance + instanceIndex;

        if (visibility) {
          _flagBuffers[globalIndex] |= currentFrameVisibilityFlag;
        } else {
          _flagBuffers[globalIndex] &= ~currentFrameVisibilityFlag;
        }

        if (!cullingEnabled) {
          _flagBuffers[globalIndex] |= frustumCullingDisabledFlag;
        } else {
          _flagBuffers[globalIndex] &= ~frustumCullingDisabledFlag;
        }
      }
    };
  }()
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/baseScene.js



function scalarLuminanceToIlluminance(luminance) {
  const K = 12.5;
  const C = 250;
  const twoPowInEV100 = luminance / K;
  return C * twoPowInEV100;
}

function illuminanceToScalarLuminance(illuminance) {
  const K = 12.5;
  const C = 250;
  const twoPowInEV100 = illuminance / C;
  return K * twoPowInEV100;
}

class baseScene_BaseScene extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    maxSceneNodes,
    batchMap = null,
    name = '',
    config
  }) {
    const _config$customAttribu = config.customAttributes,
          customAttributes = _config$customAttribu === void 0 ? [] : _config$customAttribu;
    super();
    this.name = name;
    this._instanceDataManager = new instanceDataManager_InstanceDataManager({
      batchMap,
      initialSceneNodes: maxSceneNodes,
      customAttributes
    });
    this._maxIlluminance = 0;
    this._maxEnvIlluminance = 0;
    this.extras = undefined;

    this._saveConfig(config);

    this._forceUpdateRenderQueue = false;
    this._lastFrameSceneGraphUpdate = -1;
    this._lastCullingCamera = null;
    this._lastCullingFrameNumber = -1;
  }

  shrinkToFit(emptyBatchesOnly = true, byteCountThreshold = 0) {
    return this._instanceDataManager.shrinkToFit(emptyBatchesOnly, byteCountThreshold);
  }

  getDirectShadowCastersData(look) {
    return {};
  }

  getSpotShadowCasters() {
    return [];
  }

  getOmniShadowCasters() {
    return [];
  }

  _saveConfig(config) {
    const _config$customAttribu2 = config.customAttributes,
          customAttributes = _config$customAttribu2 === void 0 ? [] : _config$customAttribu2;
    this._config = {
      customAttributes: [],
      componentClasses: [...config.componentClasses]
    };

    for (const ca of customAttributes) {
      const semantic = ca.semantic,
            countComponents = ca.countComponents;

      this._config.customAttributes.push({
        semantic,
        countComponents
      });
    }
  }

  get maxEnvLuminance() {
    return illuminanceToScalarLuminance(this._maxEnvIlluminance);
  }

  set maxEnvLuminance(value) {
    this._maxEnvIlluminance = scalarLuminanceToIlluminance(value);
  }

  get maxLuminance() {
    return illuminanceToScalarLuminance(this._maxIlluminance);
  }

  get forceUpdateRenderQueue() {
    return this._forceUpdateRenderQueue;
  }

  set forceUpdateRenderQueue(value) {
    this._forceUpdateRenderQueue = value;
  }

  get instanceDataManager() {
    return this._instanceDataManager;
  }

  get config() {
    return this._config;
  }

  _dispose() {
    super._dispose();
  }

}
Object.defineProperty(baseScene_BaseScene.prototype, 'isBaseScene', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/light.js


class light_Light extends component_Component {
  constructor({
    name = '',
    temperature = 4000,
    colorFilter = new lib["k" /* RGBColor */](1, 1, 1)
  }) {
    super();
    this.name = name;
    this._colorFilter = colorFilter.clone();
    this._temperature = temperature;
    this._temperatureUpdated = true;
  }

  markUpdated() {
    this._temperatureUpdated = false;
  }

  get needsUpdate() {
    return this._temperatureUpdated;
  }

  getColorFilter(dst) {
    dst.copy(this._colorFilter);
  }

  setColorFilter(color) {
    this._colorFilter.copy(color);

    this._temperatureUpdated = true;
  }

  get temperature() {
    return this._temperature;
  }

  set temperature(value) {
    this._temperature = value;
    this._temperatureUpdated = true;
  }

}
light_Light.ID = 'light';
Object.defineProperty(light_Light.prototype, 'isLight', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/spot-light.js


class spot_light_SpotLight extends light_Light {
  constructor({
    name,
    temperature,
    luminousPower,
    colorFilter = new lib["k" /* RGBColor */](1, 1, 1),
    size = 0.1,
    attenuationRadius = 5.0,
    innerCone = 0.0174533,
    outerCone = 0.436332
  }) {
    super({
      name,
      temperature,
      colorFilter
    });
    this._size = size;
    this._radius = attenuationRadius;
    this._invAttenRadius = 1.0 / (attenuationRadius * attenuationRadius);
    this._innerCone = innerCone;
    this._outerCone = outerCone;
    const innerConeCos = Math.cos(innerCone);
    const outerConeCos = Math.cos(outerCone);
    const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
    const lightAngleOffset = -outerConeCos * lightAngleScale;
    this._lightAngleScale = lightAngleScale;
    this._lightAngleOffset = lightAngleOffset;
    this._direction = new lib["n" /* Vector3 */]();
    this._position = new lib["n" /* Vector3 */]();
    this._luminousPowerUpdated = true;
    this._luminousPower = luminousPower;
    this._luminousIntensity = new lib["n" /* Vector3 */]();
  }

  makeUpdated() {
    super.markUpdated();
    this._luminousPowerUpdated = false;
  }

  get needsUpdate() {
    return super.needsUpdate || this._luminousPowerUpdated;
  }

  get luminousPower() {
    return this._luminousPower;
  }

  set luminousPower(value) {
    this._luminousPower = value;
    this._luminousPowerUpdated = true;
  }

  get size() {
    return this._size;
  }

  set size(value) {
    this._size = value;
  }

  get invAttenRadius() {
    return this._invAttenRadius;
  }

  get attenuationRadius() {
    return this._radius;
  }

  set attenuationRadius(value) {
    this._radius = value;
    this._invAttenRadius = 1.0 / (value * value);
  }

  get innerCone() {
    return this._innerCone;
  }

  set innerCone(value) {
    this._innerCone = value;
    const innerConeCos = Math.cos(this._innerCone);
    const outerConeCos = Math.cos(this._outerCone);
    const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
    const lightAngleOffset = -outerConeCos * lightAngleScale;
    this._lightAngleScale = lightAngleScale;
    this._lightAngleOffset = lightAngleOffset;
  }

  get outerCone() {
    return this._outerCone;
  }

  set outerCone(value) {
    this._outerCone = value;
    const innerConeCos = Math.cos(this._innerCone);
    const outerConeCos = Math.cos(this._outerCone);
    const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
    const lightAngleOffset = -outerConeCos * lightAngleScale;
    this._lightAngleScale = lightAngleScale;
    this._lightAngleOffset = lightAngleOffset;
  }

  get lightAngleScale() {
    return this._lightAngleScale;
  }

  get lightAngleOffset() {
    return this._lightAngleOffset;
  }

  getDirection(dst) {
    const _direction = this._direction;
    dst.copy(_direction);
  }

  getPosition(dst) {
    const _position = this._position;
    dst.copy(_position);
  }

  getLuminousIntensity(dst) {
    dst.copy(this._luminousIntensity);
  }

  clone() {
    const name = this.name,
          temperature = this.temperature,
          luminousPower = this.luminousPower,
          size = this.size,
          attenuationRadius = this.attenuationRadius,
          innerCone = this.innerCone,
          outerCone = this.outerCone,
          _colorFilter = this._colorFilter;
    return new spot_light_SpotLight({
      name,
      temperature,
      luminousPower,
      size,
      attenuationRadius,
      innerCone,
      outerCone,
      colorFilter: _colorFilter
    });
  }

}
Object.defineProperty(spot_light_SpotLight.prototype, 'isSpotLight', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/point-light.js


class point_light_PointLight extends light_Light {
  constructor({
    name,
    temperature,
    luminousPower,
    colorFilter = new lib["k" /* RGBColor */](1, 1, 1),
    size = 0.1,
    attenuationRadius = 5.0
  }) {
    super({
      name,
      temperature,
      colorFilter
    });
    this._size = size;
    this._radius = attenuationRadius;
    this._invAttenRadius = 1.0 / (attenuationRadius * attenuationRadius);
    this._position = new lib["n" /* Vector3 */]();
    this._luminousPowerUpdated = true;
    this._luminousPower = luminousPower;
    this._luminousIntensity = new lib["n" /* Vector3 */]();
  }

  makeUpdated() {
    super.markUpdated();
    this._luminousPowerUpdated = false;
  }

  get needsUpdate() {
    return super.needsUpdate || this._luminousPowerUpdated;
  }

  get luminousPower() {
    return this._luminousPower;
  }

  set luminousPower(value) {
    this._luminousPower = value;
    this._luminousPowerUpdated = true;
  }

  get size() {
    return this._size;
  }

  set size(value) {
    this._size = value;
  }

  get invAttenRadius() {
    return this._invAttenRadius;
  }

  get attenuationRadius() {
    return this._radius;
  }

  set attenuationRadius(value) {
    this._radius = value;
    this._invAttenRadius = 1.0 / (value * value);
  }

  getPosition(dst) {
    const _position = this._position;
    dst.copy(_position);
  }

  getLuminousIntensity(dst) {
    dst.copy(this._luminousIntensity);
  }

  clone() {
    const name = this.name,
          temperature = this.temperature,
          luminousPower = this.luminousPower,
          size = this.size,
          attenuationRadius = this.attenuationRadius,
          _colorFilter = this._colorFilter;
    return new point_light_PointLight({
      name,
      temperature,
      luminousPower,
      colorFilter: _colorFilter,
      size,
      attenuationRadius
    });
  }

}
Object.defineProperty(point_light_PointLight.prototype, 'isPointLight', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/ambient-light.js


class ambient_light_AmbientLight extends light_Light {
  constructor({
    name,
    temperature,
    illuminance,
    colorFilter = new lib["k" /* RGBColor */](1, 1, 1)
  }) {
    super({
      name,
      temperature,
      colorFilter
    });
    this._illuminanceUpdated = true;
    this._illuminance = illuminance;
    this._luminance = new lib["n" /* Vector3 */]();
  }

  makeUpdated() {
    super.markUpdated();
    this._illuminanceUpdated = false;
  }

  get needsUpdate() {
    return super.needsUpdate || this._illuminanceUpdated;
  }

  set illuminance(value) {
    this._illuminance = value;
    this._illuminanceUpdated = true;
  }

  get illuminance() {
    return this._illuminance;
  }

  getLuminance(dst) {
    dst.copy(this._luminance);
  }

  clone() {
    const name = this.name,
          temperature = this.temperature,
          illuminance = this.illuminance;
    return new ambient_light_AmbientLight({
      name,
      temperature,
      illuminance
    });
  }

}
Object.defineProperty(ambient_light_AmbientLight.prototype, 'isAmbientLight', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/directional-light.js


class directional_light_DirectionalLight extends light_Light {
  constructor({
    name,
    temperature,
    illuminance,
    colorFilter = new lib["k" /* RGBColor */](1, 1, 1)
  }) {
    super({
      name,
      temperature,
      colorFilter
    });
    this._direction = new lib["n" /* Vector3 */]();
    this._illuminanceUpdated = true;
    this._illuminance = illuminance;
    this._luminance = new lib["n" /* Vector3 */]();
  }

  makeUpdated() {
    super.markUpdated();
    this._illuminanceUpdated = false;
  }

  get needsUpdate() {
    return super.needsUpdate || this._illuminanceUpdated;
  }

  set illuminance(value) {
    this._illuminance = value;
    this._illuminanceUpdated = true;
  }

  get illuminance() {
    return this._illuminance;
  }

  getDirection(dst) {
    const _direction = this._direction;
    dst.copy(_direction);
  }

  getLuminance(dst) {
    dst.copy(this._luminance);
  }

  clone() {
    const name = this.name,
          temperature = this.temperature,
          illuminance = this.illuminance,
          _colorFilter = this._colorFilter;
    return new directional_light_DirectionalLight({
      name,
      temperature,
      illuminance,
      colorFilter: _colorFilter
    });
  }

}
Object.defineProperty(directional_light_DirectionalLight.prototype, 'isDirectionalLight', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/common.js






function temperatureToHue(temperature, hue = new lib["n" /* Vector3 */]()) {
  let t = temperature;
  let r = 0;
  let g = 0;
  let b = 0;
  t /= 100.0;

  if (t <= 66.0) {
    r = 255;
    g = t;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;

    if (g < 0) {
      g = 0;
    }

    if (g > 255) {
      g = 255;
    }
  } else {
    r = t - 60;
    r = 329.698727466 * Math.pow(r, -0.1332047592);

    if (r < 0) {
      r = 0;
    }

    if (r > 255) {
      r = 255;
    }

    g = t - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);

    if (g < 0) {
      g = 0;
    }

    if (g > 255) {
      g = 255;
    }
  }

  if (t >= 66) {
    b = 255;
  } else {
    if (t <= 19) {
      b = 0;
    } else {
      b = t - 10;
      b = 138.5177312231 * Math.log(b) - 305.0447927307;

      if (b < 0) {
        b = 0;
      }

      if (b > 255) {
        b = 255;
      }
    }
  }

  hue.set(r / 255.0, g / 255.0, b / 255.0);
  return hue;
}

function illuminanceToLuminance(illuminance, luminance = new lib["n" /* Vector3 */](1)) {
  const K = 12.5;
  const C = 250;
  const twoPowInEV100 = illuminance / C;
  luminance.multiplyNumber(K * twoPowInEV100);
  return luminance;
}

function luminousIntensityToScalarIlluminance(luminousIntensity, distance) {
  return luminousIntensity / Math.max(distance ** 2, 0.01 ** 2);
}

function computeLightProperties(light) {
  const temperature = light.temperature,
        _colorFilter = light._colorFilter;

  if (light instanceof directional_light_DirectionalLight) {
    const _luminance = light._luminance,
          _illuminance = light._illuminance;
    temperatureToHue(temperature, _luminance);
    _luminance.x *= _colorFilter.r;
    _luminance.y *= _colorFilter.g;
    _luminance.z *= _colorFilter.b;
    illuminanceToLuminance(_illuminance, _luminance);
  } else if (light instanceof ambient_light_AmbientLight) {
    const _luminance = light._luminance,
          _illuminance = light._illuminance;
    temperatureToHue(temperature, _luminance);
    illuminanceToLuminance(_illuminance, _luminance);
  } else if (light instanceof point_light_PointLight) {
    const _luminousIntensity = light._luminousIntensity,
          _luminousPower = light._luminousPower;
    const solidAngle = 4.0 * Math.PI;
    temperatureToHue(temperature, _luminousIntensity);
    _luminousIntensity.x *= _colorFilter.r;
    _luminousIntensity.y *= _colorFilter.g;
    _luminousIntensity.z *= _colorFilter.b;

    _luminousIntensity.multiplyNumber(_luminousPower / solidAngle);

    light._illuminance = luminousIntensityToScalarIlluminance(_luminousPower / solidAngle, 1);
  } else if (light instanceof spot_light_SpotLight) {
    const _luminousIntensity = light._luminousIntensity,
          _luminousPower = light._luminousPower;
    temperatureToHue(temperature, _luminousIntensity);
    _luminousIntensity.x *= _colorFilter.r;
    _luminousIntensity.y *= _colorFilter.g;
    _luminousIntensity.z *= _colorFilter.b;

    _luminousIntensity.multiplyNumber(_luminousPower / Math.PI);

    light._illuminance = luminousIntensityToScalarIlluminance(_luminousPower / Math.PI, 1);
  }
}

function updateLightPositionAndDirection(light, transformMatrix, viewMatrix) {
  if (light instanceof directional_light_DirectionalLight) {
    const _direction = light._direction;
    transformMatrix.axisZPaste(_direction);

    _direction.negate();

    _direction.multiplyLinearMatrix(viewMatrix);

    _direction.normalize();
  } else if (light instanceof spot_light_SpotLight) {
    const _position = light._position,
          _direction = light._direction;
    transformMatrix.translationPaste(_position);

    _position.multiplyAffineMatrix(viewMatrix);

    transformMatrix.axisZPaste(_direction);

    _direction.negate();

    _direction.multiplyLinearMatrix(viewMatrix);

    _direction.normalize();
  } else if (light instanceof point_light_PointLight) {
    const _position = light._position;
    transformMatrix.translationPaste(_position);

    _position.multiplyAffineMatrix(viewMatrix);
  }
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/light-shadow-caster.js

class light_shadow_caster_LightShadowCaster extends component_Component {
  constructor({
    castShadow = false
  }) {
    super();
    this._casterIndex = -1;
    this._cascades = null;
    this._spotShadowCasterData = null;
    this._omniShadowCasterData = null;
    this.castShadow = castShadow;
  }

}
light_shadow_caster_LightShadowCaster.ID = 'lightShadowCaster';
Object.defineProperty(light_shadow_caster_LightShadowCaster.prototype, 'isLightShadowCaster', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/light-component/index.js







// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/mesh-component/index.js


class mesh_component_SubMesh extends renderable_Renderable {
  constructor({
    name = '',
    geometry,
    material
  }) {
    super(geometry, material);
    this.name = name;
    this.extras = undefined;
    this._skeleton = null;
  }

  get skeleton() {
    return this._skeleton;
  }

  clone(newName) {
    const name = this.name,
          geometry = this.geometry,
          material = this.material,
          renderQueueGroup = this.renderQueueGroup,
          reallocStrategy = this.reallocStrategy,
          _skeleton = this._skeleton;
    const name_ = newName || name;
    const clone = new mesh_component_SubMesh({
      name: name_,
      geometry,
      material
    });
    clone.renderQueueGroup = renderQueueGroup;
    clone.reallocStrategy = reallocStrategy;
    clone._skeleton = _skeleton;
    return clone;
  }

}
class mesh_component_Mesh extends component_Component {
  constructor({
    name = ''
  }) {
    super();
    this.name = name;
    this._submeshes = [];
    this._skeleton = null;
    this._lastUpdateFrameNumber = 0;
    this.extras = undefined;
  }

  get lastUpdateFrameNumber() {
    return this._lastUpdateFrameNumber;
  }

  get skeleton() {
    return this._skeleton;
  }

  set skeleton(value) {
    const _skeleton = this._skeleton,
          _submeshes = this._submeshes;

    if (_skeleton === value) {
      return;
    }

    this._skeleton = value;

    if (this._skeleton !== null) {
      this._skeleton.retain();
    }

    for (const submesh of _submeshes) {
      submesh._skeleton = value;
    }

    if (_skeleton !== null) {
      _skeleton.release();
    }
  }

  addSubMesh(subMesh) {
    this._submeshes.push(subMesh);
  }

  getSubMesh(subMeshIndex) {
    return this._submeshes[subMeshIndex];
  }

  get subMeshCount() {
    return this._submeshes.length;
  }

  subMeshes() {
    return this._submeshes.values();
  }

  clone(newName) {
    const name = this.name,
          _submeshes = this._submeshes,
          skeleton = this.skeleton,
          extras = this.extras;
    const name_ = newName || name;
    const clone = new mesh_component_Mesh({
      name: name_
    });

    for (const sm of _submeshes) {
      clone.addSubMesh(sm.clone());
    }

    clone.skeleton = skeleton;
    clone.extras = extras;
    return clone;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      for (const subMesh of this._submeshes) {
        yield subMesh.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    const _submeshes = this._submeshes;

    for (const subMesh of _submeshes) {
      subMesh.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    const _submeshes = this._submeshes;

    for (const subMesh of _submeshes) {
      subMesh.dispose();
    }

    this._submeshes.length = 0;

    super._dispose();
  }

}
mesh_component_Mesh.ID = 'mesh';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/transform-component/index.js



const _splitTransform = new lib["d" /* AffineSplitTransform3 */]();

class _TransformStateMask {
  static get UPDATE_NOTHING() {
    return 0;
  }

  static get UPDATE_LOCAL() {
    return 1;
  }

  static get UPDATE_COMPONENTS() {
    return 2;
  }

  static get UPDATE_WORLD() {
    return 4;
  }

  static get UPDATE_ALL() {
    return 7;
  }

}

class transform_component_Transform extends component_Component {
  constructor(parameters = {}) {
    const _parameters$position = parameters.position,
          position = _parameters$position === void 0 ? new lib["n" /* Vector3 */](0.0, 0.0, 0.0) : _parameters$position,
          _parameters$scale = parameters.scale,
          scale = _parameters$scale === void 0 ? new lib["n" /* Vector3 */](1.0, 1.0, 1.0) : _parameters$scale,
          _parameters$orientati = parameters.orientation,
          orientation = _parameters$orientati === void 0 ? new lib["i" /* Quaternion */]() : _parameters$orientati;
    super();
    this.position = position.clone();
    this.scale = scale.clone();
    this.orientation = orientation.clone();

    _splitTransform.translation.copy(position);

    _splitTransform.scaling.copy(scale);

    _splitTransform.quaternion.copy(orientation);

    this.matrix = new lib["b" /* AffineMatrix3 */]().fromSplitTransform(_splitTransform);
    this.worldMatrix = new lib["b" /* AffineMatrix3 */]();
    this.state = _TransformStateMask.UPDATE_LOCAL | _TransformStateMask.UPDATE_WORLD;
  }

  static get StateMask() {
    return _TransformStateMask;
  }

  clone() {
    const clone = new transform_component_Transform();
    clone.position.copy(this.position);
    clone.scale.copy(this.scale);
    clone.orientation.copy(this.orientation);
    clone.matrix.copy(this.matrix);
    clone.state = this.state | _TransformStateMask.UPDATE_WORLD;
    return clone;
  }

  worldMatrixPaste(targetMatrix) {
    targetMatrix.copy(this.worldMatrix);
  }

  splitWorldTransformPaste(splitTransform = new lib["d" /* AffineSplitTransform3 */]()) {
    return splitTransform.fromMatrix(this.worldMatrix);
  }

  matrixPaste(targetMatrix) {
    targetMatrix.copy(this.matrix);
  }

  matrixCopy(sourceMatrix) {
    this.matrix.copy(sourceMatrix);
    this.state = _TransformStateMask.UPDATE_COMPONENTS | _TransformStateMask.UPDATE_COMPONENTS;
  }

  splitTransformPaste(splitTransform = new lib["d" /* AffineSplitTransform3 */]()) {
    return splitTransform.fromMatrix(this.matrix);
  }

  positionCopy(position) {
    this.position.copy(position);
    this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
  }

  scaleCopy(scale) {
    this.scale.copy(scale);
    this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
  }

  orientationCopy(orientation) {
    this.orientation.copy(orientation);
    this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
  }

}
transform_component_Transform.ID = 'transform';
Object.defineProperty(transform_component_Transform.prototype, 'isTransform', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/animation-component/bone.js


class bone_Bone extends component_Component {
  constructor(skeletonIndex, boneIndex) {
    super();
    this.boneIndex = boneIndex;
    this.skeletonIndex = skeletonIndex;
    this._inverseBindMatrix = new lib["b" /* AffineMatrix3 */]();
  }

  get inverseBindMatrix() {
    return this._inverseBindMatrix;
  }

  clone() {
    const boneIndex = this.boneIndex,
          skeletonIndex = this.skeletonIndex,
          _inverseBindMatrix = this._inverseBindMatrix;
    const clone = new bone_Bone(skeletonIndex, boneIndex);

    clone._inverseBindMatrix.copy(_inverseBindMatrix);

    return clone;
  }

}
bone_Bone.ID = 'Bone';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/animation-component/skeleton.js





let _lastSkeletonId = 0;

class skeleton_SkeletonBuffers extends disposeableUsageCounter_DisposableUsageCounter {
  constructor(width, height = 1) {
    super();
    this._width = width;
    this._height = height;
    this._boneStaging = null;
    this._boneGPU = null;
    this._lineOwners = [-1];
  }

  get isOk() {
    return this._boneGPU !== null;
  }

  init() {
    const floatsPerPixel = 4.0;
    const width = this._width,
          height = this._height;
    const data = new Float32Array(width * height * floatsPerPixel);
    this._boneStaging = data;
    this._boneGPU = new texture_resource_Texture({
      name: 'gpu_skeleton_storage',
      width,
      height,
      bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D,
      wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      magFilter: texture_resource_Texture.Filter.NEAREST,
      minFilter: texture_resource_Texture.Filter.NEAREST,
      componentType: dataTypes_DataType.FLOAT,
      format: PixelDataFormat.RGBA,
      levels: 1,
      levelsData: [new texture_resource_TextureLevelData({
        width,
        height,
        depth: 1,
        data
      })],
      dynamic: true
    });
  }

  setLineOwner(line, owner) {
    this._lineOwners[line] = owner;
  }

  getLineOwner(line) {
    return line < this._lineOwners.length ? this._lineOwners[line] : -1;
  }

  reAlloc(width, height) {
    const _boneStaging = this._boneStaging,
          _boneGPU = this._boneGPU;
    const floatsPerPixel = 4.0;
    const boneStaging = new Float32Array(width * height * floatsPerPixel);
    boneStaging.set(_boneStaging);
    this._boneStaging = boneStaging;
    _boneGPU.height = height;
    _boneGPU._levelsData[0].height = height;
    _boneGPU._levelsData[0].data = boneStaging;
    _boneGPU.needsUpdate = true;
    const lineOwners = new Array(height);

    for (let i = 0, count = lineOwners.length; i < count; i++) {
      lineOwners[i] = i < this._lineOwners.length ? this._lineOwners[i] : -1;
    }

    this._lineOwners = lineOwners;
  }

  get boneStaging() {
    return this._boneStaging;
  }

  get boneGPU() {
    return this._boneGPU;
  }

  unload() {
    if (!this.isOk) {
      return;
    }

    this._boneGPU.unload();

    this._boneStaging = null;
    this._boneGPU = null;
    this._lineOwners.length = 0;
    super.unload();
  }

  _dispose() {
    if (!this.isOk) {
      return;
    }

    this._boneGPU.release();

    this._boneStaging = null;
    this._boneGPU = null;
    this._lineOwners.length = 0;

    super._dispose();
  }

}

class skeleton_Skeleton extends disposeableUsageCounter_DisposableUsageCounter {
  constructor(name, rootTransform, countBones) {
    super();
    this._id = ++_lastSkeletonId;
    this.name = name;
    this.root = rootTransform;
    this._instanceSkeletonBuffers = [];
    this._instanceIndices = [];
    this._countBones = countBones;
  }

  getSkeletonBuffersByInstanceIndex(instanceIndex) {
    const i = this._instanceIndices.indexOf(instanceIndex);

    return i !== -1 ? this._instanceSkeletonBuffers[i] : null;
  }

  getInstanceIndex(i) {
    return this._instanceIndices[i];
  }

  getBoneMatrices(i) {
    return this._instanceSkeletonBuffers[i].boneStaging;
  }

  addSkeletonBuffers(instanceIndex, skeletonBuffers = null) {
    const _instanceSkeletonBuffers = this._instanceSkeletonBuffers,
          _instanceIndices = this._instanceIndices,
          id = this.id;
    let skeletonBuffers_ = skeletonBuffers;

    if (skeletonBuffers_ === null) {
      if (false) {}

      skeletonBuffers_ = this._createNewSkeletonBuffers();
    }

    const _skeletonBuffers_ = skeletonBuffers_,
          boneGPU = _skeletonBuffers_.boneGPU;
    const height = boneGPU.height,
          width = boneGPU.width;

    if (height <= instanceIndex) {
      const height_ = Object(lib["o" /* ceilPow2 */])(instanceIndex + 1) * 2;
      skeletonBuffers_.reAlloc(width, height_);
    }

    skeletonBuffers_.setLineOwner(instanceIndex, id);
    skeletonBuffers_.retain();

    _instanceIndices.push(instanceIndex);

    _instanceSkeletonBuffers.push(skeletonBuffers_);

    return skeletonBuffers_;
  }

  setSkeletonBuffers(instanceIndex, batchSkeletonBuffers = null) {
    const _instanceSkeletonBuffers = this._instanceSkeletonBuffers,
          _instanceIndices = this._instanceIndices;

    const i = _instanceIndices.indexOf(instanceIndex);

    if (false) {}

    _instanceSkeletonBuffers[i].release();

    const skeletonBuffers = batchSkeletonBuffers !== null ? batchSkeletonBuffers : this._createNewSkeletonBuffers();
    const boneGPU = skeletonBuffers.boneGPU;
    const height = boneGPU.height,
          width = boneGPU.width;

    if (height <= instanceIndex) {
      const height_ = Object(lib["o" /* ceilPow2 */])(instanceIndex + 1) * 2;
      skeletonBuffers.reAlloc(width, height_);
    }

    skeletonBuffers.retain();
    _instanceSkeletonBuffers[i] = skeletonBuffers;
    return skeletonBuffers;
  }

  update(i) {
    const _instanceSkeletonBuffers = this._instanceSkeletonBuffers;
    const boneGPU = _instanceSkeletonBuffers[i].boneGPU;
    boneGPU.updateLevels(() => {
      return true;
    });
  }

  get id() {
    return this._id;
  }

  get skeletonBuffersCount() {
    return this._instanceIndices.length;
  }

  get countBones() {
    return this._countBones;
  }

  _createNewSkeletonBuffers() {
    const colSize = 3;
    const countBones = this.countBones;
    const width = countBones * colSize;
    const height = 1;
    const skeletonBuffers = new skeleton_SkeletonBuffers(width, height);
    skeletonBuffers.init();
    return skeletonBuffers;
  }

  _actuallyUnload() {
    const _instanceSkeletonBuffers = this._instanceSkeletonBuffers,
          _instanceIndices = this._instanceIndices;

    for (const skeletonBuffers of _instanceSkeletonBuffers) {
      skeletonBuffers.unload();
    }

    _instanceSkeletonBuffers.length = 0;
    _instanceIndices.length = 0;

    super._actuallyUnload();
  }

  _dispose() {
    const _instanceSkeletonBuffers = this._instanceSkeletonBuffers,
          _instanceIndices = this._instanceIndices;

    for (const skeletonBuffers of _instanceSkeletonBuffers) {
      skeletonBuffers.release();
    }

    _instanceSkeletonBuffers.length = 0;
    _instanceIndices.length = 0;

    super._dispose();
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/binary-search-bounds/search-bounds.js
var search_bounds = __webpack_require__(53);
var search_bounds_default = /*#__PURE__*/__webpack_require__.n(search_bounds);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/interpolator.js

const q1 = new lib["i" /* Quaternion */]();
const q2 = new lib["i" /* Quaternion */]();
const qr = new lib["i" /* Quaternion */]();
const slerp = new lib["j" /* QuaternionSlerper */]();
function interpolate(countSamplers, samplersBuffer) {
  let offset = 0;

  for (let i = 0; i < countSamplers; i++) {
    const playtime = samplersBuffer[offset++];
    const k1 = samplersBuffer[offset++];
    const k2 = samplersBuffer[offset++];
    const interpolation = samplersBuffer[offset++];
    const countComponents = samplersBuffer[offset++];
    const ofs = countComponents;
    const ofs2 = countComponents * 2;
    const ofs3 = countComponents * 3;
    const ofs4 = countComponents * 4;
    const dt = k2 - k1;
    let alpha = (playtime - k1) / dt;
    alpha = Number.isFinite(alpha) ? alpha : 1.0;

    if (interpolation === 0.0) {
      for (let j = 0; j < countComponents; j++) {
        const out1 = samplersBuffer[offset + j];
        const out2 = samplersBuffer[offset + ofs + j];
        samplersBuffer[offset + ofs2 + j] = (1.0 - alpha) * out1 + alpha * out2;
      }

      offset += ofs3;
    } else if (interpolation === 1.0) {
      for (let j = 0; j < countComponents; j++) {
        const out1 = samplersBuffer[offset + j];
        const out2 = samplersBuffer[offset + ofs + j];
        samplersBuffer[offset + ofs2 + j] = alpha > 0.5 ? out2 : out1;
      }

      offset += ofs3;
    } else if (interpolation === 2.0) {
      const a2 = alpha * alpha;
      const a3 = a2 * alpha;
      const s2 = -2 * a3 + 3 * a2;
      const s3 = a3 - a2;
      const s0 = 1.0 - s2;
      const s1 = s3 - a2 + alpha;

      for (let j = 0; j < countComponents; j++) {
        const p0 = samplersBuffer[offset + j];
        const m0 = samplersBuffer[offset + ofs + j] * dt;
        const p1 = samplersBuffer[offset + ofs2 + j];
        const m1 = samplersBuffer[offset + ofs3 + j] * dt;
        samplersBuffer[offset + ofs4 + j] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
      }

      offset = offset + ofs4 + ofs;
    } else if (interpolation === 3.0) {
      if (false) {}
    } else if (interpolation === 4.0) {
      if (false) {}

      q1.fromArrayAt(offset, samplersBuffer);
      q2.fromArrayAt(offset + ofs, samplersBuffer);
      q1.normalize();
      q2.normalize();
      slerp.set(q1, q2);
      slerp.evaluate(alpha, qr);
      qr.toArrayAt(offset + ofs2, samplersBuffer);
      offset += ofs3;
    } else {
      if (false) {}
    }
  }
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/animation-component/animation.js





function _cmp(a, b) {
  return a - b;
}

var Interpolation;

(function (Interpolation) {
  Interpolation[Interpolation["LINEAR"] = 0] = "LINEAR";
  Interpolation[Interpolation["STEP"] = 1] = "STEP";
  Interpolation[Interpolation["CUBIC"] = 2] = "CUBIC";
  Interpolation[Interpolation["CATMULLROM"] = 3] = "CATMULLROM";
})(Interpolation || (Interpolation = {}));

class animation_Sampler {
  constructor(input, output, interpolation) {
    this.input = input;
    this.output = output;
    this.interpolation = interpolation;
    this.value = null;
    this._isQuat = false;
  }

  static get Interpolation() {
    return Interpolation;
  }

  clone() {
    const input = this.input,
          output = this.output,
          interpolation = this.interpolation,
          _isQuat = this._isQuat;
    const clone_ = new animation_Sampler(input, output, interpolation);
    clone_._isQuat = _isQuat;
    return clone_;
  }

  static _getSamplerSize(sampler, outputs) {
    let size = 5;
    const output = sampler.output,
          interpolation = sampler.interpolation;
    const output_ = outputs[output];
    const countComponents = output_.countComponents;

    switch (interpolation) {
      case Interpolation.LINEAR:
      case Interpolation.STEP:
        size += countComponents * 2;
        break;

      case Interpolation.CUBIC:
      case Interpolation.CATMULLROM:
        size += countComponents * 4;
        break;

      default:
        if (false) {}

    }

    size += countComponents;
    return size;
  }

  static _unpackSampler(sampler, buffer, offset) {
    let size = 4;
    const interpolation = sampler.interpolation;
    const countComponents = buffer[offset + size++];

    switch (interpolation) {
      case Interpolation.LINEAR:
      case Interpolation.STEP:
        size += countComponents * 2;
        break;

      case Interpolation.CUBIC:
      case Interpolation.CATMULLROM:
        size += countComponents * 4;
        break;

      default:
        if (false) {}

    }

    const valueOffset = (offset + size) * Float32Array.BYTES_PER_ELEMENT;
    sampler.value = new Float32Array(buffer.buffer, valueOffset, countComponents);
    size += countComponents;
    return size;
  }

  static _packSampler(playtime, sampler, inputs, outputs, buffer, offset) {
    let size = 0;
    const input = sampler.input,
          output = sampler.output,
          interpolation = sampler.interpolation,
          _isQuat = sampler._isQuat;
    const input_ = inputs[input];
    const output_ = outputs[output];
    const min = input_.min,
          max = input_.max;
    let playtime_ = playtime;
    playtime_ = Math.max(playtime_, min);
    playtime_ = Math.min(playtime_, max);
    buffer[offset + size++] = playtime_;
    const keyIndex1 = Math.max(search_bounds_default.a.le(input_.view, playtime_, _cmp), 0);
    const keyIndex2 = Math.min(keyIndex1 + 1, input_.view.length - 1);
    const key1 = input_.view[keyIndex1];
    const key2 = input_.view[keyIndex2];
    buffer[offset + size++] = key1;
    buffer[offset + size++] = key2;
    const countComponents = output_.countComponents,
          view = output_.view;
    buffer[offset + size++] = _isQuat && interpolation === Interpolation.LINEAR ? Interpolation.CATMULLROM + 1 : interpolation;
    buffer[offset + size++] = countComponents;
    const ofs = countComponents;
    const ofs2 = countComponents * 2;
    const ofs3 = countComponents * 3;

    switch (interpolation) {
      case Interpolation.LINEAR:
      case Interpolation.STEP:
        {
          const vofs1 = keyIndex1 * countComponents;
          const vofs2 = keyIndex2 * countComponents;

          for (let i = 0; i < countComponents; i++) {
            buffer[offset + size + i] = view[vofs1 + i];
            buffer[offset + size + ofs + i] = view[vofs2 + i];
          }
        }
        size += countComponents * 2;
        break;

      case Interpolation.CUBIC:
      case Interpolation.CATMULLROM:
        {
          const vofs1 = keyIndex1 * countComponents * 3;
          const vofs2 = keyIndex2 * countComponents * 3;

          for (let i = 0; i < countComponents; i++) {
            buffer[offset + size + i] = view[vofs1 + ofs + i];
            buffer[offset + size + ofs + i] = view[vofs1 + ofs2 + i];
            buffer[offset + size + ofs2 + i] = view[vofs2 + ofs + i];
            buffer[offset + size + ofs3 + i] = view[vofs2 + i];
          }
        }
        size += countComponents * 4;
        break;

      default:
        if (false) {}

    }

    size += countComponents;
    return size;
  }

}

class animation_Animation extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    name = '',
    duration = 0.0,
    inputs,
    outputs
  }) {
    super();
    this.name = name;
    this._active = true;
    this._lastFrame = false;
    this.looped = false;
    this.weight = 1.0;
    this._samplers = [];
    this._samplerBuffer = null;
    this._playtime = 0.0;
    this._duration = duration;
    this.timescale = 1.0;
    this._inputs = inputs;
    this._outputs = outputs;
    this.extras = undefined;
    this.needsUpdate = true;
    this.onEnd = new _wgetemp_event["a" /* Event */]();
  }

  static get Sampler() {
    return animation_Sampler;
  }

  clone() {
    const name = this.name,
          duration = this.duration,
          _inputs = this._inputs,
          _outputs = this._outputs,
          looped = this.looped,
          _samplers = this._samplers,
          timescale = this.timescale,
          _active = this._active,
          extras = this.extras;
    const clone_ = new animation_Animation({
      name,
      duration,
      inputs: _inputs,
      outputs: _outputs
    });
    clone_.looped = looped;
    clone_.timescale = timescale;
    clone_._active = _active;

    if (extras !== undefined) {
      clone_.extras = JSON.parse(JSON.stringify(extras));
    }

    for (const s of _samplers) {
      clone_.samplers.push(s.clone());
    }

    return clone_;
  }

  get duration() {
    return this._duration;
  }

  set duration(value) {
    this._duration = value;
  }

  get playtime() {
    return this._playtime;
  }

  get active() {
    return this._active;
  }

  get samplers() {
    return this._samplers;
  }

  pause() {
    this._active = false;
  }

  play() {
    this._active = true;
  }

  stop() {
    this._playtime = 0.0;
    this._active = false;
  }

  _updateSamplerBuffers() {
    const _samplers = this._samplers,
          _outputs = this._outputs;
    let bufferSize = 0;

    for (let i = 0, count = _samplers.length; i < count; i++) {
      bufferSize += animation_Sampler._getSamplerSize(_samplers[i], _outputs);
    }

    this._samplerBuffer = new Float32Array(bufferSize);
    this.needsUpdate = false;
  }

  startUpdate(dt) {
    if (!this._active) {
      return;
    }

    if (this.needsUpdate) {
      this._updateSamplerBuffers();
    }

    const _duration = this._duration,
          _playtime = this._playtime,
          timescale = this.timescale,
          _samplers = this._samplers,
          _samplerBuffer = this._samplerBuffer,
          _inputs = this._inputs,
          _outputs = this._outputs;
    const playtime = _playtime + dt * timescale;

    if (playtime <= _duration && playtime >= 0.0) {
      this._playtime = playtime;
    } else if (playtime < 0.0 || playtime > _duration) {
      this._playtime = playtime < 0.0 ? 0.0 : _duration;
      this._lastFrame = true;
    }

    const count = _samplers.length;
    let offset = 0;

    for (let i = 0; i < count; i++) {
      offset += animation_Sampler._packSampler(playtime, _samplers[i], _inputs, _outputs, _samplerBuffer, offset);
    }

    interpolate(count, _samplerBuffer);
    offset = 0;

    for (let i = 0; i < count; i++) {
      offset += animation_Sampler._unpackSampler(_samplers[i], _samplerBuffer, offset);
    }
  }

  endUpdate() {
    const active = this.active,
          looped = this.looped,
          _lastFrame = this._lastFrame,
          _playtime = this._playtime;

    if (!active) {
      return;
    }

    if (_lastFrame) {
      this._lastFrame = false;
      this._active = looped;
      this._playtime = looped ? _playtime > 0.0 ? 0.0 : this.duration : _playtime;
      this.onEnd.emit();
    }
  }

  _actuallyUnload() {
    this.stop();

    for (const track of function* () {
      yield* this._inputs;
      yield* this._outputs;
    }.call(this)) {
      track.view = null;
    }

    this._samplerBuffer = null;

    super._actuallyUnload();
  }

  _dispose() {
    this.stop();
    delete this._samplerBuffer;
    delete this._inputs;
    delete this._outputs;

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/morph-component/index.js


class morph_component_MorphTargetData extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    elementCount,
    componentCount,
    semantic,
    type
  }) {
    super();
    this.semantic = semantic;
    this.view = new type(elementCount * componentCount);
  }

  _dispose() {
    this.view = null;

    super._dispose();
  }

  _actuallyUnload() {
    this.view = null;

    super._actuallyUnload();
  }

}
class morph_component_Morph extends component_Component {
  constructor(weights) {
    super();
    this.weights = new Float32Array(weights);
    this.needsUpdate = false;
  }

  clone() {
    return new morph_component_Morph(this.weights);
  }

}
morph_component_Morph.ID = 'morph';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/animation-component/node-animation.js




function _defaultUpdate(target, valueView) {}

function _morphUpdate(target, valueView) {
  if (!(target instanceof morph_component_Morph)) {
    throw new Error(`morphUpdate expects ${morph_component_Morph.name} as target, target: ${target}`);
  }

  target.weights.set(valueView);
  target.needsUpdate = true;
}

function _translationUpdate(target, valueView) {
  if (!(target instanceof transform_component_Transform)) {
    throw new Error(`translationUpdate expects ${transform_component_Transform.name} as target, target: ${target}`);
  }

  target.position.fromArray(valueView);
  target.state |= transform_component_Transform.StateMask.UPDATE_LOCAL;
}

function _scaleUpdate(target, valueView) {
  if (!(target instanceof transform_component_Transform)) {
    throw new Error(`translationUpdate expects ${transform_component_Transform.name} as target, target: ${target}`);
  }

  target.scale.fromArray(valueView);
  target.state |= transform_component_Transform.StateMask.UPDATE_LOCAL;
}

function _orientationUpdate(target, valueView) {
  if (!(target instanceof transform_component_Transform)) {
    throw new Error(`translationUpdate expects ${transform_component_Transform.name} as target, target: ${target}`);
  }

  target.orientation.fromArray(valueView);
  target.orientation.normalize();
  target.state |= transform_component_Transform.StateMask.UPDATE_LOCAL;
}

function _matrixUpdate(target, valueView) {
  if (!(target instanceof transform_component_Transform)) {
    throw new Error(`translationUpdate expects ${transform_component_Transform.name} as target, target: ${target}`);
  }

  target.matrix.fromArray(valueView);
  target.state |= transform_component_Transform.StateMask.UPDATE_COMPONENTS;
}

class Channel {
  constructor(target, sampler, animation) {
    this.target = target;
    this.sampler = sampler;
    this.animation = animation;
    this._updater = _defaultUpdate;

    this._update = valueView => {
      _defaultUpdate(target, valueView);
    };
  }

  static get translationUpdate() {
    return _translationUpdate;
  }

  static get orientationUpdate() {
    return _orientationUpdate;
  }

  static get matrixUpdate() {
    return _matrixUpdate;
  }

  static get scaleUpdate() {
    return _scaleUpdate;
  }

  static get morphUpdate() {
    return _morphUpdate;
  }

  set update(updater) {
    const target = this.target;
    this._updater = updater;

    this._update = valueView => {
      updater(target, valueView);
    };
  }

  get update() {
    return this._update;
  }

}
class node_animation_NodeAnimation extends component_Component {
  constructor() {
    super();
    this.channels = [];
  }

  static get Channel() {
    return Channel;
  }

}
node_animation_NodeAnimation.ID = 'nodeAnimation';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/animation-component/index.js




// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/octree/index.js
function octree_slicedToArray(arr, i) { return octree_arrayWithHoles(arr) || octree_iterableToArrayLimit(arr, i) || octree_unsupportedIterableToArray(arr, i) || octree_nonIterableRest(); }

function octree_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function octree_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return octree_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return octree_arrayLikeToArray(o, minLen); }

function octree_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function octree_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function octree_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module @wgetemp/octree
 */

const SPLIT_THRESHOLD = 20;
const MERGE_THRESHOLD = 12;

function tryShrinkBounds(cell) {
  const count = cell.values.length;
  const length = 6 * count;
  const bounds = cell.bounds;
  const capacity = bounds.length;

  if (length * 4 > capacity) {
    return;
  }

  const newCapacity = 6 * Object(lib["v" /* max */])(SPLIT_THRESHOLD, count * 2);

  if (newCapacity === capacity) {
    return;
  }

  const newBounds = new Float64Array(newCapacity);

  for (let offset = 0; offset < length; offset += 6) {
    newBounds[offset] = bounds[offset];
    newBounds[offset + 1] = bounds[offset + 1];
    newBounds[offset + 2] = bounds[offset + 2];
    newBounds[offset + 3] = bounds[offset + 3];
    newBounds[offset + 4] = bounds[offset + 4];
    newBounds[offset + 5] = bounds[offset + 5];
  }

  cell.bounds = newBounds;
}

const frustumProperties = {
  lX: 0,
  lY: 0,
  lZ: 0,
  lW: 0,
  rX: 0,
  rY: 0,
  rZ: 0,
  rW: 0,
  bX: 0,
  bY: 0,
  bZ: 0,
  bW: 0,
  tX: 0,
  tY: 0,
  tZ: 0,
  tW: 0,
  nX: 0,
  nY: 0,
  nZ: 0,
  nW: 0,
  fX: 0,
  fY: 0,
  fZ: 0,
  fW: 0,
  minX: 0,
  minY: 0,
  minZ: 0,
  maxX: 0,
  maxY: 0,
  maxZ: 0
};

const crossEdgeSeparators = (() => {
  const cess = new Array(12);

  for (let i = 0; i < cess.length; ++i) {
    cess[i] = {
      eX: 0,
      eY: 0,
      eZ: 0,
      loX: 0,
      hiX: 0,
      loY: 0,
      hiY: 0,
      loZ: 0,
      hiZ: 0
    };
  }

  cess.count = 0;
  return cess;
})();

function generateCrossEdgeSeparators(eX, eY, eZ, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z) {
  const cess = crossEdgeSeparators;
  const ces = cess[cess.count++];
  ces.eX = eX;
  ces.eY = eY;
  ces.eZ = eZ;
  {
    const y = -eZ,
          z = eY;
    const p0 = c0Y * y + c0Z * z,
          p1 = c1Y * y + c1Z * z,
          p2 = c2Y * y + c2Z * z,
          p3 = c3Y * y + c3Z * z,
          p4 = c4Y * y + c4Z * z,
          p5 = c5Y * y + c5Z * z,
          p6 = c6Y * y + c6Z * z,
          p7 = c7Y * y + c7Z * z;
    const lo = ces.loX = Object(lib["w" /* min */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (lo > y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ)) {
      return true;
    }

    const hi = ces.hiX = Object(lib["v" /* max */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (hi < y * (y < 0 ? maxY : minY) + z * (z < 0 ? maxZ : minZ)) {
      return true;
    }
  }
  {
    const z = -eX,
          x = eZ;
    const p0 = c0Z * z + c0X * x,
          p1 = c1Z * z + c1X * x,
          p2 = c2Z * z + c2X * x,
          p3 = c3Z * z + c3X * x,
          p4 = c4Z * z + c4X * x,
          p5 = c5Z * z + c5X * x,
          p6 = c6Z * z + c6X * x,
          p7 = c7Z * z + c7X * x;
    const lo = ces.loY = Object(lib["w" /* min */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (lo > z * (z < 0 ? minZ : maxZ) + x * (x < 0 ? minX : maxX)) {
      return true;
    }

    const hi = ces.hiY = Object(lib["v" /* max */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (hi < z * (z < 0 ? maxZ : minZ) + x * (x < 0 ? maxX : minX)) {
      return true;
    }
  }
  {
    const x = -eY,
          y = eX;
    const p0 = c0X * x + c0Y * y,
          p1 = c1X * x + c1Y * y,
          p2 = c2X * x + c2Y * y,
          p3 = c3X * x + c3Y * y,
          p4 = c4X * x + c4Y * y,
          p5 = c5X * x + c5Y * y,
          p6 = c6X * x + c6Y * y,
          p7 = c7X * x + c7Y * y;
    const lo = ces.loZ = Object(lib["w" /* min */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (lo > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY)) {
      return true;
    }

    const hi = ces.hiZ = Object(lib["v" /* max */])(p0, p1, p2, p3, p4, p5, p6, p7);

    if (hi < x * (x < 0 ? maxX : minX) + y * (y < 0 ? maxY : minY)) {
      return true;
    }
  }
  return false;
}

class octree_Cell {
  constructor(parent) {
    this.parent = parent;
    this.deepCount = 0;
    this.bounds = new Float64Array(6 * SPLIT_THRESHOLD);
    this.values = [];
    this.child000 = null;
    this.child001 = null;
    this.child010 = null;
    this.child011 = null;
    this.child100 = null;
    this.child101 = null;
    this.child110 = null;
    this.child111 = null;
  }

  insert(valueLocations, centerX, centerY, centerZ, quarterSize, valueMinX, valueMinY, valueMinZ, valueMaxX, valueMaxY, valueMaxZ, value) {
    const deepCount = this.deepCount;

    if ((this.deepCount = deepCount + 1) > SPLIT_THRESHOLD) {
      if (deepCount === SPLIT_THRESHOLD) {
        const bounds = this.bounds,
              values = this.values;
        const count = values.length;
        this.values = [];
        let offset = 0;

        for (let i = 0; i < count; ++i) {
          this.insert(valueLocations, centerX, centerY, centerZ, quarterSize, bounds[offset], bounds[offset + 1], bounds[offset + 2], bounds[offset + 3], bounds[offset + 4], bounds[offset + 5], values[i]);
          offset += 6;
        }

        this.deepCount -= count;
        tryShrinkBounds(this);
      }

      let childCenterX, childCenterY, childCenterZ;
      let child = null;
      const mask0 = (valueMaxZ >= centerZ) << 2 | (valueMaxY >= centerY) << 1 | valueMaxX >= centerX;
      const mask1 = (valueMinZ > centerZ) << 2 | (valueMinY > centerY) << 1 | valueMinX > centerX;

      switch ((mask0 ^ mask1) << 3 | mask0 & mask1) {
        case 0b000:
          childCenterX = centerX - quarterSize;
          childCenterY = centerY - quarterSize;
          childCenterZ = centerZ - quarterSize;

          if ((child = this.child000) === null) {
            this.child000 = child = new octree_Cell(this);
          }

          break;

        case 0b001:
          childCenterX = centerX + quarterSize;
          childCenterY = centerY - quarterSize;
          childCenterZ = centerZ - quarterSize;

          if ((child = this.child001) === null) {
            this.child001 = child = new octree_Cell(this);
          }

          break;

        case 0b010:
          childCenterX = centerX - quarterSize;
          childCenterY = centerY + quarterSize;
          childCenterZ = centerZ - quarterSize;

          if ((child = this.child010) === null) {
            this.child010 = child = new octree_Cell(this);
          }

          break;

        case 0b011:
          childCenterX = centerX + quarterSize;
          childCenterY = centerY + quarterSize;
          childCenterZ = centerZ - quarterSize;

          if ((child = this.child011) === null) {
            this.child011 = child = new octree_Cell(this);
          }

          break;

        case 0b100:
          childCenterX = centerX - quarterSize;
          childCenterY = centerY - quarterSize;
          childCenterZ = centerZ + quarterSize;

          if ((child = this.child100) === null) {
            this.child100 = child = new octree_Cell(this);
          }

          break;

        case 0b101:
          childCenterX = centerX + quarterSize;
          childCenterY = centerY - quarterSize;
          childCenterZ = centerZ + quarterSize;

          if ((child = this.child101) === null) {
            this.child101 = child = new octree_Cell(this);
          }

          break;

        case 0b110:
          childCenterX = centerX - quarterSize;
          childCenterY = centerY + quarterSize;
          childCenterZ = centerZ + quarterSize;

          if ((child = this.child110) === null) {
            this.child110 = child = new octree_Cell(this);
          }

          break;

        case 0b111:
          childCenterX = centerX + quarterSize;
          childCenterY = centerY + quarterSize;
          childCenterZ = centerZ + quarterSize;

          if ((child = this.child111) === null) {
            this.child111 = child = new octree_Cell(this);
          }

          break;
      }

      if (child !== null) {
        child.insert(valueLocations, childCenterX, childCenterY, childCenterZ, quarterSize * 0.5, valueMinX, valueMinY, valueMinZ, valueMaxX, valueMaxY, valueMaxZ, value);
        return;
      }
    }

    let bounds = this.bounds,
        values = this.values;
    const count = values.length;
    const offset = 6 * count;

    if (offset === bounds.length) {
      const oldBounds = bounds;
      (bounds = new Float64Array(offset * 2)).set(oldBounds);
      this.bounds = bounds;
    }

    bounds[offset] = valueMinX;
    bounds[offset + 1] = valueMinY;
    bounds[offset + 2] = valueMinZ;
    bounds[offset + 3] = valueMaxX;
    bounds[offset + 4] = valueMaxY;
    bounds[offset + 5] = valueMaxZ;
    values.push(value);
    let location = valueLocations.get(value);

    if (location === undefined) {
      location = {
        cell: this,
        index: count
      };
      valueLocations.set(value, location);
    } else {
      location.cell = this;
      location.index = count;
    }
  }

  gather(foundValues, foundCount) {
    const values = this.values;
    const count = values.length;

    for (let i = 0; i < count; ++i) {
      foundValues[foundCount++] = values[i];
    }

    let child;

    if ((child = this.child000) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child001) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child010) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child011) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child100) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child101) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child110) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    if ((child = this.child111) !== null) {
      foundCount = child.gather(foundValues, foundCount);
    }

    return foundCount;
  }

  find(centerX, centerY, centerZ, quarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, coverY0, coverZ0, coverX1, coverY1, coverZ1, foundValues, foundCount) {
    const bounds = this.bounds,
          values = this.values;
    const count = values.length;
    let offset = 0;

    for (let i = 0; i < count; ++i) {
      if (bounds[offset] <= queryMaxX && bounds[offset + 1] <= queryMaxY && bounds[offset + 2] <= queryMaxZ && bounds[offset + 3] >= queryMinX && bounds[offset + 4] >= queryMinY && bounds[offset + 5] >= queryMinZ) {
        foundValues[foundCount++] = values[i];
      }

      offset += 6;
    }

    const hitX0 = queryMinX <= centerX,
          hitY0 = queryMinY <= centerY,
          hitZ0 = queryMinZ <= centerZ;
    const hitX1 = queryMaxX >= centerX,
          hitY1 = queryMaxY >= centerY,
          hitZ1 = queryMaxZ >= centerZ;
    const centerX0 = centerX - quarterSize,
          centerY0 = centerY - quarterSize,
          centerZ0 = centerZ - quarterSize;
    const centerX1 = centerX + quarterSize,
          centerY1 = centerY + quarterSize,
          centerZ1 = centerZ + quarterSize;
    const childQuarterSize = quarterSize * 0.5;
    let child;

    if ((child = this.child000) !== null) {
      if (coverX0 && coverY0 && coverZ0 && hitX1 && hitY1 && hitZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX0 && hitY0 && hitZ0) {
        foundCount = child.find(centerX0, centerY0, centerZ0, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, coverY0, coverZ0, hitX1, hitY1, hitZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child001) !== null) {
      if (hitX0 && coverY0 && coverZ0 && coverX1 && hitY1 && hitZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX1 && hitY0 && hitZ0) {
        foundCount = child.find(centerX1, centerY0, centerZ0, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, hitX0, coverY0, coverZ0, coverX1, hitY1, hitZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child010) !== null) {
      if (coverX0 && hitY0 && coverZ0 && hitX1 && coverY1 && hitZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX0 && hitY1 && hitZ0) {
        foundCount = child.find(centerX0, centerY1, centerZ0, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, hitY0, coverZ0, hitX1, coverY1, hitZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child011) !== null) {
      if (hitX0 && hitY0 && coverZ0 && coverX1 && coverY1 && hitZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX1 && hitY1 && hitZ0) {
        foundCount = child.find(centerX1, centerY1, centerZ0, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, hitX0, hitY0, coverZ0, coverX1, coverY1, hitZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child100) !== null) {
      if (coverX0 && coverY0 && hitZ0 && hitX1 && hitY1 && coverZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX0 && hitY0 && hitZ1) {
        foundCount = child.find(centerX0, centerY0, centerZ1, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, coverY0, hitZ0, hitX1, hitY1, coverZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child101) !== null) {
      if (hitX0 && coverY0 && hitZ0 && coverX1 && hitY1 && coverZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX1 && hitY0 && hitZ1) {
        foundCount = child.find(centerX1, centerY0, centerZ1, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, hitX0, coverY0, coverZ0, coverX1, hitY1, coverZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child110) !== null) {
      if (coverX0 && hitY0 && hitZ0 && hitX1 && coverY1 && coverZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX0 && hitY1 && hitZ1) {
        foundCount = child.find(centerX0, centerY1, centerZ1, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, hitY0, hitZ0, hitX1, coverY1, coverZ1, foundValues, foundCount);
      }
    }

    if ((child = this.child111) !== null) {
      if (hitX0 && hitY0 && hitZ0 && coverX1 && coverY1 && coverZ1) {
        foundCount = child.gather(foundValues, foundCount);
      } else if (hitX1 && hitY1 && hitZ1) {
        foundCount = child.find(centerX1, centerY1, centerZ1, childQuarterSize, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, hitX0, hitY0, hitZ0, coverX1, coverY1, coverZ1, foundValues, foundCount);
      }
    }

    return foundCount;
  }

  frustumFindAsChild(centerX, centerY, centerZ, quarterSize, minX, minY, minZ, maxX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount) {
    const fp = frustumProperties;

    if (minX <= fp.maxX && maxX >= fp.minX && minY <= fp.maxY && maxY >= fp.minY && minZ <= fp.maxZ && maxZ >= fp.minZ) {
      const lX = fp.lX,
            lY = fp.lY,
            lZ = fp.lZ,
            lW = fp.lW,
            rX = fp.rX,
            rY = fp.rY,
            rZ = fp.rZ,
            rW = fp.rW,
            bX = fp.bX,
            bY = fp.bY,
            bZ = fp.bZ,
            bW = fp.bW,
            tX = fp.tX,
            tY = fp.tY,
            tZ = fp.tZ,
            tW = fp.tW,
            nX = fp.nX,
            nY = fp.nY,
            nZ = fp.nZ,
            nW = fp.nW,
            fX = fp.fX,
            fY = fp.fY,
            fZ = fp.fZ,
            fW = fp.fW;
      lCover = lCover || 0 < lX * (lX < 0 ? maxX : minX) + lY * (lY < 0 ? maxY : minY) + lZ * (lZ < 0 ? maxZ : minZ) + lW;
      rCover = rCover || 0 < rX * (rX < 0 ? maxX : minX) + rY * (rY < 0 ? maxY : minY) + rZ * (rZ < 0 ? maxZ : minZ) + rW;
      bCover = bCover || 0 < bX * (bX < 0 ? maxX : minX) + bY * (bY < 0 ? maxY : minY) + bZ * (bZ < 0 ? maxZ : minZ) + bW;
      tCover = tCover || 0 < tX * (tX < 0 ? maxX : minX) + tY * (tY < 0 ? maxY : minY) + tZ * (tZ < 0 ? maxZ : minZ) + tW;
      nCover = nCover || 0 < nX * (nX < 0 ? maxX : minX) + nY * (nY < 0 ? maxY : minY) + nZ * (nZ < 0 ? maxZ : minZ) + nW;
      fCover = fCover || 0 < fX * (fX < 0 ? maxX : minX) + fY * (fY < 0 ? maxY : minY) + fZ * (fZ < 0 ? maxZ : minZ) + fW;

      if (lCover && rCover && bCover && tCover && nCover && fCover) {
        foundCount = this.gather(foundValues, foundCount);
      } else do {
        if (!lCover && 0 > lX * (lX < 0 ? minX : maxX) + lY * (lY < 0 ? minY : maxY) + lZ * (lZ < 0 ? minZ : maxZ) + lW) {
          break;
        }

        if (!rCover && 0 > rX * (rX < 0 ? minX : maxX) + rY * (rY < 0 ? minY : maxY) + rZ * (rZ < 0 ? minZ : maxZ) + rW) {
          break;
        }

        if (!bCover && 0 > bX * (bX < 0 ? minX : maxX) + bY * (bY < 0 ? minY : maxY) + bZ * (bZ < 0 ? minZ : maxZ) + bW) {
          break;
        }

        if (!tCover && 0 > tX * (tX < 0 ? minX : maxX) + tY * (tY < 0 ? minY : maxY) + tZ * (tZ < 0 ? minZ : maxZ) + tW) {
          break;
        }

        if (!nCover && 0 > nX * (nX < 0 ? minX : maxX) + nY * (nY < 0 ? minY : maxY) + nZ * (nZ < 0 ? minZ : maxZ) + nW) {
          break;
        }

        if (!fCover && 0 > fX * (fX < 0 ? minX : maxX) + fY * (fY < 0 ? minY : maxY) + fZ * (fZ < 0 ? minZ : maxZ) + fW) {
          break;
        }

        const cess = crossEdgeSeparators;
        let disjoint = false;

        for (let i = 0; i < 12; ++i) {
          const ces = cess[i];
          const eX = ces.eX,
                eY = ces.eY,
                eZ = ces.eZ;
          {
            const y = -eZ,
                  z = eY;

            if (ces.loX > y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) || ces.hiX < y * (y < 0 ? maxY : minY) + z * (z < 0 ? maxZ : minZ)) {
              disjoint = true;
              break;
            }
          }
          {
            const z = -eX,
                  x = eZ;

            if (ces.loY > z * (z < 0 ? minZ : maxZ) + x * (x < 0 ? minX : maxX) || ces.hiY < z * (z < 0 ? maxZ : minZ) + x * (x < 0 ? maxX : minX)) {
              disjoint = true;
              break;
            }
          }
          {
            const x = -eY,
                  y = eX;

            if (ces.loZ > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) || ces.hiZ < x * (x < 0 ? maxX : minX) + y * (y < 0 ? maxY : minY)) {
              disjoint = true;
              break;
            }
          }
        }

        if (disjoint) {
          continue;
        }

        foundCount = this.frustumFind(centerX, centerY, centerZ, quarterSize, minX, minY, minZ, maxX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
      } while (false);
    }

    return foundCount;
  }

  frustumFind(midX, midY, midZ, quarterSize, minX, minY, minZ, maxX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount) {
    const fp = frustumProperties;
    const cess = crossEdgeSeparators;
    const bounds = this.bounds,
          values = this.values;
    const count = values.length;

    for (let i = 0, offset = 0; i < count; ++i, offset += 6) {
      const minX = bounds[offset];

      if (minX > fp.maxX) {
        continue;
      }

      const minY = bounds[offset + 1];

      if (minY > fp.maxY) {
        continue;
      }

      const minZ = bounds[offset + 2];

      if (minZ > fp.maxZ) {
        continue;
      }

      const maxX = bounds[offset + 3];

      if (maxX < fp.minX) {
        continue;
      }

      const maxY = bounds[offset + 4];

      if (maxY < fp.minY) {
        continue;
      }

      const maxZ = bounds[offset + 5];

      if (maxZ < fp.minZ) {
        continue;
      }

      if (!lCover) {
        const x = fp.lX,
              y = fp.lY,
              z = fp.lZ,
              w = fp.lW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      if (!rCover) {
        const x = fp.rX,
              y = fp.rY,
              z = fp.rZ,
              w = fp.rW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      if (!bCover) {
        const x = fp.bX,
              y = fp.bY,
              z = fp.bZ,
              w = fp.bW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      if (!tCover) {
        const x = fp.tX,
              y = fp.tY,
              z = fp.tZ,
              w = fp.tW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      if (!nCover) {
        const x = fp.nX,
              y = fp.nY,
              z = fp.nZ,
              w = fp.nW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      if (!fCover) {
        const x = fp.fX,
              y = fp.fY,
              z = fp.fZ,
              w = fp.fW;

        if (0 > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) + w) {
          continue;
        }
      }

      let disjoint = false;

      for (let i = 0; i < 12; ++i) {
        const ces = cess[i];
        const eX = ces.eX,
              eY = ces.eY,
              eZ = ces.eZ;
        {
          const y = -eZ,
                z = eY;

          if (ces.loX > y * (y < 0 ? minY : maxY) + z * (z < 0 ? minZ : maxZ) || ces.hiX < y * (y < 0 ? maxY : minY) + z * (z < 0 ? maxZ : minZ)) {
            disjoint = true;
            break;
          }
        }
        {
          const z = -eX,
                x = eZ;

          if (ces.loY > z * (z < 0 ? minZ : maxZ) + x * (x < 0 ? minX : maxX) || ces.hiY < z * (z < 0 ? maxZ : minZ) + x * (x < 0 ? maxX : minX)) {
            disjoint = true;
            break;
          }
        }
        {
          const x = -eY,
                y = eX;

          if (ces.loZ > x * (x < 0 ? minX : maxX) + y * (y < 0 ? minY : maxY) || ces.hiZ < x * (x < 0 ? maxX : minX) + y * (y < 0 ? maxY : minY)) {
            disjoint = true;
            break;
          }
        }
      }

      if (disjoint) {
        continue;
      }

      foundValues[foundCount++] = values[i];
    }

    const loCenterX = midX - quarterSize,
          loCenterY = midY - quarterSize,
          loCenterZ = midZ - quarterSize;
    const hiCenterX = midX + quarterSize,
          hiCenterY = midY + quarterSize,
          hiCenterZ = midZ + quarterSize;
    const halfQuarterSize = quarterSize * 0.5;
    let child;

    if ((child = this.child000) !== null) {
      foundCount = child.frustumFindAsChild(loCenterX, loCenterY, loCenterZ, halfQuarterSize, minX, minY, minZ, midX, midY, midZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child001) !== null) {
      foundCount = child.frustumFindAsChild(hiCenterX, loCenterY, loCenterZ, halfQuarterSize, midX, minY, minZ, maxX, midY, midZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child010) !== null) {
      foundCount = child.frustumFindAsChild(loCenterX, hiCenterY, loCenterZ, halfQuarterSize, minX, midY, minZ, midX, maxY, midZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child011) !== null) {
      foundCount = child.frustumFindAsChild(hiCenterX, hiCenterY, loCenterZ, halfQuarterSize, midX, midY, minZ, maxX, maxY, midZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child100) !== null) {
      foundCount = child.frustumFindAsChild(loCenterX, loCenterY, hiCenterZ, halfQuarterSize, minX, minY, midZ, midX, midY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child101) !== null) {
      foundCount = child.frustumFindAsChild(hiCenterX, loCenterY, hiCenterZ, halfQuarterSize, midX, minY, midZ, maxX, midY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child110) !== null) {
      foundCount = child.frustumFindAsChild(loCenterX, hiCenterY, hiCenterZ, halfQuarterSize, minX, midY, midZ, midX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    if ((child = this.child111) !== null) {
      foundCount = child.frustumFindAsChild(hiCenterX, hiCenterY, hiCenterZ, halfQuarterSize, midX, midY, midZ, maxX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
    }

    return foundCount;
  }

  rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tMinY, tMinZ, tMaxX, tMaxY, tMaxZ, foundValues, foundCount) {
    const near = Object(lib["v" /* max */])(tMinX <= tMaxX ? tMinX : tMaxX, tMinY <= tMaxY ? tMinY : tMaxY, tMinZ <= tMaxZ ? tMinZ : tMaxZ, 0);
    const far = Object(lib["w" /* min */])(tMinX > tMaxX ? tMinX : tMaxX, tMinY > tMaxY ? tMinY : tMaxY, tMinZ > tMaxZ ? tMinZ : tMaxZ);

    if (near <= far) {
      const bounds = this.bounds,
            values = this.values;
      const count = values.length;

      for (let i = 0, offset = 0; i < count; ++i, offset += 6) {
        let tMinX = (bounds[offset] - originX) * recDirectionX,
            tMinY = (bounds[offset + 1] - originY) * recDirectionY,
            tMinZ = (bounds[offset + 2] - originZ) * recDirectionZ;

        if (!isFinite(tMinX)) {
          tMinX = -Infinity;
        }

        if (!isFinite(tMinY)) {
          tMinY = -Infinity;
        }

        if (!isFinite(tMinZ)) {
          tMinZ = -Infinity;
        }

        let tMaxX = (bounds[offset + 3] - originX) * recDirectionX,
            tMaxY = (bounds[offset + 4] - originY) * recDirectionY,
            tMaxZ = (bounds[offset + 5] - originZ) * recDirectionZ;

        if (!isFinite(tMaxX)) {
          tMaxX = +Infinity;
        }

        if (!isFinite(tMaxY)) {
          tMaxY = +Infinity;
        }

        if (!isFinite(tMaxZ)) {
          tMaxZ = +Infinity;
        }

        if (tMinX > tMaxX) {
          const t = tMinX;
          tMinX = tMaxX;
          tMaxX = t;
        }

        if (tMinY > tMaxY) {
          const t = tMinY;
          tMinY = tMaxY;
          tMaxY = t;
        }

        if (tMinZ > tMaxZ) {
          const t = tMinZ;
          tMinZ = tMaxZ;
          tMaxZ = t;
        }

        if (Object(lib["v" /* max */])(tMinX, tMinY, tMinZ, 0) <= Object(lib["w" /* min */])(tMaxX, tMaxY, tMaxZ)) {
          foundValues[foundCount++] = values[i];
        }
      }

      const tMidX = (tMinX + tMaxX) * 0.5,
            tMidY = (tMinY + tMaxY) * 0.5,
            tMidZ = (tMinZ + tMaxZ) * 0.5;
      const tLoMidX = Object(lib["t" /* isNaN */])(tMidX) ? +Infinity : tMidX,
            tLoMidY = Object(lib["t" /* isNaN */])(tMidY) ? +Infinity : tMidY,
            tLoMidZ = Object(lib["t" /* isNaN */])(tMidZ) ? +Infinity : tMidZ;
      const tHiMidX = Object(lib["t" /* isNaN */])(tMidX) ? -Infinity : tMidX,
            tHiMidY = Object(lib["t" /* isNaN */])(tMidY) ? -Infinity : tMidY,
            tHiMidZ = Object(lib["t" /* isNaN */])(tMidZ) ? -Infinity : tMidZ;
      let child;

      if ((child = this.child000) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tMinY, tMinZ, tLoMidX, tLoMidY, tLoMidZ, foundValues, foundCount);
      }

      if ((child = this.child001) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tHiMidX, tMinY, tMinZ, tMaxX, tLoMidY, tLoMidZ, foundValues, foundCount);
      }

      if ((child = this.child010) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tHiMidY, tMinZ, tLoMidX, tMaxY, tLoMidZ, foundValues, foundCount);
      }

      if ((child = this.child011) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tHiMidX, tHiMidY, tMinZ, tMaxX, tMaxY, tLoMidZ, foundValues, foundCount);
      }

      if ((child = this.child100) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tMinY, tHiMidZ, tLoMidX, tLoMidY, tMaxZ, foundValues, foundCount);
      }

      if ((child = this.child101) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tHiMidX, tMinY, tHiMidZ, tMaxX, tLoMidY, tMaxZ, foundValues, foundCount);
      }

      if ((child = this.child110) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tHiMidY, tHiMidZ, tLoMidX, tMaxY, tMaxZ, foundValues, foundCount);
      }

      if ((child = this.child111) !== null) {
        foundCount = child.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tHiMidX, tHiMidY, tHiMidZ, tMaxX, tMaxY, tMaxZ, foundValues, foundCount);
      }
    }

    return foundCount;
  }

}

const invProjectionTmp = new lib["g" /* HomogeneousMatrix3 */]();
/**
 * @class module:@wgetemp/octree.Octree
 * @summary Dynamic octree for spatial queries.
 * @param {Interable} [values=[]] `[value, boundingBox]` pairs to put into octree.
 */

class octree_Octree {
  constructor(values = []) {
    this._centerX = 0;
    this._centerY = 0;
    this._centerZ = 0;
    this._halfSize = 0;
    this._minX = 0;
    this._minY = 0;
    this._minZ = 0;
    this._maxX = 0;
    this._maxY = 0;
    this._maxZ = 0;
    this._root = null;
    this._valueLocations = new Map();

    for (const _ref of values) {
      var _ref2 = octree_slicedToArray(_ref, 2);

      const value = _ref2[0];
      const valueBound = _ref2[1];
      this.insert(value, valueBound);
    }
  }
  /**
   * @var module:@wgetemp/octree.Octree#count
   * @summary Count of entries in octree.
   * @type {number}
   * @readonly
   */


  get count() {
    return this._valueLocations.size;
  }
  /**
   * @function module:@wgetemp/octree.Octree#insert
   * @summary Set a bounding box for a value.
   * @desc Updates the value's bounding box it the value is already in octree.
   * @param {object} value Value to add into octree. Can be anything that can be used as a `Map`
   * key, with the same equality definition.
   * @param {module:@wgetemp/math.Box} valueBound Bounding box to associate with the value.
   */


  insert(value, valueBound) {
    this.remove(value);
    let _valueBound$min = valueBound.min,
        valueMinX = _valueBound$min.x,
        valueMinY = _valueBound$min.y,
        valueMinZ = _valueBound$min.z,
        _valueBound$max = valueBound.max,
        valueMaxX = _valueBound$max.x,
        valueMaxY = _valueBound$max.y,
        valueMaxZ = _valueBound$max.z;
    let centerX, centerY, centerZ;
    let halfSize;
    let root = this._root;

    if (root === null) {
      halfSize = Object(lib["o" /* ceilPow2 */])(Object(lib["v" /* max */])(valueMaxX - valueMinX, valueMaxY - valueMinY, valueMaxZ - valueMinZ));
      const recSize = 1 / (2 * halfSize);
      centerX = Object(lib["x" /* round */])((valueMinX + valueMaxX) * recSize) * halfSize;
      centerY = Object(lib["x" /* round */])((valueMinY + valueMaxY) * recSize) * halfSize;
      centerZ = Object(lib["x" /* round */])((valueMinZ + valueMaxZ) * recSize) * halfSize;
      root = new octree_Cell(null);
      this._centerX = centerX;
      this._centerY = centerY;
      this._centerZ = centerZ;
      this._halfSize = halfSize;
      this._minX = centerX - halfSize;
      this._minY = centerY - halfSize;
      this._minZ = centerZ - halfSize;
      this._maxX = centerX + halfSize;
      this._maxY = centerY + halfSize;
      this._maxZ = centerZ + halfSize;
      this._root = root;
    } else {
      centerX = this._centerX;
      centerY = this._centerY;
      centerZ = this._centerZ;
      halfSize = this._halfSize;
      let minX = this._minX,
          minY = this._minY,
          minZ = this._minZ,
          maxX = this._maxX,
          maxY = this._maxY,
          maxZ = this._maxZ;

      if (valueMinX < minX || valueMinY < minY || valueMinZ < minZ || valueMaxX > maxX || valueMaxY > maxY || valueMaxZ > maxZ) {
        const _root = root,
              deepCount = _root.deepCount;
        const noLift = deepCount > SPLIT_THRESHOLD;
        const complexLift = deepCount === SPLIT_THRESHOLD;
        const valueCenterX = (valueMinX + valueMaxX) * 0.5,
              valueCenterY = (valueMinY + valueMaxY) * 0.5,
              valueCenterZ = (valueMinZ + valueMaxZ) * 0.5;

        while (true) {
          const downX = valueCenterX - centerX < 0,
                downY = valueCenterY - centerY < 0,
                downZ = valueCenterZ - centerZ < 0;
          centerX += downX ? -halfSize : halfSize;
          centerY += downY ? -halfSize : halfSize;
          centerZ += downZ ? -halfSize : halfSize;
          halfSize *= 2;
          minX = centerX - halfSize;
          minY = centerY - halfSize;
          minZ = centerZ - halfSize;
          maxX = centerX + halfSize;
          maxY = centerY + halfSize;
          maxZ = centerZ + halfSize;
          const contained = valueMinX >= minX && valueMinY >= minY && valueMinZ >= minZ && valueMaxX <= maxX && valueMaxY <= maxY && valueMaxZ <= maxZ;

          if (noLift || complexLift && contained) {
            const newRoot = new octree_Cell(null);
            newRoot.deepCount = root.deepCount;

            switch (downZ << 2 | downY << 1 | downX) {
              case 0b000:
                newRoot.child000 = root;
                break;

              case 0b001:
                newRoot.child001 = root;
                break;

              case 0b010:
                newRoot.child010 = root;
                break;

              case 0b011:
                newRoot.child011 = root;
                break;

              case 0b100:
                newRoot.child100 = root;
                break;

              case 0b101:
                newRoot.child101 = root;
                break;

              case 0b110:
                newRoot.child110 = root;
                break;

              case 0b111:
                newRoot.child111 = root;
                break;
            }

            root.parent = newRoot;
            root = newRoot;
          }

          if (contained) {
            break;
          }
        }

        this._centerX = centerX;
        this._centerY = centerY;
        this._centerZ = centerZ;
        this._halfSize = halfSize;
        this._minX = minX;
        this._minY = minY;
        this._minZ = minZ;
        this._maxX = maxX;
        this._maxY = maxY;
        this._maxZ = maxZ;
        this._root = root;
      }
    }

    root.insert(this._valueLocations, centerX, centerY, centerZ, halfSize * 0.5, valueMinX, valueMinY, valueMinZ, valueMaxX, valueMaxY, valueMaxZ, value);
  }
  /**
   * @function module:@wgetemp/octree.Octree#contains
   * @summary Test whether value is in octree.
   * @param {object} value Value to test.
   * @returns {boolean} Whether value is in octree.
   */


  contains(value) {
    return this._valueLocations.has(value);
  }
  /**
   * @function module:@wgetemp/octree.Octree#boundOf
   * @summary Get bounding box for a value in octree.
   * @desc If the value is not in octree, returns undefined.
   * @param {object} value Value to get bounding box of.
   * @returns {module:@wgetemp/math.Box|undefined} Bounding box of the value.
   */


  boundOf(value) {
    const location = this._valueLocations.get(value);

    if (location === undefined) {
      return;
    }

    const bounds = location.cell.bounds;
    const offset = location.index * 6;
    const valueBound = new lib["e" /* Box */]();
    valueBound.min.fromArrayAt(offset, bounds);
    valueBound.max.fromArrayAt(offset + 3, bounds);
    return valueBound;
  }
  /**
   * @function module:@wgetemp/octree.Octree#values
   * @summary Get iterator over values in octree.
   * @returns {Iterator} Values in octree.
   */


  values() {
    return this._valueLocations.keys();
  }
  /**
   * @function module:@wgetemp/octree.Octree#bounds
   * @summary Get iterator over value bounds in octree.
   * @returns {Iterator.<module:@wgetemp/math.Box>} Value bounds in octree.
   */


  *bounds() {
    for (const value of this.values()) {
      yield this.boundOf(value);
    }
  }
  /**
   * @function module:@wgetemp/octree.Octree#entries
   * @summary Get iterator over `[value, valueBound]` pairs in octree.
   * @desc Can also be used as `[Symbol.iterator]()`.
   * @returns {Iterator} Values in octree.
   */


  *entries() {
    for (const value of this.values()) {
      yield [value, this.boundOf(value)];
    }
  }

  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * @function module:@wgetemp/octree.Octree#remove
   * @summary Delete value from octree.
   * @desc Does nothing if the value is not in octree.
   * @param {object} value Value to remove.
   */


  remove(value) {
    const valueLocations = this._valueLocations;
    const location = valueLocations.get(value);

    if (location === undefined) {
      return;
    }

    valueLocations.delete(value);
    const removeCell = location.cell;
    const removeIndex = location.index;
    const removeValues = removeCell.values,
          removeBounds = removeCell.bounds;
    const lastIndex = removeValues.length - 1;

    if (removeIndex !== lastIndex) {
      const lastValue = removeValues[lastIndex];
      removeValues[removeIndex] = lastValue;
      const lastOffset = lastIndex * 6;
      removeBounds.copyWithin(removeIndex * 6, lastOffset, lastOffset + 6);
      valueLocations.get(lastValue).index = removeIndex;
    }

    removeValues.length = lastIndex;
    let mergeCell = null;

    for (let cell = removeCell; cell !== null; cell = cell.parent) {
      if (--cell.deepCount <= MERGE_THRESHOLD) {
        mergeCell = cell;
      }
    }

    if (mergeCell === null) {
      tryShrinkBounds(removeCell);
    } else {
      const _mergeCell = mergeCell,
            mergeValues = _mergeCell.values,
            mergeBounds = _mergeCell.bounds;
      const baseMergeCount = mergeValues.length;

      for (let cell = removeCell, mergeOffset = baseMergeCount * 6;;) {
        let child;

        if ((child = cell.child000) !== null) {
          cell.child000 = null;
          const _child = child,
                childValues = _child.values,
                childBounds = _child.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child001) !== null) {
          cell.child001 = null;
          const _child2 = child,
                childValues = _child2.values,
                childBounds = _child2.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child010) !== null) {
          cell.child010 = null;
          const _child3 = child,
                childValues = _child3.values,
                childBounds = _child3.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child011) !== null) {
          cell.child011 = null;
          const _child4 = child,
                childValues = _child4.values,
                childBounds = _child4.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child100) !== null) {
          cell.child100 = null;
          const _child5 = child,
                childValues = _child5.values,
                childBounds = _child5.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child101) !== null) {
          cell.child101 = null;
          const _child6 = child,
                childValues = _child6.values,
                childBounds = _child6.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child110) !== null) {
          cell.child110 = null;
          const _child7 = child,
                childValues = _child7.values,
                childBounds = _child7.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if ((child = cell.child111) !== null) {
          cell.child111 = null;
          const _child8 = child,
                childValues = _child8.values,
                childBounds = _child8.bounds;
          const childCount = childValues.length;

          for (let i = 0, childOffset = 0; i < childCount; ++i) {
            mergeValues.push(childValues[i]);
            mergeBounds[mergeOffset] = childBounds[childOffset];
            mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
            mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
            mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
            mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
            mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
            mergeOffset += 6;
            childOffset += 6;
          }
        }

        if (cell === mergeCell) {
          break;
        }

        cell = cell.parent;
      }

      const mergeCount = mergeValues.length;

      for (let i = baseMergeCount; i < mergeCount; ++i) {
        const location = valueLocations.get(mergeValues[i]);
        location.cell = mergeCell;
        location.index = i;
      }
    }

    let centerX = this._centerX,
        centerY = this._centerY,
        centerZ = this._centerZ,
        halfSize = this._halfSize,
        root = this._root;

    while (root.values.length === 0) {
      let newCenterX = centerX,
          newCenterY = centerY,
          newCenterZ = centerZ;
      const quarterSize = halfSize * 0.5;
      let newRoot = null;
      let child;

      if ((child = root.child000) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX - quarterSize;
        newCenterY = centerY - quarterSize;
        newCenterZ = centerZ - quarterSize;
        newRoot = child;
      }

      if ((child = root.child001) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX + quarterSize;
        newCenterY = centerY - quarterSize;
        newCenterZ = centerZ - quarterSize;
        newRoot = child;
      }

      if ((child = root.child010) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX - quarterSize;
        newCenterY = centerY + quarterSize;
        newCenterZ = centerZ - quarterSize;
        newRoot = child;
      }

      if ((child = root.child011) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX + quarterSize;
        newCenterY = centerY + quarterSize;
        newCenterZ = centerZ - quarterSize;
        newRoot = child;
      }

      if ((child = root.child100) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX - quarterSize;
        newCenterY = centerY - quarterSize;
        newCenterZ = centerZ + quarterSize;
        newRoot = child;
      }

      if ((child = root.child101) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX + quarterSize;
        newCenterY = centerY - quarterSize;
        newCenterZ = centerZ + quarterSize;
        newRoot = child;
      }

      if ((child = root.child110) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX - quarterSize;
        newCenterY = centerY + quarterSize;
        newCenterZ = centerZ + quarterSize;
        newRoot = child;
      }

      if ((child = root.child111) !== null) {
        if (newRoot !== null) {
          break;
        }

        newCenterX = centerX + quarterSize;
        newCenterY = centerY + quarterSize;
        newCenterZ = centerZ + quarterSize;
        newRoot = child;
      }

      if ((root = newRoot) === null) {
        break;
      }

      centerX = newCenterX;
      centerY = newCenterY;
      centerZ = newCenterZ;
      halfSize = quarterSize;
    }

    this._root = root;

    if (root === null) {
      return;
    }

    root.parent = null;
    this._centerX = centerX;
    this._centerY = centerY;
    this._centerZ = centerZ;
    this._halfSize = halfSize;
    this._minX = centerX - halfSize;
    this._minY = centerY - halfSize;
    this._minZ = centerZ - halfSize;
    this._maxX = centerX + halfSize;
    this._maxY = centerY + halfSize;
    this._maxZ = centerZ + halfSize;
  }
  /**
   * @function module:@wgetemp/octree.Octree#clear
   * @summary Delete all entries from octree.
   */


  clear() {
    this._root = null;

    this._valueLocations.clear();
  }
  /**
   * @function module:@wgetemp/octree.Octree#find
   * @summary Find all values bounding boxes of which intersect a given box.
   * @param {module:@wgetemp/math.Box} queryBound Query box.
   * @param {Array} [foundValues=[]] Array into which to put found values.
   * It will be truncated to required length.
   * @returns {Array} `foundValues`.
   */


  find(queryBound, foundValues = []) {
    let foundCount = 0;
    const root = this._root;

    if (root !== null) {
      const centerX = this._centerX,
            centerY = this._centerY,
            centerZ = this._centerZ,
            halfSize = this._halfSize,
            minX = this._minX,
            minY = this._minY,
            minZ = this._minZ,
            maxX = this._maxX,
            maxY = this._maxY,
            maxZ = this._maxZ;
      const _queryBound$min = queryBound.min,
            queryMinX = _queryBound$min.x,
            queryMinY = _queryBound$min.y,
            queryMinZ = _queryBound$min.z,
            _queryBound$max = queryBound.max,
            queryMaxX = _queryBound$max.x,
            queryMaxY = _queryBound$max.y,
            queryMaxZ = _queryBound$max.z;
      const coverX0 = queryMinZ <= minZ,
            coverY0 = queryMinY <= minY,
            coverZ0 = queryMinX <= minX;
      const coverX1 = queryMaxZ >= maxZ,
            coverY1 = queryMaxY >= maxY,
            coverZ1 = queryMaxX >= maxX;

      if (coverX0 && coverY0 && coverZ0 && coverX1 && coverY1 && coverZ1) {
        foundCount = root.gather(foundValues, foundCount);
      } else if (queryMinX <= maxX && queryMinY <= maxY && queryMinZ <= maxZ && queryMaxX >= minX && queryMaxY >= minY && queryMaxZ >= minZ) {
        foundCount = root.find(centerX, centerY, centerZ, halfSize * 0.5, queryMinX, queryMinY, queryMinZ, queryMaxX, queryMaxY, queryMaxZ, coverX0, coverY0, coverZ0, coverX1, coverY1, coverZ1, foundValues, foundCount);
      }
    }

    foundValues.length = foundCount;
    return foundValues;
  }
  /**
   * @function module:@wgetemp/octree.Octree#webGLFrustumFind
   * @summary Find all values bounding boxes of which intersect a given frustum.
   * @param {module:@wgetemp/math.HomogeneousMatrix3|module:@wgetemp/math.AffineMatrix3} queryViewProjection
   * Query frustum specified via a WebGL view-projection matrix. Both perspective and orthographic projections are
   * supported.
   * @param {Array} [foundValues=[]] Array into which to put found values.
   * It will be truncated to required length.
   * @returns {Array} `foundValues`.
   */


  webGLFrustumFind(queryViewProjection, foundValues = []) {
    let foundCount = 0;
    const root = this._root;

    if (root !== null) {
      const centerX = this._centerX,
            centerY = this._centerY,
            centerZ = this._centerZ,
            halfSize = this._halfSize,
            minX = this._minX,
            minY = this._minY,
            minZ = this._minZ,
            maxX = this._maxX,
            maxY = this._maxY,
            maxZ = this._maxZ;

      const _00 = queryViewProjection._00,
            _10 = queryViewProjection._10,
            _20 = queryViewProjection._20,
            _queryViewProjection$ = queryViewProjection._30,
            _30 = _queryViewProjection$ === void 0 ? 0 : _queryViewProjection$,
            _01 = queryViewProjection._01,
            _11 = queryViewProjection._11,
            _21 = queryViewProjection._21,
            _queryViewProjection$2 = queryViewProjection._31,
            _31 = _queryViewProjection$2 === void 0 ? 0 : _queryViewProjection$2,
            _02 = queryViewProjection._02,
            _12 = queryViewProjection._12,
            _22 = queryViewProjection._22,
            _queryViewProjection$3 = queryViewProjection._32,
            _32 = _queryViewProjection$3 === void 0 ? 0 : _queryViewProjection$3,
            _03 = queryViewProjection._03,
            _13 = queryViewProjection._13,
            _23 = queryViewProjection._23,
            _queryViewProjection$4 = queryViewProjection._33,
            _33 = _queryViewProjection$4 === void 0 ? 1 : _queryViewProjection$4;

      const fp = frustumProperties; // https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf

      const lX = fp.lX = _03 + _00,
            lY = fp.lY = _13 + _10,
            lZ = fp.lZ = _23 + _20,
            lW = fp.lW = _33 + _30,
            rX = fp.rX = _03 - _00,
            rY = fp.rY = _13 - _10,
            rZ = fp.rZ = _23 - _20,
            rW = fp.rW = _33 - _30,
            bX = fp.bX = _03 + _01,
            bY = fp.bY = _13 + _11,
            bZ = fp.bZ = _23 + _21,
            bW = fp.bW = _33 + _31,
            tX = fp.tX = _03 - _01,
            tY = fp.tY = _13 - _11,
            tZ = fp.tZ = _23 - _21,
            tW = fp.tW = _33 - _31,
            nX = fp.nX = _03 + _02,
            nY = fp.nY = _13 + _12,
            nZ = fp.nZ = _23 + _22,
            nW = fp.nW = _33 + _32,
            fX = fp.fX = _03 - _02,
            fY = fp.fY = _13 - _12,
            fZ = fp.fZ = _23 - _22,
            fW = fp.fW = _33 - _32; // We are doing a specialized Separating Axis Theorem test (http://www.dyn4j.org/2010/01/sat/) here.

      const lCover = 0 < lX * (lX < 0 ? maxX : minX) + lY * (lY < 0 ? maxY : minY) + lZ * (lZ < 0 ? maxZ : minZ) + lW;
      const rCover = 0 < rX * (rX < 0 ? maxX : minX) + rY * (rY < 0 ? maxY : minY) + rZ * (rZ < 0 ? maxZ : minZ) + rW;
      const bCover = 0 < bX * (bX < 0 ? maxX : minX) + bY * (bY < 0 ? maxY : minY) + bZ * (bZ < 0 ? maxZ : minZ) + bW;
      const tCover = 0 < tX * (tX < 0 ? maxX : minX) + tY * (tY < 0 ? maxY : minY) + tZ * (tZ < 0 ? maxZ : minZ) + tW;
      const nCover = 0 < nX * (nX < 0 ? maxX : minX) + nY * (nY < 0 ? maxY : minY) + nZ * (nZ < 0 ? maxZ : minZ) + nW;
      const fCover = 0 < fX * (fX < 0 ? maxX : minX) + fY * (fY < 0 ? maxY : minY) + fZ * (fZ < 0 ? maxZ : minZ) + fW;

      if (lCover && rCover && bCover && tCover && nCover && fCover) {
        foundCount = root.gather(foundValues, foundCount);
      } else do {
        if (!lCover && 0 > lX * (lX < 0 ? minX : maxX) + lY * (lY < 0 ? minY : maxY) + lZ * (lZ < 0 ? minZ : maxZ) + lW) {
          break;
        }

        if (!rCover && 0 > rX * (rX < 0 ? minX : maxX) + rY * (rY < 0 ? minY : maxY) + rZ * (rZ < 0 ? minZ : maxZ) + rW) {
          break;
        }

        if (!bCover && 0 > bX * (bX < 0 ? minX : maxX) + bY * (bY < 0 ? minY : maxY) + bZ * (bZ < 0 ? minZ : maxZ) + bW) {
          break;
        }

        if (!tCover && 0 > tX * (tX < 0 ? minX : maxX) + tY * (tY < 0 ? minY : maxY) + tZ * (tZ < 0 ? minZ : maxZ) + tW) {
          break;
        }

        if (!nCover && 0 > nX * (nX < 0 ? minX : maxX) + nY * (nY < 0 ? minY : maxY) + nZ * (nZ < 0 ? minZ : maxZ) + nW) {
          break;
        }

        if (!fCover && 0 > fX * (fX < 0 ? minX : maxX) + fY * (fY < 0 ? minY : maxY) + fZ * (fZ < 0 ? minZ : maxZ) + fW) {
          break;
        }

        const _invProjectionTmp$set = invProjectionTmp.set(_00, _01, _02, _03, _10, _11, _12, _13, _20, _21, _22, _23, _30, _31, _32, _33).invert(),
              i00 = _invProjectionTmp$set._00,
              i01 = _invProjectionTmp$set._01,
              i02 = _invProjectionTmp$set._02,
              i03 = _invProjectionTmp$set._03,
              i10 = _invProjectionTmp$set._10,
              i11 = _invProjectionTmp$set._11,
              i12 = _invProjectionTmp$set._12,
              i13 = _invProjectionTmp$set._13,
              i20 = _invProjectionTmp$set._20,
              i21 = _invProjectionTmp$set._21,
              i22 = _invProjectionTmp$set._22,
              i23 = _invProjectionTmp$set._23,
              i30 = _invProjectionTmp$set._30,
              i31 = _invProjectionTmp$set._31,
              i32 = _invProjectionTmp$set._32,
              i33 = _invProjectionTmp$set._33;

        const c0rW = 1 / (i33 - i03 - i13 - i23),
              c1rW = 1 / (i33 + i03 - i13 - i23),
              c2rW = 1 / (i33 - i03 + i13 - i23),
              c3rW = 1 / (i33 + i03 + i13 - i23),
              c4rW = 1 / (i33 - i03 - i13 + i23),
              c5rW = 1 / (i33 + i03 - i13 + i23),
              c6rW = 1 / (i33 - i03 + i13 + i23),
              c7rW = 1 / (i33 + i03 + i13 + i23);
        const c0X = (i30 - i00 - i10 - i20) * c0rW,
              c1X = (i30 + i00 - i10 - i20) * c1rW,
              c2X = (i30 - i00 + i10 - i20) * c2rW,
              c3X = (i30 + i00 + i10 - i20) * c3rW,
              c4X = (i30 - i00 - i10 + i20) * c4rW,
              c5X = (i30 + i00 - i10 + i20) * c5rW,
              c6X = (i30 - i00 + i10 + i20) * c6rW,
              c7X = (i30 + i00 + i10 + i20) * c7rW;

        if ((fp.minX = Object(lib["w" /* min */])(c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X)) > maxX) {
          break;
        }

        if ((fp.maxX = Object(lib["v" /* max */])(c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X)) < minX) {
          break;
        }

        const c0Y = (i31 - i01 - i11 - i21) * c0rW,
              c1Y = (i31 + i01 - i11 - i21) * c1rW,
              c2Y = (i31 - i01 + i11 - i21) * c2rW,
              c3Y = (i31 + i01 + i11 - i21) * c3rW,
              c4Y = (i31 - i01 - i11 + i21) * c4rW,
              c5Y = (i31 + i01 - i11 + i21) * c5rW,
              c6Y = (i31 - i01 + i11 + i21) * c6rW,
              c7Y = (i31 + i01 + i11 + i21) * c7rW;

        if ((fp.minY = Object(lib["w" /* min */])(c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y)) > maxY) {
          break;
        }

        if ((fp.maxY = Object(lib["v" /* max */])(c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y)) < minY) {
          break;
        }

        const c0Z = (i32 - i02 - i12 - i22) * c0rW,
              c1Z = (i32 + i02 - i12 - i22) * c1rW,
              c2Z = (i32 - i02 + i12 - i22) * c2rW,
              c3Z = (i32 + i02 + i12 - i22) * c3rW,
              c4Z = (i32 - i02 - i12 + i22) * c4rW,
              c5Z = (i32 + i02 - i12 + i22) * c5rW,
              c6Z = (i32 - i02 + i12 + i22) * c6rW,
              c7Z = (i32 + i02 + i12 + i22) * c7rW;

        if ((fp.minZ = Object(lib["w" /* min */])(c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) > maxZ) {
          break;
        }

        if ((fp.maxZ = Object(lib["v" /* max */])(c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) < minZ) {
          break;
        }

        crossEdgeSeparators.count = 0;

        if (generateCrossEdgeSeparators(c1X - c0X, c1Y - c0Y, c1Z - c0Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c3X - c2X, c3Y - c2Y, c3Z - c2Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c5X - c4X, c5Y - c4Y, c5Z - c4Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c7X - c6X, c7Y - c6Y, c7Z - c6Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c2X - c0X, c2Y - c0Y, c2Z - c0Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c3X - c1X, c3Y - c1Y, c3Z - c1Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c6X - c4X, c6Y - c4Y, c6Z - c4Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c7X - c5X, c7Y - c5Y, c7Z - c5Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c4X - c0X, c4Y - c0Y, c4Z - c0Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c5X - c1X, c5Y - c1Y, c5Z - c1Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c6X - c2X, c6Y - c2Y, c6Z - c2Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        if (generateCrossEdgeSeparators(c7X - c3X, c7Y - c3Y, c7Z - c3Z, minX, minY, minZ, maxX, maxY, maxZ, c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X, c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y, c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) {
          break;
        }

        foundCount = root.frustumFind(centerX, centerY, centerZ, halfSize * 0.5, minX, minY, minZ, maxX, maxY, maxZ, lCover, rCover, bCover, tCover, nCover, fCover, foundValues, foundCount);
      } while (false);
    }

    foundValues.length = foundCount;
    return foundValues;
  }
  /**
   * @function module:@wgetemp/octree.Octree#rayFind
   * @summary Find all values bounding boxes of which intersect a given ray.
   * @param {module:@wgetemp/math.Ray3} ray Query ray.
   * @param {Array} [foundValues=[]] Array into which to put found values.
   * It will be truncated to required length.
   * @returns {Array} `foundValues`.
   */


  rayFind(ray, foundValues = []) {
    let foundCount = 0;
    const root = this._root;

    if (root !== null) {
      const minX = this._minX,
            minY = this._minY,
            minZ = this._minZ,
            maxX = this._maxX,
            maxY = this._maxY,
            maxZ = this._maxZ;
      const _ray$origin = ray.origin,
            originX = _ray$origin.x,
            originY = _ray$origin.y,
            originZ = _ray$origin.z,
            direction = ray.direction;
      const recDirectionX = 1 / direction.x,
            recDirectionY = 1 / direction.y,
            recDirectionZ = 1 / direction.z;
      let tMinX = (minX - originX) * recDirectionX,
          tMinY = (minY - originY) * recDirectionY,
          tMinZ = (minZ - originZ) * recDirectionZ;

      if (!isFinite(tMinX)) {
        tMinX = -Infinity;
      }

      if (!isFinite(tMinY)) {
        tMinY = -Infinity;
      }

      if (!isFinite(tMinZ)) {
        tMinZ = -Infinity;
      }

      let tMaxX = (maxX - originX) * recDirectionX,
          tMaxY = (maxY - originY) * recDirectionY,
          tMaxZ = (maxZ - originZ) * recDirectionZ;

      if (!isFinite(tMaxX)) {
        tMaxX = +Infinity;
      }

      if (!isFinite(tMaxY)) {
        tMaxY = +Infinity;
      }

      if (!isFinite(tMaxZ)) {
        tMaxZ = +Infinity;
      }

      foundCount = root.rayFind(originX, originY, originZ, recDirectionX, recDirectionY, recDirectionZ, tMinX, tMinY, tMinZ, tMaxX, tMaxY, tMaxZ, foundValues, foundCount);
    }

    foundValues.length = foundCount;
    return foundValues;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/spatialIndex.js
class SpatialIndex {
  insert(value, boundingBox) {
    throw new Error('not implemented');
  }

  remove(value) {
    throw new Error('not implemented');
  }

  boxFind(box, foundValues) {
    throw new Error('not implemented');
  }

  webGLFrustumFind(viewProjectionMatrix, foundValues) {
    throw new Error('not implemented');
  }

  rayFind(ray, foundValues) {
    throw new Error('not implemented');
  }

  _clear() {
    throw new Error('not implemented');
  }

  _copyInto(other) {
    throw new Error('not implemented');
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/octreeSpatialIndex.js
function octreeSpatialIndex_slicedToArray(arr, i) { return octreeSpatialIndex_arrayWithHoles(arr) || octreeSpatialIndex_iterableToArrayLimit(arr, i) || octreeSpatialIndex_unsupportedIterableToArray(arr, i) || octreeSpatialIndex_nonIterableRest(); }

function octreeSpatialIndex_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function octreeSpatialIndex_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return octreeSpatialIndex_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return octreeSpatialIndex_arrayLikeToArray(o, minLen); }

function octreeSpatialIndex_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function octreeSpatialIndex_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function octreeSpatialIndex_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



class octreeSpatialIndex_OctreeSpatialIndex extends SpatialIndex {
  constructor() {
    super();
    this._octree = new octree_Octree();
  }

  insert(value, boundingBox) {
    this._octree.insert(value, boundingBox);
  }

  remove(value) {
    this._octree.remove(value);
  }

  boxFind(box, foundValues) {
    return this._octree.find(box, foundValues);
  }

  webGLFrustumFind(viewProjectionMatrix, foundValues) {
    return this._octree.webGLFrustumFind(viewProjectionMatrix, foundValues);
  }

  rayFind(ray, foundValues) {
    return this._octree.rayFind(ray, foundValues);
  }

  _clear() {
    this._octree.clear();
  }

  _copyInto(other) {
    for (const _ref of this._octree) {
      var _ref2 = octreeSpatialIndex_slicedToArray(_ref, 2);

      const value = _ref2[0];
      const boundingBox = _ref2[1];
      other.insert(value, boundingBox);
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/ECS/entityManager.js
function entityManager_slicedToArray(arr, i) { return entityManager_arrayWithHoles(arr) || entityManager_iterableToArrayLimit(arr, i) || entityManager_unsupportedIterableToArray(arr, i) || entityManager_nonIterableRest(); }

function entityManager_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function entityManager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return entityManager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return entityManager_arrayLikeToArray(o, minLen); }

function entityManager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function entityManager_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function entityManager_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


const maxUint32 = Math.pow(2, 32) - 1;

function _getComponentsMask(componentClasses, countComponents) {
  const mask = new Uint32Array(countComponents);

  for (const compClass of componentClasses) {
    mask[compClass.maskIndex] |= compClass.mask;
  }

  return mask;
}

function _isNotEmptyMask(masks, count, i) {
  for (let n = 0; n < count; n++) {
    if (masks[count * i + n] !== 0) {
      return true;
    }
  }

  return false;
}

function _matchMaskStrict(masks, filter, i) {
  for (let n = 0, count = filter.length; n < count; n++) {
    if ((masks[i * count + n] & filter[n]) !== filter[n]) {
      return false;
    }
  }

  return true;
}

function _matchMask(masks, filter, i) {
  for (let n = 0, count = filter.length; n < count; n++) {
    if ((masks[i * count + n] & filter[n]) !== 0) {
      return true;
    }
  }

  return false;
}

class EntitiesIterator {
  constructor(masks, countEntities, validEntityCount, maskElementCount, filter = null, strict = false) {
    this._masks = masks;
    this._filter = filter;
    this._strict = strict;
    this._countEntities = countEntities;
    this._validEntityCount = validEntityCount;
    this._maskElementCount = maskElementCount;
    this._result = {
      done: false,
      value: null
    };
    this._current = 0;
    this._entityCounter = 0;
  }

  [Symbol.iterator]() {
    return this;
  }

  next() {
    const _masks = this._masks,
          _filter = this._filter,
          _strict = this._strict,
          _countEntities = this._countEntities,
          _validEntityCount = this._validEntityCount,
          _maskElementCount = this._maskElementCount,
          _result = this._result,
          _entityCounter = this._entityCounter;
    _result.done = true;

    if (_entityCounter >= _validEntityCount) {
      return _result;
    }

    for (let i = this._current; i < _countEntities; i++) {
      this._current = i + 1;
      const isOk = _filter === null ? _isNotEmptyMask(_masks, _maskElementCount, i) : _strict ? _matchMaskStrict(_masks, _filter, i) : _matchMask(_masks, _filter, i);

      if (isOk) {
        _result.done = false;
        _result.value = i;
        this._entityCounter++;
        break;
      }
    }

    return _result;
  }

}

let _lastComponentIndex = 0;

class ComponentRegistry {
  constructor(componentClasses) {
    this._componentRegistry = new Set();

    this._registryComponents(componentClasses);
  }

  get registry() {
    return this._componentRegistry;
  }

  get actualComponentCount() {
    const _componentRegistry = this._componentRegistry;
    let count = 0;

    for (const cmp of _componentRegistry.values()) {
      if (cmp.index !== null) {
        count++;
      }
    }

    return count;
  }

  _registryComponents(componentClasses) {
    const _componentRegistry = this._componentRegistry;
    componentClasses.sort((a, b) => {
      const _a$index = a.index,
            idx1 = _a$index === void 0 ? Infinity : _a$index;
      const _b$index = b.index,
            idx2 = _b$index === void 0 ? Infinity : _b$index;
      return idx1 - idx2;
    });
    const maskSize = Uint32Array.BYTES_PER_ELEMENT * 8;

    for (const _ref of componentClasses.entries()) {
      var _ref2 = entityManager_slicedToArray(_ref, 2);

      const componentClass = _ref2[1];
      let index = null;

      if (componentClass.index === undefined) {
        index = _lastComponentIndex++;
        const maskIndex = Math.floor(index / maskSize);
        const bitIndex = index % maskSize;
        Object.defineProperty(componentClass, 'index', {
          value: index,
          writable: false
        });
        Object.defineProperty(componentClass, 'maskIndex', {
          value: maskIndex,
          writable: false
        });
        Object.defineProperty(componentClass, 'mask', {
          value: 1 << bitIndex,
          writable: false
        });
      } else {
        index = componentClasses.index;
      }

      _componentRegistry.add(componentClass);
    }
  }

}

function _registryComponents(componentClasses) {
  return new ComponentRegistry(componentClasses);
}

class EntityManager {
  constructor(scene, config) {
    this._scene = scene;
    this._entitiesCapacity = 0;
    this._entityCount = 0;
    this._validEntityCount = 0;
    this._masks = null;
    this._maskElementCount = 0;
    this._indices = null;
    this._freeEntities = [];
    this._storage = [];
    const componentClasses = config.componentClasses,
          _config$entityAllocat = config.entityAllocationStrategy,
          entityAllocationStrategy = _config$entityAllocat === void 0 ? size => {
      return Math.floor(size * 1.618) + 1;
    } : _config$entityAllocat,
          _config$initialCountE = config.initialCountEntities,
          initialCountEntities = _config$initialCountE === void 0 ? 512 : _config$initialCountE;

    const componentRegistry = _registryComponents(componentClasses);

    this._componentRegistry = componentRegistry.registry;
    this._actualComponentCount = componentRegistry.actualComponentCount;
    this._config = {
      entityAllocationStrategy
    };

    this._reAlloc(initialCountEntities);

    for (const componentClass of this._componentRegistry.values()) {
      const index = componentClass.index,
            storageClass = componentClass.storageClass;
      this._storage[index] = index === null ? null : new storageClass(this, componentClass);
    }
  }

  _reAlloc(countEntities) {
    const _entitiesCapacity = this._entitiesCapacity,
          _indices = this._indices,
          _masks = this._masks,
          _componentRegistry = this._componentRegistry;
    const componentCount = _componentRegistry.size;

    if (_entitiesCapacity >= countEntities) {
      return;
    }

    const indices = new Uint32Array(countEntities * componentCount);
    indices.fill(maxUint32);
    this._indices = _indices !== null ? (indices.set(_indices), indices) : indices;
    this._entitiesCapacity = countEntities;
    this._maskElementCount = Math.ceil(componentCount / 32);
    const masks = new Uint32Array(countEntities * this._maskElementCount);
    masks.fill(0);
    this._masks = _masks !== null ? (masks.set(_masks), masks) : masks;
  }

  createEntity() {
    const _freeEntities = this._freeEntities,
          _entitiesCapacity = this._entitiesCapacity,
          _config = this._config;
    const entityAllocationStrategy = _config.entityAllocationStrategy;
    this._validEntityCount++;
    const entity = _freeEntities.length > 0 ? _freeEntities.pop() : this._entityCount++;

    if (this._entityCount >= _entitiesCapacity) {
      this._reAlloc(entityAllocationStrategy(_entitiesCapacity));
    }

    return entity;
  }

  isValidEntity(entity) {
    const _freeEntities = this._freeEntities,
          _entityCount = this._entityCount;
    return entity < _entityCount && !_freeEntities.includes(entity);
  }

  destroyEntity(entity) {
    const _masks = this._masks,
          _freeEntities = this._freeEntities,
          _maskElementCount = this._maskElementCount,
          _componentRegistry = this._componentRegistry,
          _storage = this._storage,
          _indices = this._indices;
    const componentCount = _componentRegistry.size;

    for (let i = 0; i < componentCount; i++) {
      if (_storage[i] === null) {
        continue;
      }

      const offset = entity * componentCount + i;
      const idx = _indices[offset];

      if (idx === maxUint32) {
        continue;
      }

      _indices[offset] = maxUint32;

      const cmp = _storage[i].get(idx);

      _storage[i].delete(idx);

      EntityManager.onDetach.emit(this, entity, cmp);
      cmp.release();
    }

    _masks.fill(0, entity * _maskElementCount, entity * _maskElementCount + _maskElementCount);

    _freeEntities.push(entity);

    this._validEntityCount--;
  }

  _entities(filter, strict = false) {
    const _masks = this._masks,
          _entityCount = this._entityCount,
          _validEntityCount = this._validEntityCount,
          _maskElementCount = this._maskElementCount;
    return new EntitiesIterator(_masks, _entityCount, _validEntityCount, _maskElementCount, filter, strict);
  }

  allEntities() {
    return this._entities(null);
  }

  entitiesWithComponents(componentClasses) {
    const _maskElementCount = this._maskElementCount;

    const filter = _getComponentsMask(componentClasses, _maskElementCount);

    return this._entities(filter, true);
  }

  entitiesWithAtLeastAComponent(componentClasses) {
    const _maskElementCount = this._maskElementCount;

    const filter = _getComponentsMask(componentClasses, _maskElementCount);

    return this._entities(filter, false);
  }

  getAllEntityComponents(entity, result = []) {
    const _indices = this._indices,
          _componentRegistry = this._componentRegistry,
          _storage = this._storage;
    const componentCount = _componentRegistry.size;
    result.length = 0;

    for (let i = 0; i < componentCount; i++) {
      if (_storage[i] === null) {
        continue;
      }

      const idx = _indices[entity * componentCount + i];

      if (idx === maxUint32) {
        continue;
      }

      result.push(_storage[i].get(idx));
    }

    return result;
  }

  getEntityComponents(entity, componentClasses, result = []) {
    const _indices = this._indices,
          _componentRegistry = this._componentRegistry,
          _storage = this._storage;
    const componentCount = _componentRegistry.size;
    result.length = 0;

    for (const componentClass of componentClasses) {
      const index = componentClass.index;
      const idx = _indices[entity * componentCount + index];
      const component = idx !== maxUint32 ? _storage[index].get(idx) : null;
      result.push(component);
    }

    return result;
  }

  attach(entity, component) {
    const _masks = this._masks,
          _indices = this._indices,
          _componentRegistry = this._componentRegistry,
          _storage = this._storage,
          _maskElementCount = this._maskElementCount;
    const componentCount = _componentRegistry.size;
    const mask = component.mask,
          index = component.index,
          maskIndex = component.maskIndex;
    const offset = entity * componentCount + index;
    _masks[_maskElementCount * entity + maskIndex] |= mask;
    _indices[offset] = _storage[index].add(entity, component);
    component.retain();
    EntityManager.onAttach.emit(this, entity, component);
  }

  detach(entity, component) {
    const _masks = this._masks,
          _indices = this._indices,
          _componentRegistry = this._componentRegistry,
          _storage = this._storage,
          _maskElementCount = this._maskElementCount;
    const componentCount = _componentRegistry.size;
    const mask = component.mask,
          index = component.index,
          maskIndex = component.maskIndex;
    const offset = entity * componentCount + index;
    _masks[_maskElementCount * entity + maskIndex] &= ~mask;
    const i = _indices[offset];
    _indices[offset] = maxUint32;

    const cmp = _storage[index].get(i);

    _storage[index].delete(i);

    EntityManager.onDetach.emit(this, entity, cmp);
    cmp.release();
  }

  getComponentStorage(instanceOrClass) {
    const _storage = this._storage;
    const index = instanceOrClass.index;
    return _storage[index];
  }

  getEntity(component) {
    const index = component.index;
    return this._storage[index].getEntity(component);
  }

  get validEntityCount() {
    return this._validEntityCount;
  }

  get componentCount() {
    return this._actualComponentCount;
  }

  get entitiesCapacity() {
    return this._entitiesCapacity;
  }

  isComponent(componentClass) {
    const index = componentClass.index >= 0 ? componentClass.index : Infinity;
    const storage = this._storage[index];
    return storage !== null && storage !== undefined;
  }

  dispose() {
    this._scene = null;
    this._componentRegistry = null;
    this._entitiesCapacity = 0;
    this._entityCount = 0;
    this._validEntityCount = 0;
    this._maskElementCount = 0;
    this._masks = null;
    this._indices = null;
    this._freeEntities.length = 0;
    const _storage = this._storage;

    for (const s of _storage) {
      if (s === null) {
        continue;
      }

      s.dispose();
    }

    _storage.length = 0;
  }

}
EntityManager.onAttach = new _wgetemp_event["a" /* Event */]();
EntityManager.onDetach = new _wgetemp_event["a" /* Event */]();
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/sceneNode.js
function sceneNode_slicedToArray(arr, i) { return sceneNode_arrayWithHoles(arr) || sceneNode_iterableToArrayLimit(arr, i) || sceneNode_unsupportedIterableToArray(arr, i) || sceneNode_nonIterableRest(); }

function sceneNode_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sceneNode_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sceneNode_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sceneNode_arrayLikeToArray(o, minLen); }

function sceneNode_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function sceneNode_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function sceneNode_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function _testMergeCompatibility(src, dst) {
  const srcRegistry = src.entityManager._componentRegistry;
  const dstRegistry = dst.entityManager._componentRegistry;

  for (const componentClass of srcRegistry.values()) {
    const index = componentClass.index;

    if (index === null) {
      continue;
    }

    if (!dstRegistry.has(componentClass)) {
      return false;
    }
  }

  return true;
}

const sceneNode_type = [transform_component_Transform];
const sceneNode_cmp = [null];
class sceneNode_SceneNode {
  constructor(scene, entity, name = '') {
    this.name = name;
    this._entity = entity;
    this._children = [];
    this._parent = null;
    this._scene = scene;
    this.extras = undefined;
  }

  get scene() {
    return this._scene;
  }

  traverse(callback) {
    if (!callback(this)) {
      return false;
    }

    const _children = this._children;

    for (const child of _children) {
      if (!child.traverse(callback)) {
        return false;
      }
    }

    return true;
  }

  get parent() {
    return this._parent;
  }

  set parent(parent) {
    if (parent !== null) {
      parent.adopt(this);
    }

    this._parent = parent;
  }

  get isRoot() {
    return this._parent === null;
  }

  createChild({
    name = ''
  }) {
    const _scene = this._scene,
          _children = this._children;
    const entityManager = _scene.entityManager;
    const entity = entityManager.createEntity();
    const child = new sceneNode_SceneNode(_scene, entity, name);

    _scene._entityToNode.set(entity, child);

    child._parent = this;

    _children.push(child);

    return child;
  }

  _destroy() {
    for (const child of this._children) {
      child._destroy();
    }

    this._scene._entityToNode.delete(this._entity);

    this._scene.entityManager.destroyEntity(this._entity);

    this._entity = 2 ** 32 - 1;
    this._scene = null;
  }

  destroy() {
    if (this._parent) {
      const siblings = this._parent.children;
      siblings.splice(siblings.indexOf(this), 1);
      this._parent = null;
    }

    const _this$getComponents = this.getComponents([transform_component_Transform]),
          _this$getComponents2 = sceneNode_slicedToArray(_this$getComponents, 1),
          transform = _this$getComponents2[0];

    if (transform !== null) {
      this.detach(transform);
    }

    this._destroy();
  }

  _updateTransformHierarchy() {
    const _this$getComponents3 = this.getComponents([transform_component_Transform]),
          _this$getComponents4 = sceneNode_slicedToArray(_this$getComponents3, 1),
          transform = _this$getComponents4[0];

    if (transform === null) {
      return;
    }

    transform.state |= transform_component_Transform.StateMask.UPDATE_WORLD;

    for (const child of this.children) {
      child._updateTransformHierarchy();
    }
  }

  _getCountNodeInBranch() {
    let count_ = 0;
    const _children = this._children;
    count_ += _children.length;

    for (const child of _children) {
      count_ += child._getCountNodeInBranch();
    }

    return count_;
  }

  splitCopy(parameters = {}) {
    const name = parameters.name,
          _parameters$cloneMate = parameters.cloneMaterials,
          cloneMaterials = _parameters$cloneMate === void 0 ? true : _parameters$cloneMate;

    const countNodes = this._getCountNodeInBranch();

    const name_ = name || `${this.name}-scene`;
    const srcScene = this._scene;
    const dstScene = new scene_Scene({
      maxSceneNodes: countNodes,
      name: name_,
      config: srcScene.config
    });
    const copyContext = {
      nodeToNode: new Map(),
      skeletonToSkeleton: new Map(),
      animationToAnimation: new Map(),
      cloneMaterials
    };

    dstScene.root._adoptForeignNode(this, copyContext);

    return new Promise(resolve => {
      const task = new scene_Scene._SceneManagementDeferredTask(scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY, resolve);
      task.data.srcScene = srcScene;
      task.data.dstScene = dstScene;
      task.data.copyContext = copyContext;
      task.output.scene = dstScene;

      this._scene._deferredTasks.push(task);
    });
  }

  mergeCopy(scene) {
    if (false) {}

    return new Promise(resolve => {
      const copyContext = {
        nodeToNode: new Map(),
        skeletonToSkeleton: new Map(),
        animationToAnimation: new Map()
      };
      const task = new scene_Scene._SceneManagementDeferredTask(scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY, resolve);
      task.data.srcScene = scene;
      task.data.dstScene = this._scene;
      task.data.dstNode = this;
      task.data.copyContext = copyContext;

      this._scene._deferredTasks.push(task);
    });
  }

  _adoptForeignNode(node, copyContext) {
    const name = node.name,
          children = node.children;
    const nodeToNode = copyContext.nodeToNode;
    const node_ = this.createChild({
      name
    });
    nodeToNode.set(node, node_);

    for (const child of children) {
      node_._adoptForeignNode(child, copyContext);
    }
  }

  adopt(child) {
    for (let ancestor = this; ancestor !== null; ancestor = ancestor._parent) {
      if (ancestor === child) {
        throw new Error('can\'t adopt ancestors');
      }
    }

    if (child._parent) {
      if (child._parent === this) {
        return;
      }

      const siblings = child._parent._children;
      siblings.splice(siblings.indexOf(child), 1);
      child._parent = null;
    }

    let _this$getComponents5 = this.getComponents([transform_component_Transform]),
        _this$getComponents6 = sceneNode_slicedToArray(_this$getComponents5, 1),
        parentTransform = _this$getComponents6[0];

    const _child$getAllComponen = child.getAllComponents(),
          _child$getAllComponen2 = sceneNode_slicedToArray(_child$getAllComponen, 1),
          childTransform = _child$getAllComponen2[0];

    if (childTransform !== null && parentTransform === null) {
      parentTransform = new transform_component_Transform();
      parentTransform.state = transform_component_Transform.StateMask.UPDATE_ALL;
      this.attach(parentTransform);
    }

    if (parentTransform !== null && childTransform !== null) {
      child._updateTransformHierarchy();
    }

    child._parent = this;

    this._children.push(child);
  }

  get children() {
    return this._children;
  }

  getComponents(componentClasses, result = []) {
    const _scene = this._scene,
          _entity = this._entity;
    const entityManager = _scene.entityManager;
    return entityManager.getEntityComponents(_entity, componentClasses, result);
  }

  getAllComponents(result = []) {
    const _scene = this._scene,
          _entity = this._entity;
    const entityManager = _scene.entityManager;
    return entityManager.getAllEntityComponents(_entity, result);
  }

  get entity() {
    return this._entity;
  }

  attach(component) {
    const _scene = this._scene,
          _entity = this._entity;

    _scene.entityManager.attach(_entity, component);

    if (component.isTransform && this._parent != null) {
      let _this$_parent$getComp = this._parent.getComponents(sceneNode_type, sceneNode_cmp),
          _this$_parent$getComp2 = sceneNode_slicedToArray(_this$_parent$getComp, 1),
          transform = _this$_parent$getComp2[0];

      if (transform === null) {
        transform = new transform_component_Transform();
        transform.state = transform_component_Transform.StateMask.UPDATE_ALL;

        this._parent.attach(transform);
      }
    }

    return this;
  }

  detach(instanceOrClass) {
    const _scene = this._scene,
          _entity = this._entity,
          _children = this._children;
    const entityManager = _scene.entityManager;

    const _ref = typeof instanceOrClass === 'function' ? entityManager.getEntityComponents(_entity, [instanceOrClass]) : (sceneNode_cmp[0] = instanceOrClass, sceneNode_cmp),
          _ref2 = sceneNode_slicedToArray(_ref, 1),
          component = _ref2[0];

    entityManager.detach(_entity, component);

    if (component.isTransform) {
      for (const child of _children) {
        const _child$getComponents = child.getComponents(sceneNode_type, sceneNode_cmp),
              _child$getComponents2 = sceneNode_slicedToArray(_child$getComponents, 1),
              transform = _child$getComponents2[0];

        if (transform !== null) {
          child.detach(transform);
        }
      }
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/scene.js
function scene_slicedToArray(arr, i) { return scene_arrayWithHoles(arr) || scene_iterableToArrayLimit(arr, i) || scene_unsupportedIterableToArray(arr, i) || scene_nonIterableRest(); }

function scene_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scene_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scene_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scene_arrayLikeToArray(o, minLen); }

function scene_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function scene_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function scene_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }















class scene_Scene extends baseScene_BaseScene {
  constructor({
    maxSceneNodes,
    batchMap = null,
    name = '',
    config
  }) {
    const componentClasses = config.componentClasses;
    super({
      maxSceneNodes,
      batchMap,
      name,
      config
    });
    this.name = name;
    const entityManager = new EntityManager(this, {
      initialCountEntities: maxSceneNodes,
      componentClasses
    });
    this._entityManager = entityManager;
    this._animations = new Map();
    this._skeletons = new Map();
    const entity = entityManager.createEntity();
    this.root = new sceneNode_SceneNode(this, entity, name);
    this._entityToNode = new Map([[entity, this.root]]);
    this._instanceKeys = new Map();
    this.shadowBiasMin = 0.0001;
    this.shadowBiasMax = 0.001;
    this.extras = undefined;
    this._deferredTasks = [];
    this._perLookData = new Map();
    this._directShadowCastersCountChanged = true;
    this._enabledDirectShadowCastersCount = 0;
    this._directShadowCastersMask = [];
    this._shadowTextureArray = null;
    this._shadowMapSize = 0;
    this._cascadesCount = 0;
    this._spotShadowCasters = [];
    this._spotShadowCastersMask = [];
    this._enabledSpotShadowCastersCount = 0;
    this._spotCastersDepthTextureArray = null;
    this._omniShadowCasters = [];
    this._omniShadowCastersMask = [];
    this._enabledOmniShadowCastersCount = 0;
    this._spatialIndex = new octreeSpatialIndex_OctreeSpatialIndex();
  }

  static get _SceneManagementDeferredTask() {
    return SystemTask;
  }

  get spatialIndex() {
    return this._spatialIndex;
  }

  set spatialIndex(newSpatialIndex) {
    if (newSpatialIndex === this._spatialIndex) {
      return;
    }

    newSpatialIndex._clear();

    this._spatialIndex._copyInto(newSpatialIndex);

    this._spatialIndex = newSpatialIndex;
  }

  getDirectShadowCastersCount(look) {
    const _perLookData = this._perLookData;

    if (_perLookData.has(look)) {
      const _perLookData$get = _perLookData.get(look),
            directShadowCasters = _perLookData$get.directShadowCasters;

      return directShadowCasters.length;
    }

    return 0;
  }

  getDirectShadowCastersData(look) {
    const _perLookData = this._perLookData;

    if (_perLookData.has(look)) {
      return _perLookData.get(look);
    }

    return {};
  }

  get directShadowCastersMask() {
    return this._directShadowCastersMask;
  }

  get spotShadowCastersCount() {
    return this._spotShadowCasters.length;
  }

  getSpotShadowCasters() {
    return this._spotShadowCasters;
  }

  get spotShadowCasters() {
    console.warn('Scene#spotShadowCasters property is deprecated, use method getSpotShadowCasters instead.');
    return this.getSpotShadowCasters();
  }

  get spotShadowCastersMask() {
    return this._spotShadowCastersMask;
  }

  get omniShadowCastersCount() {
    return this._omniShadowCasters.length;
  }

  getOmniShadowCasters() {
    return this._omniShadowCasters;
  }

  get omniShadowCasters() {
    console.warn('Scene#omniShadowCasters property is deprecated, use method getOmniShadowCasters instead.');
    return this.getOmniShadowCasters();
  }

  get omniShadowCastersMask() {
    return this._omniShadowCastersMask;
  }

  get shadowTextureArray() {
    return this._shadowTextureArray;
  }

  get spotCastersDepthTextureArray() {
    return this._spotCastersDepthTextureArray;
  }

  get forceUpdateRenderQueue() {
    return this._forceUpdateRenderQueue;
  }

  set forceUpdateRenderQueue(value) {
    this._forceUpdateRenderQueue = value;
  }

  addSkeleton(skeleton) {
    const _skeletons = this._skeletons;
    let lastIndex = -1;

    for (const _ref of _skeletons.entries()) {
      var _ref2 = scene_slicedToArray(_ref, 2);

      const i = _ref2[0];
      const s = _ref2[1];
      lastIndex = Math.max(i, lastIndex);

      if (s === skeleton) {
        return i;
      }
    }

    _skeletons.set(++lastIndex, skeleton);

    skeleton.onDispose.subscribe(() => {
      this._skeletons.delete(lastIndex);
    });
    return lastIndex;
  }

  addAnimation(animation) {
    const _animations = this._animations;
    let lastIndex = -1;

    for (const _ref3 of _animations.entries()) {
      var _ref4 = scene_slicedToArray(_ref3, 2);

      const i = _ref4[0];
      const a = _ref4[1];
      lastIndex = Math.max(i, lastIndex);

      if (a === animation) {
        return i;
      }
    }

    _animations.set(++lastIndex, animation);

    animation.onDispose.subscribe(() => {
      this._animations.delete(lastIndex);
    });
    return lastIndex;
  }

  getAnimationIndex(animation) {
    let index = -1;

    for (const _ref5 of this._animations.entries()) {
      var _ref6 = scene_slicedToArray(_ref5, 2);

      const i = _ref6[0];
      const a = _ref6[1];

      if (a === animation) {
        index = i;
        break;
      }
    }

    return index;
  }

  getSkeletonIndex(skeleton) {
    let index = -1;

    for (const _ref7 of this._skeletons.entries()) {
      var _ref8 = scene_slicedToArray(_ref7, 2);

      const i = _ref8[0];
      const s = _ref8[1];

      if (s === skeleton) {
        index = i;
        break;
      }
    }

    return index;
  }

  animations() {
    return this._animations.values();
  }

  skeletons() {
    return this._skeletons.values();
  }

  animationEntries() {
    return this._animations.entries();
  }

  skeletonEntries() {
    return this._skeletons.entries();
  }

  getAnimation(animationIndex) {
    const animation = this._animations.get(animationIndex);

    if (animation === undefined) {
      throw new Error('Animation not exist');
    }

    return animation;
  }

  getAnimationByName(name) {
    for (const animation of this._animations.values()) {
      if (name === animation.name) {
        return animation;
      }
    }

    return null;
  }

  getSkeleton(skeletonIndex) {
    const skeleton = this._skeletons.get(skeletonIndex);

    if (skeleton === undefined) {
      throw new Error('Skeleton not exist');
    }

    return skeleton;
  }

  getSkeletonByName(name) {
    for (const skeleton of this._skeletons.values()) {
      if (name === skeleton.name) {
        return skeleton;
      }
    }

    return null;
  }

  _updateDepthTextureArray(cascadesCount, shadowMapSize) {
    const _enabledDirectShadowCastersCount = this._enabledDirectShadowCastersCount;

    if (_enabledDirectShadowCastersCount === 0) {
      return;
    }

    if (this._shadowTextureArray !== null) {
      this._shadowTextureArray.release();

      this._shadowTextureArray = null;
    }

    this._shadowTextureArray = new texture_resource_Texture({
      name: 'shadow-map-array',
      width: shadowMapSize,
      height: shadowMapSize,
      depth: _enabledDirectShadowCastersCount * cascadesCount,
      bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY,
      magFilter: texture_resource_Texture.Filter.LINEAR,
      minFilter: texture_resource_Texture.Filter.LINEAR,
      wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      compareFunc: texture_resource_Texture.CompareFunc.LESS,
      compareMode: texture_resource_Texture.CompareMode.COMPARE_REF_TO_TEXTURE,
      format: PixelDataFormat.DEPTH_COMPONENT,
      internalFormat: InternalFormat.DEPTH_COMPONENT32F,
      componentType: dataTypes_DataType.FLOAT,
      levels: 1
    });
  }

  _updateSpotCastersDepthTextureArray(shadowMapSize) {
    const _enabledSpotShadowCastersCount = this._enabledSpotShadowCastersCount;

    if (_enabledSpotShadowCastersCount === 0) {
      return;
    }

    if (this._spotCastersDepthTextureArray !== null) {
      this._spotCastersDepthTextureArray.release();

      this._spotCastersDepthTextureArray = null;
    }

    this._spotCastersDepthTextureArray = new texture_resource_Texture({
      name: 'spot-shadow-map-array',
      width: shadowMapSize,
      height: shadowMapSize,
      depth: _enabledSpotShadowCastersCount,
      bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY,
      magFilter: texture_resource_Texture.Filter.LINEAR,
      minFilter: texture_resource_Texture.Filter.LINEAR,
      wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      compareFunc: texture_resource_Texture.CompareFunc.LESS,
      compareMode: texture_resource_Texture.CompareMode.COMPARE_REF_TO_TEXTURE,
      format: PixelDataFormat.DEPTH_COMPONENT,
      internalFormat: InternalFormat.DEPTH_COMPONENT32F,
      componentType: dataTypes_DataType.FLOAT,
      levels: 1
    });
  }

  _disposePerCameraData() {
    const _perLookData = this._perLookData;

    for (const _ref9 of _perLookData) {
      var _ref10 = scene_slicedToArray(_ref9, 2);

      const perCameraData = _ref10[1];

      for (const _ref11 of perCameraData.directShadowCasters) {
        const _cascades = _ref11._cascades;

        for (const cascade of _cascades) {
          if (cascade.renderTarget) {
            cascade.renderTarget.release();
            cascade.renderTarget = null;
          }

          if (cascade.texture) {
            cascade.texture.release();
            cascade.texture = null;
          }

          if (cascade.depthTexture) {
            cascade.depthTexture.release();
            cascade.depthTexture = null;
          }
        }
      }
    }
  }

  _disposeShadowTextureArray() {
    if (this._shadowTextureArray !== null) {
      this._shadowTextureArray.release();

      this._shadowTextureArray = null;
    }
  }

  _disposeSpotCastersDepthTextureArray() {
    if (this._spotCastersDepthTextureArray !== null) {
      this._spotCastersDepthTextureArray.release();

      this._spotCastersDepthTextureArray = null;
    }
  }

  traverse(callback) {
    this.root.traverse(callback);
  }

  get animationCount() {
    return this._animations.size;
  }

  get skeletonCount() {
    return this._skeletons.size;
  }

  get entityManager() {
    return this._entityManager;
  }

  dotSceneCast() {
    const srcInstanceDataManager = this.instanceDataManager,
          name = this.name,
          srcConfig = this.config;
    const maxSceneNodes = srcInstanceDataManager.capacity,
          batches = srcInstanceDataManager._instancedBatches;
    const config = {
      customAttributes: srcConfig.customAttributes
    };
    const dotScene = new dotScene_DotScene({
      maxSceneNodes,
      batchMap: srcInstanceDataManager.generateBatchMap(),
      name,
      config: {
        componentClasses: []
      }
    });
    const components = [null, null, null];
    const classes = [mesh_component_Mesh, transform_component_Transform, light_Light];
    const matrix = new lib["b" /* AffineMatrix3 */]();
    this.traverse(node => {
      const _node$getComponents = node.getComponents(classes, components),
            _node$getComponents2 = scene_slicedToArray(_node$getComponents, 3),
            mesh = _node$getComponents2[0],
            transform = _node$getComponents2[1],
            light = _node$getComponents2[2];

      if (mesh !== null) {
        for (let i = 0, count = mesh.subMeshCount; i < count; i++) {
          const subMesh = mesh.getSubMesh(0);

          if (transform !== null) {
            if (false) {}

            dotScene.addInstance(subMesh, transform.worldMatrix);
          } else {
            const instanceId = subMesh.instanceId,
                  instanceIndex = subMesh.instanceIndex;

            const _this$instanceDataMan = this.instanceDataManager.getInstanceRenderable(instanceId),
                  batchIdx = _this$instanceDataMan.batchIdx;

            const globalIndex = this.instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
            srcInstanceDataManager.readWorldTransform(matrix, globalIndex);
            dotScene.addInstance(subMesh, matrix);
          }
        }
      }

      if (light !== null) {
        if (false) {}

        dotScene.addLight(light, transform.worldMatrix);
      }

      return false;
    });
    return dotScene;
  }

  unload() {
    this.traverse(node => {
      const components = node.getComponents([mesh_component_Mesh, bone_Bone]);

      for (const component of components) {
        if (component === null) {
          continue;
        }

        component.unload();
      }

      return true;
    });

    if (this._shadowTextureArray !== null) {
      this._shadowTextureArray.unload();
    }

    if (this._spotCastersDepthTextureArray !== null) {
      this._spotCastersDepthTextureArray.unload();
    }

    super.unload();
  }

  _dispose() {
    this.spatialIndex._clear();

    this.root.destroy();
    this.entityManager.dispose();

    this._disposeShadowTextureArray();

    this._disposeSpotCastersDepthTextureArray();

    this._disposePerCameraData();

    super._dispose();
  }

}
Object.defineProperty(scene_Scene.prototype, 'isScene', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/dotScene.js
function dotScene_slicedToArray(arr, i) { return dotScene_arrayWithHoles(arr) || dotScene_iterableToArrayLimit(arr, i) || dotScene_unsupportedIterableToArray(arr, i) || dotScene_nonIterableRest(); }

function dotScene_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dotScene_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dotScene_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dotScene_arrayLikeToArray(o, minLen); }

function dotScene_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function dotScene_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function dotScene_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








class dotScene_DotScene extends baseScene_BaseScene {
  constructor({
    maxSceneNodes,
    batchMap = null,
    name = '',
    config
  }) {
    super({
      maxSceneNodes,
      batchMap,
      name,
      config
    });
    this._lights = new Map();
    this._maxIlluminance = 1;
    this._maxEnvIlluminance = 1;
  }

  addInstance(instance, worldMatrix = new lib["b" /* AffineMatrix3 */]().fromNumber(1.0)) {
    if (instance.instanceId !== null && !instance.instanceIdentifierExpired) {
      return;
    }

    const instanceDataManager = this.instanceDataManager;

    if (false) {}

    if (false) {}

    if (false) {}

    if (instance.geometry.needsUpdateBoundingBox) {
      instance.geometry.updateBoundingBox();
    }

    instanceDataManager.addInstance(instance);
    instanceDataManager.setInstanceVisibility(instance, true, true);
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex,
          id = instance.id;

    const _instanceDataManager$ = instanceDataManager.getInstanceRenderable(instanceId),
          batchIdx = _instanceDataManager$.batchIdx;

    const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
    instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
    instanceDataManager.storeRenderableIdentifier(globalIndex, id);
    this.forceUpdateRenderQueue = true;
  }

  deleteInstance(instance) {
    if (instance.instanceId === null) {
      return;
    }

    const instanceDataManager = this.instanceDataManager;
    instanceDataManager.deleteInstance(instance);
    this.forceUpdateRenderQueue = true;
  }

  setWorldMatrix(instance, worldMatrix) {
    if (false) {}

    const instanceDataManager = this.instanceDataManager;
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex;

    const _instanceDataManager$2 = instanceDataManager.getInstanceRenderable(instanceId),
          batchIdx = _instanceDataManager$2.batchIdx;

    const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
    instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
  }

  getWorldMatrix(instance, worldMatrix = new lib["b" /* AffineMatrix3 */]()) {
    if (false) {}

    const instanceDataManager = this.instanceDataManager;
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex;

    const _instanceDataManager$3 = instanceDataManager.getInstanceRenderable(instanceId),
          batchIdx = _instanceDataManager$3.batchIdx;

    const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
    instanceDataManager.readWorldTransform(worldMatrix, globalIndex);
    return worldMatrix;
  }

  changeInstanceMaterial(instance, material) {
    const instanceDataManager = this.instanceDataManager;
    instance.material = material;
    instanceDataManager.addInstance(instance);
    this.forceUpdateRenderQueue = true;
  }

  getInstancedAttribute(instance, semantic, outVal) {
    if (false) {}

    const instanceDataManager = this.instanceDataManager;
    return instanceDataManager.getInstancedAttribute(instance, semantic, outVal);
  }

  setInstancedAttribute(instance, semantic, value) {
    if (false) {}

    const instanceDataManager = this.instanceDataManager;
    instanceDataManager.setInstancedAttribute(instance, semantic, value);
  }

  setInstanceVisibility(instance, value) {
    if (false) {}

    this.instanceDataManager.setInstanceVisibility(instance, value, true);
    this.forceUpdateRenderQueue = true;
  }

  getInstanceVisibility(instance) {
    if (false) {}

    const currentFrameVisibilityFlag = 0x02;
    const instanceDataManager = this.instanceDataManager;
    const _flagBuffers = instanceDataManager._flagBuffers;
    const instanceId = instance.instanceId,
          instanceIndex = instance.instanceIndex;

    const _instanceDataManager$4 = instanceDataManager.getInstanceRenderable(instanceId),
          batchIdx = _instanceDataManager$4.batchIdx;

    const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
    return (_flagBuffers[globalIndex] & currentFrameVisibilityFlag) !== 0;
  }

  updateLight(light) {
    if (this._lights.has(light)) {
      computeLightProperties(light);
    }
  }

  addLight(light, matrix = new lib["b" /* AffineMatrix3 */]().fromNumber(1.0)) {
    computeLightProperties(light);

    this._forceMaterialsUpdate();

    this._lights.set(light, matrix);
  }

  setLightTransform(light, matrix) {
    const _lights = this._lights;

    if (_lights.has(light)) {
      _lights.set(light, matrix);
    }
  }

  getLightTransform(light) {
    const matrix = this._lights.get(light);

    if (matrix === undefined) {
      throw new Error('Light not exist');
    }

    return matrix;
  }

  deleteLight(light) {
    this._forceMaterialsUpdate();

    this._lights.delete(light);
  }

  _update(look) {
    const _lights = this._lights;
    const viewMatrix = look.viewMatrix;
    let maxIlluminance = 0;

    for (const _ref of _lights) {
      var _ref2 = dotScene_slicedToArray(_ref, 2);

      const light = _ref2[0];
      const matrix = _ref2[1];
      updateLightPositionAndDirection(light, matrix, viewMatrix);
      maxIlluminance = Math.max(maxIlluminance, light._illuminance);
    }

    this._maxIlluminance = Math.max(this._maxEnvIlluminance, maxIlluminance);
  }

  sceneCast() {
    const srcInstanceDataManager = this.instanceDataManager,
          name = this.name,
          srcConfig = this.config,
          lights = this.lights;
    const maxSceneNodes = srcInstanceDataManager.capacity,
          batches = srcInstanceDataManager._instancedBatches,
          _freeIndices = srcInstanceDataManager._freeIndices;
    const scene = new scene_Scene({
      maxSceneNodes,
      batchMap: srcInstanceDataManager.generateBatchMap(),
      name,
      config: {
        customAttributes: srcConfig.customAttributes,
        componentClasses: srcConfig.componentClasses
      }
    });
    const splitTransform = new lib["d" /* AffineSplitTransform3 */]();
    const batchCount = batches.batchCount;
    const batch = new InstancedBatch();
    const matrix = new lib["b" /* AffineMatrix3 */]();

    for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
      batches.unpackBatch(batchIdx, batch);
      const capacity = batch.capacity,
            instanceCount = batch.instanceCount,
            instanceId = batch.instanceId;
      const batchRenderable = srcInstanceDataManager.getInstanceRenderable(instanceId);
      const freeIndices = _freeIndices.get(batchRenderable) || [];
      const geometry = batchRenderable.geometry,
            material = batchRenderable.material;

      for (let instanceIdx = 0, validInstanceCount = 0; instanceIdx < capacity; instanceIdx++) {
        if (freeIndices.includes(instanceIdx)) {
          continue;
        }

        const node = scene.root.createChild({});
        const mesh = new mesh_component_Mesh({});
        const subMesh = new mesh_component_SubMesh({
          geometry,
          material
        });
        mesh.addSubMesh(subMesh);
        node.attach(mesh);
        const globalIndex = srcInstanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIdx);
        srcInstanceDataManager.readWorldTransform(matrix, globalIndex);
        splitTransform.fromAffineMatrix(matrix);
        const scale = splitTransform.scaling,
              orientation = splitTransform.quaternion,
              position = splitTransform.translation;
        node.attach(new transform_component_Transform({
          scale,
          position,
          orientation
        }));

        if (++validInstanceCount >= instanceCount) {
          break;
        }
      }
    }

    for (const _ref3 of lights.entries()) {
      var _ref4 = dotScene_slicedToArray(_ref3, 2);

      const light = _ref4[0];
      const lightMatrix = _ref4[1];
      const node = scene.root.createChild({});
      splitTransform.fromAffineMatrix(lightMatrix);
      const scale = splitTransform.scaling,
            orientation = splitTransform.quaternion,
            position = splitTransform.translation;
      node.attach(light);
      node.attach(new transform_component_Transform({
        scale,
        position,
        orientation
      }));
    }

    return scene;
  }

  get lights() {
    return this._lights;
  }

  _forceMaterialsUpdate() {
    const instanceDataManager = this.instanceDataManager;
    const _uniqueInstances = instanceDataManager._uniqueInstances;

    for (const batch of _uniqueInstances.values()) {
      batch.material.needsUpdate = true;
    }
  }

}
Object.defineProperty(dotScene_DotScene.prototype, 'isDotScene', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/vertexBufferView.js

class vertexBufferView_VertexBufferView extends disposeableUsageCounter_DisposableUsageCounter {
  constructor(staging = null, byteLength) {
    super();
    this.empty = staging === null ? true : staging.empty;
    this._staging = staging;
    let view = null;

    if (staging !== null) {
      view = staging.allocMemory(Uint8Array, byteLength);
    }

    this._view = view;
  }

  get view() {
    return this._view;
  }

  _actuallyUnload() {
    const _staging = this._staging,
          _view = this._view;

    if (_staging !== null && _view !== null) {
      _staging.releaseMemory(_view);
    }

    this._view = null;

    super._actuallyUnload();
  }

  _dispose() {
    const _staging = this._staging,
          _view = this._view;

    if (_staging !== null && _view !== null) {
      _staging.releaseMemory(_view);
    }

    this._staging = null;
    this._view = null;

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/vertexAttribute.js

class vertexAttribute_VertexAttribute extends disposeableUsageCounter_DisposableUsageCounter {
  constructor({
    vertexData,
    offset,
    stride,
    semantic,
    normalized = false,
    countComponents,
    countElements,
    componentType,
    elementType,
    type
  }) {
    super();
    this._vertexData = vertexData.retain();
    this.offset = offset;
    this.stride = stride;
    this.semantic = semantic;
    this.normalized = normalized;
    this.countElements = countElements;
    this.countComponents = countComponents;
    this.componentType = componentType;
    this.elementType = elementType;
    this.type = type;
    let view = null;

    if (vertexData.view !== null) {
      view = vertexData.empty ? {
        byteOffset: vertexData.view.byteOffset + offset
      } : new type(vertexData.view.buffer, vertexData.view.byteOffset + offset, Math.max(0, (countElements - 1) * stride / type.BYTES_PER_ELEMENT + countComponents));
    }

    this.view = view;
  }

  get vertexData() {
    return this._vertexData;
  }

  _dispose() {
    this.view = null;

    this._vertexData.release();

    this._vertexData = null;

    super._dispose();
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), this._vertexData.load()]);
  }

  _actuallyUnload() {
    this.view = null;

    this._vertexData.unload();

    super._actuallyUnload();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/vertexAttributeType.js
var VertexAttributeType;

(function (VertexAttributeType) {
  VertexAttributeType[VertexAttributeType["SCALAR"] = 0] = "SCALAR";
  VertexAttributeType[VertexAttributeType["VEC2"] = 1] = "VEC2";
  VertexAttributeType[VertexAttributeType["VEC3"] = 2] = "VEC3";
  VertexAttributeType[VertexAttributeType["VEC4"] = 3] = "VEC4";
  VertexAttributeType[VertexAttributeType["MAT2"] = 4] = "MAT2";
  VertexAttributeType[VertexAttributeType["MAT3"] = 5] = "MAT3";
  VertexAttributeType[VertexAttributeType["MAT4"] = 6] = "MAT4";
})(VertexAttributeType || (VertexAttributeType = {}));

function getVertexAttributeCountComponents(attributeType) {
  switch (attributeType) {
    case VertexAttributeType.SCALAR:
      return 1;

    case VertexAttributeType.VEC2:
      return 2;

    case VertexAttributeType.VEC3:
      return 3;

    case VertexAttributeType.VEC4:
    case VertexAttributeType.MAT2:
      return 4;

    case VertexAttributeType.MAT3:
      return 9;

    case VertexAttributeType.MAT4:
      return 16;

    default:
      throw new Error('Unknown attribute type');
  }
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderTarget/renderTargetCanvas.js

class renderTargetCanvas_RenderTargetCanvas extends renderTarget_RenderTarget {
  constructor(properties = {}) {
    super();
    let canvas = null;
    var _properties$canvas = properties.canvas;
    canvas = _properties$canvas === void 0 ? document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas') : _properties$canvas;

    if (false) {}

    this._canvas = canvas;
    const width = properties.width,
          height = properties.height,
          _properties$updateSty = properties.updateStyle,
          updateStyle = _properties$updateSty === void 0 ? true : _properties$updateSty;
    canvas.width = width || canvas.width;
    canvas.height = height || canvas.height;

    if (updateStyle !== false) {
      canvas.style.width = `${canvas.width}px`;
      canvas.style.height = `${canvas.height}px`;
    }
  }

  resize(width, height, pixelRatio = 1, updateStyle = true) {
    const _canvas = this._canvas;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = `${width}px`;
      _canvas.style.height = `${height}px`;
    }
  }

  get width() {
    return this._canvas.width;
  }

  get height() {
    return this._canvas.height;
  }

  get canvas() {
    return this._canvas;
  }

}
Object.defineProperty(renderTargetCanvas_RenderTargetCanvas.prototype, 'isRenderTargetCanvas', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/renderTarget/renderTargetCube.js


class renderTargetCube_RenderTargetCube extends renderTargetFramebuffer_RenderTargetFramebuffer {
  constructor({
    width,
    height
  }) {
    super({
      width,
      height
    });
    this._target = texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
  }

  setColorAttachment(layoutPosition, attachment, level = 0) {
    if (false) {}

    super.setColorAttachment(layoutPosition, attachment, level, texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X);
    this._target = texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
  }

  set target(target) {
    this._target = target;
    const _properties = this._properties,
          _colorAttachments = this._colorAttachments,
          _depthStencilAttachments = this._depthStencilAttachments;

    for (const attachment of _colorAttachments.values()) {
      const props = _properties.get(attachment);

      props.target = target;
      props.needsUpdate = true;
    }

    for (const attachment of _depthStencilAttachments.values()) {
      if (attachment.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
        const props = _properties.get(attachment);

        props.target = target;
        props.needsUpdate = true;
      }
    }

    this._needsUpdateAttachments = true;
  }

  get target() {
    return this._target;
  }

  get targetIndex() {
    return this._target - texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
  }

}
Object.defineProperty(renderTargetCube_RenderTargetCube.prototype, 'isRenderTargetCube', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/core/index.js



































// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/geometry-resource/index.js



let lastGeometryId = 1;

class AttributesProxy extends Map {
  set(semantic, attribute) {
    var _a;

    attribute.retain();
    (_a = super.get(semantic)) === null || _a === void 0 ? void 0 : _a.release();
    super.set(semantic, attribute);
    return this;
  }

  delete(semantic) {
    var _a;

    (_a = super.get(semantic)) === null || _a === void 0 ? void 0 : _a.release();
    return super.delete(semantic);
  }

  clear() {
    for (const attribute of super.values()) {
      attribute.release();
    }

    super.clear();
  }

}

class geometry_resource_Geometry extends resource_Resource {
  constructor(options = {}) {
    super();
    const _options$primitiveTyp = options.primitiveType,
          primitiveType = _options$primitiveTyp === void 0 ? PrimitiveType.TRIANGLES : _options$primitiveTyp;
    this.id = lastGeometryId++;
    this.attributes = new AttributesProxy();
    this.morphTargets = new AttributesProxy();
    this.primitiveType = primitiveType;
    this.boundingBox = new lib["e" /* Box */]();
    this.needsUpdateBoundingBox = true;
    this._indices = null;
  }

  destructor() {
    var _a;

    (_a = this._indices) === null || _a === void 0 ? void 0 : _a.release();
    this.attributes.clear();
    this.morphTargets.clear();
    super.destructor();
  }

  get indices() {
    return this._indices;
  }

  set indices(value) {
    var _a;

    value === null || value === void 0 ? void 0 : value.retain();
    (_a = this._indices) === null || _a === void 0 ? void 0 : _a.release();
    this._indices = value;
  }

  updateBoundingBox() {
    const attributes = this.attributes,
          boundingBox = this.boundingBox;
    const attribute = attributes.get(AttributeSemantic.POSITION);
    const array = attribute.view;
    const stride = attribute.stride / attribute.type.BYTES_PER_ELEMENT;
    boundingBox.min.fromNumber(+Infinity);
    boundingBox.max.fromNumber(-Infinity);
    const value = new lib["n" /* Vector3 */]();

    for (let i = 0, count = attribute.countElements; i < count; i++) {
      value.fromArrayAt(i * stride, array);
      boundingBox.consumePoint(value);
    }

    this.needsUpdateBoundingBox = false;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      if (this._indices !== null) {
        yield this._indices.load();
      }

      for (const a of this.attributes.values()) {
        yield a.load();
      }

      for (const m of this.morphTargets.values()) {
        yield m.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    if (this._indices !== null) {
      this._indices.unload();
    }

    for (const a of this.attributes.values()) {
      a.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    var _a;

    (_a = this._indices) === null || _a === void 0 ? void 0 : _a.release();
    this.attributes.clear();
    this.morphTargets.clear();

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderTechnique.js
function _copyObject(src, dst = {}) {
  for (const k of Object.keys(src)) {
    dst[k] = src[k];
  }

  return dst;
}

function _clearUndefinedProps(src, dst) {
  for (const k of Object.keys(dst)) {
    if (src[k] === undefined) {
      delete dst[k];
    }
  }
}

class RenderTechnique {
  constructor(name, defines, extensions) {
    this._program = null;
    this._defines = _copyObject(defines);
    this._extensions = _copyObject(extensions);
    this._output = 0;
    this._outputLayout = null;
    this.name = name;
    this.cacheKey = '';
    this.needsUpdate = true;
  }

  get defines() {
    return this._defines;
  }

  set defines(value) {
    this._defines = _copyObject(value, this._defines);

    _clearUndefinedProps(value, this._defines);
  }

  get extensions() {
    return this._extensions;
  }

  set extensions(value) {
    this._extensions = _copyObject(value);

    _clearUndefinedProps(value, this._extensions);
  }

  set program(value) {
    const _program = this._program;

    if (value === _program) {
      return;
    }

    if (value !== null) {
      value.retain();
    }

    if (_program !== null) {
      _program.release();
    }

    this._program = value;
  }

  get program() {
    return this._program;
  }

}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/webGLBaseMaterial.js





function _getTextureSlot(slots, id) {
  let slot = -1;

  for (let i = 0; i < 16; i++) {
    if (slots[i * 3] === id) {
      slot = i;
      break;
    }
  }

  return slot;
}

class webGLBaseMaterial_WebGLBaseMaterial extends material_Material {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$alphaMode = properties.alphaMode,
          alphaMode = _properties$alphaMode === void 0 ? material_Material.AlphaMode.OPAQUE : _properties$alphaMode,
          _properties$alphaCuto = properties.alphaCutoff,
          alphaCutoff = _properties$alphaCuto === void 0 ? 0.0 : _properties$alphaCuto,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.NONE : _properties$cullFace;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this._passTechniques = new Map();
    this._textureSlots = new Array(48);
    this._activeTexturesCount = 0;
    this._receiveShadow = false;
    this._castShadow = false;
    this._currentProgram = null;
  }

  get program() {
    return this._currentProgram;
  }

  get receiveShadow() {
    return this._receiveShadow;
  }

  set receiveShadow(value) {
    if (this._receiveShadow === value) {
      return;
    }

    this._receiveShadow = value;
    this.needsUpdate = true;
  }

  get castShadow() {
    return this._castShadow;
  }

  set castShadow(value) {
    if (this._castShadow === value) {
      return;
    }

    this._castShadow = value;
    this.needsUpdate = true;
  }

  get needsUpdate() {
    const _passTechniques = this._passTechniques;

    for (const t of _passTechniques.values()) {
      if (t.needsUpdate) {
        return true;
      }
    }

    return false;
  }

  set needsUpdate(value) {
    const _passTechniques = this._passTechniques;

    for (const t of _passTechniques.values()) {
      t.needsUpdate = value;
    }
  }

  get shaders() {
    return this._shaders;
  }

  getTechnique(renderPassId) {
    const technique = this._passTechniques.get(renderPassId);

    return technique !== undefined ? technique : null;
  }

  _applyDefault(gl, state, programs, renderPass, technique) {
    const cullFace = this.cullFace,
          alphaMode = this.alphaMode,
          _textureSlots = this._textureSlots,
          depthTest = this.depthTest,
          depthWrite = this.depthWrite;
    const statistics = renderPass.statistics,
          renderPassId = renderPass.id;
    statistics.materialCount++;
    this._activeTexturesCount = 0;

    _textureSlots.fill(0);

    if (technique.program === null) {
      technique.program = programs.getProgram(this, renderPassId);
    }

    const program = technique.program;
    state.program = program.webglProgram;
    state.cullFace = cullFace === material_Material.CullFace.NONE ? null : cullFace;

    switch (alphaMode) {
      case material_Material.AlphaMode.BLEND:
        state.blending = WebGLBlendingType.NormalBlending;
        break;

      case material_Material.AlphaMode.ADDITIVE_BLEND:
        state.blending = WebGLBlendingType.AdditiveBlending;
        break;

      case material_Material.AlphaMode.SUBTRACTIVE_BLEND:
        state.blending = WebGLBlendingType.SubtractiveBlending;
        break;

      case material_Material.AlphaMode.MULTIPLY_BLEND:
        state.blending = WebGLBlendingType.MultiplyBlending;
        break;

      case material_Material.AlphaMode.CUSTOM_BLEND:
        {
          const _blendEq = this._blendEq,
                _blendEqAlpha = this._blendEqAlpha,
                _srcRGB = this._srcRGB,
                _dstRGB = this._dstRGB,
                _srcAlpha = this._srcAlpha,
                _dstAlpha = this._dstAlpha;
          state.setCustomBlending(_blendEq, _blendEqAlpha, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha);
          break;
        }

      default:
        state.blending = WebGLBlendingType.NoBlending;
    }

    state.depthMask = depthWrite;
    state.depthTest = depthTest;
    statistics.programCount += state._programHasChanged;
    this._currentProgram = program;
  }

  _updateTechnique(renderPassId) {
    let technique = this.getTechnique(renderPassId);
    const _shaders = this._shaders,
          _passTechniques = this._passTechniques;
    const _shaders$name = _shaders.name,
          name = _shaders$name === void 0 ? '' : _shaders$name,
          _shaders$extensions = _shaders.extensions,
          extensions = _shaders$extensions === void 0 ? {} : _shaders$extensions,
          _shaders$defines = _shaders.defines,
          defines = _shaders$defines === void 0 ? {} : _shaders$defines;

    if (technique === null) {
      technique = new RenderTechnique(`${name}_${renderPassId}`, defines, extensions);

      _passTechniques.set(renderPassId, technique);
    } else if (technique.needsUpdate) {
      technique.defines = defines;
      technique.extensions = extensions;
    }

    return technique;
  }

  _resetTechniqueProgram(technique) {
    if (technique.program !== null) {
      technique.program = null;
    }
  }

  _setTexture(gl, uniform, texture, textures) {
    const id = texture.id;
    const _textureSlots = this._textureSlots;

    let slot = _getTextureSlot(_textureSlots, id);

    if (slot === -1) {
      slot = this._activeTexturesCount++;

      const _textures$getWebGLTex = textures.getWebGLTexture(texture),
            bindingPoint = _textures$getWebGLTex.bindingPoint,
            webGLTexture = _textures$getWebGLTex.webGLTexture;

      _textureSlots[slot * 3 + 0] = id;
      _textureSlots[slot * 3 + 1] = bindingPoint;
      _textureSlots[slot * 3 + 2] = webGLTexture;
    }

    uniform.setValue(slot);
  }

  _setSkeletonMap(gl, renderable, uniforms, textures) {
    const _renderable$skeletonB = renderable.skeletonBuffers,
          skeletonBuffers = _renderable$skeletonB === void 0 ? null : _renderable$skeletonB;

    if (skeletonBuffers === null || !skeletonBuffers.isOk) {
      return;
    }

    const boneGPU = skeletonBuffers.boneGPU;
    const uniform = uniforms.get('bonesMap');

    if (uniform === undefined) {
      throw new Error('uniform is undefined');
    }

    if (false) {}

    this._setTexture(gl, uniform, boneGPU, textures);
  }

  _bindTextures(gl) {
    const _textureSlots = this._textureSlots,
          _activeTexturesCount = this._activeTexturesCount;

    for (let slot = 0; slot < _activeTexturesCount; slot++) {
      const bindingPoint = _textureSlots[slot * 3 + 1];
      const webGLTexture = _textureSlots[slot * 3 + 2];
      gl.activeTexture(gl.TEXTURE0 + slot);
      gl.bindTexture(bindingPoint, webGLTexture);
    }
  }

  _needsUpdate(renderable, renderPass, technique, webgl2Support) {
    const alphaMode = this.alphaMode,
          alphaCutoff = this.alphaCutoff;
    const srgbOutput = renderPass.srgbOutput,
          output = renderPass.output,
          _outputLayout = renderPass._outputLayout,
          _premultipliedAlpha = renderPass._premultipliedAlpha;
    const defines = technique.defines;
    const SRGB_OUTPUT = defines.SRGB_OUTPUT,
          SKINNING = defines.SKINNING,
          ALPHA_TEST = defines.ALPHA_TEST,
          PREMULTIPLIED_ALPHA = defines.PREMULTIPLIED_ALPHA,
          OUTPUT_MASK = defines.OUTPUT_MASK;
    const _renderable$skeletonB2 = renderable.skeletonBuffers,
          skeletonBuffers = _renderable$skeletonB2 === void 0 ? null : _renderable$skeletonB2;

    if (srgbOutput && SRGB_OUTPUT === undefined) {
      technique.needsUpdate = true;
      defines.SRGB_OUTPUT = '';
    } else if (!srgbOutput && SRGB_OUTPUT !== undefined) {
      technique.needsUpdate = true;
      delete defines.SRGB_OUTPUT;
    }

    if (skeletonBuffers !== null && skeletonBuffers.isOk) {
      const boneGPU = skeletonBuffers.boneGPU;
      const width = boneGPU.width,
            height = boneGPU.height;

      if (SKINNING === undefined || defines.BONES_TEXTURE_HEIGHT !== height) {
        technique.needsUpdate = true;
        defines.SKINNING = '';
        defines.BONES_PER_VERTEX = 4;
        defines.BONES_TEXTURE_WIDTH = width;
        defines.BONES_TEXTURE_HEIGHT = height;
      }
    } else if ((skeletonBuffers === null || !skeletonBuffers.isOk) && SKINNING !== undefined) {
      technique.needsUpdate = true;
      delete defines.SKINNING;
      delete defines.BONES_PER_VERTEX;
      delete defines.BONES_TEXTURE_WIDTH;
      delete defines.BONES_TEXTURE_HEIGHT;
    }

    if (alphaMode === material_Material.AlphaMode.MASK && ALPHA_TEST === undefined) {
      technique.needsUpdate = true;
      defines.ALPHA_TEST = alphaCutoff;
    } else if (alphaMode !== material_Material.AlphaMode.MASK && ALPHA_TEST !== undefined) {
      technique.needsUpdate = true;
      delete defines.ALPHA_TEST;
    }

    if (output !== OUTPUT_MASK) {
      technique.needsUpdate = true;
      technique._output = output;
      technique._outputLayout = _outputLayout;
      defines.OUTPUT_MASK = output;
    }

    if (_premultipliedAlpha && PREMULTIPLIED_ALPHA === undefined) {
      technique.needsUpdate = true;
      defines.PREMULTIPLIED_ALPHA = '';
    } else if (!_premultipliedAlpha && PREMULTIPLIED_ALPHA !== undefined) {
      technique.needsUpdate = true;
      delete defines.PREMULTIPLIED_ALPHA;
    }

    return technique.needsUpdate;
  }

  _dispose() {
    const _passTechniques = this._passTechniques;

    for (const technique of _passTechniques.values()) {
      technique.program = null;
    }

    _passTechniques.clear();

    super._dispose();
  }

  static _testIfNewTextureRequireUpdate(oldTex, newTex) {
    if (oldTex !== null && newTex === null) {
      return true;
    }

    if (oldTex === null && newTex !== null) {
      return true;
    }

    return false;
  }

}
/* harmony default export */ var webGLBaseMaterial = (webGLBaseMaterial_WebGLBaseMaterial);
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/unlit.vert
var unlit = __webpack_require__(166);
var unlit_default = /*#__PURE__*/__webpack_require__.n(unlit);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/unlit.frag
var shaders_unlit = __webpack_require__(111);
var shaders_unlit_default = /*#__PURE__*/__webpack_require__.n(shaders_unlit);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/pbr.vert
var pbr = __webpack_require__(167);
var pbr_default = /*#__PURE__*/__webpack_require__.n(pbr);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/pbr.frag
var shaders_pbr = __webpack_require__(168);
var shaders_pbr_default = /*#__PURE__*/__webpack_require__.n(shaders_pbr);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/farplane.vert
var farplane = __webpack_require__(112);
var farplane_default = /*#__PURE__*/__webpack_require__.n(farplane);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/environment.frag
var environment = __webpack_require__(169);
var environment_default = /*#__PURE__*/__webpack_require__.n(environment);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/convolution.frag
var convolution = __webpack_require__(170);
var convolution_default = /*#__PURE__*/__webpack_require__.n(convolution);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/sprite.vert
var shaders_sprite = __webpack_require__(171);
var sprite_default = /*#__PURE__*/__webpack_require__.n(shaders_sprite);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/depth.vert
var shaders_depth = __webpack_require__(172);
var depth_default = /*#__PURE__*/__webpack_require__.n(shaders_depth);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/depth.frag
var shaderLib_shaders_depth = __webpack_require__(173);
var shaders_depth_default = /*#__PURE__*/__webpack_require__.n(shaderLib_shaders_depth);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/line.vert
var shaders_line = __webpack_require__(174);
var line_default = /*#__PURE__*/__webpack_require__.n(shaders_line);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/line.frag
var shaderLib_shaders_line = __webpack_require__(175);
var shaders_line_default = /*#__PURE__*/__webpack_require__.n(shaderLib_shaders_line);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/screenquad.vert
var screenquad = __webpack_require__(176);
var screenquad_default = /*#__PURE__*/__webpack_require__.n(screenquad);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/shaders/copy.frag
var copy = __webpack_require__(177);
var copy_default = /*#__PURE__*/__webpack_require__.n(copy);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/math.glsl
var math = __webpack_require__(178);
var math_default = /*#__PURE__*/__webpack_require__.n(math);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/matrixRoutines.glsl
var matrixRoutines = __webpack_require__(179);
var matrixRoutines_default = /*#__PURE__*/__webpack_require__.n(matrixRoutines);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/clipPositionParams.glsl
var clipPositionParams = __webpack_require__(180);
var clipPositionParams_default = /*#__PURE__*/__webpack_require__.n(clipPositionParams);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/clipPositionVert.glsl
var clipPositionVert = __webpack_require__(181);
var clipPositionVert_default = /*#__PURE__*/__webpack_require__.n(clipPositionVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/transformAttributesVert.glsl
var transformAttributesVert = __webpack_require__(182);
var transformAttributesVert_default = /*#__PURE__*/__webpack_require__.n(transformAttributesVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/transformVert.glsl
var transformVert = __webpack_require__(183);
var transformVert_default = /*#__PURE__*/__webpack_require__.n(transformVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/viewPositionVert.glsl
var viewPositionVert = __webpack_require__(184);
var viewPositionVert_default = /*#__PURE__*/__webpack_require__.n(viewPositionVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/normalVert.glsl
var normalVert = __webpack_require__(185);
var normalVert_default = /*#__PURE__*/__webpack_require__.n(normalVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/transformUv.glsl
var transformUv = __webpack_require__(186);
var transformUv_default = /*#__PURE__*/__webpack_require__.n(transformUv);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/colorMapParamsVert.glsl
var colorMapParamsVert = __webpack_require__(187);
var colorMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(colorMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/albedoMapParamsVert.glsl
var albedoMapParamsVert = __webpack_require__(188);
var albedoMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(albedoMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/normalMapParamsVert.glsl
var normalMapParamsVert = __webpack_require__(189);
var normalMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(normalMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/normalMapParamsFrag.glsl
var normalMapParamsFrag = __webpack_require__(190);
var normalMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(normalMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/metalnessRoughnessMapParamsVert.glsl
var metalnessRoughnessMapParamsVert = __webpack_require__(191);
var metalnessRoughnessMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(metalnessRoughnessMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/ambientOcclusionMapFrag.glsl
var ambientOcclusionMapFrag = __webpack_require__(192);
var ambientOcclusionMapFrag_default = /*#__PURE__*/__webpack_require__.n(ambientOcclusionMapFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/ambientOcclusionMapParamsVert.glsl
var ambientOcclusionMapParamsVert = __webpack_require__(193);
var ambientOcclusionMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(ambientOcclusionMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/ambientOcclusionMapParamsFrag.glsl
var ambientOcclusionMapParamsFrag = __webpack_require__(194);
var ambientOcclusionMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(ambientOcclusionMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/worldSpaceVaryingsParamsVert.glsl
var worldSpaceVaryingsParamsVert = __webpack_require__(195);
var worldSpaceVaryingsParamsVert_default = /*#__PURE__*/__webpack_require__.n(worldSpaceVaryingsParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/worldSpaceVaryingsParamsFrag.glsl
var worldSpaceVaryingsParamsFrag = __webpack_require__(196);
var worldSpaceVaryingsParamsFrag_default = /*#__PURE__*/__webpack_require__.n(worldSpaceVaryingsParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/worldSpaceVaryingsVert.glsl
var worldSpaceVaryingsVert = __webpack_require__(197);
var worldSpaceVaryingsVert_default = /*#__PURE__*/__webpack_require__.n(worldSpaceVaryingsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/worldSpaceFragContextParamsFrag.glsl
var worldSpaceFragContextParamsFrag = __webpack_require__(198);
var worldSpaceFragContextParamsFrag_default = /*#__PURE__*/__webpack_require__.n(worldSpaceFragContextParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/worldSpaceFragContextFrag.glsl
var worldSpaceFragContextFrag = __webpack_require__(199);
var worldSpaceFragContextFrag_default = /*#__PURE__*/__webpack_require__.n(worldSpaceFragContextFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/iblSH.glsl
var iblSH = __webpack_require__(200);
var iblSH_default = /*#__PURE__*/__webpack_require__.n(iblSH);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/diffuseIlluminanceMapParamsFrag.glsl
var diffuseIlluminanceMapParamsFrag = __webpack_require__(201);
var diffuseIlluminanceMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(diffuseIlluminanceMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/preFilteredEnvMapParamsFrag.glsl
var preFilteredEnvMapParamsFrag = __webpack_require__(202);
var preFilteredEnvMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(preFilteredEnvMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/albedoMapFrag.glsl
var albedoMapFrag = __webpack_require__(203);
var albedoMapFrag_default = /*#__PURE__*/__webpack_require__.n(albedoMapFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/normalMapFrag.glsl
var normalMapFrag = __webpack_require__(204);
var normalMapFrag_default = /*#__PURE__*/__webpack_require__.n(normalMapFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/metalnessRoughnessMapFrag.glsl
var metalnessRoughnessMapFrag = __webpack_require__(205);
var metalnessRoughnessMapFrag_default = /*#__PURE__*/__webpack_require__.n(metalnessRoughnessMapFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/trowbridgeReitzNDF.glsl
var trowbridgeReitzNDF = __webpack_require__(206);
var trowbridgeReitzNDF_default = /*#__PURE__*/__webpack_require__.n(trowbridgeReitzNDF);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/geometryFunc.glsl
var geometryFunc = __webpack_require__(207);
var geometryFunc_default = /*#__PURE__*/__webpack_require__.n(geometryFunc);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/burleyBRDF.glsl
var burleyBRDF = __webpack_require__(208);
var burleyBRDF_default = /*#__PURE__*/__webpack_require__.n(burleyBRDF);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/lambertBRDF.glsl
var lambertBRDF = __webpack_require__(209);
var lambertBRDF_default = /*#__PURE__*/__webpack_require__.n(lambertBRDF);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/specularBRDF.glsl
var specularBRDF = __webpack_require__(210);
var specularBRDF_default = /*#__PURE__*/__webpack_require__.n(specularBRDF);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/matrixWorldView.glsl
var matrixWorldView = __webpack_require__(211);
var matrixWorldView_default = /*#__PURE__*/__webpack_require__.n(matrixWorldView);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/lightsParamsFrag.glsl
var lightsParamsFrag = __webpack_require__(212);
var lightsParamsFrag_default = /*#__PURE__*/__webpack_require__.n(lightsParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/schlickFunc.glsl
var schlickFunc = __webpack_require__(213);
var schlickFunc_default = /*#__PURE__*/__webpack_require__.n(schlickFunc);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/materialPBR.glsl
var materialPBR = __webpack_require__(214);
var materialPBR_default = /*#__PURE__*/__webpack_require__.n(materialPBR);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/lightFragContext.glsl
var lightFragContext = __webpack_require__(215);
var lightFragContext_default = /*#__PURE__*/__webpack_require__.n(lightFragContext);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/materialPBRFrag.glsl
var materialPBRFrag = __webpack_require__(216);
var materialPBRFrag_default = /*#__PURE__*/__webpack_require__.n(materialPBRFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/attenuation.glsl
var attenuation = __webpack_require__(217);
var attenuation_default = /*#__PURE__*/__webpack_require__.n(attenuation);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/toneMappingFragParams.glsl
var toneMappingFragParams = __webpack_require__(218);
var toneMappingFragParams_default = /*#__PURE__*/__webpack_require__.n(toneMappingFragParams);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/rgbToSrgbFunc.glsl
var rgbToSrgbFunc = __webpack_require__(219);
var rgbToSrgbFunc_default = /*#__PURE__*/__webpack_require__.n(rgbToSrgbFunc);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/alphaTestFrag.glsl
var alphaTestFrag = __webpack_require__(220);
var alphaTestFrag_default = /*#__PURE__*/__webpack_require__.n(alphaTestFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/shadowMapParamsFrag.glsl
var shadowMapParamsFrag = __webpack_require__(221);
var shadowMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(shadowMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/directShadowCastersFrag.glsl
var directShadowCastersFrag = __webpack_require__(222);
var directShadowCastersFrag_default = /*#__PURE__*/__webpack_require__.n(directShadowCastersFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/spotShadowCastersFrag.glsl
var spotShadowCastersFrag = __webpack_require__(223);
var spotShadowCastersFrag_default = /*#__PURE__*/__webpack_require__.n(spotShadowCastersFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/omniShadowCastersFrag.glsl
var omniShadowCastersFrag = __webpack_require__(224);
var omniShadowCastersFrag_default = /*#__PURE__*/__webpack_require__.n(omniShadowCastersFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/skinningParamsVert.glsl
var skinningParamsVert = __webpack_require__(225);
var skinningParamsVert_default = /*#__PURE__*/__webpack_require__.n(skinningParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/emissiveMapParamsVert.glsl
var emissiveMapParamsVert = __webpack_require__(226);
var emissiveMapParamsVert_default = /*#__PURE__*/__webpack_require__.n(emissiveMapParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/emissiveMapFrag.glsl
var emissiveMapFrag = __webpack_require__(227);
var emissiveMapFrag_default = /*#__PURE__*/__webpack_require__.n(emissiveMapFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/emissiveMapParamsFrag.glsl
var emissiveMapParamsFrag = __webpack_require__(228);
var emissiveMapParamsFrag_default = /*#__PURE__*/__webpack_require__.n(emissiveMapParamsFrag);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/morphParamsVert.glsl
var morphParamsVert = __webpack_require__(229);
var morphParamsVert_default = /*#__PURE__*/__webpack_require__.n(morphParamsVert);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/clearCoatFrag.glsl
var clearCoatFrag = __webpack_require__(230);
var clearCoatFrag_default = /*#__PURE__*/__webpack_require__.n(clearCoatFrag);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/chunks/index.js





















































const ShaderChunks = {
  math: math_default.a,
  matrixRoutines: matrixRoutines_default.a,
  alphaTestFrag: alphaTestFrag_default.a,
  colorMapParamsVert: colorMapParamsVert_default.a,
  albedoMapParamsVert: albedoMapParamsVert_default.a,
  normalMapParamsVert: normalMapParamsVert_default.a,
  normalMapParamsFrag: normalMapParamsFrag_default.a,
  metalnessRoughnessMapParamsVert: metalnessRoughnessMapParamsVert_default.a,
  worldSpaceVaryingsParamsVert: worldSpaceVaryingsParamsVert_default.a,
  worldSpaceVaryingsParamsFrag: worldSpaceVaryingsParamsFrag_default.a,
  worldSpaceVaryingsVert: worldSpaceVaryingsVert_default.a,
  worldSpaceFragContextParamsFrag: worldSpaceFragContextParamsFrag_default.a,
  worldSpaceFragContextFrag: worldSpaceFragContextFrag_default.a,
  skinningParamsVert: skinningParamsVert_default.a,
  ambientOcclusionMapFrag: ambientOcclusionMapFrag_default.a,
  ambientOcclusionMapParamsVert: ambientOcclusionMapParamsVert_default.a,
  ambientOcclusionMapParamsFrag: ambientOcclusionMapParamsFrag_default.a,
  iblSH: iblSH_default.a,
  diffuseIlluminanceMapParamsFrag: diffuseIlluminanceMapParamsFrag_default.a,
  preFilteredEnvMapParamsFrag: preFilteredEnvMapParamsFrag_default.a,
  albedoMapFrag: albedoMapFrag_default.a,
  normalMapFrag: normalMapFrag_default.a,
  metalnessRoughnessMapFrag: metalnessRoughnessMapFrag_default.a,
  clipPositionParams: clipPositionParams_default.a,
  clipPositionVert: clipPositionVert_default.a,
  transformAttributesVert: transformAttributesVert_default.a,
  transformVert: transformVert_default.a,
  matrixWorldView: matrixWorldView_default.a,
  viewPositionVert: viewPositionVert_default.a,
  normalVert: normalVert_default.a,
  transformUv: transformUv_default.a,
  schlickFunc: schlickFunc_default.a,
  geometryFunc: geometryFunc_default.a,
  trowbridgeReitzNDF: trowbridgeReitzNDF_default.a,
  burleyBRDF: burleyBRDF_default.a,
  lambertBRDF: lambertBRDF_default.a,
  specularBRDF: specularBRDF_default.a,
  materialPBR: materialPBR_default.a,
  lightFragContext: lightFragContext_default.a,
  lightsParamsFrag: lightsParamsFrag_default.a,
  materialPBRFrag: materialPBRFrag_default.a,
  attenuation: attenuation_default.a,
  toneMappingFragParams: toneMappingFragParams_default.a,
  rgbToSrgbFunc: rgbToSrgbFunc_default.a,
  shadowMapParamsFrag: shadowMapParamsFrag_default.a,
  directShadowCastersFrag: directShadowCastersFrag_default.a,
  spotShadowCastersFrag: spotShadowCastersFrag_default.a,
  omniShadowCastersFrag: omniShadowCastersFrag_default.a,
  emissiveMapParamsVert: emissiveMapParamsVert_default.a,
  emissiveMapFrag: emissiveMapFrag_default.a,
  emissiveMapParamsFrag: emissiveMapParamsFrag_default.a,
  morphParamsVert: morphParamsVert_default.a,
  clearCoatFrag: clearCoatFrag_default.a
};
/* harmony default export */ var chunks = (ShaderChunks);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/shaderLib/index.js















const ShaderLib = {
  unlitMeshShader: {
    name: 'UNLIT_MESH_SHADER',
    extensions: {},
    defines: {},
    vertexShader: unlit_default.a,
    fragmentShader: shaders_unlit_default.a
  },
  pbrMeshShader: {
    name: 'PBR_MESH_SHADER',
    extensions: {},
    defines: {},
    vertexShader: pbr_default.a,
    fragmentShader: shaders_pbr_default.a
  },
  environmentShader: {
    name: 'ENVIROMENT_SHADER',
    extensions: {},
    defines: {},
    vertexShader: farplane_default.a,
    fragmentShader: environment_default.a
  },
  convolutionShader: {
    name: 'CONVOLUTION_SHADER',
    extensions: {},
    defines: {},
    vertexShader: farplane_default.a,
    fragmentShader: convolution_default.a
  },
  spriteShader: {
    name: 'SPRITE_SHADER',
    extensions: {},
    defines: {},
    vertexShader: sprite_default.a,
    fragmentShader: shaders_unlit_default.a
  },
  depthShader: {
    name: 'DEPTH_SHADER',
    extensions: {},
    defines: {},
    vertexShader: depth_default.a,
    fragmentShader: shaders_depth_default.a
  },
  lineShader: {
    name: 'LINE_SHADER',
    extensions: {},
    defines: {},
    vertexShader: line_default.a,
    fragmentShader: shaders_line_default.a
  },
  copyShader: {
    name: 'COPY_SHADER',
    extensions: {},
    defines: {},
    vertexShader: screenquad_default.a,
    fragmentShader: copy_default.a
  }
};
/* harmony default export */ var shaderLib = (ShaderLib);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/depthMaterial.js



const depthShader = ShaderLib.depthShader;
class depthMaterial_DepthMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$alphaMode = properties.alphaMode,
          alphaMode = _properties$alphaMode === void 0 ? material_Material.AlphaMode.OPAQUE : _properties$alphaMode,
          _properties$alphaCuto = properties.alphaCutoff,
          alphaCutoff = _properties$alphaCuto === void 0 ? 0.0 : _properties$alphaCuto,
          _properties$opacity = properties.opacity,
          opacity = _properties$opacity === void 0 ? 1 : _properties$opacity,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.BACK : _properties$cullFace,
          defines = properties.defines;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this.isDepthMaterial = true;
    this.opacity = opacity;
    const vertexShader = depthShader.vertexShader,
          fragmentShader = depthShader.fragmentShader;
    this._shaders = {
      name: depthShader.name,
      extensions: {},
      defines: {
        VIEW_TO_CLIP_POSITION: '',
        OMNI_DIRECTIONAL_CASTERS_ZFAR: 100,
        ...defines
      },
      vertexShader,
      fragmentShader
    };
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const alphaMode = this.alphaMode,
          opacity = this.opacity;
    const program = technique.program,
          defines = technique.defines;
    const layout = program.layout;
    const uniforms = layout.uniforms;

    if (defines.VIEW_TO_CLIP_POSITION !== undefined) {
      const look = renderPass.look,
            renderTarget = renderPass.renderTarget;
      {
        const uniform = uniforms.get('viewMatrix');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        if (look.isCubeCamera) {
          const targetIndex = renderTarget.targetIndex;
          uniform.setValue(look.viewMatrices[targetIndex]);
        } else {
          uniform.setValue(look.viewMatrix);
        }
      }
      {
        const uniform = uniforms.get('projectionMatrix');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(look.projectionMatrix);
      }
    } else {
      const look = renderPass.look,
            renderTarget = renderPass.renderTarget;
      const uniform = uniforms.get('viewProjectionMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      if (look.isCubeCamera) {
        const targetIndex = renderTarget.targetIndex;
        uniform.setValue(look.viewProjectionMatrices[targetIndex]);
      } else {
        uniform.setValue(look.viewProjectionMatrix);
      }
    }

    if (alphaMode === material_Material.AlphaMode.MASK) {
      const uniform = uniforms.get('opacity');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(opacity);
    }

    if (renderable.hasMorph) {
      const uniform = uniforms.get('morphWeights');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(renderable.morphWeights);
    }

    this._setSkeletonMap(gl, renderable, uniforms, textures);

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    const alphaMode = this.alphaMode,
          alphaCutoff = this.alphaCutoff;

    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const defines = technique.defines;

    if (alphaMode === material_Material.AlphaMode.MASK) {
      defines.ALPHA_TEST = alphaCutoff;
    } else {
      delete defines.ALPHA_TEST;
    }

    {
      const positionMorphTargetCount = renderable.positionMorphTargetCount,
            normalMorphTargetCount = renderable.normalMorphTargetCount;

      if (positionMorphTargetCount !== 0 && defines.POSITION_MORPH_COUNT === undefined) {
        defines.POSITION_MORPH_COUNT = positionMorphTargetCount;
      } else if (positionMorphTargetCount === 0 && defines.POSITION_MORPH_COUNT !== undefined) {
        delete defines.POSITION_MORPH_COUNT;
      }

      if (normalMorphTargetCount !== 0 && defines.NORMAL_MORPH_COUNT === undefined) {
        defines.NORMAL_MORPH_COUNT = normalMorphTargetCount;
      } else if (normalMorphTargetCount === 0 && defines.NORMAL_MORPH_COUNT !== undefined) {
        delete defines.NORMAL_MORPH_COUNT;
      }
    }
    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

  clone() {
    return new depthMaterial_DepthMaterial({
      name: this.name,
      alphaMode: this.alphaMode,
      alphaCutoff: this.alphaCutoff,
      cullFace: this.cullFace
    });
  }

}
/* harmony default export */ var depthMaterial = (depthMaterial_DepthMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/copyMaterial.js



const copyShader = ShaderLib.copyShader;
class copyMaterial_CopyMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(name) {
    const alphaMode = material_Material.AlphaMode.OPAQUE;
    const alphaCutoff = 0.0;
    const cullFace = material_Material.CullFace.BACK;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this.isCopyMaterial = true;
    this._srcRect = [0, 0, 0, 0];
    this._dstRect = [0, 0, 0, 0];
    this.srcTexture = null;
    const vertexShader = copyShader.vertexShader,
          fragmentShader = copyShader.fragmentShader;
    this._shaders = {
      name: copyShader.name,
      extensions: {},
      defines: {},
      vertexShader,
      fragmentShader
    };
  }

  get srcRect() {
    return this._srcRect;
  }

  set srcRect(value) {
    this._srcRect[0] = value[0];
    this._srcRect[1] = value[0];
    this._srcRect[2] = value[0];
    this._srcRect[3] = value[0];
  }

  get dstRect() {
    return this._dstRect;
  }

  set dstRect(value) {
    this._dstRect[0] = value[0];
    this._dstRect[1] = value[1];
    this._dstRect[2] = value[2];
    this._dstRect[3] = value[3];
  }

  get cacheKey() {
    return this._cacheKey;
  }

  get shaders() {
    return this._shaders;
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _srcRect = this._srcRect,
          _dstRect = this._dstRect,
          srcTexture = this.srcTexture;
    const program = technique.program;
    const layout = program.layout;
    const uniforms = layout.uniforms;
    {
      const uniform = uniforms.get('srcRect');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_srcRect);
    }
    {
      const uniform = uniforms.get('srcDest');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_dstRect);
    }
    {
      const uniform = uniforms.get('src');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      this._setTexture(gl, uniform, srcTexture, textures);
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const defines = technique.defines;
    this._cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

  clone() {
    return new copyMaterial_CopyMaterial(this.name);
  }

}
/* harmony default export */ var materials_copyMaterial = (copyMaterial_CopyMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLContextType.js
var WebGLContextType;

(function (WebGLContextType) {
  WebGLContextType["NONE"] = "";
  WebGLContextType["WEB_GL"] = "webgl";
  WebGLContextType["WEB_GL_EXPERIMENTAL"] = "experimental-webgl";
  WebGLContextType["WEB_GL_2"] = "webgl2";
  WebGLContextType["WEB_GL_2_EXPERIMENTAL"] = "experimental-webgl2";
})(WebGLContextType || (WebGLContextType = {}));

function hasWebGL2Support(gl) {
  return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
}
function testWebGLContext(gl) {
  let isWebGLContext = false;
  let isWebGL2Context = false;

  if (hasWebGL2Support(gl)) {
    isWebGLContext = true;
    isWebGL2Context = true;
  } else if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    isWebGLContext = true;
    isWebGL2Context = false;
  }

  return {
    isWebGLContext,
    isWebGL2Context
  };
}
/* harmony default export */ var webGLContextType = (WebGLContextType);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLBuffer.js


class OutOfMemoryError extends Error {
  constructor() {
    super('out of memory error');
  }

}

class webGLBuffer_WebGLBuffer {
  constructor(gl, size, bindingPoint, usage) {
    const _testWebGLContext = testWebGLContext(gl),
          isWebGLContext = _testWebGLContext.isWebGLContext,
          isWebGL2Context = _testWebGLContext.isWebGL2Context;

    if (false) {}

    const buffer = gl.createBuffer();
    this._buffer = buffer;
    this._gl = gl;
    this._size = size;
    this._bindingPoint = bindingPoint;
    gl.bindBuffer(bindingPoint, buffer);
    {
      const error = gl.getError();

      if (error !== gl.NO_ERROR) {
        if (error === gl.INVALID_OPERATION) {
          throw new Error('error on attempt to bind buffer, INVALID_OPERATION');
        }

        if (false) {}
      }
    }
    gl.bufferData(bindingPoint, size, usage);
    {
      const error = gl.getError();

      if (error !== gl.NO_ERROR) {
        if (error === gl.OUT_OF_MEMORY) {
          throw new OutOfMemoryError();
        }

        if (error === gl.INVALID_VALUE) {
          throw new Error(`INVALID_VALUE on attempt to allocate ${size} bytes of memory`);
        }

        if (false) {}

        if (false) {}
      }
    }
    gl.bindBuffer(bindingPoint, null);
  }

  dispose() {
    this._gl.deleteBuffer(this._buffer);
  }

  subdata(source, offset) {
    const gl = this._gl,
          bindingPoint = this._bindingPoint;

    const _testWebGLContext2 = testWebGLContext(gl),
          isWebGL2Context = _testWebGLContext2.isWebGL2Context;

    gl.bindBuffer(bindingPoint, this._buffer);

    if (isWebGL2Context) {
      gl.bufferSubData(bindingPoint, offset, source);
    } else {
      gl.bufferSubData(bindingPoint, offset, source);
    }
  }

  get buffer() {
    return this._buffer;
  }

  get bindingPoint() {
    return this._bindingPoint;
  }

  get size() {
    return this._size;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/types.js
var ShaderExtensionBehaviour;

(function (ShaderExtensionBehaviour) {
  ShaderExtensionBehaviour["ENABLE"] = "enable";
  ShaderExtensionBehaviour["REQUIRE"] = "require";
  ShaderExtensionBehaviour["WARN"] = "warn";
  ShaderExtensionBehaviour["DISABLE"] = "disable";
})(ShaderExtensionBehaviour || (ShaderExtensionBehaviour = {}));
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLExtensions.js


class webGLExtensions_WebGLExtensions {
  constructor(gl) {
    const _testWebGLContext = testWebGLContext(gl),
          isWebGLContext = _testWebGLContext.isWebGLContext,
          isWebGL2Context = _testWebGLContext.isWebGL2Context;

    const gl2 = gl;
    const extensions = new Map();

    if (false) {}

    const _getLostContextExtension = () => {
      return gl.getExtension('WEBGL_lose_context') || gl.getExtension('WEBKIT_WEBGL_lose_contex') || gl.getExtension('MOZ_WEBGL_lose_context');
    };

    const _getWebGL2DrawBuffersExtension = () => {
      return {
        COLOR_ATTACHMENT0_WEBGL: gl.COLOR_ATTACHMENT0,
        COLOR_ATTACHMENT1_WEBGL: gl2.COLOR_ATTACHMENT1,
        COLOR_ATTACHMENT2_WEBGL: gl2.COLOR_ATTACHMENT2,
        COLOR_ATTACHMENT3_WEBGL: gl2.COLOR_ATTACHMENT3,
        COLOR_ATTACHMENT4_WEBGL: gl2.COLOR_ATTACHMENT4,
        COLOR_ATTACHMENT5_WEBGL: gl2.COLOR_ATTACHMENT5,
        COLOR_ATTACHMENT6_WEBGL: gl2.COLOR_ATTACHMENT6,
        COLOR_ATTACHMENT7_WEBGL: gl2.COLOR_ATTACHMENT7,
        COLOR_ATTACHMENT8_WEBGL: gl2.COLOR_ATTACHMENT8,
        COLOR_ATTACHMENT9_WEBGL: gl2.COLOR_ATTACHMENT9,
        COLOR_ATTACHMENT10_WEBGL: gl2.COLOR_ATTACHMENT10,
        COLOR_ATTACHMENT11_WEBGL: gl2.COLOR_ATTACHMENT11,
        COLOR_ATTACHMENT12_WEBGL: gl2.COLOR_ATTACHMENT12,
        COLOR_ATTACHMENT13_WEBGL: gl2.COLOR_ATTACHMENT13,
        COLOR_ATTACHMENT14_WEBGL: gl2.COLOR_ATTACHMENT14,
        COLOR_ATTACHMENT15_WEBGL: gl2.COLOR_ATTACHMENT15,
        DRAW_BUFFER0_WEBGL: gl2.DRAW_BUFFER0,
        DRAW_BUFFER1_WEBGL: gl2.DRAW_BUFFER1,
        DRAW_BUFFER2_WEBGL: gl2.DRAW_BUFFER2,
        DRAW_BUFFER3_WEBGL: gl2.DRAW_BUFFER3,
        DRAW_BUFFER4_WEBGL: gl2.DRAW_BUFFER4,
        DRAW_BUFFER5_WEBGL: gl2.DRAW_BUFFER5,
        DRAW_BUFFER6_WEBGL: gl2.DRAW_BUFFER6,
        DRAW_BUFFER7_WEBGL: gl2.DRAW_BUFFER7,
        DRAW_BUFFER8_WEBGL: gl2.DRAW_BUFFER8,
        DRAW_BUFFER9_WEBGL: gl2.DRAW_BUFFER9,
        DRAW_BUFFER10_WEBGL: gl2.DRAW_BUFFER10,
        DRAW_BUFFER11_WEBGL: gl2.DRAW_BUFFER11,
        DRAW_BUFFER12_WEBGL: gl2.DRAW_BUFFER12,
        DRAW_BUFFER13_WEBGL: gl2.DRAW_BUFFER13,
        DRAW_BUFFER14_WEBGL: gl2.DRAW_BUFFER14,
        DRAW_BUFFER15_WEBGL: gl2.DRAW_BUFFER15,
        MAX_COLOR_ATTACHMENTS_WEBGL: gl2.MAX_COLOR_ATTACHMENTS,
        MAX_DRAW_BUFFERS_WEBGL: gl2.MAX_DRAW_BUFFERS,
        drawBuffersWEBGL: buffers => {
          gl2.drawBuffers(buffers);
        }
      };
    };

    const _get2 = name => {
      let extension = null;

      if (false) {}

      if (false) {}

      switch (name) {
        case 'OES_fbo_render_mipmap':
        case 'EXT_shader_texture_lod':
        case 'EXT_frag_depth':
          extension = {};
          break;

        case 'EXT_disjoint_timer_query_webgl2':
        case 'EXT_disjoint_timer_query':
          extension = gl.getExtension('EXT_disjoint_timer_query_webgl2');
          break;

        case 'OES_texture_half_float':
          extension = {
            HALF_FLOAT_OES: gl2.HALF_FLOAT
          };
          break;

        case 'WEBGL_lose_context':
          extension = _getLostContextExtension();
          break;

        case 'OES_standard_derivatives':
          extension = {
            FRAGMENT_SHADER_DERIVATIVE_HINT_OES: gl2.FRAGMENT_SHADER_DERIVATIVE_HINT
          };
          break;

        case 'OES_vertex_array_object':
          extension = {
            VERTEX_ARRAY_BINDING_OES: gl2.VERTEX_ARRAY_BINDING,
            createVertexArrayOES: () => {
              return gl2.createVertexArray();
            },
            deleteVertexArrayOES: arrayObject => {
              gl2.deleteVertexArray(arrayObject);
            },
            isVertexArrayOES: arrayObject => {
              return gl2.isVertexArray(arrayObject);
            },
            bindVertexArrayOES: arrayObject => {
              gl2.bindVertexArray(arrayObject);
            }
          };
          break;

        case 'WEBGL_debug_renderer_info':
        case 'WEBGL_debug_shaders':
        case 'EXT_float_blend':
        case 'WEBGL_shared_resources':
        case 'WEBGL_get_buffer_sub_data_async':
        case 'WEBGL_security_sensitive_resources':
        case 'EXT_texture_filter_anisotropic':
        case 'EXT_color_buffer_float':
        case 'OES_texture_float_linear':
        case 'WEBGL_compressed_texture_atc':
        case 'WEBGL_compressed_texture_etc1':
        case 'WEBGL_compressed_texture_astc':
        case 'WEBGL_compressed_texture_s3tc_srgb':
        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension(name);
          break;

        case 'EXT_blend_minmax':
        case 'OES_element_index_uint':
          extension = {};
          break;

        case 'WEBGL_depth_texture':
          extension = {
            UNSIGNED_INT_24_8_WEBGL: gl2.UNSIGNED_INT_24_8
          };
          break;

        case 'WEBGL_draw_buffers':
          extension = _getWebGL2DrawBuffersExtension();
          break;

        case 'ANGLE_instanced_arrays':
          extension = {
            VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: gl2.VERTEX_ATTRIB_ARRAY_DIVISOR,
            drawArraysInstancedANGLE: (mode, first, count, instanceCount) => {
              gl2.drawArraysInstanced(mode, first, count, instanceCount);
            },
            drawElementsInstancedANGLE: (mode, count, type, offset, instanceCount) => {
              gl2.drawElementsInstanced(mode, count, type, offset, instanceCount);
            },
            vertexAttribDivisorANGLE: (index, divisor) => {
              gl2.vertexAttribDivisor(index, divisor);
            }
          };
          break;

        case 'EXT_sRGB':
          extension = {
            SRGB_EXT: gl2.SRGB,
            SRGB_ALPHA_EXT: gl2.SRGB8_ALPHA8,
            SRGB8_ALPHA8_EXT: gl2.SRGB8_ALPHA8,
            FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: gl2.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING
          };
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension(name) || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      return extension;
    };

    const _get = name => {
      let extension = null;

      switch (name) {
        case 'WEBGL_lose_context':
          extension = _getLostContextExtension();
          break;

        case 'OES_fbo_render_mipmap':
        case 'OES_texture_float':
        case 'OES_texture_half_float':
        case 'OES_texture_float_linear':
        case 'OES_texture_half_float_linear':
        case 'OES_standard_derivatives':
        case 'OES_vertex_array_object':
        case 'WEBGL_debug_renderer_info':
        case 'WEBGL_debug_shaders':
        case 'OES_element_index_uint':
        case 'EXT_texture_filter_anisotropic':
        case 'EXT_frag_depth':
        case 'EXT_blend_minmax':
        case 'EXT_shader_texture_lod':
        case 'EXT_color_buffer_half_float':
        case 'EXT_sRGB':
        case 'EXT_disjoint_timer_query':
        case 'WEBGL_shared_resources':
        case 'WEBGL_security_sensitive_resources':
        case 'WEBGL_color_buffer_float':
        case 'WEBGL_draw_buffers':
        case 'ANGLE_instanced_arrays':
        case 'EXT_float_blend':
        case 'WEBGL_compressed_texture_atc':
        case 'WEBGL_compressed_texture_etc1':
        case 'WEBGL_compressed_texture_astc':
        case 'WEBGL_compressed_texture_s3tc_srgb':
        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension(name);
          break;

        case 'WEBGL_depth_texture':
          extension = gl.getExtension(name) || gl.getExtension('WEBKIT_WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture');
          break;

        case 'WEBGL_get_buffer_sub_data_async':
          throw Error('can not use WEBGL_get_buffer_sub_data_async in WebGL 1.0 RenderingContext');

        case 'EXT_disjoint_timer_query_webgl2':
          throw Error('do not use EXT_disjoint_timer_query_webgl2 in WebGL 1.0 RenderingContext, use EXT_disjoint_timer_query instead');

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension(name) || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
          break;
      }

      return extension;
    };

    this.get = name => {
      if (!extensions.has(name)) {
        extensions.set(name, isWebGL2Context ? _get2(name) : _get(name));
      }

      return extensions.get(name) || null;
    };
  }

  static get ShaderExtensionBehaviour() {
    return ShaderExtensionBehaviour;
  }

}
/* harmony default export */ var webGLExtensions = (webGLExtensions_WebGLExtensions);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLCapabilities.js

class webGLCapabilities_WebGLCapabilities {
  constructor(gl, extensions) {
    const webgl2Support = hasWebGL2Support(gl);
    this._webgl2Support = webgl2Support;
    this._gles3Support = webgl2Support;
    this._maxMSAASize = webgl2Support ? gl.getParameter(gl.MAX_SAMPLES) : 1;
    {
      const extension = extensions.get('EXT_texture_filter_anisotropic');
      const maxAnisotropy = extension !== null ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      this.filterAnisotropySupport = maxAnisotropy > 0;
      this.maxAnisotropy = maxAnisotropy;
    }
    {
      let precision = 'highp';

      if (gl.getShaderPrecisionFormat) {
        const vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
        const vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
        const fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        const fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
        const highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
        const mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

        if (!highpAvailable) {
          if (!mediumpAvailable) {
            precision = 'mediump';
          } else {
            precision = 'lowp';
          }
        }
      }

      this._precision = precision;
    }
    this._vaoSupport = extensions.get('OES_vertex_array_object') !== null;
    this._uintIndexSupport = extensions.get('OES_element_index_uint') !== null;
    this._textureFloatSupport = webgl2Support ? true : extensions.get('OES_texture_float') !== null;
    this._textureHalfFloatSupport = webgl2Support ? true : extensions.get('OES_texture_half_float') !== null;
    this._textureFloatLinearSupport = extensions.get('OES_texture_float_linear') !== null;
    this._textureHalfFloatLinearSupport = webgl2Support ? true : extensions.get('OES_texture_half_float_linear') !== null;
    this._colorBufferFloatSupport = webgl2Support && extensions.get('EXT_color_buffer_float') !== null || !webgl2Support && extensions.get('WEBGL_color_buffer_float') !== null;
    this._colorBufferHalfFloatSupport = webgl2Support && extensions.get('EXT_color_buffer_float') !== null || !webgl2Support && extensions.get('EXT_color_buffer_half_float') !== null;
    this._maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    {
      const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this._maxVertexTextures = maxVertexTextures;
      this._vertexTextures = maxVertexTextures > 0;
    }
    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

    this._maxCubemapSize = () => gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

    this._maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._maxInterpolators = gl.getParameter(gl.MAX_VARYING_VECTORS);
    this._maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    this._sRGBSupport = extensions.get('EXT_sRGB') !== null;
    this._shaderTextureLodSupport = extensions.get('EXT_shader_texture_lod') !== null;
    this._depthTextureSupport = extensions.get('WEBGL_depth_texture') !== null;
    this._floatBlend = extensions.get('EXT_float_blend') !== null && this._colorBufferFloatSupport;
    {
      const ext = extensions.get('WEBGL_draw_buffers');
      const maxColorAttachments = ext !== null ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
      const maxDrawBuffers = ext !== null ? gl.getParameter(ext.MAX_DRAW_BUFFERS_WEBGL) : 1;
      this.mrtSupport = maxColorAttachments > 1 && maxDrawBuffers > 1;
      this.maxColorAttachments = maxColorAttachments;
      this.maxDrawBuffers = maxDrawBuffers;
    }
  }

  get webgl2Support() {
    return this._webgl2Support;
  }

  get gles3Support() {
    return this._gles3Support;
  }

  get maxMSAASize() {
    return this._maxMSAASize;
  }

  get precision() {
    return this._precision;
  }

  get vaoSupport() {
    return this._vaoSupport;
  }

  get vertexTextures() {
    return this._vertexTextures;
  }

  get maxVertexTextures() {
    return this._maxVertexTextures;
  }

  get maxTextures() {
    return this._maxTextures;
  }

  get maxTextureSize() {
    return this._maxTextureSize;
  }

  get maxCubemapSize() {
    return this._maxCubemapSize;
  }

  get maxAttributes() {
    return this._maxAttributes;
  }

  get maxVertexUniforms() {
    return this._maxVertexUniforms;
  }

  get maxInterpolators() {
    return this._maxInterpolators;
  }

  get maxFragmentUniforms() {
    return this._maxFragmentUniforms;
  }

  get nonPowerOfTwoTextureSupport() {
    return this.webgl2Support;
  }

  get uintIndexSupport() {
    return this._uintIndexSupport;
  }

  get textureFloatSupport() {
    return this._textureFloatSupport;
  }

  get colorBufferFloatSupport() {
    return this._colorBufferFloatSupport;
  }

  get colorBufferHalfFloatSupport() {
    return this._colorBufferHalfFloatSupport;
  }

  get textureHalfFloatSupport() {
    return this._textureHalfFloatSupport;
  }

  get textureFloatLinearSupport() {
    return this._textureFloatLinearSupport;
  }

  get textureHalfFloatLinearSupport() {
    return this._textureHalfFloatLinearSupport;
  }

  get sRGBSupport() {
    return this._sRGBSupport;
  }

  get shaderTextureLodSupport() {
    return this._shaderTextureLodSupport;
  }

  get depthTextureSupport() {
    return this._depthTextureSupport;
  }

  get floatBlend() {
    return this._floatBlend;
  }

}
/* harmony default export */ var webGLCapabilities = (webGLCapabilities_WebGLCapabilities);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLAttributes/binding.js
function binding_slicedToArray(arr, i) { return binding_arrayWithHoles(arr) || binding_iterableToArrayLimit(arr, i) || binding_unsupportedIterableToArray(arr, i) || binding_nonIterableRest(); }

function binding_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function binding_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return binding_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return binding_arrayLikeToArray(o, minLen); }

function binding_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function binding_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function binding_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




const _bindVertexInput = (ctx, batch, layout, vbo, ibo, ebo, bytesPerInstance, layout2) => {
  const gl = ctx.context,
        ext = ctx.instancedArraysAPI;
  const geometry = batch.geometry,
        firstInstance = batch.firstInstance;
  const attributes = geometry.attributes;
  const attributesLayout = layout.attributes;
  gl.bindBuffer(ebo.bindingPoint, ebo.buffer);
  gl.bindBuffer(vbo.bindingPoint, vbo.buffer);

  for (const _ref of attributesLayout.entries()) {
    var _ref2 = binding_slicedToArray(_ref, 2);

    const semantic = _ref2[0];
    const attributeLayout = _ref2[1];
    const instanced = attributeLayout.instanced,
          location = attributeLayout.location,
          active = attributeLayout.active;

    if (instanced || !active) {
      continue;
    }

    const attribute = attributes.get(semantic);

    if (false) {}

    const countComponents = attribute.countComponents,
          componentType = attribute.componentType,
          normalized = attribute.normalized,
          stride = attribute.stride,
          view = attribute.view;
    const offset = view.byteOffset;
    gl.enableVertexAttribArray(location);
    ext.vertexAttribDivisorANGLE(location, 0);
    gl.vertexAttribPointer(location, countComponents, componentType, normalized, stride, offset);
  }

  gl.bindBuffer(ibo.bindingPoint, ibo.buffer);

  for (const _ref3 of attributesLayout.entries()) {
    var _ref4 = binding_slicedToArray(_ref3, 2);

    const semantic = _ref4[0];
    const attributeLayout = _ref4[1];
    const instanced = attributeLayout.instanced,
          location = attributeLayout.location,
          countComponents = attributeLayout.countComponents,
          divisor = attributeLayout.divisor,
          active = attributeLayout.active;

    if (!instanced || !active) {
      continue;
    }

    const type = gl.FLOAT;
    const normalized = false;
    const stride = bytesPerInstance;
    let offset = firstInstance * stride;

    switch (semantic) {
      case AttributeSemantic.INSTANCE_IDENTIFIERS:
        offset += 48;
        break;

      case AttributeSemantic.INSTANCE_TRANSFORM_1:
        offset += 0;
        break;

      case AttributeSemantic.INSTANCE_TRANSFORM_2:
        offset += 16;
        break;

      case AttributeSemantic.INSTANCE_TRANSFORM_3:
        offset += 32;
        break;

      default:
        {
          const customInstancedAttribute = layout2.get(semantic);

          if (customInstancedAttribute === undefined) {
            continue;
          }

          offset += customInstancedAttribute.byteOffset;
        }
    }

    gl.enableVertexAttribArray(location);
    ext.vertexAttribDivisorANGLE(location, divisor);
    gl.vertexAttribPointer(location, countComponents, type, normalized, stride, offset);
  }
};

const _bindVAO = (ctx, batch, layout, vbo, ibo, ebo, stride, layout2) => {
  const ext = ctx.vaoAPI;
  const version = layout.version;

  if (version !== batch.vaoLayoutVersion) {
    const _batch$vao = batch.vao,
          vao = _batch$vao === void 0 ? null : _batch$vao;

    if (vao !== null) {
      ext.deleteVertexArrayOES(vao);
      batch.vao = null;
    }
  }

  if (batch.vao === null) {
    batch.webGLAttributeSystem = ctx;
    batch.vao = ext.createVertexArrayOES();
    ext.bindVertexArrayOES(batch.vao);

    _bindVertexInput(ctx, batch, layout, vbo, ibo, ebo, stride, layout2);

    ext.bindVertexArrayOES(null);
    batch.vaoLayoutVersion = version;
  }

  ext.bindVertexArrayOES(batch.vao);
};

const _bindDepthVAO = (ctx, batch, layout, vbo, ibo, ebo, stride, layout2) => {
  const ext = ctx.vaoAPI;
  const version = layout.version;

  if (version !== batch.depthVaoLayoutVersion) {
    const _batch$depthVao = batch.depthVao,
          depthVao = _batch$depthVao === void 0 ? null : _batch$depthVao;

    if (depthVao !== null) {
      ext.deleteVertexArrayOES(depthVao);
      batch.depthVao = null;
    }
  }

  if (batch.depthVao === null) {
    batch.webGLAttributeSystem = ctx;
    batch.depthVao = ext.createVertexArrayOES();
    ext.bindVertexArrayOES(batch.depthVao);

    _bindVertexInput(ctx, batch, layout, vbo, ibo, ebo, stride, layout2);

    ext.bindVertexArrayOES(null);
    batch.depthVaoLayoutVersion = version;
  }

  ext.bindVertexArrayOES(batch.depthVao);
};

const _unbindVAO = ctx => {
  const ext = ctx.vaoAPI;
  ext.bindVertexArrayOES(null);
};

const _unbindVertexInput = (ctx, layout) => {
  const gl = ctx.context;
  const attributesLayout = layout.attributes;

  for (const _ref5 of attributesLayout.values()) {
    const location = _ref5.location;
    gl.disableVertexAttribArray(location);
  }
};


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLAttributes/index.js

class webGLAttributes_WebGLAttributes {
  constructor(parameters) {
    const gl = parameters.gl,
          capabilities = parameters.capabilities,
          extensions = parameters.extensions;
    const vaoSupport = capabilities.vaoSupport;
    this.context = gl;
    this.vaoAPI = extensions.get('OES_vertex_array_object');
    this.instancedArraysAPI = extensions.get('ANGLE_instanced_arrays');
    this._bindVertexInput = vaoSupport ? _bindVAO : _bindVertexInput;
    this._bindDepthVertexInput = vaoSupport ? _bindDepthVAO : _bindVertexInput;
    this._unbindVertexInput = vaoSupport ? _unbindVAO : _unbindVertexInput;
  }

  bindVertexInput(batch, inputLayout, instanceLayout, instancedDataStride, vbo, ibo, ebo) {
    this._bindVertexInput(this, batch, inputLayout, vbo, ibo, ebo, instancedDataStride, instanceLayout);
  }

  bindDepthVertexInput(batch, inputLayout, instanceLayout, instancedDataStride, vbo, ibo, ebo) {
    this._bindDepthVertexInput(this, batch, inputLayout, vbo, ibo, ebo, instancedDataStride, instanceLayout);
  }

  unbindVertexInput(inputLayout) {
    this._unbindVertexInput(this, inputLayout);
  }

  deleteRenderable(batch) {
    const ext = this.vaoAPI;
    const _batch$vao = batch.vao,
          vao = _batch$vao === void 0 ? null : _batch$vao,
          _batch$depthVao = batch.depthVao,
          depthVao = _batch$depthVao === void 0 ? null : _batch$depthVao;

    if (vao !== null) {
      ext.deleteVertexArrayOES(vao);
      batch.vao = null;
    }

    if (depthVao !== null) {
      ext.deleteVertexArrayOES(depthVao);
      batch.depthVao = null;
    }
  }

}
/* harmony default export */ var renderer_webGLAttributes = (webGLAttributes_WebGLAttributes);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLTextures.js


const emptyLevelData = new texture_resource_TextureLevelData({
  data: null
});

function _adjustComponentType(texture, extensions) {
  const componentType = texture.componentType;

  if (componentType === dataTypes_DataType.HALF_FLOAT) {
    const ext = extensions.get('OES_texture_half_float');

    if (ext === null) {
      throw new Error(`device does not support component type HALF_FLOAT (${componentType})`);
    }

    texture.componentType = ext.HALF_FLOAT_OES;
  }
}

function _adjustInternalFormat(texture, extensions, webGL2Support) {
  const internalFormat = texture.internalFormat;

  if (!webGL2Support && (internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8)) {
    if (internalFormat === InternalFormat.SRGB8_ALPHA8) {
      texture.internalFormat = InternalFormat.RGBA;
      texture._gammaDecode = true;
    } else if (internalFormat === InternalFormat.SRGB8) {
      texture.internalFormat = InternalFormat.RGB;
      texture._gammaDecode = true;
    }
  } else if (webGL2Support && internalFormat === InternalFormat.SRGB8) {
    texture.internalFormat = InternalFormat.RGB8;
    texture._gammaDecode = true;
  }
}

const isCustomImageData = data => Boolean(data && data.isCustomImageData);

function _adjustCustomImageData(texture) {
  const _levelsData = texture._levelsData;

  for (const _ref of _levelsData) {
    const data = _ref.data;

    if (!isCustomImageData(data)) {
      continue;
    }

    const imageType = data.imageType;

    switch (imageType) {
      case CustomImageData.Type.RGBE:
        {
          const _extraBuffer = data._extraBuffer;
          data.buffer = _extraBuffer;
          const obj = {
            internalFormat: InternalFormat.RGBA,
            componentType: dataTypes_DataType.FLOAT
          };
          Object.assign(texture, obj);
          Object.assign(data, obj);
        }
        break;

      default:
        if (false) {}

        break;
    }
  }
}

function _getBestInternalFormat(format, componentType, webgl2Support) {
  if (format === PixelDataFormat.RGB) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return webgl2Support ? InternalFormat.RGB8 : InternalFormat.RGB;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_SHORT_5_6_5) {
      return webgl2Support ? InternalFormat.RGB565 : InternalFormat.RGB;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_INT_10F_11F_11F_REV && webgl2Support) {
      return InternalFormat.R11F_G11F_B10F;
    }

    if (componentType === dataTypes_DataType.HALF_FLOAT && webgl2Support) {
      return InternalFormat.RGB16F;
    }

    if (componentType === dataTypes_DataType.FLOAT && webgl2Support) {
      return InternalFormat.RGB32F;
    }
  } else if (format === PixelDataFormat.RGBA) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return webgl2Support ? InternalFormat.RGBA8 : InternalFormat.RGBA;
    }

    if (componentType === dataTypes_DataType.HALF_FLOAT && webgl2Support) {
      return InternalFormat.RGBA16F;
    }

    if (componentType === dataTypes_DataType.FLOAT) {
      return webgl2Support ? InternalFormat.RGBA32F : InternalFormat.RGBA;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_SHORT_4_4_4_4) {
      return webgl2Support ? InternalFormat.RGBA4 : InternalFormat.RGBA;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_SHORT_5_5_5_1) {
      return webgl2Support ? InternalFormat.RGB5_A1 : InternalFormat.RGBA;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_INT_2_10_10_10_REV && webgl2Support) {
      return InternalFormat.RGB10_A2;
    }
  } else if (format === PixelDataFormat.LUMINANCE_ALPHA) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.LUMINANCE_ALPHA;
    }
  } else if (format === PixelDataFormat.LUMINANCE) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.LUMINANCE;
    }
  } else if (format === PixelDataFormat.ALPHA) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.ALPHA;
    }
  } else if (format === PixelDataFormat.RED && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.R8;
    }

    if (componentType === dataTypes_DataType.HALF_FLOAT) {
      return InternalFormat.R16F;
    }

    if (componentType === dataTypes_DataType.FLOAT) {
      return InternalFormat.R32F;
    }
  } else if (format === PixelDataFormat.RED_INTEGER && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.R8UI;
    }
  } else if (format === PixelDataFormat.RG && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.RG8;
    }

    if (componentType === dataTypes_DataType.HALF_FLOAT) {
      return InternalFormat.RG16F;
    }

    if (componentType === dataTypes_DataType.FLOAT) {
      return InternalFormat.RG32F;
    }
  } else if (format === PixelDataFormat.RG_INTEGER && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.RG8UI;
    }
  } else if (format === PixelDataFormat.RGB_INTEGER && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.RGB8UI;
    }
  } else if (format === PixelDataFormat.RGBA_INTEGER && webgl2Support) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.RGBA8UI;
    }
  } else if (format === PixelDataFormat.DEPTH_COMPONENT) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.DEPTH_COMPONENT;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_SHORT) {
      return InternalFormat.DEPTH_COMPONENT16;
    }

    if (componentType === dataTypes_DataType.FLOAT) {
      return InternalFormat.DEPTH_COMPONENT32F;
    }
  } else if (format === PixelDataFormat.DEPTH_STENCIL) {
    if (componentType === dataTypes_DataType.UNSIGNED_BYTE) {
      return InternalFormat.DEPTH_STENCIL;
    }

    if (componentType === dataTypes_DataType.UNSIGNED_INT_24_8) {
      return InternalFormat.DEPTH24_STENCIL8;
    }

    if (componentType === dataTypes_DataType.FLOAT_32_UNSIGNED_INT_24_8_REV && webgl2Support) {
      return InternalFormat.DEPTH32F_STENCIL8;
    }
  }

  throw new Error(`could not choose suit internal format for format ${format} and type ${componentType}`);
}

function _getMipmapsCount(w, h, d, bindingPoint, webgl2Support) {
  if (!(Object(lib["u" /* isPow2 */])(w) && Object(lib["u" /* isPow2 */])(h)) && !webgl2Support) {
    return 1;
  }

  let maxsize = Math.max(w, h);

  if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_3D) {
    maxsize = Math.max(maxsize, d);
  }

  return Math.floor(Math.log2(maxsize)) + 1;
}

function _subImage2D(gl, bindingPoint, level, format, type, baseWidth, baseHeight, levelData, webgl2Support) {
  const _levelData$xoffset = levelData.xoffset,
        xoffset = _levelData$xoffset === void 0 ? 0 : _levelData$xoffset,
        _levelData$yoffset = levelData.yoffset,
        yoffset = _levelData$yoffset === void 0 ? 0 : _levelData$yoffset,
        _levelData$width = levelData.width,
        width = _levelData$width === void 0 ? baseWidth : _levelData$width,
        _levelData$height = levelData.height,
        height = _levelData$height === void 0 ? baseHeight : _levelData$height,
        data = levelData.data;
  const gl2 = gl;

  if (type === gl.UNSIGNED_BYTE && data instanceof Uint8Array || (type === gl.UNSIGNED_SHORT || type === gl.UNSIGNED_SHORT_5_6_5 || type === gl.UNSIGNED_SHORT_5_5_5_1 || type === gl.UNSIGNED_SHORT_4_4_4_4 || type === gl2.HALF_FLOAT) && data instanceof Uint16Array || (type === gl2.UNSIGNED_INT_5_9_9_9_REV || type === gl2.UNSIGNED_INT_2_10_10_10_REV || type === gl2.UNSIGNED_INT_10F_11F_11F_REV || type === gl2.UNSIGNED_INT_24_8) && data instanceof Uint32Array || (type === gl.FLOAT || type === gl2.FLOAT_32_UNSIGNED_INT_24_8_REV) && data instanceof Float32Array) {
    if (webgl2Support) {
      const srcOffset = 0;
      gl2.texSubImage2D(bindingPoint, level, xoffset, yoffset, width, height, format, type, data, srcOffset);
    } else {
      gl.texSubImage2D(bindingPoint, level, xoffset, yoffset, width, height, format, type, data);
    }
  } else if (data instanceof ImageData && format === gl.RGBA && type === gl.UNSIGNED_BYTE || data instanceof HTMLImageElement || data instanceof HTMLVideoElement || data instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
    if (webgl2Support) {
      gl2.texSubImage2D(bindingPoint, level, xoffset, yoffset, width, height, format, type, data);
    } else {
      gl.texSubImage2D(bindingPoint, level, xoffset, yoffset, format, type, data);
    }
  } else if (data instanceof CustomImageData) {
    if (webgl2Support) {
      const srcOffset = 0;
      gl2.texSubImage2D(bindingPoint, level, xoffset, yoffset, width, height, format, type, data.buffer, srcOffset);
    } else {
      gl.texSubImage2D(bindingPoint, level, xoffset, yoffset, width, height, format, type, data.buffer);
    }
  } else {
    throw new Error('can not execute texSubImage2D: image data does not correspond with type or format');
  }
}

function _texImage2D(gl, bindingPoint, level, internalFormat, format, type, baseWidth, baseHeight, levelData, webgl2Support) {
  const _levelData$width2 = levelData.width,
        width = _levelData$width2 === void 0 ? baseWidth : _levelData$width2,
        _levelData$height2 = levelData.height,
        height = _levelData$height2 === void 0 ? baseHeight : _levelData$height2,
        data = levelData.data;
  const gl2 = gl;

  if (data === null) {
    if (webgl2Support) {
      gl2.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data);
    } else {
      gl.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data);
    }
  } else if (type === gl.UNSIGNED_BYTE && data instanceof Uint8Array || (type === gl.UNSIGNED_SHORT || type === gl.UNSIGNED_SHORT_5_6_5 || type === gl.UNSIGNED_SHORT_5_5_5_1 || type === gl.UNSIGNED_SHORT_4_4_4_4 || type === gl2.HALF_FLOAT) && data instanceof Uint16Array || (type === gl2.UNSIGNED_INT_5_9_9_9_REV || type === gl2.UNSIGNED_INT_2_10_10_10_REV || type === gl2.UNSIGNED_INT_10F_11F_11F_REV || type === gl2.UNSIGNED_INT_24_8) && data instanceof Uint32Array || (type === gl.FLOAT || type === gl2.FLOAT_32_UNSIGNED_INT_24_8_REV) && data instanceof Float32Array) {
    if (webgl2Support) {
      const srcOffset = 0;
      gl.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data, srcOffset);
    } else {
      gl.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data);
    }
  } else if (data instanceof ImageData && format === gl.RGBA && type === gl.UNSIGNED_BYTE || data instanceof HTMLImageElement || data instanceof HTMLVideoElement || data instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
    if (webgl2Support) {
      gl2.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data);
    } else {
      gl.texImage2D(bindingPoint, level, internalFormat, format, type, data);
    }
  } else if (data instanceof CustomImageData) {
    if (webgl2Support) {
      const srcOffset = 0;
      gl2.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data.buffer, srcOffset);
    } else {
      gl.texImage2D(bindingPoint, level, internalFormat, width, height, 0, format, type, data.buffer);
    }
  } else {
    throw new Error('can not execute texSubImage2D: image data does not correspond with type or format');
  }
}

function _subImage3D(gl, bindingPoint, level, format, type, baseWidth, baseHeight, baseDepth, levelData) {
  const _levelData$xoffset2 = levelData.xoffset,
        xoffset = _levelData$xoffset2 === void 0 ? 0 : _levelData$xoffset2,
        _levelData$yoffset2 = levelData.yoffset,
        yoffset = _levelData$yoffset2 === void 0 ? 0 : _levelData$yoffset2,
        _levelData$zoffset = levelData.zoffset,
        zoffset = _levelData$zoffset === void 0 ? 0 : _levelData$zoffset,
        _levelData$width3 = levelData.width,
        width = _levelData$width3 === void 0 ? baseWidth : _levelData$width3,
        _levelData$height3 = levelData.height,
        height = _levelData$height3 === void 0 ? baseHeight : _levelData$height3,
        _levelData$depth = levelData.depth,
        depth = _levelData$depth === void 0 ? baseDepth : _levelData$depth,
        data = levelData.data;

  if (type === gl.UNSIGNED_BYTE && data instanceof Uint8Array || (type === gl.UNSIGNED_SHORT || type === gl.UNSIGNED_SHORT_5_6_5 || type === gl.UNSIGNED_SHORT_5_5_5_1 || type === gl.UNSIGNED_SHORT_4_4_4_4 || type === gl.HALF_FLOAT) && data instanceof Uint16Array || (type === gl.UNSIGNED_INT_5_9_9_9_REV || type === gl.UNSIGNED_INT_2_10_10_10_REV || type === gl.UNSIGNED_INT_10F_11F_11F_REV || type === gl.UNSIGNED_INT_24_8) && data instanceof Uint32Array || (type === gl.FLOAT || type === gl.FLOAT_32_UNSIGNED_INT_24_8_REV) && data instanceof Float32Array) {
    const srcOffset = 0;
    gl.texSubImage3D(bindingPoint, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data, srcOffset);
  } else if (data instanceof ImageData && format === gl.RGBA && type === gl.UNSIGNED_BYTE || data instanceof HTMLImageElement || data instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
    gl.texSubImage3D(bindingPoint, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
  } else {
    throw new Error('can not execute texSubImage2D: image data does not correspond with type or format');
  }
}

function webGLTextures_deleteDataFromTextureLevelData(levelData) {
  if (Array.isArray(levelData)) {
    for (const ld of levelData) {
      webGLTextures_deleteDataFromTextureLevelData(ld);
    }
  } else if (levelData !== undefined && levelData !== null) {
    levelData.data = null;
  }
}

class webGLTextures_WebGLTextures {
  constructor({
    gl,
    capabilities,
    extensions
  }) {
    const gl2 = gl;

    this._updateTextureLevels = texture => {
      const webgl2Support = capabilities.webgl2Support;
      const _webGLTexture = texture._webGLTexture,
            bindingPoint = texture.bindingPoint,
            format = texture.format,
            width = texture.width,
            height = texture.height,
            depth = texture.depth,
            componentType = texture.componentType,
            _levelsData = texture._levelsData,
            levels = texture.levels;
      const type = componentType;

      if (_levelsData.length === 0) {
        return;
      }

      gl.bindTexture(bindingPoint, _webGLTexture);

      if (bindingPoint === gl.TEXTURE_2D) {
        const generateMipmaps = _levelsData.length > 0 && _levelsData.length < levels;

        if (generateMipmaps) {
          _subImage2D(gl, bindingPoint, 0, format, type, width, height, _levelsData[0], webgl2Support);

          gl.generateMipmap(bindingPoint);
        } else {
          for (let i = 0; i < levels; i++) {
            _subImage2D(gl, bindingPoint, i, format, type, width, height, _levelsData[i], webgl2Support);
          }
        }
      } else if (bindingPoint === gl.TEXTURE_CUBE_MAP) {
        let generateMipmaps = false;

        for (let i = 0; i < 6; i++) {
          const faceLevels = _levelsData.length > i ? _levelsData[i] : [];

          if (!generateMipmaps && faceLevels.length > 0 && faceLevels.length < levels) {
            generateMipmaps = true;
          }

          const faceTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + i;

          for (let j = 0, count = faceLevels.length; j < count; j++) {
            _subImage2D(gl, faceTarget, j, format, type, width, height, faceLevels[j], webgl2Support);
          }
        }

        if (generateMipmaps) {
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
      } else if (bindingPoint === gl2.TEXTURE_3D && webgl2Support) {
        const generateMipmaps = _levelsData.length > 0 && _levelsData.length < levels;

        if (generateMipmaps) {
          _subImage3D(gl2, bindingPoint, 0, format, type, width, height, depth, _levelsData[0]);

          gl2.generateMipmap(bindingPoint);
        } else {
          for (let i = 0; i < levels; i++) {
            _subImage3D(gl2, bindingPoint, i, format, type, width, height, depth, _levelsData[i]);
          }
        }
      } else if (bindingPoint === gl2.TEXTURE_2D_ARRAY && webgl2Support) {
        let generateMipmaps = false;

        for (let arrayIndex = 0, arrayLength = _levelsData.length; arrayIndex < arrayLength; arrayIndex++) {
          const depthLevels = _levelsData[arrayIndex];

          if (!generateMipmaps) {
            generateMipmaps = depthLevels.length > 0 && depthLevels.length < levels;
          }

          _subImage3D(gl2, bindingPoint, 0, format, type, width, height, arrayIndex, depthLevels[0]);
        }

        if (generateMipmaps) {
          gl.generateMipmap(bindingPoint);
        }

        for (let arrayIndex = 0, arrayLength = _levelsData.length; arrayIndex < arrayLength; arrayIndex++) {
          const depthLevels = _levelsData[arrayIndex];
          const rewriteMips = depthLevels.length === levels;

          if (rewriteMips) {
            for (let lod = 1; lod < levels; lod++) {
              _subImage3D(gl2, bindingPoint, lod, format, type, width, height, arrayIndex, depthLevels[lod]);
            }
          }
        }
      }

      gl.bindTexture(bindingPoint, null);
      texture._needsUpdateLevels = false;
    };

    this.getWebGLTexture = texture => {
      if (!texture.needsUpdate) {
        if (texture._needsUpdateLevels) {
          this._updateTextureLevels(texture);
        }

        return texture;
      }

      this.disposeTexture(texture);
      texture._webGLTextureSystem = this;
      const webgl2Support = capabilities.webgl2Support;

      if (!webgl2Support) {
        _adjustCustomImageData(texture);

        _adjustComponentType(texture, extensions);
      }

      const bindingPoint = texture.bindingPoint,
            wrapS = texture.wrapS,
            wrapT = texture.wrapT,
            width = texture.width,
            height = texture.height,
            depth = texture.depth,
            componentType = texture.componentType,
            _levelsData = texture._levelsData;

      if (texture.internalFormat === null) {
        const format = texture.format;
        texture.internalFormat = _getBestInternalFormat(format, componentType, webgl2Support);
      }

      if (texture.levels === undefined) {
        texture.levels = _getMipmapsCount(width, height, depth, bindingPoint, webgl2Support);
      }

      const texId = gl.createTexture();
      gl.bindTexture(bindingPoint, texId);
      const levels = texture.levels;

      if (levels > 1) {
        if (texture.minFilter === undefined) {
          texture.minFilter = texture_resource_Texture.Filter.LINEAR_MIPMAP_LINEAR;
        }

        if (texture.magFilter === undefined) {
          texture.magFilter = texture_resource_Texture.Filter.LINEAR;
        }

        const filterAnisotropySupport = capabilities.filterAnisotropySupport,
              maxAnisotropy = capabilities.maxAnisotropy;

        if (filterAnisotropySupport && texture.minFilter === texture_resource_Texture.Filter.LINEAR_MIPMAP_LINEAR && texture.magFilter === texture_resource_Texture.Filter.LINEAR) {
          const _texture$anisotropyDe = texture.anisotropyDegree,
                anisotropyDegree = _texture$anisotropyDe === void 0 ? 1 : _texture$anisotropyDe;

          const _anisotropyDegree = Math.min(Math.max(anisotropyDegree, 1), maxAnisotropy);

          const extension = extensions.get('EXT_texture_filter_anisotropic');
          gl.texParameterf(bindingPoint, extension.TEXTURE_MAX_ANISOTROPY_EXT, _anisotropyDegree);
        }
      } else {
        if (texture.minFilter === undefined) {
          texture.minFilter = texture_resource_Texture.Filter.NEAREST;
        }

        if (texture.magFilter === undefined) {
          texture.magFilter = texture_resource_Texture.Filter.NEAREST;
        }
      }

      _adjustInternalFormat(texture, extensions, webgl2Support);

      const minFilter = texture.minFilter,
            magFilter = texture.magFilter,
            internalFormat = texture.internalFormat,
            format = texture.format;
      const type = componentType;
      gl.texParameteri(bindingPoint, gl.TEXTURE_WRAP_S, wrapS);
      gl.texParameteri(bindingPoint, gl.TEXTURE_WRAP_T, wrapT);
      gl.texParameteri(bindingPoint, gl.TEXTURE_MIN_FILTER, minFilter);
      gl.texParameteri(bindingPoint, gl.TEXTURE_MAG_FILTER, magFilter);

      if (webgl2Support) {
        const compareFunc = texture.compareFunc,
              compareMode = texture.compareMode;
        gl.texParameteri(bindingPoint, gl2.TEXTURE_COMPARE_FUNC, compareFunc);
        gl.texParameteri(bindingPoint, gl2.TEXTURE_COMPARE_MODE, compareMode);
      }

      if (bindingPoint === gl.TEXTURE_2D) {
        const generateMipmaps = _levelsData.length > 0 && _levelsData.length < levels;
        const createEmpty = _levelsData.length === 0;

        if (type === 0) {
          for (let i = 0, count = _levelsData.length; i < count; i++) {
            const _levelsData$i = _levelsData[i],
                  w = _levelsData$i.width,
                  h = _levelsData$i.height,
                  data = _levelsData$i.data;
            gl.compressedTexImage2D(bindingPoint, i, internalFormat, w, h, 0, data);
          }
        } else if (webgl2Support) {
          gl2.texStorage2D(bindingPoint, levels, internalFormat, width, height);

          if (generateMipmaps) {
            _subImage2D(gl, bindingPoint, 0, format, type, width, height, _levelsData[0], webgl2Support);

            gl2.generateMipmap(bindingPoint);
          } else if (!createEmpty) {
            for (let i = 0; i < levels; i++) {
              _subImage2D(gl, bindingPoint, i, format, type, width, height, _levelsData[i], webgl2Support);
            }
          }
        } else {
          if (generateMipmaps) {
            if (false) {}

            _texImage2D(gl, bindingPoint, 0, internalFormat, format, type, width, height, _levelsData[0], webgl2Support);

            gl.generateMipmap(bindingPoint);
          } else if (createEmpty) {
            _texImage2D(gl, bindingPoint, 0, internalFormat, format, type, width, height, emptyLevelData, webgl2Support);
          } else {
            for (let i = 0; i < levels; i++) {
              _texImage2D(gl, bindingPoint, i, internalFormat, format, type, width, height, _levelsData[i], webgl2Support);
            }
          }
        }
      } else if (bindingPoint === gl.TEXTURE_CUBE_MAP) {
        let generateMipmaps = false;

        if (webgl2Support) {
          gl2.texStorage2D(bindingPoint, levels, internalFormat, width, height);

          for (let i = 0; i < 6; i++) {
            const faceLevels = _levelsData.length > i ? _levelsData[i] : [];

            if (!generateMipmaps && faceLevels.length > 0 && faceLevels.length < levels) {
              generateMipmaps = true;
            }

            const faceTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + i;

            for (let j = 0, count = faceLevels.length; j < count; j++) {
              _subImage2D(gl, faceTarget, j, format, type, width, height, faceLevels[j], webgl2Support);
            }
          }
        } else {
          for (let i = 0; i < 6; i++) {
            const faceLevels = _levelsData.length > i ? _levelsData[i] : [];

            if (!generateMipmaps && faceLevels.length > 0 && faceLevels.length < levels) {
              generateMipmaps = true;
            }

            if (false) {}

            const createEmpty = faceLevels.length === 0;
            const faceTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + i;

            if (createEmpty) {
              _texImage2D(gl, faceTarget, 0, internalFormat, format, type, width, height, emptyLevelData, webgl2Support);
            } else {
              for (let j = 0, count = faceLevels.length; j < count; j++) {
                _texImage2D(gl, faceTarget, j, internalFormat, format, type, width, height, faceLevels[j], webgl2Support);
              }
            }
          }
        }

        if (generateMipmaps) {
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
      } else if (bindingPoint === gl2.TEXTURE_3D && webgl2Support) {
        const generateMipmaps = _levelsData.length > 0 && _levelsData.length < levels;
        const createEmpty = _levelsData.length === 0;
        gl2.texStorage3D(bindingPoint, levels, internalFormat, width, height, depth);

        if (generateMipmaps) {
          _subImage3D(gl2, bindingPoint, 0, format, type, width, height, depth, _levelsData[0]);

          gl.generateMipmap(bindingPoint);
        } else if (!createEmpty) {
          for (let i = 0; i < levels; i++) {
            _subImage3D(gl2, bindingPoint, i, format, type, width, height, depth, _levelsData[i]);
          }
        }
      } else if (bindingPoint === gl2.TEXTURE_2D_ARRAY && webgl2Support) {
        gl2.texStorage3D(bindingPoint, levels, internalFormat, width, height, depth);
        let generateMipmaps = false;

        for (let arrayIndex = 0, arrayLength = _levelsData.length; arrayIndex < arrayLength; arrayIndex++) {
          const depthLevels = _levelsData[arrayIndex];

          if (!generateMipmaps) {
            generateMipmaps = depthLevels.length > 0 && depthLevels.length < levels;
          }

          _subImage3D(gl2, bindingPoint, 0, format, type, width, height, arrayIndex, depthLevels[0]);
        }

        if (generateMipmaps) {
          gl.generateMipmap(bindingPoint);
        }

        for (let arrayIndex = 0, arrayLength = _levelsData.length; arrayIndex < arrayLength; arrayIndex++) {
          const depthLevels = _levelsData[arrayIndex];
          const rewriteMips = depthLevels.length === levels;

          if (rewriteMips) {
            for (let lod = 1; lod < levels; lod++) {
              _subImage3D(gl2, bindingPoint, lod, format, type, width, height, arrayIndex, depthLevels[lod]);
            }
          }
        }
      } else {
        throw new Error(`wrong texture bindingPoint ${bindingPoint} for current graphics context`);
      }

      gl.bindTexture(bindingPoint, null);
      texture._webGLTexture = texId;
      texture.needsUpdate = false;
      texture._needsUpdateLevels = false;

      if (!texture.dynamic) {
        webGLTextures_deleteDataFromTextureLevelData(texture._levelsData);
      }

      return texture;
    };

    this.generateMipMaps = texture => {
      const webgl2Support = capabilities.webgl2Support;
      const _webGLTexture = texture._webGLTexture,
            bindingPoint = texture.bindingPoint,
            width = texture.width,
            height = texture.height,
            depth = texture.depth,
            _levelsData = texture._levelsData;

      if (false) {}

      if (false) {}

      if (texture.levels === undefined) {
        texture.levels = _getMipmapsCount(width, height, depth, bindingPoint, webgl2Support);
      }

      if (texture.levels <= 1) {
        return;
      }

      let generateMipMaps = true;

      if (Array.isArray(_levelsData)) {
        if (bindingPoint === gl.TEXTURE_2D || bindingPoint === gl2.TEXTURE_3D) {
          generateMipMaps = _levelsData.length <= 1;
        } else if (bindingPoint === gl.TEXTURE_CUBE_MAP) {
          for (let i = 0; i < 6; i++) {
            const faceLevels = _levelsData.length > i ? _levelsData[i] : [];
            generateMipMaps = generateMipMaps && faceLevels.length <= 1;
          }
        } else if (bindingPoint === gl2.TEXTURE_2D_ARRAY) {
          for (let i = 0, count = _levelsData.length; i < count; i++) {
            const surfaceLevels = _levelsData[i];
            generateMipMaps = generateMipMaps && surfaceLevels.length <= 1;
          }
        }
      }

      if (false) {}

      if (generateMipMaps) {
        gl.bindTexture(bindingPoint, _webGLTexture);
        gl.generateMipmap(bindingPoint);
      }
    };

    this.disposeTexture = texture => {
      const _webGLTexture = texture._webGLTexture;

      if (_webGLTexture === null) {
        return;
      }

      gl.deleteTexture(_webGLTexture);
      texture._webGLTexture = null;
    };
  }

}
/* harmony default export */ var renderer_webGLTextures = (webGLTextures_WebGLTextures);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/uniformsContainer.js
class UniformsContainer {
  constructor() {
    this.name = '';
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/uniformSetters.js
function uniformSetters_slicedToArray(arr, i) { return uniformSetters_arrayWithHoles(arr) || uniformSetters_iterableToArrayLimit(arr, i) || uniformSetters_unsupportedIterableToArray(arr, i) || uniformSetters_nonIterableRest(); }

function uniformSetters_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function uniformSetters_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return uniformSetters_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return uniformSetters_arrayLikeToArray(o, minLen); }

function uniformSetters_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function uniformSetters_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function uniformSetters_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const typeProperties = new Map();
const samplerTypes = [];
const setters = new Map();
var UniformType;

(function (UniformType) {
  UniformType[UniformType["BASIC"] = 0] = "BASIC";
  UniformType[UniformType["ARRAY"] = 1] = "ARRAY";
  UniformType[UniformType["LONG_ARRAY"] = 2] = "LONG_ARRAY";
})(UniformType || (UniformType = {}));

(function fillTypeProperties() {
  if (typeof WebGLRenderingContext !== 'undefined') {
    const gl = WebGLRenderingContext;
    typeProperties.set(gl.FLOAT, ['x', 'f', []]);
    typeProperties.set(gl.FLOAT_VEC2, ['xy', 'f', []]);
    typeProperties.set(gl.FLOAT_VEC3, ['xyz', 'f', []]);
    typeProperties.set(gl.FLOAT_VEC4, ['xyzw', 'f', []]);
    typeProperties.set(gl.INT, ['x', 'i', []]);
    typeProperties.set(gl.INT_VEC2, ['xy', 'i', []]);
    typeProperties.set(gl.INT_VEC3, ['xyz', 'i', []]);
    typeProperties.set(gl.INT_VEC4, ['xyzw', 'i', []]);
    typeProperties.set(gl.BOOL, ['x', 'i', []]);
    typeProperties.set(gl.BOOL_VEC2, ['xy', 'i', []]);
    typeProperties.set(gl.BOOL_VEC3, ['xyz', 'i', []]);
    typeProperties.set(gl.BOOL_VEC4, ['xyz', 'i', []]);
    typeProperties.set(gl.FLOAT_MAT2, ['', 'f', [2]]);
    typeProperties.set(gl.FLOAT_MAT3, ['', 'f', [3]]);
    typeProperties.set(gl.FLOAT_MAT4, ['', 'f', [4]]);
    samplerTypes.push(...[gl.SAMPLER_2D, gl.SAMPLER_CUBE]);
  }

  if (typeof WebGL2RenderingContext !== 'undefined') {
    const gl = WebGL2RenderingContext;
    typeProperties.set(gl.UNSIGNED_INT, ['x', 'u', []]);
    typeProperties.set(gl.UNSIGNED_INT_VEC2, ['xy', 'u', []]);
    typeProperties.set(gl.UNSIGNED_INT_VEC3, ['xyz', 'u', []]);
    typeProperties.set(gl.UNSIGNED_INT_VEC4, ['xyzw', 'u', []]);
    typeProperties.set(gl.FLOAT_MAT2x3, ['', 'f', [2, 3]]);
    typeProperties.set(gl.FLOAT_MAT2x4, ['', 'f', [2, 4]]);
    typeProperties.set(gl.FLOAT_MAT3x2, ['', 'f', [3, 2]]);
    typeProperties.set(gl.FLOAT_MAT3x4, ['', 'f', [3, 4]]);
    typeProperties.set(gl.FLOAT_MAT4x2, ['', 'f', [4, 2]]);
    typeProperties.set(gl.FLOAT_MAT4x3, ['', 'f', [4, 3]]);
    typeProperties.set(gl.SAMPLER_3D, ['', 'i', []]);
    samplerTypes.push(...[gl.SAMPLER_3D, gl.SAMPLER_2D_SHADOW, gl.SAMPLER_2D_ARRAY, gl.SAMPLER_2D_ARRAY_SHADOW, gl.SAMPLER_CUBE_SHADOW, gl.INT_SAMPLER_2D, gl.INT_SAMPLER_3D, gl.INT_SAMPLER_CUBE, gl.INT_SAMPLER_2D_ARRAY, gl.UNSIGNED_INT_SAMPLER_2D, gl.UNSIGNED_INT_SAMPLER_3D, gl.UNSIGNED_INT_SAMPLER_CUBE, gl.UNSIGNED_INT_SAMPLER_2D_ARRAY]);
  }
})();

function generateSetter(parameters) {
  const components = parameters.components,
        typeSufix = parameters.typeSufix,
        uniformType = parameters.uniformType,
        _parameters$matrixSiz = parameters.matrixSize,
        matrixSize = _parameters$matrixSiz === void 0 ? [] : _parameters$matrixSiz;

  const generator = function* () {
    if (matrixSize.length === 0) {
      const n = components.length;
      yield `const elements = new Array(${n});`;
    }

    if (matrixSize.length === 1) {
      const _matrixSize = uniformSetters_slicedToArray(matrixSize, 1),
            n = _matrixSize[0];

      yield `const elements = new Array(${n * n});`;
    } else if (matrixSize.length === 2) {
      const _matrixSize2 = uniformSetters_slicedToArray(matrixSize, 2),
            c = _matrixSize2[0],
            r = _matrixSize2[1];

      yield `const elements = new Array(${c * r});`;
    }

    yield 'return function _setValue(value) {';
    yield 'const { _gl, location, _cache } = this;';
    yield 'const gl = _gl;';

    if (uniformType === UniformType.BASIC) {
      if (components.length === 1) {
        yield 'if (_cache === value) return;';
        yield `gl.uniform1${typeSufix}(location, value);`;
        yield 'this._cache = value;';
      } else if (components.length > 1) {
        yield 'if (_cache !== null && _cache.equals(value)) return;';
        yield 'if (_cache === null) this._cache = value.clone();';

        if (matrixSize.length === 0) {
          yield 'value.toArray(elements);';
          yield `gl.uniform${components.length}${typeSufix}v(location, elements);`;
        } else if (matrixSize.length === 1) {
          const n = matrixSize[0];
          yield `if (value.rowCount === ${n} && value.columnCount === ${n}) {`;
          yield 'value.toRowArray(elements);';
          yield '} else {';
          yield 'value.toHomogeneousRowArray(elements);';
          yield '}';
          yield `gl.uniformMatrix${matrixSize[0]}${typeSufix}v(location, false, elements);`;
        } else if (matrixSize.length === 2) {
          const _matrixSize3 = uniformSetters_slicedToArray(matrixSize, 2),
                c = _matrixSize3[0],
                r = _matrixSize3[1];

          yield 'const { elements } = value;';
          yield `gl.uniformMatrix${c}x${r}${typeSufix}v(location, false, elements);`;
        }

        yield 'this._cache.copy(value);';
      }
    } else if (uniformType === UniformType.ARRAY || uniformType === UniformType.LONG_ARRAY) {
      if (uniformType === UniformType.ARRAY) {
        yield 'let isCacheValid = true;';
        yield 'if (_cache === null) this._cache = [];';
        yield 'for (let i = 0, count = value.length; i < count; i++) {';
        yield '    if (this._cache[i] !== value[i]) {';
        yield '        isCacheValid = false;';
        yield '        this._cache[i] = value[i];';
        yield '    }';
        yield '}';
        yield 'if (isCacheValid) return;';
      }

      if (matrixSize.length === 0) {
        yield `gl.uniform${components.length}${typeSufix}v(location, value);`;
      } else if (matrixSize.length === 1) {
        yield `gl.uniformMatrix${matrixSize[0]}${typeSufix}v(location, false, value);`;
      } else if (matrixSize.length === 2) {
        const _matrixSize4 = uniformSetters_slicedToArray(matrixSize, 2),
              c = _matrixSize4[0],
              r = _matrixSize4[1];

        yield `gl.uniformMatrix${c}x${r}${typeSufix}v(location, false, value);`;
      }
    }

    yield '};';
  };

  const body = [...generator()].join('\n');
  return new Function(...[], body)();
}

(function generateSetters() {
  const components = ['x', 'xy', 'xyz', 'xyzw'];
  const typeSufixes = ['f', 'i', 'u'];
  const types = [UniformType.BASIC, UniformType.ARRAY, UniformType.LONG_ARRAY];

  for (const type of types) {
    let typePrefix = 'Basic';

    if (type === UniformType.ARRAY) {
      typePrefix = 'Array';
    }

    if (type === UniformType.LONG_ARRAY) {
      typePrefix = 'LArray';
    }

    for (const comps of components) {
      for (const sufix of typeSufixes) {
        {
          const l = comps.length;
          const name = `set${typePrefix}Uniform${l}${sufix}`;
          const parameters = {
            components: comps,
            typeSufix: sufix,
            uniformType: type
          };
          setters.set(name, generateSetter(parameters));
        }
        {
          const l = comps.length;

          if (l > 1) {
            const name = `set${typePrefix}UniformMatrix${l}${sufix}`;
            const parameters = {
              components: comps,
              typeSufix: sufix,
              uniformType: type,
              matrixSize: [l]
            };
            setters.set(name, generateSetter(parameters));
          }
        }
        {
          const l = comps.length;
          const rows = [2, 3, 4];

          if (l > 1) {
            for (const r of rows) {
              const c = l;
              const name = `set${typePrefix}UniformMatrix${c}x${r}${sufix}`;
              const parameters = {
                components: comps,
                typeSufix: sufix,
                uniformType: type,
                matrixSize: [c, r]
              };
              setters.set(name, generateSetter(parameters));
            }
          }
        }
      }
    }
  }
})();

function getSetterName(type, size) {
  if (samplerTypes.includes(type)) {
    return 'setBasicUniform1i';
  }

  const properties = typeProperties.get(type);

  if (properties === undefined) {
    throw new Error(`could not get properties for type: ${type}`);
  }

  const _properties = uniformSetters_slicedToArray(properties, 3),
        components = _properties[0],
        sufix = _properties[1],
        msize = _properties[2];

  let countComponents = components.length;
  let methodSufix = '';
  let prefix = '';

  if (countComponents === 0) {
    if (msize.length === 1) {
      const _msize = uniformSetters_slicedToArray(msize, 1),
            s = _msize[0];

      countComponents = s * s;
      methodSufix = `Matrix${s}${sufix}`;
    } else if (msize.length === 2) {
      const _msize2 = uniformSetters_slicedToArray(msize, 2),
            c = _msize2[0],
            r = _msize2[1];

      countComponents = c * r;
      methodSufix = `Matrix${c}x${r}${sufix}`;
    }
  } else {
    methodSufix = `${countComponents}${sufix}`;
  }

  if (size > 1) {
    prefix = countComponents * size > 16 ? 'LArray' : 'Array';
  } else {
    prefix = 'Basic';
  }

  return `set${prefix}Uniform${methodSufix}`;
}

function getUniformSetter(name, type, size) {
  const setter = setters.get(getSetterName(type, size));

  if (setter === undefined) {
    throw new Error(`could not find suit setter for uniform ${name}`);
  }

  return setter;
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/basicTypeUniform.js

class basicTypeUniform_BasicTypeUniform {
  constructor(name_, gl, program, info) {
    const name = info.name,
          size = info.size,
          type = info.type;
    this._gl = gl;
    this._cache = null;
    this.name = name_;
    this.size = size;
    this.type = type;
    this.location = gl.getUniformLocation(program, name);
    this.setValue = getUniformSetter(name, type, size);
  }

  isArray() {
    return this.size > 1;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/structUniform.js

class structUniform_StructUniform extends UniformsContainer {
  constructor(name) {
    super();
    this.name = name;
    this._layout = new Map();
  }

  add(name, uniform) {
    const _layout = this._layout;

    _layout.set(name, uniform);
  }

  get(name) {
    return this._layout.get(name);
  }

  find(name) {
    const uniform = this.get(name);
    return uniform !== undefined ? uniform : null;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/arrayUniform.js

class arrayUniform_ArrayUniform extends UniformsContainer {
  constructor(name) {
    super();
    this.name = name;
    this._array = [];
  }

  add(index, uniform) {
    this._array[index] = uniform;
  }

  get(index) {
    return this._array[index];
  }

  find(name) {
    const _array = this._array;

    for (const uniform of _array) {
      if (uniform.name === name) {
        return uniform;
      }
    }

    return null;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLUniforms/index.js
function webGLUniforms_slicedToArray(arr, i) { return webGLUniforms_arrayWithHoles(arr) || webGLUniforms_iterableToArrayLimit(arr, i) || webGLUniforms_unsupportedIterableToArray(arr, i) || webGLUniforms_nonIterableRest(); }

function webGLUniforms_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function webGLUniforms_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return webGLUniforms_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return webGLUniforms_arrayLikeToArray(o, minLen); }

function webGLUniforms_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function webGLUniforms_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function webGLUniforms_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }









const regex = /(\w+)$|(\w+)\[(\d+)\]$|(\w+)\[(\d+)\].|(\w+)./g;

function parseUniform(gl, program, container, info) {
  const name = info.name;
  regex.lastIndex = 0;
  let match = null;
  let _container = container;

  while ((match = regex.exec(name)) !== null) {
    const _match = match,
          _match2 = webGLUniforms_slicedToArray(_match, 7),
          group1 = _match2[1],
          group2 = _match2[2],
          group3 = _match2[3],
          group4 = _match2[4],
          group5 = _match2[5],
          group6 = _match2[6];

    {
      const basic = group1;

      if (basic !== undefined) {
        const key = basic;

        _container.add(key, new basicTypeUniform_BasicTypeUniform(basic, gl, program, info));

        break;
      }
    }
    {
      const array = group2;

      if (array !== undefined) {
        const index = +group3;
        const key = array;

        if (false) {}

        _container.add(key, new basicTypeUniform_BasicTypeUniform(array, gl, program, info));

        break;
      }
    }
    {
      const array = group4;
      const index = group5;

      if (array !== undefined) {
        const key = array;

        let uniform = _container.find(array);

        if (uniform === null) {
          uniform = new arrayUniform_ArrayUniform(array);

          _container.add(key, uniform);
        }

        let struct = uniform.find(index);

        if (struct === null) {
          struct = new structUniform_StructUniform(index);
          uniform.add(+index, struct);
        }

        _container = struct;
        continue;
      }
    }
    {
      const struct = group6;

      if (struct !== undefined) {
        const key = struct;

        let uniform = _container.find(struct);

        if (uniform === null) {
          uniform = new structUniform_StructUniform(struct);

          _container.add(key, uniform);
        }

        _container = uniform;
        continue;
      }
    }
  }
}

class webGLUniforms_WebGLUniforms extends UniformsContainer {
  constructor() {
    super();
    this._layout = new Map();
  }

  update(gl, program) {
    this._layout.clear();

    const activeUniformsCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (let i = 0; i < activeUniformsCount; i++) {
      const info = gl.getActiveUniform(program, i);
      parseUniform(gl, program, this, info);
    }
  }

  add(index, uniform) {
    this._layout.set(index, uniform);
  }

  get(index) {
    return this._layout.get(index);
  }

  find(name) {
    const uniform = this.get(name);
    return uniform !== undefined ? uniform : null;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLPrograms/pragmaCommands.js
function pragmaCommands_slicedToArray(arr, i) { return pragmaCommands_arrayWithHoles(arr) || pragmaCommands_iterableToArrayLimit(arr, i) || pragmaCommands_unsupportedIterableToArray(arr, i) || pragmaCommands_nonIterableRest(); }

function pragmaCommands_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function pragmaCommands_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pragmaCommands_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pragmaCommands_arrayLikeToArray(o, minLen); }

function pragmaCommands_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function pragmaCommands_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function pragmaCommands_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function removeComments(src) {
  const out = src;
  const oneline = /\/\/.+/g;
  const multiline = /\/\*(?:(?:.|\n)*)\*\//gm;
  out.replace(oneline, '');
  out.replace(multiline, '');
  return out;
}

function getComponentsCount(type) {
  if (/^[u]{0,1}int|float$/.test(type)) {
    return 1;
  }

  const match = type.match(/^vec([2-4])$/);

  if (match !== null) {
    const _match = pragmaCommands_slicedToArray(match, 2),
          group = _match[1];

    return parseInt(group, 10);
  }

  throw new Error(`wrong attribute type ${type}`);
}

function parseFragOutput(string, outputLayout, gles3Support) {
  const pattern = /^[ |\t]*#[ |\t]*pragma[ |\t]+fragOutput[ |\t]*[(|"|<]([a-zA-Z]+[\w|\d]*),[ |\t]*([r|g|b|a]{0,4}|[x|y|z|w]{0,4}|[s|t|p|q]{0,4}),[ |\t]*(.+)[)|"|>][;]{0,1}/gm;
  const isDef = outputLayout === null || outputLayout.size === 0;
  const isMRT = outputLayout !== null && outputLayout.size > 1;
  let outputContainter;

  if (gles3Support) {
    outputContainter = isMRT ? 'fragData' : 'fragColor';
  } else {
    outputContainter = isMRT ? 'gl_FragData' : 'gl_FragColor';
  }

  function parser(match, semanticName, accessors, value) {
    const semantic = OutputLayoutSemantic[semanticName];
    let code = '';
    const access = accessors.length === 0 ? accessors : `.${accessors}`;

    if (isDef && semantic === OutputLayoutSemantic.DEFAULT) {
      code = `${outputContainter}${access} = ${value};`;
    } else if (!isMRT && !isDef && outputLayout.has(semantic)) {
      code = `${outputContainter}${access} = ${value};`;
    } else if (isMRT) {
      const index = outputLayout.get(semantic);
      code = index === undefined ? '' : `${outputContainter}[${index}]${access} = ${value};`;
    }

    return code;
  }

  return string.replace(pattern, parser);
}
function parseFragOutputs(string, outputLayout, gles3Support) {
  const pattern = /^[ |\t]*#[ |\t]*pragma[ |\t]+fragOutputs[;]{0,1}/gm;

  function parser() {
    return outputLayout !== null && outputLayout.size > 1 ? gles3Support ? `out vec4 fragData[${outputLayout.size}];` : '' : gles3Support ? 'out vec4 fragColor;' : '';
  }

  return string.replace(pattern, parser);
}
function parseAttributes(string, attributes, gles3Support) {
  const pattern = /^[ |\t]*#[ |\t]*pragma[ |\t]+attribute[ |\t]*[(|"|<]([a-zA-Z]+[\w|\d]*),[ |\t]*([u]{0,1}int|float|vec[2-4]+),[ |\t]*(\w+),[ |\t]*(\d+)[)|"|>][;]{0,1}/gm;
  let locationCounter = 0;
  attributes.clear();

  function parser(match, name, type, semanticName, divisorStr) {
    const semantic = AttributeSemantic[semanticName];

    if (semantic === undefined) {
      throw new Error(`attribute ${name} has unexpected semantic value: ${semanticName}`);
    }

    if (attributes.has(semantic)) {
      throw new Error(`attribute ${name} use the same ${semanticName} semantic as attribute ${attributes.get(semantic).name}`);
    }

    if (false) {}

    const location = gles3Support ? locationCounter++ : 0;
    const code = gles3Support ? `layout(location = ${location}) in ${type} ${name};` : `attribute ${type} ${name};`;
    const divisor = parseInt(divisorStr, 10);
    const instanced = divisor > 0;
    const countComponents = getComponentsCount(type);
    const active = false;
    attributes.set(semantic, {
      name,
      location,
      instanced,
      divisor,
      countComponents,
      active
    });
    return code;
  }

  return string.replace(pattern, parser);
}
function parseIncludes(string) {
  const pattern = /^[ |\t]*#[ |\t]*pragma[ |\t]+include[ \t]*[(|"|<]([\w|\d]+)[.\w+]*[)|"|>]/gm;

  function parser(match, include) {
    const replace = ShaderChunks[include];

    if (replace === undefined) {
      throw new Error(`can not resolve include: ${include}, from: ${match}`);
    }

    return parseIncludes(replace);
  }

  return string.replace(pattern, parser);
}

function parseIndex(idx) {
  const pattern = /^[ |\t]*(int|uint)[ |\t]+([_a-zA-Z](?:\w)*)[ |\t]*=[ |\t]*((?:\d+))[ |\t]*$/;
  const match = pattern.exec(idx);

  if (match === null) {
    throw new Error(`could not unroll cycle, index: ${idx} does not match template`);
  }

  const _match2 = pragmaCommands_slicedToArray(match, 4),
        type = _match2[1],
        name = _match2[2],
        value = _match2[3];

  return [type, name, +value];
}

class CycleCondition {
  constructor(cond, limit) {
    let condition = null;

    if (cond === '<') {
      condition = CycleCondition.LESS;
    } else if (cond === '<=') {
      condition = CycleCondition.LEQUEL;
    } else if (cond === '>') {
      condition = CycleCondition.GREATER;
    } else if (cond === '>=') {
      condition = CycleCondition.GEQUEL;
    }

    this.condition = condition;
    this.limit = +limit;
  }

  static get LESS() {
    return 0;
  }

  static get LEQUEL() {
    return 1;
  }

  static get GREATER() {
    return 2;
  }

  static get GEQUEL() {
    return 3;
  }

  test(i) {
    const limit = this.limit,
          condition = this.condition;

    if (condition === CycleCondition.LESS) {
      return i < limit;
    }

    if (condition === CycleCondition.LEQUEL) {
      return i <= limit;
    }

    if (condition === CycleCondition.GREATER) {
      return i > limit;
    }

    if (condition === CycleCondition.GEQUEL) {
      return i >= limit;
    }

    return false;
  }

}

function parseCondition(condition, indexName, defines) {
  const pattern = new RegExp(`^[ |\t]*${indexName}[ |\t]*(<|<=|>|>=)[ |\t]*((?:\\w)+)[ |\t]*$`);
  const match = pattern.exec(condition);

  if (match === null) {
    throw new Error(`could not unroll cycle, condition: ${condition} does not match template`);
  }

  const _match3 = pragmaCommands_slicedToArray(match, 3),
        cond = _match3[1],
        define = _match3[2];

  const limit = +defines[define];

  if (false) {}

  return new CycleCondition(cond, limit);
}

function parseIncrement(increment, indexName) {
  const pattern = new RegExp(`^[ |\t]*(?:(--|\\+\\+)${indexName}|${indexName}(--|\\+\\+)||${indexName}[ |\t]*([-|\\+])=[ |\t]*(\\d+))[ |\t]*$`);
  const match = pattern.exec(increment);

  if (match === null) {
    throw new Error(`could not unroll cycle, increment: ${increment} does not match template`);
  }

  const _match4 = pragmaCommands_slicedToArray(match, 5),
        group1 = _match4[1],
        group2 = _match4[2],
        group3 = _match4[3],
        group4 = _match4[4];

  let step = 0;

  if (group1 !== undefined || group2 !== undefined) {
    const op = group1 || group2;

    if (op === '--') {
      step = -1;
    } else if (op === '++') {
      step = 1;
    }
  }

  if (group3 !== undefined && group4 !== undefined) {
    if (group3 === '-') {
      step = -group4;
    } else if (group3 === '+') {
      step = +group4;
    }
  }

  if (step === 0) {
    throw new Error(`could not unroll cycle, increment: ${increment} does not match template`);
  }

  return step;
}

function unrollCycle(src, defines, tabs = '\t') {
  let out = src;
  const pattern = /#[ |\t]*pragma[ |\t]+unroll[ |\t|\n]+for[ |\t]*\((.+);(.+);(.+)\)/gm;
  let match = null;

  while ((match = pattern.exec(out)) !== null) {
    const lastIndex = pattern.lastIndex;

    const _match5 = match,
          _match6 = pragmaCommands_slicedToArray(_match5, 4),
          full = _match6[0],
          group1 = _match6[1],
          group2 = _match6[2],
          group3 = _match6[3];

    const cycleStart = lastIndex - full.length;

    const _parseIndex = parseIndex(group1),
          _parseIndex2 = pragmaCommands_slicedToArray(_parseIndex, 3),
          indexType = _parseIndex2[0],
          indexName = _parseIndex2[1],
          initialValue = _parseIndex2[2];

    const condition = parseCondition(group2, indexName, defines);
    const step = parseIncrement(group3, indexName);
    let endBody = -1;
    let startBody = -1;
    let cursor = lastIndex;
    let state = 0;
    let blockCounter = 0;

    while (true) {
      if (state === 0) {
        const i = out.indexOf('{', cursor);
        const j = out.indexOf(';', cursor);

        if (j < i || i === -1) {
          startBody = cursor;
          endBody = j;
          break;
        } else if (j > i) {
          cursor = i + 1;
          state = 1;
          blockCounter++;
          startBody = cursor;
          continue;
        }

        state = 3;
        break;
      }

      if (state === 1) {
        const i = out.indexOf('{', cursor);
        const j = out.indexOf('}', cursor);

        if (j === -1) {
          state = 3;
          break;
        }

        if (i === -1) {
          if (--blockCounter === 0) {
            endBody = j;
            break;
          }

          cursor = j + 1;
        }

        if (i < j) {
          cursor = i + 1;
          blockCounter++;
          continue;
        }

        if (i > j) {
          if (--blockCounter === 0) {
            endBody = j;
            break;
          }

          cursor = j + 1;
          continue;
        }

        state = 3;
        break;
      }
    }

    if (false) {}

    let body = out.substring(startBody, endBody);
    body = unrollCycle(body, defines, tabs + '\t');
    const unrolled = [];

    for (let index = initialValue; condition.test(index); index += step) {
      unrolled.push(...[`{ // iteration ${index}`, `${tabs}\tconst ${indexType} ${indexName} = ${index};`, body, `${tabs}}`, '']);
    }

    const unrolledCycle = unrolled.join('\n');
    const tail = out.slice(0, cycleStart);
    const head = endBody + 1 < out.length ? out.slice(endBody + 1) : '';
    out = tail + unrolledCycle + head;
    pattern.lastIndex = 0;
  }

  return out;
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLPrograms/webGLProgram.js






let _lastLayoutVersion = 0;
let _lastUniqueProgramId = 0;

const _directLightOutputMask = OutputLayoutSemantic.DEFAULT | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR | OutputLayoutSemantic.TM_DIFFUSE | OutputLayoutSemantic.TM_SPECULAR | OutputLayoutSemantic.SPECULAR | OutputLayoutSemantic.DIFFUSE | OutputLayoutSemantic.DIRECT_DIFFUSE | OutputLayoutSemantic.DIRECT_SPECULAR;

const _indirectLightOutputMask = OutputLayoutSemantic.DEFAULT | OutputLayoutSemantic.TM_DIFFUSE | OutputLayoutSemantic.TM_SPECULAR | OutputLayoutSemantic.SPECULAR | OutputLayoutSemantic.DIFFUSE | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR | OutputLayoutSemantic.INDIRECT_DIFFUSE | OutputLayoutSemantic.INDIRECT_SPECULAR;

const _defaultOutputMask = OutputLayoutSemantic.DEFAULT;
const _xyYColorMask = OutputLayoutSemantic.CIE_xyY_COLOR;
const _luvColorMask = OutputLayoutSemantic.CIE_LUV_COLOR;
const _linearHDRColorMask = OutputLayoutSemantic.LINEAR_HDR_COLOR;
const _instanceColorMask = OutputLayoutSemantic.INSTANCE_COLOR;
const _fragOutputMasks = [`#define INSTANCE_COLOR_OUTPUT_MASK ${_instanceColorMask}`, `#define DIRECT_LIGHT_OUTPUT_MASK ${_directLightOutputMask}`, `#define INDIRECT_LIGHT_OUTPUT_MASK ${_indirectLightOutputMask}`, `#define DEFAULT_OUTPUT_MASK ${_defaultOutputMask}`, `#define CIE_xyY_COLOR ${_xyYColorMask}`, `#define CIE_LUV_COLOR ${_luvColorMask}`, `#define LINEAR_HDR_COLOR ${_linearHDRColorMask}`];

function prepareSamplers(programLayout, material, capabilities) {
  const samplers = [];
  const samplerDefines = [];
  const arrayIndices = [];
  const readFunctions = [];
  const samplerInUse = new Map();
  const samplerUniformNames = programLayout.samplerUniformNames;
  const gles3Support = capabilities.gles3Support,
        webgl2Support = capabilities.webgl2Support;
  let samplerIndex = 0;

  for (const key of Object.keys(material)) {
    const materialProperty = material[key];

    if (!(materialProperty instanceof material_Material.TextureProperties)) {
      continue;
    }

    const texture = materialProperty.texture;
    const internalFormat = texture.internalFormat,
          _gammaDecode = texture._gammaDecode;
    let gammaDecode = _gammaDecode;

    if (!webgl2Support) {
      gammaDecode = gammaDecode || internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8;
    } else {
      gammaDecode = gammaDecode || internalFormat === InternalFormat.SRGB8;
    }

    if (!samplerInUse.has(texture)) {
      let type;

      if (texture.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
        type = 'sampler2D';
      } else if (texture.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        type = 'highp sampler2DArray';
      } else {
        continue;
      }

      const samplerName = `sampler${++samplerIndex}`;
      const sampler = `uniform ${type} ${samplerName};`;
      samplers.push(sampler);
      samplerInUse.set(texture, samplerName);
    }

    if (materialProperty instanceof material_Material.TextureArrayProperties) {
      const uniform = `uniform float ${key}Index;`;
      arrayIndices.push(uniform);
    }

    {
      const samplerName = samplerInUse.get(texture);
      const define = `#define ${key}Sampler ${samplerName}`;
      samplerDefines.push(define);
      samplerUniformNames.set(key, samplerName);
    }
    {
      const uv = materialProperty instanceof material_Material.TextureArrayProperties && gles3Support ? `vec3 uv_ = vec3(uv, ${key}Index);` : 'vec2 uv_ = uv;';
      const readTexture = gles3Support ? `texture(${key}Sampler, uv_);` : `texture2D(${key}Sampler, uv_);`;
      const gammaDecoding = gammaDecode ? '\ttex.rgb = pow(tex.rgb, vec3(2.2));' : '';
      const readFunction = [`vec4 ${key}ReadFunc(vec2 uv) {`, `\t${uv}`, `\tvec4 tex = ${readTexture}`, gammaDecoding, '\treturn tex;', '}'].join('\n');
      readFunctions.push(readFunction);
    }
  }

  return {
    samplers,
    samplerDefines,
    arrayIndices,
    readFunctions
  };
}

function prepareUvChannels(material) {
  const uvAttributes = [];
  const uvDefines = [];
  const channelsInUse = new Set();

  for (const key of Object.keys(material)) {
    const materialProperty = material[key];

    if (!(materialProperty instanceof material_Material.TextureProperties)) {
      continue;
    }

    const channel = materialProperty.channel,
          texture = materialProperty.texture;
    const bindingPoint = texture.bindingPoint;
    let type;

    if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D || bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
      type = 'vec2';
    } else if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_3D) {
      type = 'vec3';
    } else {
      continue;
    }

    if (!channelsInUse.has(channel)) {
      const attribute = `#pragma attribute(uv${channel}, ${type}, TEX_COORD_CHANNEL_${channel}, 0);`;
      uvAttributes.push(attribute);
      channelsInUse.add(channel);
    }

    const uvNameDefine = `#define ${key}Uv uv${channel}`;
    uvDefines.push(uvNameDefine);
  }

  return {
    uvAttributes,
    uvDefines
  };
}

function prepareMorphAttributes(defines) {
  const morphAttributes = [];
  const _defines$POSITION_MOR = defines.POSITION_MORPH_COUNT,
        POSITION_MORPH_COUNT = _defines$POSITION_MOR === void 0 ? 0 : _defines$POSITION_MOR,
        _defines$NORMAL_MORPH = defines.NORMAL_MORPH_COUNT,
        NORMAL_MORPH_COUNT = _defines$NORMAL_MORPH === void 0 ? 0 : _defines$NORMAL_MORPH;

  for (let i = 0; i < POSITION_MORPH_COUNT; i++) {
    const attribute = `#pragma attribute(morphPosition${i}, vec3, POSITION_MORPH_${i}, 0);`;
    morphAttributes.push(attribute);
  }

  for (let i = 0; i < NORMAL_MORPH_COUNT; i++) {
    const attribute = `#pragma attribute(morphNormal${i}, vec3, NORMAL_MORPH_${i}, 0);`;
    morphAttributes.push(attribute);
  }

  return morphAttributes;
}

function getShaderExtensions(technique, supportedExtensions) {
  const shaderExtensions = [];
  const extensions = technique.extensions;
  const names = Object.keys(extensions);

  for (const name of names) {
    const behaviour = extensions[name];
    const extension = supportedExtensions.get(name);

    if (extension === null && behaviour === webGLExtensions_WebGLExtensions.ShaderExtensionBehaviour.REQUIRE) {
      throw new Error(`extension ${name} is required, but not supported`);
    }

    shaderExtensions.push(`#extension GL_${name}: ${behaviour}`);
  }

  return shaderExtensions;
}

function getDefineLines(defines) {
  const defines_ = [];
  const names = Object.keys(defines);

  for (const name of names) {
    const value = defines[name];
    defines_.push(`#define ${name} ${value}`);
  }

  return defines_;
}

class webGLProgram_WebGLProgram extends disposeableUsageCounter_DisposableUsageCounter {
  constructor(gl, material, renderPassId, extensions, capabilities) {
    super();
    this._gl = gl;
    this.optimization = true;
    this._webglProgram = null;
    this._vertexShaderCode = '';
    this._fragmentShaderCode = '';
    this._capabilities = capabilities;
    this._layout = {
      version: ++_lastLayoutVersion,
      needsUpdate: false,
      attributes: new Map(),
      uniforms: new webGLUniforms_WebGLUniforms(),
      samplerUniformNames: new Map()
    };

    this._prepareShaderCode(renderPassId, material, extensions, capabilities);
  }

  get layout() {
    const gl = this._gl;

    this._buildProgram(gl);

    this._updateLayout(gl, this._capabilities);

    return this._layout;
  }

  get webglProgram() {
    const gl = this._gl;

    this._buildProgram(gl);

    this._updateLayout(gl, this._capabilities);

    return this._webglProgram;
  }

  _dispose() {
    const _gl = this._gl,
          _webglProgram = this._webglProgram;

    if (_webglProgram !== null) {
      _gl.deleteProgram(_webglProgram);
    }

    this._webglProgram = null;

    super._dispose();
  }

  get vertexShader() {
    return this._vertexShaderCode;
  }

  get fragmentShader() {
    return this._fragmentShaderCode;
  }

  _updateLayout(gl, capabilities) {
    const _layout = this._layout,
          _webglProgram = this._webglProgram;
    const needsUpdate = _layout.needsUpdate,
          attributes = _layout.attributes,
          uniforms = _layout.uniforms;

    if (_webglProgram === null) {
      throw new Error('_webglProgram is null');
    }

    if (!needsUpdate) {
      return;
    }

    _layout.version = ++_lastLayoutVersion;
    uniforms.update(gl, _webglProgram);
    const webgl2Support = capabilities.webgl2Support;
    const activeAttributesCount = gl.getProgramParameter(_webglProgram, gl.ACTIVE_ATTRIBUTES);

    for (let i = 0; i < activeAttributesCount; i++) {
      const info = gl.getActiveAttrib(_webglProgram, i);
      const name = info.name;

      for (const attribute of attributes.values()) {
        if (attribute.name === name) {
          attribute.active = true;
          attribute.location = webgl2Support ? attribute.location : gl.getAttribLocation(_webglProgram, name);
        }
      }
    }

    _layout.needsUpdate = false;
  }

  _buildProgram(gl) {
    if (this._webglProgram !== null) {
      return;
    }

    const _layout = this._layout,
          _vertexShaderCode = this._vertexShaderCode,
          _fragmentShaderCode = this._fragmentShaderCode;
    const webglProgram = gl.createProgram();

    if (webglProgram === null) {
      throw new Error('webglProgram is null');
    }

    const webglVertexShader = gl.createShader(gl.VERTEX_SHADER);

    if (webglVertexShader === null) {
      throw new Error('webglVertexShader is null');
    }

    gl.shaderSource(webglVertexShader, _vertexShaderCode);
    gl.compileShader(webglVertexShader);
    {
      const log = gl.getShaderInfoLog(webglVertexShader);

      if (log && log.length > 0) {
        console.warn(log);
      }
    }
    const webglFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

    if (webglFragmentShader === null) {
      throw new Error('webglFragmentShader is null');
    }

    gl.shaderSource(webglFragmentShader, _fragmentShaderCode);
    gl.compileShader(webglFragmentShader);
    {
      const log = gl.getShaderInfoLog(webglFragmentShader);

      if (log && log.length > 0) {
        console.warn(log);
      }
    }
    gl.attachShader(webglProgram, webglVertexShader);
    gl.attachShader(webglProgram, webglFragmentShader);
    gl.linkProgram(webglProgram);
    {
      const log = gl.getProgramInfoLog(webglProgram);

      if (log && log.length > 0) {
        console.warn(log);
      }
    }
    gl.deleteShader(webglVertexShader);
    gl.deleteShader(webglFragmentShader);
    this._webglProgram = webglProgram;
    _layout.needsUpdate = true;
  }

  _prepareShaderCode(renderPassId, material, extensions, capabilities) {
    const _layout = this._layout,
          optimization = this.optimization;
    const shaders = material.shaders;
    const technique = material.getTechnique(renderPassId);

    const defines = technique.defines,
          _technique$_outputLay = technique._outputLayout,
          _outputLayout = _technique$_outputLay === void 0 ? null : _technique$_outputLay;

    const vertexShader = shaders.vertexShader,
          fragmentShader = shaders.fragmentShader;
    const shaderExtensions = getShaderExtensions(technique, extensions);
    const defineLines = getDefineLines(defines);
    const gles3Support = capabilities.gles3Support,
          precision = capabilities.precision;
    const gles3define = gles3Support ? '#define GLES_3' : '';
    const version = gles3Support ? '#version 300 es' : '#version 100';
    const opt = optimization ? 'on' : 'off';
    const name = `${technique.name}_${++_lastUniqueProgramId}`;
    {
      const attributes = _layout.attributes;

      const _prepareUvChannels = prepareUvChannels(material),
            uvAttributes = _prepareUvChannels.uvAttributes,
            uvDefines = _prepareUvChannels.uvDefines;

      const morphAttributes = prepareMorphAttributes(defines);
      let vertexShaderCode = [...uvAttributes, ...morphAttributes, ...uvDefines, vertexShader].join('\n');
      vertexShaderCode = parseIncludes(vertexShaderCode);
      vertexShaderCode = removeComments(vertexShaderCode);
      vertexShaderCode = unrollCycle(vertexShaderCode, defines);
      vertexShaderCode = parseAttributes(vertexShaderCode, attributes, gles3Support);
      const codeLines = [version, `#pragma optimize(${opt})`, ...shaderExtensions, ...defineLines, ..._fragOutputMasks, `precision ${precision} float;`, `precision ${precision} int;`, `#define SHADER_NAME ${name}`, gles3define, vertexShaderCode];
      this._vertexShaderCode = codeLines.join('\n');
    }
    {
      let fragmentShaderCode = fragmentShader;
      fragmentShaderCode = parseIncludes(fragmentShaderCode);
      fragmentShaderCode = parseFragOutput(fragmentShaderCode, _outputLayout, gles3Support);
      fragmentShaderCode = parseFragOutputs(fragmentShaderCode, _outputLayout, gles3Support);
      fragmentShaderCode = removeComments(fragmentShaderCode);
      fragmentShaderCode = unrollCycle(fragmentShaderCode, defines);

      const _prepareSamplers = prepareSamplers(_layout, material, capabilities),
            samplers = _prepareSamplers.samplers,
            samplerDefines = _prepareSamplers.samplerDefines,
            arrayIndices = _prepareSamplers.arrayIndices,
            readFunctions = _prepareSamplers.readFunctions;

      const codeLines = [version, `#pragma optimize(${opt})`, ...shaderExtensions, ...arrayIndices, ...defineLines, ..._fragOutputMasks, `precision ${precision} float;`, `precision ${precision} int;`, `#define SHADER_NAME ${name}`, gles3define, ...samplers, ...samplerDefines, ...readFunctions, fragmentShaderCode];
      this._fragmentShaderCode = codeLines.join('\n');
    }
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLPrograms/index.js

class webGLPrograms_WebGLPrograms {
  constructor({
    gl,
    extensions,
    capabilities
  }) {
    this.gl = gl;
    this.extensions = extensions;
    this.capabilities = capabilities;
    this.programCache = new Map();
  }

  getProgram(material, renderPassId) {
    const gl = this.gl,
          extensions = this.extensions,
          capabilities = this.capabilities,
          programCache = this.programCache;
    let materialProgramCache = programCache.get(material.constructor);

    if (materialProgramCache === undefined) {
      materialProgramCache = new Map();
      programCache.set(material.constructor, materialProgramCache);
    }

    const _material$getTechniqu = material.getTechnique(renderPassId),
          cacheKey = _material$getTechniqu.cacheKey;

    let program = materialProgramCache.get(cacheKey);

    if (program === undefined) {
      program = new webGLProgram_WebGLProgram(gl, material, renderPassId, extensions, capabilities);
      materialProgramCache.set(cacheKey, program);
    }

    return program;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLRenderBuffers.js
class WebGLRenderBuffers {
  constructor({
    gl,
    capabilities
  }) {
    this.getWebGLRenderBuffer = renderBuffer => {
      if (!renderBuffer.needsUpdate) {
        return renderBuffer;
      }

      this.disposeRenderBuffer(renderBuffer);
      renderBuffer._webGLRenderBufferSystem = this;
      const width = renderBuffer.width,
            height = renderBuffer.height,
            samples = renderBuffer.samples,
            internalFormat = renderBuffer.internalFormat;
      const webgl2Support = capabilities.webgl2Support;
      const rbo = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);

      if (samples > 1 && webgl2Support) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, internalFormat, width, height);
      } else if (samples === 1) {
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
      } else {
        throw new Error('can not create render buffer for current context and samples count');
      }

      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      renderBuffer._webGLRenderBuffer = rbo;
      renderBuffer.needsUpdate = false;
      return renderBuffer;
    };

    this.disposeRenderBuffer = renderBuffer => {
      const _webGLRenderBuffer = renderBuffer._webGLRenderBuffer;

      if (_webGLRenderBuffer === null) {
        return;
      }

      gl.deleteRenderbuffer(_webGLRenderBuffer);
      renderBuffer._webGLRenderBuffer = null;
    };
  }

}
/* harmony default export */ var renderer_webGLRenderBuffers = (WebGLRenderBuffers);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLFramebuffers/index.js

class webGLFramebuffers_WebGLFramebuffers {
  constructor({
    gl,
    capabilities,
    extensions,
    webGLTextures,
    webGLRenderBuffers
  }) {
    this.getWebGLFramebuffer = renderTarget => {
      if (!renderTarget.needsUpdate) {
        return renderTarget;
      }

      const _needsUpdate = renderTarget._needsUpdate;

      if (_needsUpdate) {
        this.deleteFramebuffer(renderTarget);
      }

      renderTarget._webGLFramebufferSystem = this;
      const _colorAttachments = renderTarget._colorAttachments,
            _depthStencilAttachments = renderTarget._depthStencilAttachments,
            colorAttachmentCount = renderTarget.colorAttachmentCount;
      const drawBuffers = [];
      const drawBuffersExt = extensions.get('WEBGL_draw_buffers');
      const mrtSupport = capabilities.mrtSupport,
            maxColorAttachments = capabilities.maxColorAttachments;

      if (!mrtSupport && colorAttachmentCount > 1) {
        throw new Error(`color attachment count: ${colorAttachmentCount}, current device support only: 1`);
      }

      if (colorAttachmentCount > maxColorAttachments) {
        throw new Error(`color attachment count: ${colorAttachmentCount}, current device support only: ${maxColorAttachments}`);
      }

      const framebuffer = _needsUpdate ? gl.createFramebuffer() : renderTarget._webGLFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

      for (const layout of _colorAttachments.keys()) {
        const _renderTarget$getColo = renderTarget.getColorAttachment(layout),
              attachment = _renderTarget$getColo.attachment,
              properties = _renderTarget$getColo.properties;

        const level = properties.level,
              target = properties.target,
              layer = properties.layer,
              needsUpdate = properties.needsUpdate;

        if (!needsUpdate && !_needsUpdate) {
          continue;
        }

        if (attachment instanceof texture_resource_Texture) {
          const _webGLTextures$getWeb = webGLTextures.getWebGLTexture(attachment),
                webGLTexture = _webGLTextures$getWeb.webGLTexture;

          const bindingPoint = attachment.bindingPoint;

          switch (bindingPoint) {
            case texture_resource_Texture.BindingPoint.TEXTURE_2D:
            case texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP:
              gl.framebufferTexture2D(gl.FRAMEBUFFER, layout, target, webGLTexture, level);
              break;

            case texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY:
              gl.framebufferTextureLayer(gl.FRAMEBUFFER, layout, webGLTexture, level, layer);
              break;

            default:
              break;
          }
        } else if (attachment instanceof renderBuffer_RenderBuffer) {
          const _webGLRenderBuffers$g = webGLRenderBuffers.getWebGLRenderBuffer(attachment),
                webGLRenderBuffer = _webGLRenderBuffers$g.webGLRenderBuffer;

          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, layout, gl.RENDERBUFFER, webGLRenderBuffer);
        }

        properties.needsUpdate = false;
        drawBuffers.push(layout);
      }

      for (const layout of _depthStencilAttachments.keys()) {
        const _renderTarget$getDept = renderTarget.getDepthStencilAttachment(layout),
              attachment = _renderTarget$getDept.attachment,
              properties = _renderTarget$getDept.properties;

        const layer = properties.layer,
              target = properties.target,
              needsUpdate = properties.needsUpdate;

        if (!needsUpdate && !_needsUpdate) {
          continue;
        }

        if (attachment instanceof texture_resource_Texture) {
          const _webGLTextures$getWeb2 = webGLTextures.getWebGLTexture(attachment),
                webGLTexture = _webGLTextures$getWeb2.webGLTexture;

          const bindingPoint = attachment.bindingPoint;

          switch (bindingPoint) {
            case texture_resource_Texture.BindingPoint.TEXTURE_2D:
              gl.framebufferTexture2D(gl.FRAMEBUFFER, layout, gl.TEXTURE_2D, webGLTexture, 0);
              break;

            case texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP:
              gl.framebufferTexture2D(gl.FRAMEBUFFER, layout, target, webGLTexture, 0);
              break;

            case texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY:
              gl.framebufferTextureLayer(gl.FRAMEBUFFER, layout, webGLTexture, 0, layer);
              break;

            default:
              break;
          }
        } else if (attachment instanceof renderBuffer_RenderBuffer) {
          const _webGLRenderBuffers$g2 = webGLRenderBuffers.getWebGLRenderBuffer(attachment),
                webGLRenderBuffer = _webGLRenderBuffers$g2.webGLRenderBuffer;

          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, layout, gl.RENDERBUFFER, webGLRenderBuffer);
        }

        properties.needsUpdate = false;
      }

      if (_needsUpdate) {
        const maxDrawBuffers = capabilities.maxDrawBuffers;

        if (colorAttachmentCount > 1) {
          if (drawBuffers.length > maxDrawBuffers) {
            throw new Error(`renderTarget required: ${drawBuffers.length},` + ` current device can provide only ${maxDrawBuffers}`);
          }

          drawBuffersExt.drawBuffersWEBGL(drawBuffers);
        }

        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        if (status !== gl.FRAMEBUFFER_COMPLETE) {
          if (status === gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
            throw new Error('frame buffer is incomplete, status: ' + status.toString(16) + '. FRAMEBUFFER_INCOMPLETE_ATTACHMENT: The attachment types are mismatched or not all' + ' framebuffer attachment points are framebuffer attachment complete');
          }

          if (status === gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
            throw new Error('frame buffer is incomplete, status: ' + status.toString(16) + '. FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: There is no attachment.');
          }

          if (status === gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
            throw new Error('frame buffer is incomplete, status: ' + status.toString(16) + '. FRAMEBUFFER_INCOMPLETE_DIMENSIONS:' + ' Height and width of the attachment are not the same.');
          }

          if (status === gl.FRAMEBUFFER_UNSUPPORTED) {
            throw new Error('frame buffer is incomplete, status: ' + status.toString(16) + '. FRAMEBUFFER_UNSUPPORTED');
          }

          if (status === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
            throw new Error('frame buffer is incomplete, status: ' + status.toString(16) + '. FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:' + ' The values are different among attached renderbuffers');
          }

          throw new Error('frame buffer is incomplete, unknown status: ' + status.toString(16));
        }
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      renderTarget._webGLFramebuffer = framebuffer;
      renderTarget._needsUpdate = false;
      renderTarget._needsUpdateAttachments = false;
      return renderTarget;
    };

    this.deleteFramebuffer = renderTarget => {
      const _webGLFramebuffer = renderTarget._webGLFramebuffer;

      if (_webGLFramebuffer === null) {
        return;
      }

      gl.deleteFramebuffer(_webGLFramebuffer);
      renderTarget._webGLFramebuffer = null;
    };

    this._sync = () => {
      gl.finish();
    };
  }

}
/* harmony default export */ var renderer_webGLFramebuffers = (webGLFramebuffers_WebGLFramebuffers);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLPowerPreferenceType.js
var WebGLPowerPreferenceType;

(function (WebGLPowerPreferenceType) {
  WebGLPowerPreferenceType["DEFAULT"] = "default";
  WebGLPowerPreferenceType["LOW_POWER"] = "default";
  WebGLPowerPreferenceType["HIGH_PERFORMANCE"] = "high-performance";
})(WebGLPowerPreferenceType || (WebGLPowerPreferenceType = {}));
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLFramebuffers/webGLFramebufferCopy.js
function webGLFramebufferCopy_slicedToArray(arr, i) { return webGLFramebufferCopy_arrayWithHoles(arr) || webGLFramebufferCopy_iterableToArrayLimit(arr, i) || webGLFramebufferCopy_unsupportedIterableToArray(arr, i) || webGLFramebufferCopy_nonIterableRest(); }

function webGLFramebufferCopy_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function webGLFramebufferCopy_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return webGLFramebufferCopy_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return webGLFramebufferCopy_arrayLikeToArray(o, minLen); }

function webGLFramebufferCopy_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function webGLFramebufferCopy_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function webGLFramebufferCopy_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function _webGL1FramebufferCopy(renderer, srcFramebuffer, dstFramebuffer, srcLayout, srcRect = null, dstRect = null, copyMaterial) {
  const screenSquare = renderer.screenSquare;
  const material = copyMaterial;
  const scene = new dotScene_DotScene({
    name: 'frame-copy-scene',
    maxSceneNodes: 2,
    config: {
      componentClasses: []
    }
  });
  const renderPass = new render_request_RenderRequest({
    scene,
    look: new look_Look(),
    srgbOutput: false
  });
  const srcRect_ = [0, 0, 1, 1];
  const dstRect_ = [0, 0, 1, 1];

  if (srcRect !== null) {
    srcRect_[0] = srcRect.min.x / srcFramebuffer.width;
    srcRect_[1] = srcRect.min.y / srcFramebuffer.height;
    srcRect_[2] = srcRect.max.x / srcFramebuffer.width;
    srcRect_[3] = srcRect.max.y / srcFramebuffer.height;
  }

  if (dstRect !== null) {
    dstRect_[0] = dstRect.min.x / dstFramebuffer.width;
    dstRect_[1] = dstRect.min.y / dstFramebuffer.height;
    dstRect_[2] = dstRect.max.x / dstFramebuffer.width;
    dstRect_[3] = dstRect.max.y / dstFramebuffer.height;
  }

  material.srcRect = srcRect_;
  material.dstRect = dstRect_;

  if (false) {}

  const subMesh = new mesh_component_SubMesh({
    geometry: screenSquare,
    material
  });
  scene.addInstance(subMesh);
  material.srcTexture = srcFramebuffer.getColorAttachment(srcLayout).attachment;
  renderer.render(renderPass);
  subMesh.dispose();
  scene.release();
}

function _webGL2FramebufferCopy(renderer, srcFramebuffer, dstFramebuffer, srcLayout, dstLayout, srcRect = null, dstRect = null, copyFilter = null, copyMask = null) {
  const gl = renderer.context;
  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer.webGLFramebuffer);

  if (false) {}

  gl.readBuffer(srcLayout);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer.webGLFramebuffer);

  if (false) {}

  const drawBuffers = [];

  for (let i = 0, count = dstFramebuffer.colorAttachmentCount; i < count; i++) {
    const layout = renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0 + i;
    drawBuffers.push(dstLayout === layout ? dstLayout : gl.NONE);
  }

  gl.drawBuffers(drawBuffers);

  const _ref = srcRect === null ? [0, 0, srcFramebuffer.width, srcFramebuffer.height] : [srcRect.min.x, srcRect.min.y, srcRect.max.x, srcRect.max.y],
        _ref2 = webGLFramebufferCopy_slicedToArray(_ref, 4),
        x0 = _ref2[0],
        y0 = _ref2[1],
        w0 = _ref2[2],
        h0 = _ref2[3];

  const _ref3 = dstRect === null ? [0, 0, dstFramebuffer.width, dstFramebuffer.height] : [dstRect.min.x, dstRect.min.y, dstRect.max.x, dstRect.max.y],
        _ref4 = webGLFramebufferCopy_slicedToArray(_ref3, 4),
        x1 = _ref4[0],
        y1 = _ref4[1],
        w1 = _ref4[2],
        h1 = _ref4[3];

  const filter_ = copyFilter !== null ? copyFilter : gl.NEAREST;
  const mask_ = copyMask !== null ? copyMask : gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
  gl.blitFramebuffer(x0, y0, w0, h0, x1, y1, w1, h1, mask_, filter_);
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/webGLSubPass.js



function _applyMaterial(gl, renderable, state, programs, textures, renderPass, currentMaterial, renderableMaterial) {
  return currentMaterial !== renderableMaterial ? (renderableMaterial.apply(gl, renderable, state, programs, textures, renderPass), renderableMaterial) : currentMaterial;
}

function _draw(gl, ext, statistics, geometry, visibleInstanceCount) {
  let elementCount = 0;
  const primitiveType = geometry.primitiveType,
        _geometry$indices = geometry.indices,
        indices = _geometry$indices === void 0 ? null : _geometry$indices;

  if (indices === null) {
    const attributes = geometry.attributes;
    const position = attributes.get(AttributeSemantic.POSITION);

    if (false) {}

    const count = position.countElements;
    const firstVertexIndex = 0;
    ext.drawArraysInstancedANGLE(primitiveType, firstVertexIndex, count, visibleInstanceCount);
    elementCount = count;
  } else {
    const count = indices.countElements,
          view = indices.view,
          componentType = indices.componentType;
    const byteOffset = view.byteOffset;
    ext.drawElementsInstancedANGLE(primitiveType, count, componentType, byteOffset, visibleInstanceCount);
    elementCount = count;
  }

  statistics.drawCallCount++;
  statistics.instanceCount += visibleInstanceCount;
  statistics.vertexCount += elementCount * visibleInstanceCount;
}

function _subPass(gl, ext, state, programs, textures, attributes, vertexInput, renderPass, queue, subPassIndex) {
  renderPass.onSubpassStart.emit(subPassIndex);
  const scene = renderPass.scene,
        statistics = renderPass.statistics,
        clearMask = renderPass.clearMask,
        rangedPass = renderPass.rangedPass;
  const instanceDataManager = scene.instanceDataManager;
  const bytesPerInstance = instanceDataManager.bytesPerInstance,
        customInstancedAttributeLayout = instanceDataManager.customInstancedAttributeLayout;
  let currentMaterial = null;
  let firstRenderable = 0;
  let renderableCount = queue.length;
  statistics.subpassCount++;

  if (rangedPass) {
    let rangeIndex = renderPass.queueRangeIndex,
        rangeSize = renderPass.queueRangeSize,
        rangeOffset = renderPass._queueRangeOffset;
    renderPass.onRangeStart.emit(rangeIndex, rangeOffset, rangeSize, renderableCount);
    const queueRangeIndex = renderPass.queueRangeIndex,
          queueRangeSize = renderPass.queueRangeSize;

    if (queueRangeIndex !== rangeIndex) {
      rangeIndex = queueRangeIndex;
      rangeSize = queueRangeSize;
      rangeOffset = rangeIndex * rangeSize;
    }

    firstRenderable = rangeOffset;
    renderableCount = Math.min(rangeOffset + rangeSize, renderableCount);
  }

  if (clearMask !== ClearMask.NONE) {
    gl.clear(clearMask);
  }

  for (let i = firstRenderable; i < renderableCount; i++) {
    const r = queue[i];
    const visibleInstanceCount = r.visibleInstanceCount,
          material = r.material,
          geometry = r.geometry;
    const visible = material.visible;

    if (!visible) {
      continue;
    }

    currentMaterial = _applyMaterial(gl, r, state, programs, textures, renderPass, currentMaterial, material);
    const program = material.program;
    const gpuInstancedData = instanceDataManager.gpuInstancedData;
    const vertexBuffer = vertexInput.vertexBuffer,
          elementsBuffer = vertexInput.elementsBuffer;
    const layout = program.layout;
    attributes.bindVertexInput(r, layout, customInstancedAttributeLayout, bytesPerInstance, vertexBuffer, gpuInstancedData, elementsBuffer);

    _draw(gl, ext, statistics, geometry, visibleInstanceCount);

    attributes.unbindVertexInput(layout);
  }

  state.depthMask = true;
  renderPass.onSubpassEnd.emit(subPassIndex);
}
function _depthSubPass(gl, ext, state, programs, textures, attributes, vertexInput, renderPass, queue, subPassIndex, depthMaterialIndex) {
  renderPass.onSubpassStart.emit(subPassIndex);
  const scene = renderPass.scene,
        statistics = renderPass.statistics;
  const instanceDataManager = scene.instanceDataManager;
  const bytesPerInstance = instanceDataManager.bytesPerInstance,
        customInstancedAttributeLayout = instanceDataManager.customInstancedAttributeLayout;
  let currentMaterial = null;
  statistics.subpassCount++;
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  for (const r of queue) {
    const depthMaterials = r.depthMaterials,
          visibleInstanceCount = r.visibleInstanceCount,
          material = r.material,
          geometry = r.geometry;
    const depthMaterial = depthMaterials[depthMaterialIndex];
    const visible = material.visible;

    if (depthMaterial === null || !visible) {
      continue;
    }

    currentMaterial = _applyMaterial(gl, r, state, programs, textures, renderPass, currentMaterial, depthMaterial);
    const program = depthMaterial.program;
    const gpuInstancedData = instanceDataManager.gpuInstancedData;
    const vertexBuffer = vertexInput.vertexBuffer,
          elementsBuffer = vertexInput.elementsBuffer;
    const layout = program.layout;
    attributes.bindDepthVertexInput(r, layout, customInstancedAttributeLayout, bytesPerInstance, vertexBuffer, gpuInstancedData, elementsBuffer);

    _draw(gl, ext, statistics, geometry, visibleInstanceCount);

    attributes.unbindVertexInput(layout);
  }

  renderPass.onSubpassEnd.emit(subPassIndex);
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/renderer/index.js
function renderer_slicedToArray(arr, i) { return renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest(); }

function renderer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }

function renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function renderer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function renderer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

































function _webGLBufferAlloc(gl, size, target, hint) {
  return new webGLBuffer_WebGLBuffer(gl, size, target, hint);
}

function _updateVertexInput(gl, vertexInputData) {
  const vertexBuffer = vertexInputData.vertexBuffer,
        elementsBuffer = vertexInputData.elementsBuffer,
        vertexStaging = vertexInputData.vertexStaging,
        elementStaging = vertexInputData.elementStaging;

  if (elementStaging.subdatas.length > 0) {
    for (let i = 0, count = elementStaging.subdatas.length; i < count; i++) {
      const _elementStaging$subda = elementStaging.subdatas[i],
            offset = _elementStaging$subda.offset,
            size = _elementStaging$subda.size;
      const source = new Uint8Array(elementStaging.buffer, offset, size);
      elementsBuffer.subdata(source, offset);
    }

    elementStaging.subdatas.length = 0;
  }

  if (vertexStaging.subdatas.length > 0) {
    for (let i = 0, count = vertexStaging.subdatas.length; i < count; i++) {
      const _vertexStaging$subdat = vertexStaging.subdatas[i],
            offset = _vertexStaging$subdat.offset,
            size = _vertexStaging$subdat.size;
      const source = new Float32Array(vertexStaging.buffer, offset, size / Float32Array.BYTES_PER_ELEMENT);
      vertexBuffer.subdata(source, offset);
    }

    vertexStaging.subdatas.length = 0;
  }

  gl.bindBuffer(elementsBuffer.bindingPoint, elementsBuffer.buffer);
}

function _getScreenSquareIndices(elementStaging, elementBuffer) {
  const elements = new vertexBufferView_VertexBufferView(elementStaging, 6 * Uint8Array.BYTES_PER_ELEMENT);

  if (elementStaging.empty) {
    const elementsView = new Uint8Array(6);
    elementsView.set([0, 1, 2, 0, 2, 3]);
    elementBuffer.subdata(elementsView, elements.view.byteOffset);
  } else {
    const elementsView = new Uint8Array(elements.view.buffer, elements.view.byteOffset, 6);
    elementsView.set([0, 1, 2, 0, 2, 3]);
  }

  return new vertexAttribute_VertexAttribute({
    vertexData: elements,
    offset: 0,
    stride: 1,
    semantic: AttributeSemantic.NONE,
    normalized: false,
    countComponents: 1,
    countElements: 6,
    componentType: dataTypes_DataType.UNSIGNED_BYTE,
    elementType: VertexAttributeType.SCALAR,
    type: Uint8Array
  });
}

function _getScreenSquareAttributes(vertexStaging, vertexBuffer) {
  const vertices = new vertexBufferView_VertexBufferView(vertexStaging, 8 * Float32Array.BYTES_PER_ELEMENT);

  if (vertexStaging.empty) {
    const verticesView = new Float32Array(8);
    verticesView.set([-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]);
    vertexBuffer.subdata(verticesView, vertices.view.byteOffset);
  } else {
    const verticesView = new Float32Array(vertices.view.buffer, vertices.view.byteOffset, 8);
    verticesView.set([-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]);
  }

  return new vertexAttribute_VertexAttribute({
    vertexData: vertices,
    offset: 0,
    stride: 8,
    semantic: AttributeSemantic.POSITION,
    normalized: false,
    countComponents: 2,
    countElements: 4,
    componentType: dataTypes_DataType.FLOAT,
    elementType: VertexAttributeType.VEC2,
    type: Float32Array
  });
}

function _getTriangleAttributes(vertexStaging, vertexBuffer) {
  const vertices = new vertexBufferView_VertexBufferView(vertexStaging, 3 * Float32Array.BYTES_PER_ELEMENT);

  if (vertexStaging.empty) {
    const verticesView = new Float32Array(3);
    verticesView.set([0, 1, 2]);
    vertexBuffer.subdata(verticesView, vertices.view.byteOffset);
  } else {
    const verticesView = new Float32Array(vertices.view.buffer, vertices.view.byteOffset, 3);
    verticesView.set([0, 1, 2]);
  }

  return new vertexAttribute_VertexAttribute({
    vertexData: vertices,
    offset: 0,
    stride: 4,
    semantic: AttributeSemantic.POSITION,
    normalized: false,
    countComponents: 1,
    countElements: 3,
    componentType: dataTypes_DataType.FLOAT,
    elementType: VertexAttributeType.SCALAR,
    type: Float32Array
  });
}

const resizeViewport = {
  x: 0,
  y: 0,
  width: 1,
  height: 1
};
class renderer_Renderer {
  constructor(properties) {
    this._nextSubPass = function __nextSubPass() {
      const viewport = {
        x: 0,
        y: 0,
        width: 1,
        height: 1
      };
      let prevRT = null;
      return function _nextSubPass(renderPass, subPassIndex) {
        const _context = this._context,
              _state = this._state,
              _webGLFramebuffers = this._webGLFramebuffers,
              _defaultRenderTarget = this._defaultRenderTarget,
              _pixelRatio = this._pixelRatio;
        const gl = _context;
        const rangedPass = renderPass.rangedPass,
              queueRangeIndex = renderPass.queueRangeIndex;
        const updateQueue = !rangedPass || queueRangeIndex === 0;
        const renderTarget = renderPass.renderTarget || _defaultRenderTarget;

        const _renderPass$_viewport = renderPass._viewport,
              _viewport = _renderPass$_viewport === void 0 ? null : _renderPass$_viewport,
              _multiplyPixelRatio = renderPass._multiplyPixelRatio,
              look = renderPass.look;

        let customViewport = false;

        if (_viewport !== null) {
          customViewport = true;
          viewport.x = _multiplyPixelRatio ? _viewport.x * _pixelRatio : _viewport.x;
          viewport.y = _multiplyPixelRatio ? _viewport.y * _pixelRatio : _viewport.y;
          viewport.width = _multiplyPixelRatio ? _viewport.width * _pixelRatio : _viewport.width;
          viewport.height = _multiplyPixelRatio ? _viewport.height * _pixelRatio : _viewport.height;
          look.aspect = viewport.width / viewport.height;
        }

        const subPass = updateQueue ? this._frustumCull(renderPass, subPassIndex) : renderPass.renderQueue;

        if (renderTarget.isRenderTargetCanvas) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);

          if (customViewport) {
            _state.viewport = viewport;
          } else if (prevRT !== renderTarget) {
            const width = renderTarget.width,
                  height = renderTarget.height;
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = width;
            viewport.height = height;
            _state.viewport = viewport;
          }
        } else if (renderTarget.isRenderTargetCube) {
          renderTarget.target = texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + subPassIndex;

          const _webGLFramebuffers$ge = _webGLFramebuffers.getWebGLFramebuffer(renderTarget),
                webGLFramebuffer = _webGLFramebuffers$ge.webGLFramebuffer;

          gl.bindFramebuffer(gl.FRAMEBUFFER, webGLFramebuffer);

          if (customViewport) {
            _state.viewport = viewport;
          } else if (prevRT !== renderTarget) {
            const width = renderTarget.width,
                  height = renderTarget.height;
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = width;
            viewport.height = height;
            _state.viewport = viewport;
          }
        } else if (renderTarget.isRenderTargetFramebuffer) {
          const _webGLFramebuffers$ge2 = _webGLFramebuffers.getWebGLFramebuffer(renderTarget),
                webGLFramebuffer = _webGLFramebuffers$ge2.webGLFramebuffer;

          gl.bindFramebuffer(gl.FRAMEBUFFER, webGLFramebuffer);

          if (customViewport) {
            _state.viewport = viewport;
          } else if (prevRT !== renderTarget) {
            const width = renderTarget.width,
                  height = renderTarget.height;
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = width;
            viewport.height = height;
            _state.viewport = viewport;
          }
        }

        prevRT = renderTarget;
        return subPass;
      };
    }();

    this.copyRenderTargetFramebuffers = function () {
      const copyMaterial_ = new copyMaterial_CopyMaterial('renderer-copy-material');
      return function ({
        srcRenderTargetFrameBuffer,
        dstRenderTargetFrameBuffer,
        srcLayout = renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0,
        dstLayout = renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0,
        srcRect = null,
        dstRect = null,
        filter = false,
        copyColor = true,
        copyDepth = false,
        copyStencil = false,
        copyMaterial = copyMaterial_
      }) {
        const capabilities = this.capabilities,
              frameBuffers = this.frameBuffers,
              gl = this.context;
        const webgl2Support = capabilities.webgl2Support;
        const srcFramebuffer = frameBuffers.getWebGLFramebuffer(srcRenderTargetFrameBuffer);
        const dstFramebuffer = frameBuffers.getWebGLFramebuffer(dstRenderTargetFrameBuffer);

        if (webgl2Support && copyMaterial.id === copyMaterial_.id) {
          const filter_ = filter ? gl.LINEAR : gl.NEAREST;
          let mask = 0;

          if (copyColor) {
            mask |= gl.COLOR_BUFFER_BIT;
          }

          if (copyDepth) {
            mask |= gl.DEPTH_BUFFER_BIT;
          }

          if (copyStencil) {
            mask |= gl.STENCIL_BUFFER_BIT;
          }

          _webGL2FramebufferCopy(this, srcFramebuffer, dstFramebuffer, srcLayout, dstLayout, srcRect, dstRect, filter_, mask);
        } else {
          if (false) {}

          if (false) {}

          if (false) {}

          if (false) {}

          _webGL1FramebufferCopy(this, srcFramebuffer, dstFramebuffer, srcLayout, srcRect, dstRect, copyMaterial);
        }
      };
    }();

    {
      const canvas = properties.canvas;
      this._defaultRenderTarget = new renderTargetCanvas_RenderTargetCanvas({
        canvas
      });
    }
    {
      const _defaultRenderTarget = this._defaultRenderTarget;
      const canvas = _defaultRenderTarget.canvas;
      const _properties$possibleC = properties.possibleContextTypes,
            possibleContextTypes = _properties$possibleC === void 0 ? [] : _properties$possibleC,
            _properties$alpha = properties.alpha,
            alpha = _properties$alpha === void 0 ? true : _properties$alpha,
            _properties$depth = properties.depth,
            depth = _properties$depth === void 0 ? true : _properties$depth,
            _properties$stencil = properties.stencil,
            stencil = _properties$stencil === void 0 ? true : _properties$stencil,
            _properties$antialias = properties.antialias,
            antialias = _properties$antialias === void 0 ? true : _properties$antialias,
            _properties$premultip = properties.premultipliedAlpha,
            premultipliedAlpha = _properties$premultip === void 0 ? false : _properties$premultip,
            _properties$preserveD = properties.preserveDrawingBuffer,
            preserveDrawingBuffer = _properties$preserveD === void 0 ? false : _properties$preserveD,
            _properties$failIfMaj = properties.failIfMajorPerformanceCaveat,
            failIfMajorPerformanceCaveat = _properties$failIfMaj === void 0 ? false : _properties$failIfMaj,
            _properties$powerPref = properties.powerPreference,
            powerPreference = _properties$powerPref === void 0 ? WebGLPowerPreferenceType.DEFAULT : _properties$powerPref,
            _properties$desynchro = properties.desynchronized,
            desynchronized = _properties$desynchro === void 0 ? false : _properties$desynchro,
            pixelRatio = properties.pixelRatio;

      if (possibleContextTypes.length === 0) {
        possibleContextTypes.push(WebGLContextType.WEB_GL_2, WebGLContextType.WEB_GL_2_EXPERIMENTAL, WebGLContextType.WEB_GL, WebGLContextType.WEB_GL_EXPERIMENTAL);
      }

      const attributes = {
        alpha,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        failIfMajorPerformanceCaveat,
        powerPreference,
        desynchronized
      };
      let contextCreationResult = null;
      let context = null;
      let contextType_ = null;

      try {
        for (const contextType of possibleContextTypes) {
          context = canvas.getContext(contextType, attributes);
          contextCreationResult = testWebGLContext(context);

          if (contextCreationResult.isWebGLContext) {
            contextType_ = contextType;
            break;
          }
        }

        if (contextCreationResult === null || !contextCreationResult.isWebGLContext) {
          throw new Error('could not create webgl context');
        }

        canvas.addEventListener('webglcontextlost', () => undefined, false);
      } catch (error) {
        throw new Error(`can not create webgl rendering context: ${error}`);
      }

      this._context = context;
      this._contextType = contextType_;
      this._pixelRatio = typeof pixelRatio === 'number' ? pixelRatio : window.devicePixelRatio || 1;
    }
    {
      const _context = this._context;
      const gl = _context;
      const _properties$colorSpac = properties.colorSpaceConversion,
            colorSpaceConversion = _properties$colorSpac === void 0 ? false : _properties$colorSpac;
      const value = colorSpaceConversion ? gl.BROWSER_DEFAULT_WEBGL : gl.NONE;
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, value);
    }
    {
      const _context = this._context;
      const premultipliedAlpha = properties.premultipliedAlpha;
      const gl = _context;
      const extensions = new webGLExtensions_WebGLExtensions(_context);
      this._extensions = extensions;
      const capabilities = new webGLCapabilities_WebGLCapabilities(_context, extensions);
      this._capabilities = capabilities;
      const state = new webGLState_WebGLState(_context, {
        premultipliedAlpha
      });
      this._state = state;
      const webGLTextures = new webGLTextures_WebGLTextures({
        gl,
        capabilities,
        extensions
      });
      this._webGLTextures = webGLTextures;
      const webGLRenderBuffers = new WebGLRenderBuffers({
        gl,
        capabilities
      });
      const webGLPrograms = new webGLPrograms_WebGLPrograms({
        gl,
        capabilities,
        extensions
      });
      this._webGLPrograms = webGLPrograms;
      const webGLFramebuffers = new webGLFramebuffers_WebGLFramebuffers({
        gl,
        capabilities,
        extensions,
        webGLTextures,
        webGLRenderBuffers
      });
      this._webGLFramebuffers = webGLFramebuffers;
    }
    {
      const _extensions = this._extensions,
            gl = this._context;

      const rendererInfo = _extensions.get('WEBGL_debug_renderer_info');

      const vendor = rendererInfo !== null ? gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL) : 'unknown';
      const device = rendererInfo !== null ? gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL) : 'unknown';
      Object.defineProperties(this, {
        gpuName: {
          value: device
        },
        gpuVendor: {
          value: vendor
        }
      });
    }
    {
      const _context = this._context;
      const _properties$memoryCon = properties.memoryConfig,
            memoryConfig = _properties$memoryCon === void 0 ? {} : _properties$memoryCon,
            elementStaging = properties.elementStaging,
            vertexStaging = properties.vertexStaging;
      const elementsMemorySize = memoryConfig.elementsMemorySize,
            verticesMemorySize = memoryConfig.verticesMemorySize;
      const gl = _context;
      const elementsMemorySize_ = elementsMemorySize || elementStaging.size - elementStaging.size % 4;
      const verticesMemorySize_ = verticesMemorySize || vertexStaging.size;
      const vertexInputData = {
        elementStaging,
        vertexStaging,
        elementsBuffer: new webGLBuffer_WebGLBuffer(gl, elementsMemorySize_, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW),
        vertexBuffer: new webGLBuffer_WebGLBuffer(gl, verticesMemorySize_, gl.ARRAY_BUFFER, gl.STATIC_DRAW),
        verticesMemorySize: verticesMemorySize_,
        elementsMemeorySize: elementsMemorySize_
      };
      this._vertexInputData = vertexInputData;
    }
    {
      const _extensions = this._extensions;

      const glExtInstances = _extensions.get('ANGLE_instanced_arrays');

      this._glExtInstances = glExtInstances;
    }
    {
      const _context = this._context,
            _capabilities = this._capabilities,
            _extensions = this._extensions;
      const gl = _context;
      const capabilities = _capabilities;
      const extensions = _extensions;
      const webGLAttributes = new webGLAttributes_WebGLAttributes({
        gl,
        capabilities,
        extensions
      });
      this._webGLAttributes = webGLAttributes;
    }
    {
      const _vertexInputData = this._vertexInputData;
      const elementStaging = _vertexInputData.elementStaging,
            vertexStaging = _vertexInputData.vertexStaging,
            elementsBuffer = _vertexInputData.elementsBuffer,
            vertexBuffer = _vertexInputData.vertexBuffer;

      const position = _getScreenSquareAttributes(vertexStaging, vertexBuffer);

      const indices = _getScreenSquareIndices(elementStaging, elementsBuffer);

      this._screenSquare = new geometry_resource_Geometry();

      this._screenSquare.attributes.set(AttributeSemantic.POSITION, position);

      this._screenSquare.indices = indices;
      this._screenSquare.needsUpdateBoundingBox = false;

      this._screenSquare.retain();
    }
    {
      const _vertexInputData = this._vertexInputData;
      const vertexStaging = _vertexInputData.vertexStaging,
            vertexBuffer = _vertexInputData.vertexBuffer;

      const position = _getTriangleAttributes(vertexStaging, vertexBuffer);

      this._screenTriangle = new geometry_resource_Geometry();

      this._screenTriangle.attributes.set(AttributeSemantic.POSITION, position);

      this._screenTriangle.needsUpdateBoundingBox = false;

      this._screenTriangle.retain();
    }
    this._depthMaterials = [new depthMaterial_DepthMaterial({
      name: 'directional-casters'
    }), new depthMaterial_DepthMaterial({
      name: 'omni-directional-casters',
      defines: {
        OMNI_DIRECTIONAL_CASTER: ''
      }
    })];
    this.onFrameStart = new _wgetemp_event["a" /* Event */]();
    this.onFrameEnd = new _wgetemp_event["a" /* Event */]();
  }

  render(renderRequest) {
    this.onFrameStart.emit();
    renderRequest.onStart.emit();
    const scene = renderRequest.scene,
          statistics = renderRequest.statistics;

    if (scene instanceof dotScene_DotScene) {
      scene._update(renderRequest.look);
    }

    const capabilities = this.capabilities,
          _context = this._context,
          _vertexInputData = this._vertexInputData,
          _state = this._state,
          _webGLTextures = this._webGLTextures,
          _webGLPrograms = this._webGLPrograms,
          _webGLAttributes = this._webGLAttributes,
          _glExtInstances = this._glExtInstances;
    const webgl2Support = capabilities.webgl2Support;
    const gl = _context;

    _updateVertexInput(_context, _vertexInputData);

    renderRequest._premultipliedAlpha = _state.premultipliedAlpha;
    statistics.reset();
    {
      const directShadowCastersData = scene.getDirectShadowCastersData(renderRequest.look);

      if (directShadowCastersData) {
        const _directShadowCastersD = directShadowCastersData.directShadowCasters,
              directShadowCasters = _directShadowCastersD === void 0 ? [] : _directShadowCastersD;

        if (directShadowCasters.length > 0) {
          const renderPassCamera = renderRequest.look;
          const renderPassRenderTarget = renderRequest.renderTarget;
          const renderPassViewport = renderRequest._viewport;
          renderRequest._viewport = null;
          const _state$_colorClearVal = _state._colorClearValue,
                r = _state$_colorClearVal.r,
                g = _state$_colorClearVal.g,
                b = _state$_colorClearVal.b;
          const a = _state._alphaClearValue;

          for (const _ref of directShadowCasters) {
            const _cascades = _ref._cascades;

            for (const _ref2 of _cascades.entries()) {
              var _ref3 = renderer_slicedToArray(_ref2, 2);

              const subPassIndex = _ref3[0];
              var _ref3$ = _ref3[1];
              const camera = _ref3$.camera;
              const renderTarget = _ref3$.renderTarget;
              renderRequest.look = camera;
              renderRequest.renderTarget = renderTarget;

              const renderQueue = this._nextSubPass(renderRequest, subPassIndex);

              _depthSubPass(gl, _glExtInstances, _state, _webGLPrograms, _webGLTextures, _webGLAttributes, _vertexInputData, renderRequest, renderQueue, subPassIndex, 0);
            }
          }

          renderRequest.look = renderPassCamera;
          renderRequest.renderTarget = renderPassRenderTarget;
          renderRequest._viewport = renderPassViewport;
          gl.clearColor(r, g, b, a);
        }
      }
    }
    {
      const spotShadowCasters = scene.getSpotShadowCasters();

      if (spotShadowCasters && spotShadowCasters.length > 0) {
        const renderPassCamera = renderRequest.look;
        const renderPassRenderTarget = renderRequest.renderTarget;
        const renderPassViewport = renderRequest._viewport;
        renderRequest._viewport = null;
        const _state$_colorClearVal2 = _state._colorClearValue,
              r = _state$_colorClearVal2.r,
              g = _state$_colorClearVal2.g,
              b = _state$_colorClearVal2.b;
        const a = _state._alphaClearValue;

        for (const _ref4 of spotShadowCasters) {
          const shadowCaster = _ref4.shadowCaster;
          const _spotShadowCasterData = shadowCaster._spotShadowCasterData;
          const camera = _spotShadowCasterData.camera,
                renderTarget = _spotShadowCasterData.renderTarget;
          renderRequest.look = camera;
          renderRequest.renderTarget = renderTarget;

          const renderQueue = this._nextSubPass(renderRequest, 0);

          _depthSubPass(gl, _glExtInstances, _state, _webGLPrograms, _webGLTextures, _webGLAttributes, _vertexInputData, renderRequest, renderQueue, 0, 0);
        }

        renderRequest.look = renderPassCamera;
        renderRequest.renderTarget = renderPassRenderTarget;
        renderRequest._viewport = renderPassViewport;
        gl.clearColor(r, g, b, a);
      }
    }
    {
      const omniShadowCasters = scene.getOmniShadowCasters();

      if (omniShadowCasters && omniShadowCasters.length > 0) {
        const renderPassCamera = renderRequest.look;
        const renderPassRenderTarget = renderRequest.renderTarget;
        const renderPassViewport = renderRequest._viewport;
        renderRequest._viewport = null;
        const _state$_colorClearVal3 = _state._colorClearValue,
              r = _state$_colorClearVal3.r,
              g = _state$_colorClearVal3.g,
              b = _state$_colorClearVal3.b;
        const a = _state._alphaClearValue;

        for (const _ref5 of omniShadowCasters) {
          const shadowCaster = _ref5.shadowCaster;
          const _omniShadowCasterData = shadowCaster._omniShadowCasterData;
          const cubeCamera = _omniShadowCasterData.cubeCamera;
          const renderTarget = _omniShadowCasterData.renderTarget,
                renderTargets = _omniShadowCasterData.renderTargets;
          renderRequest.look = cubeCamera;

          if (webgl2Support) {
            renderRequest.renderTarget = renderTarget;
          }

          for (let subPassIndex = 0; subPassIndex < 6; ++subPassIndex) {
            if (!webgl2Support) {
              renderRequest.renderTarget = renderTargets[subPassIndex];
              renderRequest.renderTarget.targetIndex = subPassIndex;
            }

            const renderQueue = this._nextSubPass(renderRequest, subPassIndex);

            _depthSubPass(gl, _glExtInstances, _state, _webGLPrograms, _webGLTextures, _webGLAttributes, _vertexInputData, renderRequest, renderQueue, subPassIndex, 1);
          }
        }

        renderRequest.look = renderPassCamera;
        renderRequest.renderTarget = renderPassRenderTarget;
        renderRequest._viewport = renderPassViewport;
        gl.clearColor(r, g, b, a);
      }
    }

    const subPassCount = this._getSubPassCount(renderRequest);

    const rangedPass = renderRequest.rangedPass;

    if (false) {}

    for (let subPassIndex = 0; subPassIndex < subPassCount; subPassIndex++) {
      const renderQueue = this._nextSubPass(renderRequest, subPassIndex);

      _subPass(gl, _glExtInstances, _state, _webGLPrograms, _webGLTextures, _webGLAttributes, _vertexInputData, renderRequest, renderQueue, subPassIndex);
    }

    if (rangedPass) {
      renderRequest._queueRangeIndex = ++renderRequest._queueRangeIndex;
      renderRequest._queueRangeOffset += renderRequest.queueRangeSize;
    }

    renderRequest.onEnd.emit();
    this.onFrameEnd.emit();
    renderRequest.frameNumber++;
  }

  readPixels(renderTarget, x, y, width, height, buffer) {
    const _width = renderTarget.width,
          _height = renderTarget.height;

    if (false) {}

    if (false) {}

    const gl = this._context;
    const gl2 = gl;

    if (renderTarget instanceof renderTargetCanvas_RenderTargetCanvas) {
      gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
    } else if (renderTarget.isRenderTargetFramebuffer) {
      const capabilities = this.capabilities,
            frameBuffers = this.frameBuffers;
      const webgl2Support = capabilities.webgl2Support;
      const target = webgl2Support ? gl2.READ_FRAMEBUFFER : gl.FRAMEBUFFER;

      const _renderTarget$getColo = renderTarget.getColorAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0),
            attachment = _renderTarget$getColo.attachment;

      const format = attachment.format,
            componentType = attachment.componentType;

      const _frameBuffers$getWebG = frameBuffers.getWebGLFramebuffer(renderTarget),
            webGLFramebuffer = _frameBuffers$getWebG.webGLFramebuffer;

      gl.bindFramebuffer(target, webGLFramebuffer);
      gl.readPixels(x, y, width, height, format, componentType, buffer);
      gl.bindFramebuffer(target, null);
    }
  }

  _frustumCull(renderPass, subPassIndex) {
    const scene = renderPass.scene;
    const gl = this._context;
    const instanceDataManager = scene.instanceDataManager;
    const result = renderPass.runFrustumCull(subPassIndex);
    instanceDataManager.flushInstancedMemory(gl, _webGLBufferAlloc);
    return result;
  }

  _getSubPassCount(renderPass) {
    const _defaultRenderTarget = this._defaultRenderTarget;
    const renderTarget = renderPass.renderTarget || _defaultRenderTarget;

    if (renderTarget instanceof renderTargetCanvas_RenderTargetCanvas) {
      return 1;
    }

    if (renderTarget instanceof renderTargetCube_RenderTargetCube) {
      return 6;
    }

    if (renderTarget instanceof renderTargetFramebuffer_RenderTargetFramebuffer) {
      return 1;
    }

    return 0;
  }

  get context() {
    return this._context;
  }

  get contextType() {
    return this._contextType;
  }

  get capabilities() {
    return this._capabilities;
  }

  get elementStaging() {
    return this._vertexInputData.elementStaging;
  }

  set elementStaging(value) {
    const gl = this._context,
          _vertexInputData = this._vertexInputData,
          _screenSquare = this._screenSquare;
    _screenSquare.indices = null;
    _vertexInputData.elementStaging = value;
    const stagingSize = _vertexInputData.elementStaging.buffer.byteLength;
    const bufferSize = _vertexInputData.elementsBuffer === null ? 0 : _vertexInputData.elementsBuffer.size;

    if (stagingSize > bufferSize) {
      if (_vertexInputData.elementsBuffer !== null) {
        _vertexInputData.elementsBuffer.dispose();
      }

      _vertexInputData.elementsBuffer = new webGLBuffer_WebGLBuffer(gl, stagingSize, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
      _vertexInputData.elementsMemeorySize = stagingSize;
    }

    _screenSquare.indices = _getScreenSquareIndices(value, _vertexInputData.elementsBuffer);
  }

  get vertexStaging() {
    return this._vertexInputData.vertexStaging;
  }

  set vertexStaging(value) {
    const gl = this._context,
          _vertexInputData = this._vertexInputData,
          _screenSquare = this._screenSquare,
          _screenTriangle = this._screenTriangle;

    _screenSquare.attributes.clear();

    _screenTriangle.attributes.clear();

    _vertexInputData.vertexStaging = value;
    const stagingSize = _vertexInputData.vertexStaging.buffer.byteLength;
    const bufferSize = _vertexInputData.vertexBuffer === null ? 0 : _vertexInputData.vertexBuffer.size;

    if (stagingSize > bufferSize) {
      if (_vertexInputData.vertexBuffer !== null) {
        _vertexInputData.vertexBuffer.dispose();
      }

      _vertexInputData.vertexBuffer = new webGLBuffer_WebGLBuffer(gl, stagingSize, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
      _vertexInputData.verticesMemorySize = stagingSize;
    }

    _screenSquare.attributes.set(AttributeSemantic.POSITION, _getScreenSquareAttributes(value, _vertexInputData.vertexBuffer));

    _screenTriangle.attributes.set(AttributeSemantic.POSITION, _getTriangleAttributes(value, _vertexInputData.vertexBuffer));
  }

  get indexHardwareBuffer() {
    return this._vertexInputData.elementsBuffer;
  }

  get vertexHardwareBuffer() {
    return this._vertexInputData.vertexBuffer;
  }

  get defaultRenderTarget() {
    return this._defaultRenderTarget;
  }

  get canvas() {
    return this._defaultRenderTarget.canvas;
  }

  get width() {
    return this._defaultRenderTarget.width;
  }

  get height() {
    return this._defaultRenderTarget.height;
  }

  get extensions() {
    return this._extensions;
  }

  get state() {
    return this._state;
  }

  get screenSquare() {
    return this._screenSquare;
  }

  get screenTriangle() {
    return this._screenTriangle;
  }

  get pixelRatio() {
    return this._pixelRatio;
  }

  set pixelRatio(value) {
    const canvas = this.canvas;
    const style = canvas.style;

    const _style$width$match$ma = style.width.match(/\d+/g).map(Number),
          _style$width$match$ma2 = renderer_slicedToArray(_style$width$match$ma, 1),
          width = _style$width$match$ma2[0];

    const _style$height$match$m = style.height.match(/\d+/g).map(Number),
          _style$height$match$m2 = renderer_slicedToArray(_style$height$match$m, 1),
          height = _style$height$match$m2[0];

    this._pixelRatio = value;
    this.resize(width, height, false);
  }

  get frameBuffers() {
    return this._webGLFramebuffers;
  }

  get textures() {
    return this._webGLTextures;
  }

  resize(w, h, updateStyle = true) {
    const _defaultRenderTarget = this._defaultRenderTarget,
          _pixelRatio = this._pixelRatio,
          _state = this._state;
    resizeViewport.x = 0;
    resizeViewport.y = 0;
    resizeViewport.width = Math.floor(w * _pixelRatio);
    resizeViewport.height = Math.floor(h * _pixelRatio);

    _defaultRenderTarget.resize(w, h, _pixelRatio, updateStyle);

    _state.viewport = resizeViewport;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/pbrMeshMaterial/utils.js
function utils_slicedToArray(arr, i) { return utils_arrayWithHoles(arr) || utils_iterableToArrayLimit(arr, i) || utils_unsupportedIterableToArray(arr, i) || utils_nonIterableRest(); }

function utils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }

function utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function utils_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function utils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





const _exposureApplyMask = OutputLayoutSemantic.DEFAULT;
const _iblMask = OutputLayoutSemantic.DIFFUSE | OutputLayoutSemantic.SPECULAR | OutputLayoutSemantic.TM_DIFFUSE | OutputLayoutSemantic.TM_SPECULAR | OutputLayoutSemantic.INDIRECT_SPECULAR | OutputLayoutSemantic.INDIRECT_DIFFUSE | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR | OutputLayoutSemantic.DEFAULT;
const _emissiveMask = OutputLayoutSemantic.EMISSIVE | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR | OutputLayoutSemantic.DEFAULT;
const _worldCameraMask = _iblMask | OutputLayoutSemantic.DIRECT_SPECULAR | OutputLayoutSemantic.DIRECT_DIFFUSE;
const _lightsMask = _worldCameraMask;
const _cascadeShadowMask = _worldCameraMask;
const _metalnessRoughnessF0Mask = _worldCameraMask | OutputLayoutSemantic.COLOR_1;
const _albedoMask = _worldCameraMask | OutputLayoutSemantic.COLOR_0;
const _opacityMask = _worldCameraMask & ~OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.COLOR_0;
const _normalsMask = _worldCameraMask | OutputLayoutSemantic.NORMALS;

function _getLightIterator(renderPass) {
  const scene = renderPass.scene;

  if (scene instanceof scene_Scene) {
    const entityManager = scene.entityManager;
    return entityManager.getComponentStorage(light_Light).components();
  }

  if (scene instanceof dotScene_DotScene) {
    return scene.lights.keys();
  }

  return [];
}

function _setLightProperty(structUniform, propertyName, value) {
  structUniform.get(propertyName).setValue(value);
}

function _setLuminousIntensity(structUniform, intensity) {
  _setLightProperty(structUniform, 'luminousIntensity', intensity);
}

function _setLightDirection(structUniform, direction) {
  _setLightProperty(structUniform, 'viewSpaceDirection', direction);
}

function _setLightPosition(structUniform, position) {
  _setLightProperty(structUniform, 'viewSpacePosition', position);
}

function _setLightSize(structUniform, size) {
  _setLightProperty(structUniform, 'size', size);
}

function _setLightInvAttenRadius(structUniform, invAttenRadius) {
  _setLightProperty(structUniform, 'invAttenRadius', invAttenRadius);
}

const _applyLights = (() => {
  const luminance = new lib["n" /* Vector3 */]();
  const intensity = new lib["n" /* Vector3 */]();
  const direction = new lib["n" /* Vector3 */]();
  const position = new lib["n" /* Vector3 */]();
  return function (gl, uniforms, renderPass, technique) {
    const _output = technique._output;

    const lights = _getLightIterator(renderPass);

    let dirLightIndex = 0;
    let pointLightIndex = 0;
    let spotLightIndex = 0;
    let directionalLights = null;
    let pointLights = null;
    let spotLights = null;

    if ((_output & _lightsMask) === 0) {
      return;
    }

    for (const light of lights) {
      if (light instanceof directional_light_DirectionalLight) {
        if (directionalLights === null) {
          directionalLights = uniforms.get('directionalLight');
        }

        if (!(directionalLights instanceof arrayUniform_ArrayUniform)) {
          throw new Error('directionalLights is not ArrayUniform');
        }

        const dirLight = directionalLights.get(dirLightIndex++);

        if (dirLight === undefined) {
          throw new Error('uniform is undefined');
        }

        light.getLuminance(luminance);
        light.getDirection(direction);

        _setLightProperty(dirLight, 'luminance', luminance);

        _setLightDirection(dirLight, direction);
      } else if (light instanceof ambient_light_AmbientLight) {
        light.getLuminance(luminance);
        const ambientLight = uniforms.get('ambientLight');

        if (ambientLight === undefined) {
          throw new Error('uniform is undefined');
        }

        ambientLight.get('luminance').setValue(luminance);
      } else if (light instanceof point_light_PointLight) {
        if (pointLights === null) {
          pointLights = uniforms.get('pointLight');
        }

        if (!(pointLights instanceof arrayUniform_ArrayUniform)) {
          throw new Error('pointLights is not ArrayUniform');
        }

        const pointLight = pointLights.get(pointLightIndex++);

        if (pointLight === undefined) {
          throw new Error('uniform is undefined');
        }

        light.getLuminousIntensity(intensity);
        light.getPosition(position);
        const size = light.size,
              invAttenRadius = light.invAttenRadius;

        _setLuminousIntensity(pointLight, intensity);

        _setLightPosition(pointLight, position);

        _setLightSize(pointLight, size);

        _setLightInvAttenRadius(pointLight, invAttenRadius);
      } else if (light instanceof spot_light_SpotLight) {
        if (spotLights === null) {
          spotLights = uniforms.get('spotLight');
        }

        if (!(spotLights instanceof arrayUniform_ArrayUniform)) {
          throw new Error('spotLights is not ArrayUniform');
        }

        const spotLight = spotLights.get(spotLightIndex++);

        if (spotLight === undefined) {
          throw new Error('uniform is undefined');
        }

        light.getLuminousIntensity(intensity);
        light.getPosition(position);
        light.getDirection(direction);
        const size = light.size,
              invAttenRadius = light.invAttenRadius,
              lightAngleScale = light.lightAngleScale,
              lightAngleOffset = light.lightAngleOffset;

        _setLuminousIntensity(spotLight, intensity);

        _setLightPosition(spotLight, position);

        _setLightDirection(spotLight, direction);

        _setLightSize(spotLight, size);

        _setLightInvAttenRadius(spotLight, invAttenRadius);

        _setLightProperty(spotLight, 'lightAngleScale', lightAngleScale);

        _setLightProperty(spotLight, 'lightAngleOffset', lightAngleOffset);
      }
    }
  };
})();
function _updateLightCount(defines, renderPass) {
  const lights = _getLightIterator(renderPass);

  let dirLightCount = 0;
  let useAmbientLight = false;
  let pointLightCount = 0;
  let spotLightCount = 0;

  for (const light of lights) {
    if (light instanceof directional_light_DirectionalLight) {
      dirLightCount++;
    } else if (light instanceof ambient_light_AmbientLight) {
      useAmbientLight = true;
    } else if (light instanceof point_light_PointLight) {
      pointLightCount++;
    } else if (light instanceof spot_light_SpotLight) {
      spotLightCount++;
    }
  }

  defines.DIRECTIONAL_LIGHTS_COUNT = dirLightCount;
  defines.POINT_LIGHTS_COUNT = pointLightCount;
  defines.SPOT_LIGHTS_COUNT = spotLightCount;

  if (useAmbientLight) {
    defines.USE_AMBIENT_LIGHT = '';
  } else {
    delete defines.USE_AMBIENT_LIGHT;
  }
}
function _prepSamplerInfo(propName, samplers, texToSampler, textId, prevSlot, channel, decode) {
  let sampler = texToSampler.get(textId);
  let slot = prevSlot;

  if (sampler === undefined) {
    sampler = {
      slot: ++slot,
      channel
    };

    if (decode !== undefined) {
      sampler.decode = decode;
    }

    texToSampler.set(textId, sampler);
  }

  samplers[propName] = sampler;
  return slot;
}
function _updateDirectShadowCasters(gl, uniforms, renderPass, textures, webgl2Support) {
  const scene = renderPass.scene;

  if (!scene.isScene) {
    return;
  }

  const shadowTextureArray = scene.shadowTextureArray,
        directShadowCastersMask = scene.directShadowCastersMask;
  const _cascadesCount = scene._cascadesCount,
        _shadowMapSize = scene._shadowMapSize;
  const directShadowCastersData = scene.getDirectShadowCastersData(renderPass.look);
  const _directShadowCastersD = directShadowCastersData.directShadowCasters,
        directShadowCasters = _directShadowCastersD === void 0 ? [] : _directShadowCastersD,
        frustumSplits = directShadowCastersData.frustumSplits;
  {
    const uniform = uniforms.get('frustumSplits');

    if (uniform === undefined) {
      throw new Error('uniform is undefined');
    }

    uniform.setValue(frustumSplits);
  }
  let lightIndex = 0;
  let directShadowCastersSamplers = null;
  {
    const uniform = uniforms.get('directShadowCastersMask');

    if (uniform === undefined) {
      throw new Error('uniform is undefined');
    }

    uniform.setValue(directShadowCastersMask);
  }

  if (webgl2Support) {
    const uniformLocation = gl.getUniformLocation(this.program.webglProgram, 'directShadowCastersSamplers');

    if (false) {}

    if (directShadowCastersSamplers === null) {
      directShadowCastersSamplers = uniforms.get('directShadowCastersSamplers');
    }

    if (directShadowCastersSamplers === undefined) {
      throw new Error('uniform is undefined');
    }

    directShadowCastersSamplers.location = uniformLocation;

    this._setTexture(gl, directShadowCastersSamplers, shadowTextureArray, textures);
  } else {
    const uniform = uniforms.get('shadowMapSize');

    if (uniform === undefined) {
      throw new Error('uniform is undefined');
    }

    uniform.setValue(1 / _shadowMapSize);
  }

  for (const _ref of directShadowCasters) {
    const light = _ref.light;
    const _cascades = _ref._cascades;
    const directionalLight = light;

    if (!directionalLight.isDirectionalLight) {
      continue;
    }

    for (const _ref2 of _cascades.entries()) {
      var _ref3 = utils_slicedToArray(_ref2, 2);

      const cascadeIndex = _ref3[0];
      var _ref3$ = _ref3[1];
      const camera = _ref3$.camera;
      const texture = _ref3$.texture;
      const index = lightIndex * _cascadesCount + cascadeIndex;

      if (!webgl2Support) {
        const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `directShadowCastersSamplers[${index}]`);

        if (false) {}

        if (directShadowCastersSamplers === null) {
          directShadowCastersSamplers = uniforms.get('directShadowCastersSamplers');
        }

        if (directShadowCastersSamplers === undefined) {
          throw new Error('uniform is undefined');
        }

        directShadowCastersSamplers.location = uniformLocation;

        this._setTexture(gl, directShadowCastersSamplers, texture, textures);
      }

      {
        const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `directShadowCastersTransforms[${index}]`);

        if (false) {}

        gl.uniformMatrix4fv(uniformLocation, false, camera.viewProjectionMatrix.toArray([]));
      }
    }

    ++lightIndex;
  }
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/pbrMeshMaterial/index.js
function pbrMeshMaterial_slicedToArray(arr, i) { return pbrMeshMaterial_arrayWithHoles(arr) || pbrMeshMaterial_iterableToArrayLimit(arr, i) || pbrMeshMaterial_unsupportedIterableToArray(arr, i) || pbrMeshMaterial_nonIterableRest(); }

function pbrMeshMaterial_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function pbrMeshMaterial_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pbrMeshMaterial_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pbrMeshMaterial_arrayLikeToArray(o, minLen); }

function pbrMeshMaterial_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function pbrMeshMaterial_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function pbrMeshMaterial_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








const pbrMeshShader = ShaderLib.pbrMeshShader;
const pbrMeshMaterial_vertexShader = pbrMeshShader.vertexShader,
      pbrMeshMaterial_fragmentShader = pbrMeshShader.fragmentShader;
class pbrMeshMaterial_PbrMeshMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$alphaMode = properties.alphaMode,
          alphaMode = _properties$alphaMode === void 0 ? material_Material.AlphaMode.OPAQUE : _properties$alphaMode,
          _properties$alphaCuto = properties.alphaCutoff,
          alphaCutoff = _properties$alphaCuto === void 0 ? 0.0 : _properties$alphaCuto,
          _properties$opacity = properties.opacity,
          opacity = _properties$opacity === void 0 ? 1 : _properties$opacity,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.NONE : _properties$cullFace,
          _properties$albedo = properties.albedo,
          albedo = _properties$albedo === void 0 ? new lib["k" /* RGBColor */](1, 1, 1) : _properties$albedo,
          _properties$albedoMap = properties.albedoMap,
          albedoMap = _properties$albedoMap === void 0 ? null : _properties$albedoMap,
          _properties$metalness = properties.metalness,
          metalness = _properties$metalness === void 0 ? 0.5 : _properties$metalness,
          _properties$roughness = properties.roughness,
          roughness = _properties$roughness === void 0 ? 0.5 : _properties$roughness,
          _properties$metalness2 = properties.metalnessRoughnessMap,
          metalnessRoughnessMap = _properties$metalness2 === void 0 ? null : _properties$metalness2,
          _properties$normalMap = properties.normalMap,
          normalMap = _properties$normalMap === void 0 ? null : _properties$normalMap,
          _properties$ambientOc = properties.ambientOcclusionMap,
          ambientOcclusionMap = _properties$ambientOc === void 0 ? null : _properties$ambientOc,
          _properties$emissiveM = properties.emissiveMap,
          emissiveMap = _properties$emissiveM === void 0 ? null : _properties$emissiveM,
          _properties$emissive = properties.emissive,
          emissive = _properties$emissive === void 0 ? new lib["k" /* RGBColor */](0, 0, 0) : _properties$emissive,
          _properties$clearCoat = properties.clearCoatStrength,
          clearCoatStrength = _properties$clearCoat === void 0 ? 0.0 : _properties$clearCoat,
          _properties$clearCoat2 = properties.clearCoatRoughness,
          clearCoatRoughness = _properties$clearCoat2 === void 0 ? 0.0 : _properties$clearCoat2,
          _properties$normalInc = properties.normalIncidenceFresnel,
          normalIncidenceFresnel = _properties$normalInc === void 0 ? 0.05 : _properties$normalInc,
          _properties$roughness2 = properties.roughnessAffectDiffuse,
          roughnessAffectDiffuse = _properties$roughness2 === void 0 ? true : _properties$roughness2,
          _properties$illuminan = properties.illuminanceMap,
          illuminanceMap = _properties$illuminan === void 0 ? null : _properties$illuminan,
          _properties$preFilter = properties.preFilteredEnvMap,
          preFilteredEnvMap = _properties$preFilter === void 0 ? null : _properties$preFilter,
          _properties$brdfLUT = properties.brdfLUT,
          brdfLUT = _properties$brdfLUT === void 0 ? null : _properties$brdfLUT,
          _properties$receiveSh = properties.receiveShadow,
          receiveShadow = _properties$receiveSh === void 0 ? false : _properties$receiveSh,
          _properties$castShado = properties.castShadow,
          castShadow = _properties$castShado === void 0 ? false : _properties$castShado;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this.isPbrMeshMaterial = true;
    this._receiveShadow = receiveShadow;
    this._castShadow = castShadow;
    this.lit = true;
    this.opacity = opacity;
    this.roughnessAffectDiffuse = roughnessAffectDiffuse;
    this._albedo = albedo.clone();
    this.normalIncidenceFresnel = normalIncidenceFresnel;
    this._albedoMap = null;
    this.albedoMap = albedoMap;
    this.metalness = metalness;
    this.roughness = roughness;
    this._metalnessRoughnessMap = null;
    this.metalnessRoughnessMap = metalnessRoughnessMap;
    this._normalMap = null;
    this.normalMap = normalMap;
    this._ambientOcclusionMap = null;
    this.ambientOcclusionMap = ambientOcclusionMap;
    this._emissive = emissive.clone();
    this._emissiveMap = null;
    this.emissiveMap = emissiveMap;
    this._clearCoatStrength = clearCoatStrength;
    this.clearCoatRoughness = clearCoatRoughness;
    this._illuminanceMap = null;
    this.illuminanceMap = illuminanceMap;
    this._preFilteredEnvMap = null;
    this.preFilteredEnvMap = preFilteredEnvMap;
    this._brdfLUT = null;
    this.brdfLUT = brdfLUT;
    this._SH = null;
    this._shaders = {
      name: pbrMeshShader.name,
      extensions: {},
      defines: {
        CSM_CASCADES_COUNT: 0,
        SHADOW_SATURATION: 1,
        OMNI_DIRECTIONAL_CASTERS_ZFAR: 100
      },
      vertexShader: pbrMeshMaterial_vertexShader,
      fragmentShader: pbrMeshMaterial_fragmentShader
    };
  }

  clone(parameters = {}) {
    const name = parameters.name;
    const properties = {
      name: name || `${this.name}-clone`,
      alphaMode: this.alphaMode,
      alphaCutoff: this.alphaCutoff,
      opacity: this.opacity,
      cullFace: this.cullFace,
      albedo: this.albedo,
      albedoMap: this.albedoMap,
      metalness: this.metalness,
      roughness: this.roughness,
      metalnessRoughnessMap: this.metalnessRoughnessMap,
      normalMap: this.normalMap,
      ambientOcclusionMap: this.ambientOcclusionMap,
      emissiveMap: this.emissiveMap,
      emissive: this.emissive,
      clearCoatStrength: this.clearCoatStrength,
      clearCoatRoughness: this.clearCoatRoughness,
      normalIncidenceFresnel: this.normalIncidenceFresnel,
      roughnessAffectDiffuse: this.roughnessAffectDiffuse,
      illuminanceMap: this.illuminanceMap,
      preFilteredEnvMap: this.preFilteredEnvMap,
      brdfLUT: this.brdfLUT,
      castShadow: this._castShadow,
      receiveShadow: this._receiveShadow
    };
    const clone = new pbrMeshMaterial_PbrMeshMaterial(properties);
    clone.sphericalHarmonics = this._SH;
    return clone;
  }

  get clearCoatStrength() {
    return this._clearCoatStrength;
  }

  set clearCoatStrength(value) {
    if (this._clearCoatStrength === 0 && value > 0) {
      this.needsUpdate = true;
    } else if (this._clearCoatStrength > 0 && value === 0) {
      this.needsUpdate = true;
    }

    this._clearCoatStrength = value;
  }

  get roughnessAffectDiffuse() {
    return this._roughnessAffectDiffuse;
  }

  set roughnessAffectDiffuse(value) {
    if (this._roughnessAffectDiffuse === value) {
      return;
    }

    this._roughnessAffectDiffuse = value;
    this.needsUpdate = true;
  }

  set albedo(value) {
    this._albedo.copy(value);
  }

  get albedo() {
    return this._albedo;
  }

  set albedoMap(value) {
    if (false) {}

    if (this._albedoMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._albedoMap, value);
    const prevMap = this._albedoMap;

    if (value !== null) {
      const albedoMap = value;

      if (false) {}

      if (albedoMap instanceof texture_resource_Texture) {
        if (this._albedoMap !== null) {
          this._albedoMap.texture = albedoMap;
        } else if (albedoMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._albedoMap = new material_Material.TextureProperties(albedoMap);
        } else if (albedoMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._albedoMap = new material_Material.TextureArrayProperties(albedoMap);
        }
      } else {
        this._albedoMap = albedoMap.material instanceof material_Material ? albedoMap.clone() : albedoMap;
      }

      this._albedoMap.material = this;

      this._albedoMap.retain();
    } else {
      this._albedoMap.material = null;
      this._albedoMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get albedoMap() {
    return this._albedoMap;
  }

  set metalnessRoughnessMap(value) {
    if (false) {}

    if (this._metalnessRoughnessMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._metalnessRoughnessMap, value);
    const prevMap = this._metalnessRoughnessMap;

    if (value !== null) {
      const metalnessRoughnessMap = value;

      if (false) {}

      if (metalnessRoughnessMap instanceof texture_resource_Texture) {
        if (this._metalnessRoughnessMap !== null) {
          this._metalnessRoughnessMap.texture = metalnessRoughnessMap;
        } else if (metalnessRoughnessMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._metalnessRoughnessMap = new material_Material.TextureProperties(metalnessRoughnessMap);
        } else if (metalnessRoughnessMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._metalnessRoughnessMap = new material_Material.TextureArrayProperties(metalnessRoughnessMap);
        }
      } else {
        this._metalnessRoughnessMap = metalnessRoughnessMap.material instanceof material_Material ? metalnessRoughnessMap.clone() : metalnessRoughnessMap;
      }

      this._metalnessRoughnessMap.material = this;

      this._metalnessRoughnessMap.retain();
    } else {
      this._metalnessRoughnessMap.material = null;
      this._metalnessRoughnessMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get metalnessRoughnessMap() {
    return this._metalnessRoughnessMap;
  }

  set normalMap(value) {
    if (false) {}

    if (this._normalMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._normalMap, value);
    const prevMap = this._normalMap;

    if (value !== null) {
      const normalMap = value;

      if (false) {}

      if (normalMap instanceof texture_resource_Texture) {
        if (this._normalMap !== null) {
          this._normalMap.texture = normalMap;
        } else if (normalMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._normalMap = new material_Material.NormalMapProperties(normalMap);
        } else if (normalMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._normalMap = new material_Material.NormalMapFromArrayProperties(normalMap);
        }
      } else {
        this._normalMap = normalMap.material instanceof material_Material ? normalMap.clone() : normalMap;
      }

      this._normalMap.material = this;

      this._normalMap.retain();
    } else {
      this._normalMap.material = null;
      this._normalMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get normalMap() {
    return this._normalMap;
  }

  set ambientOcclusionMap(value) {
    if (false) {}

    if (this._ambientOcclusionMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._ambientOcclusionMap, value);
    const prevMap = this._ambientOcclusionMap;

    if (value !== null) {
      const ambientOcclusionMap = value;

      if (false) {}

      if (ambientOcclusionMap instanceof texture_resource_Texture) {
        if (this._ambientOcclusionMap !== null) {
          this._ambientOcclusionMap.texture = ambientOcclusionMap;
        } else if (ambientOcclusionMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._ambientOcclusionMap = new material_Material.AOMapProperties(ambientOcclusionMap);
        } else if (ambientOcclusionMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._ambientOcclusionMap = new material_Material.AOMapFromArrayProperties(ambientOcclusionMap);
        }
      } else {
        this._ambientOcclusionMap = ambientOcclusionMap.material instanceof material_Material ? ambientOcclusionMap.clone() : ambientOcclusionMap;
      }

      this._ambientOcclusionMap.material = this;

      this._ambientOcclusionMap.retain();
    } else {
      this._ambientOcclusionMap.material = null;
      this._ambientOcclusionMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get ambientOcclusionMap() {
    return this._ambientOcclusionMap;
  }

  set illuminanceMap(value) {
    if (false) {}

    if (this._illuminanceMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._illuminanceMap, value);
    const prevMap = this._illuminanceMap;

    if (value !== null) {
      const illuminanceMap = value;

      if (false) {}

      if (false) {}

      this._illuminanceMap = illuminanceMap;
      this.sphericalHarmonics = null;

      this._illuminanceMap.retain();
    } else {
      this._illuminanceMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get illuminanceMap() {
    return this._illuminanceMap;
  }

  set preFilteredEnvMap(value) {
    if (false) {}

    if (this._preFilteredEnvMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._preFilteredEnvMap, value);
    const prevMap = this._preFilteredEnvMap;

    if (value !== null) {
      const preFilteredEnvMap = value;

      if (false) {}

      if (false) {}

      this._preFilteredEnvMap = preFilteredEnvMap;

      this._preFilteredEnvMap.retain();
    } else {
      this._preFilteredEnvMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get preFilteredEnvMap() {
    return this._preFilteredEnvMap;
  }

  set brdfLUT(value) {
    if (false) {}

    if (this._brdfLUT === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._brdfLUT, value);
    const prevMap = this._brdfLUT;

    if (value !== null) {
      const brdfLUT = value;

      if (false) {}

      if (false) {}

      this._brdfLUT = brdfLUT;

      this._brdfLUT.retain();
    } else {
      this._brdfLUT = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get brdfLUT() {
    return this._brdfLUT;
  }

  set sphericalHarmonics(value) {
    if (this._SH === value) {
      return;
    }

    this.needsUpdate = this._SH === null && value !== null || this._SH !== null && value === null || this._SH !== null && value !== null && this._SH.length !== value.length;
    this._SH = value;

    if (this._SH !== null) {
      this.illuminanceMap = null;
    }
  }

  get sphericalHarmonics() {
    return this._SH;
  }

  set emissiveMap(value) {
    if (false) {}

    if (this._emissiveMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._emissiveMap, value);
    const prevMap = this._emissiveMap;

    if (value !== null) {
      const emissiveMap = value;

      if (false) {}

      if (emissiveMap instanceof texture_resource_Texture) {
        if (this._emissiveMap !== null) {
          this._emissiveMap.texture = emissiveMap;
        } else if (emissiveMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._emissiveMap = new material_Material.EmissiveMapProperties(1.0, emissiveMap);
        } else if (emissiveMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._emissiveMap = new material_Material.EmissiveMapFromArrayProperties(1.0, emissiveMap);
        }
      } else {
        this._emissiveMap = emissiveMap.material instanceof material_Material ? emissiveMap.clone() : emissiveMap;
      }

      this._emissiveMap.material = this;

      this._emissiveMap.retain();
    } else {
      this._emissiveMap.material = null;
      this._emissiveMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  get emissiveMap() {
    return this._emissiveMap;
  }

  get emissive() {
    return this._emissive;
  }

  set emissive(value) {
    this._emissive.copy(value);
  }

  get shaders() {
    return this._shaders;
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const look = renderPass.look,
          scene = renderPass.scene,
          renderPassId = renderPass.id;
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _albedoMap = this._albedoMap,
          _normalMap = this._normalMap,
          _metalnessRoughnessMap = this._metalnessRoughnessMap,
          _ambientOcclusionMap = this._ambientOcclusionMap,
          _SH = this._SH,
          _illuminanceMap = this._illuminanceMap,
          _preFilteredEnvMap = this._preFilteredEnvMap,
          _brdfLUT = this._brdfLUT,
          _albedo = this._albedo,
          _emissiveMap = this._emissiveMap,
          _emissive = this._emissive,
          metalness = this.metalness,
          roughness = this.roughness,
          normalIncidenceFresnel = this.normalIncidenceFresnel,
          clearCoatRoughness = this.clearCoatRoughness,
          clearCoatStrength = this.clearCoatStrength,
          opacity = this.opacity,
          _receiveShadow = this._receiveShadow;
    const defines = technique.defines,
          program = technique.program,
          _output = technique._output;
    const USE_AMBIENT_LIGHT = defines.USE_AMBIENT_LIGHT,
          DIFFUSE_ILLUMINANCE_MAP = defines.DIFFUSE_ILLUMINANCE_MAP,
          CLEAR_COAT = defines.CLEAR_COAT;
    const layout = program.layout;
    const uniforms = layout.uniforms,
          samplerUniformNames = layout.samplerUniformNames;
    const worldMatrix = look.worldMatrix,
          viewMatrix = look.viewMatrix,
          projectionMatrix = look.projectionMatrix,
          exposure = look.exposure;

    if ((_output & _metalnessRoughnessF0Mask) !== 0) {
      const uniform = uniforms.get('metalness');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(metalness);
    }

    if ((_output & _metalnessRoughnessF0Mask) !== 0) {
      const uniform = uniforms.get('roughness');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(roughness);
    }

    if ((_output & _metalnessRoughnessF0Mask) !== 0 && CLEAR_COAT !== undefined) {
      {
        const uniform = uniforms.get('clearCoatRoughness');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(clearCoatRoughness);
      }
      {
        const uniform = uniforms.get('clearCoatStrength');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(clearCoatStrength);
      }
    }

    if ((_output & _metalnessRoughnessF0Mask) !== 0) {
      const uniform = uniforms.get('normalIncidenceFresnel');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(normalIncidenceFresnel);
    }

    {
      const uniform = uniforms.get('viewMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(viewMatrix);
    }
    {
      const uniform = uniforms.get('projectionMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(projectionMatrix);
    }

    if (defines.WORLD_SPACE_FRAG_CONTEXT !== undefined && (_output & _worldCameraMask) !== 0) {
      const uniform = uniforms.get('cameraWorldMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(worldMatrix);
    }

    if (defines.DIRECT_SHADOW_CASTERS_COUNT !== undefined && defines.DIRECT_SHADOW_CASTERS_COUNT > 0 && (_output & _cascadeShadowMask) !== 0) {
      const uniform = uniforms.get('cameraNearFar');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      const _renderPass$look = renderPass.look,
            znear = _renderPass$look.znear,
            zfar = _renderPass$look.zfar;
      uniform.setValue([znear, zfar]);
    }

    if ((_output & _exposureApplyMask) !== 0) {
      const uniform = uniforms.get('manualExposure');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(exposure);
    }

    if (_albedoMap instanceof material_Material.TextureProperties && (_output & _albedoMask) !== 0) {
      {
        const uniform = uniforms.get('albedoMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const transform = _albedoMap.transform;
        uniform.setValue(transform);
      }
      {
        const uniformName = samplerUniformNames.get('_albedoMap');
        const texture = _albedoMap.texture;
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }

      if (_albedoMap instanceof material_Material.TextureArrayProperties) {
        const index = _albedoMap.index;
        const uniform = uniforms.get('_albedoMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if (_normalMap instanceof material_Material.TextureProperties && (_output & _normalsMask) !== 0) {
      const transform = _normalMap.transform,
            scale = _normalMap.scale,
            texture = _normalMap.texture;
      {
        const uniform = uniforms.get('normalMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(transform);
      }
      {
        const uniform = uniforms.get('normalScale');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(scale);
      }
      {
        const uniformName = samplerUniformNames.get('_normalMap');
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }

      if (_normalMap instanceof material_Material.TextureArrayProperties) {
        const index = _normalMap.index;
        const uniform = uniforms.get('_normalMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if (_metalnessRoughnessMap instanceof material_Material.TextureProperties && (_output & _metalnessRoughnessF0Mask) !== 0) {
      const transform = _metalnessRoughnessMap.transform,
            texture = _metalnessRoughnessMap.texture;
      {
        const uniform = uniforms.get('metalnessRoughnessMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(transform);
      }
      {
        const uniformName = samplerUniformNames.get('_metalnessRoughnessMap');
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }

      if (_metalnessRoughnessMap instanceof material_Material.TextureArrayProperties) {
        const index = _metalnessRoughnessMap.index;
        const uniform = uniforms.get('_metalnessRoughnessMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if (_ambientOcclusionMap instanceof material_Material.TextureProperties && (USE_AMBIENT_LIGHT != null || DIFFUSE_ILLUMINANCE_MAP != null || _SH !== null) && (_output & _iblMask) !== 0) {
      const transform = _ambientOcclusionMap.transform,
            texture = _ambientOcclusionMap.texture,
            strength = _ambientOcclusionMap.strength;
      {
        const uniform = uniforms.get('ambientOcclusionMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(transform);
      }
      {
        const uniformName = samplerUniformNames.get('_ambientOcclusionMap');
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }
      {
        const uniform = uniforms.get('ambientOcclusionStrength');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(strength);
      }

      if (_ambientOcclusionMap instanceof material_Material.TextureArrayProperties) {
        const index = _ambientOcclusionMap.index;
        const uniform = uniforms.get('_ambientOcclusionMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if ((_output & _emissiveMask) !== 0) {
      {
        const uniform = uniforms.get('emissiveFactor');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(_emissive);
      }

      if (_emissiveMap instanceof material_Material.TextureProperties) {
        const luminance = _emissiveMap.luminance,
              transform = _emissiveMap.transform,
              texture = _emissiveMap.texture;
        {
          const uniform = uniforms.get('emissiveLuminance');

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          uniform.setValue(luminance);
        }
        {
          const uniform = uniforms.get('emissiveMapTransform');

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          uniform.setValue(transform);
        }
        {
          const uniformName = samplerUniformNames.get('_emissiveMap');
          const uniform = uniforms.get(uniformName);

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          this._setTexture(gl, uniform, texture, textures);
        }

        if (_emissiveMap instanceof material_Material.EmissiveMapFromArrayProperties) {
          const index = _emissiveMap.index;
          const uniform = uniforms.get('_emissiveMapIndex');

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          uniform.setValue(index);
        }
      }
    }

    if (_SH !== null && (_output & _iblMask) !== 0) {
      const uniform = uniforms.get('iblSH');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_SH);
    }

    if (_illuminanceMap instanceof texture_resource_Texture && (_output & _iblMask) !== 0) {
      const uniform = uniforms.get('_illuminanceMap');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      this._setTexture(gl, uniform, _illuminanceMap, textures);
    }

    if (_preFilteredEnvMap instanceof texture_resource_Texture && (_output & _iblMask) !== 0) {
      {
        const uniform = uniforms.get('_preFilteredEnvMap');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, _preFilteredEnvMap, textures);
      }
      {
        const uniform = uniforms.get('maxReflectionLOD');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const levels = _preFilteredEnvMap.levels;
        uniform.setValue(levels);
      }
    }

    if (_brdfLUT instanceof texture_resource_Texture && (_output & _iblMask) !== 0) {
      const uniform = uniforms.get('_brdfLUT');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      this._setTexture(gl, uniform, _brdfLUT, textures);
    }

    if ((_output & _albedoMask) !== 0) {
      const uniform = uniforms.get('albedo');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_albedo);
    }

    if ((_output & _opacityMask) !== 0) {
      const uniform = uniforms.get('opacity');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(opacity);
    }

    if (renderable.hasMorph) {
      const uniform = uniforms.get('morphWeights');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(renderable.morphWeights);
    }

    this._setSkeletonMap(gl, renderable, uniforms, textures);

    _applyLights(gl, uniforms, renderPass, technique);

    if (_receiveShadow && scene instanceof scene_Scene) {
      if (scene.getDirectShadowCastersCount(look) > 0) {
        this._updateDirectShadowCasters(gl, uniforms, renderPass, textures, webgl2Support);
      }

      if (scene.spotShadowCastersCount > 0) {
        this._updateSpotShadowCasters(gl, uniforms, scene, textures, webgl2Support);
      }

      if (scene.omniShadowCastersCount > 0) {
        this._updateOmniDirectShadowCasters(gl, uniforms, scene, textures, webgl2Support);
      }
    }

    if (false) {}

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const _albedoMap = this._albedoMap,
          _normalMap = this._normalMap,
          _metalnessRoughnessMap = this._metalnessRoughnessMap,
          _ambientOcclusionMap = this._ambientOcclusionMap,
          _emissiveMap = this._emissiveMap,
          _SH = this._SH,
          _illuminanceMap = this._illuminanceMap,
          _preFilteredEnvMap = this._preFilteredEnvMap,
          _brdfLUT = this._brdfLUT,
          roughnessAffectDiffuse = this.roughnessAffectDiffuse,
          _receiveShadow = this._receiveShadow,
          _clearCoatStrength = this._clearCoatStrength;
    const defines = technique.defines,
          extensions = technique.extensions;
    const texToSampler = new Map();
    const samplers = {};
    let samplerIdx = 0;

    if ('isScene' in renderPass.scene) {
      const ecsScene = renderPass.scene;
      defines.MIN_BIAS = ecsScene.shadowBiasMin;
      defines.MAX_BIAS = ecsScene.shadowBiasMax;
    }

    _updateLightCount(defines, renderPass);

    if (!webgl2Support && _normalMap instanceof material_Material.TextureProperties) {
      extensions.OES_standard_derivatives = ShaderExtensionBehaviour.REQUIRE;
    } else {
      delete extensions.OES_standard_derivatives;
    }

    if (!webgl2Support && _preFilteredEnvMap instanceof texture_resource_Texture) {
      extensions.EXT_shader_texture_lod = ShaderExtensionBehaviour.REQUIRE;
    } else {
      delete extensions.EXT_shader_texture_lod;
    }

    if (!webgl2Support && renderPass._outputLayout !== null && renderPass._outputLayout.size > 1) {
      extensions.EXT_draw_buffers = ShaderExtensionBehaviour.ENABLE;
    } else {
      delete extensions.EXT_draw_buffers;
    }

    if (_clearCoatStrength > 0 && defines.CLEAR_COAT === undefined) {
      defines.CLEAR_COAT = '';
    } else if (_clearCoatStrength === 0 && defines.CLEAR_COAT !== undefined) {
      delete defines.CLEAR_COAT;
    }

    if (roughnessAffectDiffuse) {
      defines.BURLEY_DIFFUSE = '';
      delete defines.LAMBERT_DIFFUSE;
    } else {
      defines.LAMBERT_DIFFUSE = '';
      delete defines.BURLEY_DIFFUSE;
    }

    defines.VIEW_TO_CLIP_POSITION = '';

    if (_albedoMap instanceof material_Material.TextureProperties) {
      defines.ALBEDO_MAP = '';
      const bindingPoint = _albedoMap.bindingPoint,
            channel = _albedoMap.channel,
            texture = _albedoMap.texture;
      const internalFormat = texture.internalFormat,
            _gammaDecode = texture._gammaDecode;
      let albedoGammaDecode = _gammaDecode;

      if (!webgl2Support) {
        albedoGammaDecode = albedoGammaDecode || internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8;
      } else {
        albedoGammaDecode = albedoGammaDecode || internalFormat === InternalFormat.SRGB8;
      }

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.ALBEDO_MAP_FROM_ARRAY = '';
      } else {
        delete defines.ALBEDO_MAP_FROM_ARRAY;
      }

      samplerIdx = _prepSamplerInfo('a', samplers, texToSampler, texture.id, samplerIdx, channel, albedoGammaDecode);
    } else {
      delete defines.ALBEDO_MAP;
    }

    if (_normalMap instanceof material_Material.TextureProperties) {
      defines.NORMAL_MAP = '';
      const bindingPoint = _normalMap.bindingPoint,
            channel = _normalMap.channel,
            texture = _normalMap.texture;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.NORMAL_MAP_FROM_ARRAY = '';
      } else {
        delete defines.NORMAL_MAP_FROM_ARRAY;
      }

      samplerIdx = _prepSamplerInfo('n', samplers, texToSampler, texture.id, samplerIdx, channel);

      if (false) {}
    } else {
      delete defines.NORMAL_MAP;
    }

    if (_metalnessRoughnessMap instanceof material_Material.TextureProperties) {
      defines.METALNESS_ROUGHNESS_MAP = '';
      const bindingPoint = _metalnessRoughnessMap.bindingPoint,
            channel = _metalnessRoughnessMap.channel,
            texture = _metalnessRoughnessMap.texture;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.METALNESS_ROUGHNESS_MAP_FROM_ARRAY = '';
      } else {
        delete defines.METALNESS_ROUGHNESS_MAP_FROM_ARRAY;
      }

      samplerIdx = _prepSamplerInfo('mr', samplers, texToSampler, texture.id, samplerIdx, channel);

      if (false) {}
    } else {
      delete defines.METALNESS_ROUGHNESS_MAP;
    }

    if (_SH !== null) {
      defines.SH_BAND_COUNT = Math.max(1, Math.floor(Math.sqrt(_SH.length / 3)));
      defines.WORLD_SPACE_VARYINGS = '';
      defines.WORLD_SPACE_FRAG_CONTEXT = '';
    } else {
      delete defines.SH_BAND_COUNT;
    }

    if (_illuminanceMap instanceof texture_resource_Texture) {
      defines.DIFFUSE_ILLUMINANCE_MAP = '';
      defines.WORLD_SPACE_VARYINGS = '';
      defines.WORLD_SPACE_FRAG_CONTEXT = '';
      samplerIdx = _prepSamplerInfo('il', samplers, texToSampler, _illuminanceMap.id, samplerIdx, 0);
    } else {
      delete defines.DIFFUSE_ILLUMINANCE_MAP;
    }

    if (_preFilteredEnvMap instanceof texture_resource_Texture) {
      defines.PRE_FILTERED_ENV_MAP = '';
      defines.WORLD_SPACE_VARYINGS = '';
      defines.WORLD_SPACE_FRAG_CONTEXT = '';
      samplerIdx = _prepSamplerInfo('pf', samplers, texToSampler, _preFilteredEnvMap.id, samplerIdx, 0);
    } else {
      delete defines.PRE_FILTERED_ENV_MAP;
    }

    if (_brdfLUT instanceof texture_resource_Texture) {
      defines.BRDF_LUT = '';
      samplerIdx = _prepSamplerInfo('bl', samplers, texToSampler, _brdfLUT.id, samplerIdx, 0);
    } else {
      delete defines.BRDF_LUT;
    }

    if (_ambientOcclusionMap instanceof material_Material.TextureProperties && (defines.USE_AMBIENT_LIGHT != null || defines.DIFFUSE_ILLUMINANCE_MAP != null || _SH !== null)) {
      defines.AMBIENT_OCCLUSION_MAP = '';
      const bindingPoint = _ambientOcclusionMap.bindingPoint,
            channel = _ambientOcclusionMap.channel,
            texture = _ambientOcclusionMap.texture;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.AMBIENT_OCCLUSION_MAP_FROM_ARRAY = '';
      } else {
        delete defines.AMBIENT_OCCLUSION_MAP_FROM_ARRAY;
      }

      samplerIdx = _prepSamplerInfo('ao', samplers, texToSampler, texture.id, samplerIdx, channel);

      if (false) {}
    } else {
      delete defines.AMBIENT_OCCLUSION_MAP;
    }

    if (_emissiveMap instanceof material_Material.TextureProperties) {
      defines.EMISSIVE_MAP = '';
      const bindingPoint = _emissiveMap.bindingPoint,
            channel = _emissiveMap.channel,
            texture = _emissiveMap.texture;
      const internalFormat = texture.internalFormat,
            _gammaDecode = texture._gammaDecode;
      let emissiveMapGammaDecode = _gammaDecode;

      if (!webgl2Support) {
        emissiveMapGammaDecode = emissiveMapGammaDecode || internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8;
      } else {
        emissiveMapGammaDecode = emissiveMapGammaDecode || internalFormat === InternalFormat.SRGB8;
      }

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.EMISSIVE_MAP_FROM_ARRAY = '';
      } else {
        delete defines.EMISSIVE_MAP_FROM_ARRAY;
      }

      samplerIdx = _prepSamplerInfo('e', samplers, texToSampler, texture.id, samplerIdx, channel, emissiveMapGammaDecode);

      if (false) {}
    } else {
      delete defines.EMISSIVE_MAP;
    }

    if (_receiveShadow && 'isScene' in renderPass.scene) {
      const scene = renderPass.scene;
      const look = renderPass.look;
      const directShadowCastersCount = scene.getDirectShadowCastersCount(look);
      defines.DIRECT_SHADOW_CASTERS_COUNT = directShadowCastersCount;
      defines.CSM_CASCADES_COUNT = scene._cascadesCount;
      const spotShadowCastersCount = scene.spotShadowCastersCount,
            omniShadowCastersCount = scene.omniShadowCastersCount;
      defines.SPOT_SHADOW_CASTERS_COUNT = spotShadowCastersCount;
      defines.OMNI_SHADOW_CASTERS_COUNT = omniShadowCastersCount;

      if (directShadowCastersCount > 0 || spotShadowCastersCount > 0 || omniShadowCastersCount > 0) {
        defines.SHADOW_MAPPING = '';
        defines.WORLD_SPACE_VARYINGS = '';
      }

      if (omniShadowCastersCount > 0) {
        defines.WORLD_SPACE_FRAG_CONTEXT = '';
      }
    } else {
      delete defines.SHADOW_MAPPING;
    }

    {
      const positionMorphTargetCount = renderable.positionMorphTargetCount,
            normalMorphTargetCount = renderable.normalMorphTargetCount;

      if (positionMorphTargetCount !== 0 && defines.POSITION_MORPH_COUNT === undefined) {
        defines.POSITION_MORPH_COUNT = positionMorphTargetCount;
      } else if (positionMorphTargetCount === 0 && defines.POSITION_MORPH_COUNT !== undefined) {
        delete defines.POSITION_MORPH_COUNT;
      }

      if (normalMorphTargetCount !== 0 && defines.NORMAL_MORPH_COUNT === undefined) {
        defines.NORMAL_MORPH_COUNT = normalMorphTargetCount;
      } else if (normalMorphTargetCount === 0 && defines.NORMAL_MORPH_COUNT !== undefined) {
        delete defines.NORMAL_MORPH_COUNT;
      }
    }
    const extdefs = JSON.stringify(samplers);
    technique.cacheKey = `${JSON.stringify(defines)}_${extdefs}`;
    technique.needsUpdate = false;
  }

  _needsUpdate(renderable, renderPass, technique, webgl2Support) {
    const cullFace = this.cullFace;
    const defines = technique.defines;
    const WORLD_SPACE_FRAG_CONTEXT = defines.WORLD_SPACE_FRAG_CONTEXT,
          WORLD_SPACE_VARYINGS = defines.WORLD_SPACE_VARYINGS;
    const SHADOW_MAPPING = defines.SHADOW_MAPPING,
          OMNI_SHADOW_CASTERS_COUNT = defines.OMNI_SHADOW_CASTERS_COUNT;
    const HAS_BACK_SIDE = defines.HAS_BACK_SIDE;

    if (WORLD_SPACE_FRAG_CONTEXT !== undefined) {
      const DIFFUSE_ILLUMINANCE_MAP = defines.DIFFUSE_ILLUMINANCE_MAP,
            PRE_FILTERED_ENV_MAP = defines.PRE_FILTERED_ENV_MAP;

      if (DIFFUSE_ILLUMINANCE_MAP === undefined && PRE_FILTERED_ENV_MAP === undefined && OMNI_SHADOW_CASTERS_COUNT === 0) {
        delete defines.WORLD_SPACE_FRAG_CONTEXT;
        technique.needsUpdate = true;
      }
    } else if (WORLD_SPACE_VARYINGS !== undefined) {
      if (WORLD_SPACE_FRAG_CONTEXT === undefined && SHADOW_MAPPING === undefined) {
        delete defines.WORLD_SPACE_VARYINGS;
        technique.needsUpdate = true;
      }
    }

    if (SHADOW_MAPPING !== undefined && 'isScene' in renderPass.scene) {
      const scene = renderPass.scene;
      const look = renderPass.look;

      if (defines.CSM_CASCADES_COUNT !== scene._cascadesCount) {
        technique.needsUpdate = true;
      }

      const directShadowCastersCount = scene.getDirectShadowCastersCount(look);

      if (defines.DIRECT_SHADOW_CASTERS_COUNT !== directShadowCastersCount) {
        technique.needsUpdate = true;
      }

      const spotShadowCastersCount = scene.spotShadowCastersCount;

      if (defines.SPOT_SHADOW_CASTERS_COUNT !== spotShadowCastersCount) {
        technique.needsUpdate = true;
      }
    }

    if ((cullFace === material_Material.CullFace.NONE || cullFace === material_Material.CullFace.FRONT) && HAS_BACK_SIDE === undefined) {
      defines.HAS_BACK_SIDE = '';
      technique.needsUpdate = true;
    } else if ((cullFace === material_Material.CullFace.BACK || cullFace === material_Material.CullFace.BOTH) && HAS_BACK_SIDE !== undefined) {
      delete defines.HAS_BACK_SIDE;
      technique.needsUpdate = true;
    }

    return super._needsUpdate(renderable, renderPass, technique, webgl2Support);
  }

  _updateDirectShadowCasters(gl, uniforms, renderPass, textures, webgl2Support) {
    const scene = renderPass.scene;

    if (!scene.isScene) {
      return;
    }

    const shadowTextureArray = scene.shadowTextureArray,
          directShadowCastersMask = scene.directShadowCastersMask;
    const _cascadesCount = scene._cascadesCount,
          _shadowMapSize = scene._shadowMapSize;
    const directShadowCastersData = scene.getDirectShadowCastersData(renderPass.look);
    const _directShadowCastersD = directShadowCastersData.directShadowCasters,
          directShadowCasters = _directShadowCastersD === void 0 ? [] : _directShadowCastersD,
          frustumSplits = directShadowCastersData.frustumSplits;
    {
      const uniform = uniforms.get('frustumSplits');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(frustumSplits);
    }
    let lightIndex = 0;
    let directShadowCastersSamplers = null;
    {
      const uniform = uniforms.get('directShadowCastersMask');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(directShadowCastersMask);
    }

    if (webgl2Support) {
      const uniformLocation = gl.getUniformLocation(this.program.webglProgram, 'directShadowCastersSamplers');

      if (false) {}

      if (directShadowCastersSamplers === null) {
        directShadowCastersSamplers = uniforms.get('directShadowCastersSamplers');
      }

      if (directShadowCastersSamplers === undefined) {
        throw new Error('uniform is undefined');
      }

      directShadowCastersSamplers.location = uniformLocation;

      this._setTexture(gl, directShadowCastersSamplers, shadowTextureArray, textures);
    } else {
      const uniform = uniforms.get('shadowMapSize');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(1 / _shadowMapSize);
    }

    for (const _ref of directShadowCasters) {
      const light = _ref.light;
      const _cascades = _ref._cascades;
      const directionalLight = light;

      if (!directionalLight.isDirectionalLight) {
        continue;
      }

      for (const _ref2 of _cascades.entries()) {
        var _ref3 = pbrMeshMaterial_slicedToArray(_ref2, 2);

        const cascadeIndex = _ref3[0];
        var _ref3$ = _ref3[1];
        const camera = _ref3$.camera;
        const texture = _ref3$.texture;
        const index = lightIndex * _cascadesCount + cascadeIndex;

        if (!webgl2Support) {
          const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `directShadowCastersSamplers[${index}]`);

          if (false) {}

          if (directShadowCastersSamplers === null) {
            directShadowCastersSamplers = uniforms.get('directShadowCastersSamplers');
          }

          if (directShadowCastersSamplers === undefined) {
            throw new Error('uniform is undefined');
          }

          directShadowCastersSamplers.location = uniformLocation;

          this._setTexture(gl, directShadowCastersSamplers, texture, textures);
        }

        {
          const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `directShadowCastersTransforms[${index}]`);

          if (false) {}

          gl.uniformMatrix4fv(uniformLocation, false, camera.viewProjectionMatrix.toArray([]));
        }
      }

      ++lightIndex;
    }
  }

  _updateSpotShadowCasters(gl, uniforms, scene, textures, webgl2Support) {
    {
      const spotShadowCastersMask = scene.spotShadowCastersMask;
      const uniform = uniforms.get('spotShadowCastersMask');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(spotShadowCastersMask);
    }
    const spotShadowCasters = scene.getSpotShadowCasters();
    const spotCastersDepthTextureArray = scene.spotCastersDepthTextureArray;
    const _shadowMapSize = scene._shadowMapSize;
    const spotShadowCastersSamplers = uniforms.get('spotShadowCastersSamplers');

    if (spotShadowCastersSamplers === undefined) {
      throw new Error('uniform is undefined');
    }

    if (webgl2Support) {
      const uniformLocation = gl.getUniformLocation(this.program.webglProgram, 'spotShadowCastersSamplers');

      if (false) {}

      if (spotShadowCastersSamplers === undefined) {
        throw new Error('uniform is undefined');
      }

      spotShadowCastersSamplers.location = uniformLocation;

      this._setTexture(gl, spotShadowCastersSamplers, spotCastersDepthTextureArray, textures);
    } else {
      const uniform = uniforms.get('spotCastersShadowMapSize');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(1 / _shadowMapSize);
    }

    for (const _ref4 of spotShadowCasters.entries()) {
      var _ref5 = pbrMeshMaterial_slicedToArray(_ref4, 2);

      const index = _ref5[0];
      const shadowCaster = _ref5[1].shadowCaster;
      const _spotShadowCasterData = shadowCaster._spotShadowCasterData;
      const camera = _spotShadowCasterData.camera,
            depthTexture = _spotShadowCasterData.depthTexture;
      {
        const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `spotShadowCastersTransforms[${index}]`);

        if (false) {}

        gl.uniformMatrix4fv(uniformLocation, false, camera.viewProjectionMatrix.toArray([]));
      }

      if (!webgl2Support) {
        const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `spotShadowCastersSamplers[${index}]`);

        if (false) {}

        spotShadowCastersSamplers.location = uniformLocation;

        this._setTexture(gl, spotShadowCastersSamplers, depthTexture, textures);
      }
    }
  }

  _updateOmniDirectShadowCasters(gl, uniforms, scene, textures, webgl2Support) {
    {
      const omniShadowCastersMask = scene.omniShadowCastersMask;
      const uniform = uniforms.get('omniShadowCastersMask');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(omniShadowCastersMask);
    }
    const omniShadowCasters = scene.getOmniShadowCasters();
    const omniShadowCastersSamplers = uniforms.get('omniShadowCastersSamplers');

    if (omniShadowCastersSamplers === undefined) {
      throw new Error('uniform is undefined');
    }

    for (const _ref6 of omniShadowCasters.entries()) {
      var _ref7 = pbrMeshMaterial_slicedToArray(_ref6, 2);

      const index = _ref7[0];
      const shadowCaster = _ref7[1].shadowCaster;
      const _omniShadowCasterData = shadowCaster._omniShadowCasterData;
      const depthTexture = _omniShadowCasterData.depthTexture;
      {
        const uniformLocation = gl.getUniformLocation(this.program.webglProgram, `omniShadowCastersSamplers[${index}]`);

        if (false) {}

        omniShadowCastersSamplers.location = uniformLocation;

        this._setTexture(gl, omniShadowCastersSamplers, depthTexture, textures);
      }
    }
  }

  getTextures() {
    const textures = new Set();

    if (this.albedoMap !== null) {
      textures.add(this.albedoMap.texture);
    }

    if (this.normalMap !== null) {
      textures.add(this.normalMap.texture);
    }

    if (this.metalnessRoughnessMap !== null) {
      textures.add(this.metalnessRoughnessMap.texture);
    }

    if (this.ambientOcclusionMap !== null) {
      textures.add(this.ambientOcclusionMap.texture);
    }

    if (this.emissiveMap !== null) {
      textures.add(this.emissiveMap.texture);
    }

    return textures;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      if (this.albedoMap !== null) {
        yield this.albedoMap.load();
      }

      if (this.metalnessRoughnessMap !== null) {
        yield this.metalnessRoughnessMap.load();
      }

      if (this.normalMap !== null) {
        yield this.normalMap.load();
      }

      if (this.ambientOcclusionMap !== null) {
        yield this.ambientOcclusionMap.load();
      }

      if (this.emissiveMap !== null) {
        yield this.emissiveMap.load();
      }

      if (this.illuminanceMap !== null) {
        yield this.illuminanceMap.load();
      }

      if (this.preFilteredEnvMap !== null) {
        yield this.preFilteredEnvMap.load();
      }

      if (this.brdfLUT !== null) {
        yield this.brdfLUT.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    if (this.albedoMap !== null) {
      this.albedoMap.unload();
    }

    if (this.metalnessRoughnessMap !== null) {
      this.metalnessRoughnessMap.unload();
    }

    if (this.normalMap !== null) {
      this.normalMap.unload();
    }

    if (this.ambientOcclusionMap !== null) {
      this.ambientOcclusionMap.unload();
    }

    if (this.emissiveMap !== null) {
      this.emissiveMap.unload();
    }

    if (this.illuminanceMap !== null) {
      this.illuminanceMap.unload();
    }

    if (this.preFilteredEnvMap !== null) {
      this.preFilteredEnvMap.unload();
    }

    if (this.brdfLUT !== null) {
      this.brdfLUT.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    this.albedoMap = null;
    this.metalnessRoughnessMap = null;
    this.normalMap = null;
    this.ambientOcclusionMap = null;
    this.emissiveMap = null;
    this.illuminanceMap = null;
    this.preFilteredEnvMap = null;
    this.brdfLUT = null;

    super._dispose();
  }

}
/* harmony default export */ var pbrMeshMaterial = (pbrMeshMaterial_PbrMeshMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/unlitMeshMaterial.js





const unlitMeshShader = ShaderLib.unlitMeshShader;
const unlitMeshMaterial_vertexShader = unlitMeshShader.vertexShader,
      unlitMeshMaterial_fragmentShader = unlitMeshShader.fragmentShader;

const _colorMask = OutputLayoutSemantic.DEFAULT | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.CIE_LUV_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR;

const unlitMeshMaterial_opacityMask = OutputLayoutSemantic.DEFAULT | OutputLayoutSemantic.CIE_xyY_COLOR | OutputLayoutSemantic.LINEAR_HDR_COLOR;

class unlitMeshMaterial_UnlitMeshMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$alphaMode = properties.alphaMode,
          alphaMode = _properties$alphaMode === void 0 ? material_Material.AlphaMode.OPAQUE : _properties$alphaMode,
          _properties$alphaCuto = properties.alphaCutoff,
          alphaCutoff = _properties$alphaCuto === void 0 ? 0.0 : _properties$alphaCuto,
          _properties$opacity = properties.opacity,
          opacity = _properties$opacity === void 0 ? 1 : _properties$opacity,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.NONE : _properties$cullFace,
          _properties$color = properties.color,
          color = _properties$color === void 0 ? new lib["k" /* RGBColor */](1, 1, 1) : _properties$color,
          _properties$colorMap = properties.colorMap,
          colorMap = _properties$colorMap === void 0 ? null : _properties$colorMap;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this.isUnlitMeshMaterial = true;
    this.opacity = opacity;
    this._color = color.clone();
    this._colorMap = null;
    this.colorMap = colorMap;
    this._shaders = {
      name: unlitMeshShader.name,
      extensions: {},
      defines: {},
      vertexShader: unlitMeshMaterial_vertexShader,
      fragmentShader: unlitMeshMaterial_fragmentShader
    };
  }

  get color() {
    return this._color;
  }

  set color(value) {
    this._color.copy(value);
  }

  get colorMap() {
    return this._colorMap;
  }

  set colorMap(value) {
    if (false) {}

    if (this._colorMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._colorMap, value);
    const prevColorMap = this._colorMap;

    if (value !== null) {
      const colorMap = value;

      if (false) {}

      if (colorMap instanceof texture_resource_Texture) {
        if (this._colorMap !== null) {
          this._colorMap.texture = colorMap;
        } else if (colorMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._colorMap = new material_Material.TextureProperties(colorMap);
        } else if (colorMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._colorMap = new material_Material.TextureArrayProperties(colorMap);
        }
      } else {
        this._colorMap = colorMap.material instanceof material_Material ? colorMap.clone() : colorMap;
      }

      this._colorMap.material = this;

      this._colorMap.retain();
    } else {
      this._colorMap.material = null;
      this._colorMap = null;
    }

    if (prevColorMap !== null) {
      prevColorMap.release();
    }
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _colorMap = this._colorMap,
          _color = this._color,
          opacity = this.opacity;
    const program = technique.program,
          _output = technique._output;
    const layout = program.layout;
    const uniforms = layout.uniforms,
          samplerUniformNames = layout.samplerUniformNames;
    {
      const look = renderPass.look;
      const viewProjectionMatrix = look.viewProjectionMatrix;
      const uniform = uniforms.get('viewProjectionMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(viewProjectionMatrix);
    }

    if (_colorMap instanceof material_Material.TextureProperties && (_output & _colorMask) !== 0) {
      {
        const uniform = uniforms.get('colorMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const transform = _colorMap.transform;
        uniform.setValue(transform);
      }
      {
        const uniformName = samplerUniformNames.get('_colorMap');
        const texture = _colorMap.texture;
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }

      if (_colorMap instanceof material_Material.TextureArrayProperties) {
        const index = _colorMap.index;
        const uniform = uniforms.get('_colorMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if ((_output & _colorMask) !== 0) {
      const uniform = uniforms.get('color');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_color);
    }

    if ((_output & unlitMeshMaterial_opacityMask) !== 0) {
      const uniform = uniforms.get('opacity');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(opacity);
    }

    if (renderable.hasMorph) {
      const uniform = uniforms.get('morphWeights');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(renderable.morphWeights);
    }

    this._setSkeletonMap(gl, renderable, uniforms, textures);

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const _colorMap = this._colorMap;
    const defines = technique.defines;
    let colorMapChannel = null;
    let colorGammaDecode = null;

    if (_colorMap instanceof material_Material.TextureProperties) {
      defines.COLOR_MAP = '';
      const bindingPoint = _colorMap.bindingPoint,
            channel = _colorMap.channel,
            texture = _colorMap.texture;
      const internalFormat = texture.internalFormat,
            _gammaDecode = texture._gammaDecode;
      colorGammaDecode = _gammaDecode;

      if (!webgl2Support) {
        colorGammaDecode = internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8;
      } else {
        colorGammaDecode = internalFormat === InternalFormat.SRGB8;
      }

      colorMapChannel = channel;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.COLOR_MAP_FROM_ARRAY = '';
      } else {
        delete defines.COLOR_MAP_FROM_ARRAY;
      }
    } else {
      delete defines.COLOR_MAP;
    }

    {
      const positionMorphTargetCount = renderable.positionMorphTargetCount,
            normalMorphTargetCount = renderable.normalMorphTargetCount;

      if (positionMorphTargetCount !== 0 && defines.POSITION_MORPH_COUNT === undefined) {
        defines.POSITION_MORPH_COUNT = positionMorphTargetCount;
      } else if (positionMorphTargetCount === 0 && defines.POSITION_MORPH_COUNT !== undefined) {
        delete defines.POSITION_MORPH_COUNT;
      }

      if (normalMorphTargetCount !== 0 && defines.NORMAL_MORPH_COUNT === undefined) {
        defines.NORMAL_MORPH_COUNT = normalMorphTargetCount;
      } else if (normalMorphTargetCount === 0 && defines.NORMAL_MORPH_COUNT !== undefined) {
        delete defines.NORMAL_MORPH_COUNT;
      }
    }
    technique.cacheKey = `${JSON.stringify(defines)}_${colorMapChannel}_${colorGammaDecode}`;
    technique.needsUpdate = false;
  }

  clone(parameters = {}) {
    const name = parameters.name;
    const properties = {
      name: name || `${name}-clone`,
      alphaMode: this.alphaMode,
      alphaCutoff: this.alphaCutoff,
      opacity: this.opacity,
      cullFace: this.cullFace,
      color: this.color,
      colorMap: this.colorMap
    };
    return new unlitMeshMaterial_UnlitMeshMaterial(properties);
  }

  getTextures() {
    const textures = new Set();

    if (this.colorMap !== null) {
      textures.add(this.colorMap.texture);
    }

    return textures;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      if (this.colorMap !== null) {
        yield this.colorMap.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    if (this.colorMap !== null) {
      this.colorMap.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    this.colorMap = null;

    super._dispose();
  }

}
/* harmony default export */ var unlitMeshMaterial = (unlitMeshMaterial_UnlitMeshMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/environmentMaterial.js






const environmentShader = ShaderLib.environmentShader;
const environmentMaterial_exposureApplyMask = OutputLayoutSemantic.DEFAULT;
class environmentMaterial_EnvironmentMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? 'environment-material' : _properties$name,
          _properties$environme = properties.environmentMap,
          environmentMap = _properties$environme === void 0 ? null : _properties$environme,
          _properties$defines = properties.defines,
          defines = _properties$defines === void 0 ? {} : _properties$defines;
    super({
      name,
      alphaMode: material_Material.AlphaMode.OPAQUE,
      alphaCutoff: 0,
      cullFace: material_Material.CullFace.NONE
    });
    this.isEnvironmentMaterial = true;
    const vertexShader = environmentShader.vertexShader,
          fragmentShader = environmentShader.fragmentShader;
    this._shaders = {
      name,
      extensions: {},
      defines: {
        CUBE: '',
        ...defines
      },
      vertexShader,
      fragmentShader
    };
    this._environmentMap = null;
    this.environmentMap = environmentMap;
    this.depthWrite = false;
    this.useLogLUV = false;
    this.mipLevel = null;
  }

  get environmentMap() {
    return this._environmentMap;
  }

  set environmentMap(value) {
    if (false) {}

    if (this._environmentMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._environmentMap, value);
    const prevMap = this._environmentMap;

    if (value !== null) {
      const environmentMap = value;

      if (false) {}

      const bindingPoint = environmentMap.bindingPoint;

      if (false) {}

      const _shaders = this._shaders;
      const defines = _shaders.defines;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
        defines.EQUIRECTANGULAR_FORMAT = '';
      } else if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
        delete defines.EQUIRECTANGULAR_FORMAT;
      }

      const _ref = this._environmentMap || {},
            prevBindingPoint = _ref.bindingPoint;

      this._environmentMap = environmentMap.material instanceof material_Material ? environmentMap.clone() : environmentMap;
      this.needsUpdate = prevBindingPoint !== bindingPoint;
      this._environmentMap.material = this;

      this._environmentMap.retain();
    } else {
      this._environmentMap.material = null;
      this._environmentMap = null;
    }

    if (prevMap !== null) {
      prevMap.release();
    }
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const look = renderPass.look,
          renderTarget = renderPass.renderTarget;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _environmentMap = this._environmentMap;
    const program = technique.program,
          _output = technique._output;
    const layout = program.layout;
    const uniforms = layout.uniforms;
    {
      const uniform = uniforms.get('viewProjectionMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      const viewProjectionMatrix = (() => {
        if (look.isCubeCamera) {
          const targetIndex = renderTarget.targetIndex;
          return look.viewProjectionMatrices[targetIndex];
        }

        return look.viewProjectionMatrix;
      })();

      uniform.setValue(viewProjectionMatrix);
    }

    if ((_output & environmentMaterial_exposureApplyMask) !== 0) {
      const uniform = uniforms.get('manualExposure');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(look.exposure);
    }

    {
      const uniform = uniforms.get('_colorMap');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      this._setTexture(gl, uniform, _environmentMap.texture, textures);
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const defines = technique.defines;

    if (this.useLogLUV) {
      defines.USE_LOG_LUV = '';
    } else {
      delete defines.USE_LOG_LUV;
    }

    if (this.mipLevel) {
      defines.MIP_LEVEL = this.mipLevel;
    } else {
      delete defines.MIP_LEVEL;
    }

    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

  _needsUpdate(renderable, renderPass, technique, webgl2Support) {
    const extensions = technique.extensions;

    if (!webgl2Support && extensions.EXT_shader_texture_lod === undefined) {
      extensions.EXT_shader_texture_lod = ShaderExtensionBehaviour.REQUIRE;
      technique.needsUpdate = true;
    }

    return super._needsUpdate(renderable, renderPass, technique, webgl2Support);
  }

  clone(parameters = {}) {
    const name = parameters.name;
    const defines = {
      EQUIRECTANGULAR_FORMAT: this._shaders.defines.EQUIRECTANGULAR_FORMAT
    };
    const properties = {
      name: name || `${this.name}-clone`,
      environmentMap: this.environmentMap,
      defines
    };
    return new environmentMaterial_EnvironmentMaterial(properties);
  }

  getTextures() {
    const textures = new Set();

    if (this.environmentMap !== null) {
      textures.add(this.environmentMap.texture);
    }

    return textures;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      if (this.environmentMap !== null) {
        yield this.environmentMap.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    if (this.environmentMap !== null) {
      this.environmentMap.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    this.environmentMap = null;

    super._dispose();
  }

}
/* harmony default export */ var environmentMaterial = (environmentMaterial_EnvironmentMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/convolutionMaterial.js





const convolutionShader = ShaderLib.convolutionShader;
class convolutionMaterial_ConvolutionMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? 'convolution-material' : _properties$name,
          environmentMap = properties.environmentMap,
          _properties$samplesNu = properties.samplesNumber,
          samplesNumber = _properties$samplesNu === void 0 ? 512 : _properties$samplesNu,
          _properties$samplingD = properties.samplingDelta,
          samplingDelta = _properties$samplingD === void 0 ? Math.PI / 64 : _properties$samplingD,
          _properties$defines = properties.defines,
          defines = _properties$defines === void 0 ? {} : _properties$defines;
    super({
      name,
      alphaMode: material_Material.AlphaMode.OPAQUE,
      alphaCutoff: 0,
      cullFace: material_Material.CullFace.NONE
    });
    const vertexShader = convolutionShader.vertexShader,
          fragmentShader = convolutionShader.fragmentShader;
    this._shaders = {
      name: convolutionShader.name,
      extensions: {},
      defines: {
        SAMPLES_NUMBER: samplesNumber,
        SAMPLING_DELTA: samplingDelta,
        ...defines
      },
      vertexShader,
      fragmentShader
    };
    this._environmentMap = null;
    this.environmentMap = environmentMap;
  }

  get environmentMap() {
    return this._environmentMap;
  }

  set environmentMap(value) {
    if (this.environmentMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._environmentMap, value);

    if (value !== null) {
      const environmentMap = value;

      if (false) {}

      const bindingPoint = environmentMap.bindingPoint;

      if (false) {}

      this._environmentMap = environmentMap.material instanceof material_Material ? environmentMap.clone() : environmentMap;
      this._environmentMap.material = this;
      this._environmentMap.texture = environmentMap.texture;
      const _shaders = this._shaders;
      const defines = _shaders.defines;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
        defines.EQUIRECTANGULAR_FORMAT = '';
        this.needsUpdate = true;
      } else if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
        delete defines.EQUIRECTANGULAR_FORMAT;
        this.needsUpdate = true;
      }
    } else {
      this._environmentMap.material = null;
      this._environmentMap = null;
    }
  }

  get shaders() {
    return this._shaders;
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const _environmentMap = this._environmentMap;
    const look = renderPass.look,
          renderTarget = renderPass.renderTarget;
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const program = technique.program,
          defines = technique.defines;
    const layout = program.layout;
    const uniforms = layout.uniforms;
    const PRE_FILTERING_ENV_MAP = defines.PRE_FILTERING_ENV_MAP,
          BRDF_CONVOLUTION = defines.BRDF_CONVOLUTION;

    if (defines.CUBE !== undefined) {
      const uniform = uniforms.get('viewProjectionMatrix');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      if (false) {}

      if (false) {}

      if (look.isCubeCamera) {
        const targetIndex = renderTarget.targetIndex;
        uniform.setValue(look.viewProjectionMatrices[targetIndex]);
      } else {
        uniform.setValue(look.viewProjectionMatrix);
      }
    }

    if (defines.RADIANCE_CONVOLUTION !== undefined || PRE_FILTERING_ENV_MAP !== undefined) {
      const uniform = uniforms.get('_environmentMap');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      this._setTexture(gl, uniform, _environmentMap.texture, textures);
    }

    if (PRE_FILTERING_ENV_MAP !== undefined) {
      {
        const uniform = uniforms.get('roughness');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const roughness = this.roughness;
        uniform.setValue(roughness);
      }

      if (defines.SAMPLE_MIP_LEVEL !== undefined) {
        const uniform = uniforms.get('resolution');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const width = _environmentMap.width;
        uniform.setValue(width);
      }
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const defines = technique.defines;
    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

  _needsUpdate(renderable, renderPass, technique, webgl2Support) {
    const _environmentMap = this._environmentMap;
    const defines = technique.defines,
          extensions = technique.extensions;
    const levels = _environmentMap.levels;
    const SAMPLE_MIP_LEVEL = defines.SAMPLE_MIP_LEVEL;
    const RADIANCE_CONVOLUTION = defines.RADIANCE_CONVOLUTION,
          PRE_FILTERING_ENV_MAP = defines.PRE_FILTERING_ENV_MAP,
          BRDF_CONVOLUTION = defines.BRDF_CONVOLUTION;

    if (BRDF_CONVOLUTION !== undefined) {
      if (defines.SCREEN_QUAD == null || defines.CUBE !== undefined) {
        defines.SCREEN_QUAD = '';
        delete defines.CUBE;
        technique.needsUpdate = true;
      }
    } else if (RADIANCE_CONVOLUTION !== undefined || PRE_FILTERING_ENV_MAP !== undefined) {
      if (defines.CUBE == null || defines.SCREEN_QUAD !== undefined) {
        defines.CUBE = '';
        delete defines.SCREEN_QUAD;
        technique.needsUpdate = true;
      }
    }

    if (levels > 1 && PRE_FILTERING_ENV_MAP !== undefined) {
      if (SAMPLE_MIP_LEVEL === undefined) {
        defines.SAMPLE_MIP_LEVEL = '';
        technique.needsUpdate = true;

        if (!webgl2Support) {
          extensions.EXT_shader_texture_lod = ShaderExtensionBehaviour.REQUIRE;
        }
      }
    } else {
      if (SAMPLE_MIP_LEVEL !== undefined) {
        delete defines.SAMPLE_MIP_LEVEL;
        technique.needsUpdate = true;

        if (!webgl2Support) {
          delete extensions.EXT_shader_texture_lod;
        }
      }
    }

    defines.OUTPUT_MASK = 0;
    return super._needsUpdate(renderable, renderPass, technique, webgl2Support);
  }

}
/* harmony default export */ var convolutionMaterial = (convolutionMaterial_ConvolutionMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/spriteMaterial.js





const spriteShader = ShaderLib.spriteShader;
const spriteMaterial_vertexShader = spriteShader.vertexShader,
      spriteMaterial_fragmentShader = spriteShader.fragmentShader;
class spriteMaterial_SpriteMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$alphaMode = properties.alphaMode,
          alphaMode = _properties$alphaMode === void 0 ? material_Material.AlphaMode.OPAQUE : _properties$alphaMode,
          _properties$alphaCuto = properties.alphaCutoff,
          alphaCutoff = _properties$alphaCuto === void 0 ? 0.0 : _properties$alphaCuto,
          _properties$opacity = properties.opacity,
          opacity = _properties$opacity === void 0 ? 1.0 : _properties$opacity,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.BACK : _properties$cullFace,
          _properties$color = properties.color,
          color = _properties$color === void 0 ? new lib["k" /* RGBColor */](1, 1, 1) : _properties$color,
          _properties$colorMap = properties.colorMap,
          colorMap = _properties$colorMap === void 0 ? null : _properties$colorMap,
          _properties$rotation = properties.rotation,
          rotation = _properties$rotation === void 0 ? 0.0 : _properties$rotation,
          _properties$center = properties.center,
          center = _properties$center === void 0 ? new lib["m" /* Vector2 */]() : _properties$center;
    super({
      name,
      alphaMode,
      alphaCutoff,
      cullFace
    });
    this.isSpriteMaterial = true;
    this.opacity = opacity;
    this._color = color.clone();
    this._colorMap = null;
    this.colorMap = colorMap;
    this.rotation = rotation;
    this._center = center.clone();
    this._shaders = {
      name: spriteShader.name,
      extensions: {},
      defines: {},
      vertexShader: spriteMaterial_vertexShader,
      fragmentShader: spriteMaterial_fragmentShader
    };
  }

  get color() {
    return this._color;
  }

  set color(value) {
    this._color.copy(value);
  }

  get center() {
    return this._center;
  }

  get colorMap() {
    return this._colorMap;
  }

  set colorMap(value) {
    if (this._colorMap === value) {
      return;
    }

    this.needsUpdate = webGLBaseMaterial_WebGLBaseMaterial._testIfNewTextureRequireUpdate(this._colorMap, value);
    const prevColorMap = this._colorMap;

    if (value !== null) {
      const colorMap = value;

      if (false) {}

      if (colorMap instanceof texture_resource_Texture) {
        if (this._colorMap !== null) {
          this._colorMap.texture = colorMap;
        } else if (colorMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D) {
          this._colorMap = new material_Material.TextureProperties(colorMap);
        } else if (colorMap.bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
          this._colorMap = new material_Material.TextureArrayProperties(colorMap);
        }
      } else {
        this._colorMap = colorMap.material instanceof material_Material ? colorMap.clone() : colorMap;
      }

      this._colorMap.material = this;

      this._colorMap.retain();
    } else {
      this._colorMap.material = null;
      this._colorMap = null;
    }

    if (prevColorMap !== null) {
      prevColorMap.release();
    }
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _colorMap = this._colorMap,
          _color = this._color,
          opacity = this.opacity,
          rotation = this.rotation,
          _center = this._center;
    const program = technique.program,
          _output = technique._output;
    const layout = program.layout;
    const uniforms = layout.uniforms,
          samplerUniformNames = layout.samplerUniformNames;
    {
      const look = renderPass.look;
      const viewMatrix = look.viewMatrix,
            projectionMatrix = look.projectionMatrix;
      const uniform1 = uniforms.get('viewMatrix');
      const uniform2 = uniforms.get('projectionMatrix');

      if (uniform1 === undefined) {
        throw new Error('uniform is undefined');
      }

      if (uniform2 === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform1.setValue(viewMatrix);
      uniform2.setValue(projectionMatrix);
    }

    if (_colorMap instanceof material_Material.TextureProperties && (_output & OutputLayoutSemantic.DEFAULT) !== 0) {
      {
        const uniform = uniforms.get('colorMapTransform');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        const transform = _colorMap.transform;
        uniform.setValue(transform);
      }
      {
        const uniformName = samplerUniformNames.get('_colorMap');
        const texture = _colorMap.texture;
        const uniform = uniforms.get(uniformName);

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        this._setTexture(gl, uniform, texture, textures);
      }

      if (_colorMap instanceof material_Material.TextureArrayProperties) {
        const index = _colorMap.index;
        const uniform = uniforms.get('_colorMapIndex');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(index);
      }
    }

    if ((_output & OutputLayoutSemantic.DEFAULT) !== 0) {
      const uniform = uniforms.get('color');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_color);
    }

    if ((_output & OutputLayoutSemantic.DEFAULT) !== 0) {
      const uniform = uniforms.get('opacity');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(opacity);
    }

    {
      const uniform = uniforms.get('rotation');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(rotation);
    }
    {
      const uniform = uniforms.get('center');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_center);
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderRequest, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderRequest, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const _colorMap = this._colorMap,
          alphaMode = this.alphaMode,
          alphaCutoff = this.alphaCutoff;
    const defines = technique.defines;
    let colorMapChannel = null;
    let colorGammaDecode = null;

    if (_colorMap instanceof material_Material.TextureProperties) {
      defines.COLOR_MAP = '';
      const bindingPoint = _colorMap.bindingPoint,
            channel = _colorMap.channel,
            texture = _colorMap.texture;
      const internalFormat = texture.internalFormat,
            _gammaDecode = texture._gammaDecode;
      colorGammaDecode = _gammaDecode;

      if (!webgl2Support) {
        colorGammaDecode = internalFormat === InternalFormat.SRGB8_ALPHA8 || internalFormat === InternalFormat.SRGB8;
      } else {
        colorGammaDecode = internalFormat === InternalFormat.SRGB8;
      }

      colorMapChannel = channel;

      if (bindingPoint === texture_resource_Texture.BindingPoint.TEXTURE_2D_ARRAY) {
        defines.COLOR_MAP_FROM_ARRAY = '';
      } else {
        delete defines.COLOR_MAP_FROM_ARRAY;
      }
    } else {
      delete defines.COLOR_MAP;
    }

    if (alphaMode === material_Material.AlphaMode.MASK) {
      defines.ALPHA_TEST = alphaCutoff;
    } else {
      delete defines.ALPHA_TEST;
    }

    technique.cacheKey = `${JSON.stringify(defines)}_${colorMapChannel}_${colorGammaDecode}`;
    technique.needsUpdate = false;
  }

  clone(parameters = {}) {
    const name = parameters.name;
    const properties = {
      name: name || `${name}-clone`,
      alphaMode: this.alphaMode,
      alphaCutoff: this.alphaCutoff,
      opacity: this.opacity,
      cullFace: this.cullFace,
      color: this.color,
      colorMap: this.colorMap,
      rotation: this.rotation,
      center: this.center
    };
    return new spriteMaterial_SpriteMaterial(properties);
  }

  getTextures() {
    const textures = new Set();

    if (this.colorMap !== null) {
      textures.add(this.colorMap.texture);
    }

    return textures;
  }

  unload() {
    if (this.colorMap !== null) {
      this.colorMap.unload();
    }
  }

  _dispose() {
    this.colorMap = null;

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/lineMaterial.js




const lineShader = ShaderLib.lineShader;
const lineMaterial_vertexShader = lineShader.vertexShader,
      lineMaterial_fragmentShader = lineShader.fragmentShader;
class lineMaterial_LineMaterial extends webGLBaseMaterial_WebGLBaseMaterial {
  constructor(properties = {}) {
    const _properties$name = properties.name,
          name = _properties$name === void 0 ? '' : _properties$name,
          _properties$defines = properties.defines,
          defines = _properties$defines === void 0 ? {} : _properties$defines,
          _properties$cullFace = properties.cullFace,
          cullFace = _properties$cullFace === void 0 ? material_Material.CullFace.NONE : _properties$cullFace,
          _properties$color = properties.color,
          color = _properties$color === void 0 ? new lib["k" /* RGBColor */](1, 1, 1) : _properties$color,
          _properties$opacity = properties.opacity,
          opacity = _properties$opacity === void 0 ? 1 : _properties$opacity;
    super({
      name,
      cullFace
    });
    this.isLineMaterial = true;
    this._color = color.clone();
    this.opacity = opacity;
    this._shaders = {
      name: lineShader.name,
      extensions: {},
      defines,
      vertexShader: lineMaterial_vertexShader,
      fragmentShader: lineMaterial_fragmentShader
    };
  }

  get color() {
    return this._color;
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderPass.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const _color = this._color,
          opacity = this.opacity;
    const program = technique.program,
          defines = technique.defines;
    const layout = program.layout;
    const uniforms = layout.uniforms;
    const VIEW_TO_CLIP_POSITION = defines.VIEW_TO_CLIP_POSITION;
    {
      const look = renderPass.look;

      if (VIEW_TO_CLIP_POSITION !== undefined) {
        const viewMatrix = look.viewMatrix,
              projectionMatrix = look.projectionMatrix;
        {
          const uniform = uniforms.get('viewMatrix');

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          uniform.setValue(viewMatrix);
        }
        {
          const uniform = uniforms.get('projectionMatrix');

          if (uniform === undefined) {
            throw new Error('uniform is undefined');
          }

          uniform.setValue(projectionMatrix);
        }
      } else {
        const viewProjectionMatrix = look.viewProjectionMatrix;
        const uniform = uniforms.get('viewProjectionMatrix');

        if (uniform === undefined) {
          throw new Error('uniform is undefined');
        }

        uniform.setValue(viewProjectionMatrix);
      }
    }
    {
      const uniform = uniforms.get('color');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(_color);
    }
    {
      const uniform = uniforms.get('opacity');

      if (uniform === undefined) {
        throw new Error('uniform is undefined');
      }

      uniform.setValue(opacity);
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const defines = technique.defines;
    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

}
/* harmony default export */ var lineMaterial = (lineMaterial_LineMaterial);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/materialFactory.js



class materialFactory_MaterialFactory {
  createPbrMeshMaterial(options) {
    return new pbrMeshMaterial_PbrMeshMaterial(options);
  }

  createUnlitMeshMaterial(options) {
    return new unlitMeshMaterial_UnlitMeshMaterial(options);
  }

  createEnvironmentMaterial(options) {
    return new environmentMaterial_EnvironmentMaterial(options);
  }

}
/* harmony default export */ var materialFactory = (materialFactory_MaterialFactory);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/materials/index.js










// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/webgl-renderer/index.js




// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/animation-system/index.js
function animation_system_slicedToArray(arr, i) { return animation_system_arrayWithHoles(arr) || animation_system_iterableToArrayLimit(arr, i) || animation_system_unsupportedIterableToArray(arr, i) || animation_system_nonIterableRest(); }

function animation_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function animation_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return animation_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return animation_system_arrayLikeToArray(o, minLen); }

function animation_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function animation_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function animation_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const boneMatrixSize = 12;
const animation_system_componentClasses = [transform_component_Transform];
const entityComponents = [];
const boneMatrix = new lib["b" /* AffineMatrix3 */]();
class animation_system_AnimationSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    EntityManager.onAttach.subscribe((entityManager, entity, component) => {
      const index = component.index;
      const _scene = entityManager._scene;

      switch (index) {
        case node_animation_NodeAnimation.index:
          {
            const channels = component.channels;

            for (const channel of channels) {
              _scene.getAnimation(channel.animation).retain();
            }
          }
          break;

        case bone_Bone.index:
          _scene.getSkeleton(component.skeletonIndex).retain();

          break;

        default:
      }
    });
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;
      const _scene = entityManager._scene;

      switch (index) {
        case node_animation_NodeAnimation.index:
          {
            const channels = component.channels;

            for (const channel of channels) {
              _scene.getAnimation(channel.animation).release();
            }
          }
          break;

        case bone_Bone.index:
          _scene.getSkeleton(component.skeletonIndex).release();

          break;

        default:
      }
    });
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          dt = _core$currentRequest.dt;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(node_animation_NodeAnimation)) {
      return;
    }

    const nodeAnimationStorage = entityManager.getComponentStorage(node_animation_NodeAnimation);

    for (const animation of scene.animations()) {
      animation.startUpdate(dt);
    }

    for (const nodeAnimation of nodeAnimationStorage.components()) {
      const channels = nodeAnimation.channels;

      for (const channel of channels) {
        const animation = channel.animation,
              sampler = channel.sampler;
        const animation_ = scene.getAnimation(animation);
        const active = animation_.active,
              samplers = animation_.samplers;

        if (!active) {
          continue;
        }

        channel.update(samplers[sampler].value);
      }
    }

    for (const animation of scene.animations()) {
      animation.endUpdate();
    }
  }

  onLateUpdate(core) {
    const scene = core.currentRequest.scene;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(bone_Bone)) {
      return;
    }

    const boneStorage = entityManager.getComponentStorage(bone_Bone);

    for (const _ref of boneStorage.entries()) {
      var _ref2 = animation_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const bone = _ref2[1];

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, animation_system_componentClasses, entityComponents),
            _entityManager$getEnt2 = animation_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      const skeletonIndex = bone.skeletonIndex,
            boneIndex = bone.boneIndex,
            inverseBindMatrix = bone.inverseBindMatrix;
      const skeleton = scene.getSkeleton(skeletonIndex);
      const root = skeleton.root,
            skeletonBuffersCount = skeleton.skeletonBuffersCount,
            _countBones = skeleton._countBones;
      const state = transform.state,
            worldMatrix = transform.worldMatrix;

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0) {
        boneMatrix.copy(root.worldMatrix).invert().preMultiply(worldMatrix).preMultiply(inverseBindMatrix);

        for (let i = 0; i < skeletonBuffersCount; i++) {
          const instanceIndex = skeleton.getInstanceIndex(i);
          const boneMatrices = skeleton.getBoneMatrices(i);
          const instanceOffset = boneMatrixSize * _countBones * instanceIndex;
          boneMatrix.toAffineColumnArrayAt(instanceOffset + boneMatrixSize * boneIndex, boneMatrices);
          skeleton.update(i);
        }
      }
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    srcScene,
    dstScene,
    copyContext
  }) {
    const _copyContext$nodeToNo = copyContext.nodeToNode,
          nodeToNode = _copyContext$nodeToNo === void 0 ? new Map() : _copyContext$nodeToNo,
          _copyContext$skeleton = copyContext.skeletonToSkeleton,
          skeletonToSkeleton = _copyContext$skeleton === void 0 ? new Map() : _copyContext$skeleton,
          _copyContext$animatio = copyContext.animationToAnimation,
          animationToAnimation = _copyContext$animatio === void 0 ? new Map() : _copyContext$animatio;
    const xfrmToXfrm = new Map();
    const skeletonsToCopy = new Set();
    const animationsToCopy = new Set();

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = animation_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      let _dstNode$getComponent = dstNode.getComponents([transform_component_Transform]),
          _dstNode$getComponent2 = animation_system_slicedToArray(_dstNode$getComponent, 1),
          dstTransform = _dstNode$getComponent2[0];

      const _srcNode$getComponent = srcNode.getComponents([transform_component_Transform, node_animation_NodeAnimation, bone_Bone]),
            _srcNode$getComponent2 = animation_system_slicedToArray(_srcNode$getComponent, 3),
            srcTransform = _srcNode$getComponent2[0],
            srcNodeAnimation = _srcNode$getComponent2[1],
            srcBone = _srcNode$getComponent2[2];

      if (srcTransform !== null && dstTransform === null) {
        dstTransform = srcTransform.clone();
        dstNode.attach(dstTransform);
      } else if (srcTransform !== null && dstTransform !== null) {
        dstTransform.position.copy(srcTransform.position);
        dstTransform.scale.copy(srcTransform.scale);
        dstTransform.orientation.copy(srcTransform.orientation);
        dstTransform.state = transform_component_Transform.StateMask.UPDATE_LOCAL;
      }

      if (srcNodeAnimation !== null) {
        for (const ch of srcNodeAnimation.channels) {
          animationsToCopy.add(ch.animation);
        }
      }

      if (srcBone !== null) {
        skeletonsToCopy.add(srcBone.skeletonIndex);
      }

      xfrmToXfrm.set(srcTransform, dstTransform);
    }

    for (const _ref5 of srcScene.animationEntries()) {
      var _ref6 = animation_system_slicedToArray(_ref5, 2);

      const srcIndex = _ref6[0];
      const a = _ref6[1];

      if (!animationsToCopy.has(srcIndex)) {
        continue;
      }

      const c = a.clone();
      const dstIndex = dstScene.addAnimation(c);
      animationToAnimation.set(srcIndex, dstIndex);
    }

    for (const _ref7 of srcScene.skeletonEntries()) {
      var _ref8 = animation_system_slicedToArray(_ref7, 2);

      const srcIndex = _ref8[0];
      const srcSkeleton = _ref8[1];

      if (!skeletonsToCopy.has(srcIndex)) {
        continue;
      }

      const countBones = srcSkeleton.countBones;
      const dstRoot = xfrmToXfrm.get(srcSkeleton.root);
      const dstSkeleton = new skeleton_Skeleton(srcSkeleton.name, dstRoot, countBones);
      const dstIndex = dstScene.addSkeleton(dstSkeleton);
      skeletonToSkeleton.set(srcIndex, dstIndex);
    }

    for (const _ref9 of nodeToNode.entries()) {
      var _ref10 = animation_system_slicedToArray(_ref9, 2);

      const srcNode = _ref10[0];
      const dstNode = _ref10[1];

      const _srcNode$getComponent3 = srcNode.getComponents([bone_Bone]),
            _srcNode$getComponent4 = animation_system_slicedToArray(_srcNode$getComponent3, 1),
            srcBone = _srcNode$getComponent4[0];

      if (srcBone === null) {
        continue;
      }

      const dstBone = srcBone.clone();
      const skeletonIndex = skeletonToSkeleton.get(srcBone.skeletonIndex);
      dstBone.skeletonIndex = skeletonIndex;
      dstNode.attach(dstBone);
    }

    for (const _ref11 of nodeToNode.entries()) {
      var _ref12 = animation_system_slicedToArray(_ref11, 2);

      const srcNode = _ref12[0];
      const dstNode = _ref12[1];

      const _srcNode$getComponent5 = srcNode.getComponents([node_animation_NodeAnimation]),
            _srcNode$getComponent6 = animation_system_slicedToArray(_srcNode$getComponent5, 1),
            srcNodeAnimation = _srcNode$getComponent6[0];

      if (srcNodeAnimation === null) {
        continue;
      }

      const srcChannels = srcNodeAnimation.channels;
      const dstChannels = [];
      const dstNodeAnimation = new node_animation_NodeAnimation();
      dstNodeAnimation.channels = dstChannels;

      for (const srcChannel of srcChannels) {
        const target = srcChannel.target,
              sampler = srcChannel.sampler,
              animation = srcChannel.animation,
              _updater = srcChannel._updater;
        const target_ = target instanceof transform_component_Transform ? xfrmToXfrm.get(target) : target;
        const animation_ = animationToAnimation.get(animation);
        const dstChannel = new node_animation_NodeAnimation.Channel(target_, sampler, animation_);
        dstChannel.update = _updater;
        dstChannels.push(dstChannel);
      }

      dstNode.attach(dstNodeAnimation);
    }
  }

}
animation_system_AnimationSystem.ID = 'animation';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/camera-system/index.js
function camera_system_slicedToArray(arr, i) { return camera_system_arrayWithHoles(arr) || camera_system_iterableToArrayLimit(arr, i) || camera_system_unsupportedIterableToArray(arr, i) || camera_system_nonIterableRest(); }

function camera_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function camera_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return camera_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return camera_system_arrayLikeToArray(o, minLen); }

function camera_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function camera_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function camera_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






const localClipper = new lib["f" /* HalfSpace3 */]();
function applyClipper(camera) {
  localClipper.copy(camera.clipper).applyAffineMatrix(camera.viewMatrix);

  if (camera.reflected) {
    localClipper.flip();
  }

  const normal = localClipper.normal,
        offset = localClipper.offset;
  const proj = camera.projectionMatrix;

  const x = (Object(lib["y" /* sign */])(normal.x) + proj._20) / proj._00;

  const y = (Object(lib["y" /* sign */])(normal.y) + proj._21) / proj._11;

  const z = -1;
  const w = (1 + proj._22) / proj._32;
  const f = 2 / (normal.x * x + normal.y * y + normal.z * z - offset * w);
  proj._02 = normal.x * f;
  proj._12 = normal.y * f;
  proj._22 = normal.z * f + 1;
  proj._32 = -offset * f;
}
const camera_system_center = new lib["n" /* Vector3 */]();
const reflector = new lib["b" /* AffineMatrix3 */]();
function reflect(camera) {
  const worldMatrix = camera.worldMatrix,
        clipper = camera.clipper;
  reflector.fromReflection(clipper.normal);
  clipper.centerPaste(camera_system_center);
  reflector.translate(camera_system_center);
  reflector.preTranslate(camera_system_center.negate());
  worldMatrix.multiply(reflector);
  worldMatrix._00 *= -1;
  worldMatrix._01 *= -1;
  worldMatrix._02 *= -1;
}
const lateUpdateClasses = [transform_component_Transform];
class camera_system_CameraSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          width = _core$currentRequest.width,
          height = _core$currentRequest.height;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(camera_component_Camera)) {
      return;
    }

    const cameraAspect = width / height;
    const storage = entityManager.getComponentStorage(camera_component_Camera);

    for (const camera of storage.components()) {
      if (cameraAspect !== camera.aspect) {
        camera.aspect = width / height;
        camera.needsUpdateProjection = true;
      }

      const projectionType = camera.projectionType,
            needsUpdateProjection = camera.needsUpdateProjection;

      if (!needsUpdateProjection) {
        continue;
      }

      camera.onEarlyUpdateStart.emit();

      if (projectionType === camera_component_Camera.ProjectionTypes.PERSPECTIVE) {
        camera.projectionMatrix.fromWebGLPerspectiveProjection(camera.aspect, camera.yfov, camera.znear, camera.zfar);
      } else if (projectionType === camera_component_Camera.ProjectionTypes.ORTHOGRAPHIC) {
        camera.projectionMatrix.fromWebGLOrthographicProjection(camera.xmag, camera.ymag, camera.znear, camera.zfar);
      }

      camera.onEarlyUpdateEnd.emit();
    }
  }

  onLateUpdate(core) {
    const _core$currentRequest2 = core.currentRequest,
          scene = _core$currentRequest2.scene,
          frameNumber = _core$currentRequest2.frameNumber;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(camera_component_Camera)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(camera_component_Camera);

    for (const _ref of storage.entries()) {
      var _ref2 = camera_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const camera = _ref2[1];

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, lateUpdateClasses, components),
            _entityManager$getEnt2 = camera_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      const state = transform.state;
      const needsUpdateProjection = camera.needsUpdateProjection,
            worldMatrix = camera.worldMatrix,
            viewMatrix = camera.viewMatrix,
            projectionMatrix = camera.projectionMatrix,
            viewProjectionMatrix = camera.viewProjectionMatrix;

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0) {
        worldMatrix.copy(transform.worldMatrix);

        if (camera.clipper && camera.reflected) {
          reflect(camera);
        }

        viewMatrix.copy(worldMatrix).invert();
        camera.lastFrameUpdate = frameNumber;
      }

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0 || needsUpdateProjection) {
        viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);

        if (camera.clipper) {
          applyClipper(camera);
        }

        camera.lastFrameUpdate = frameNumber;
      }

      if (camera.lastFrameUpdate === frameNumber) {
        camera.onLateUpdateEnd.emit();
      }

      camera.needsUpdateProjection = false;
      const look = core.currentRequest.look;
      look.aspect = camera.aspect;
      look.yfov = camera.yfov;
      look.zfar = camera.zfar;
      look.znear = camera.znear;
      look.exposure = camera.exposure;
      look.viewMatrix.copy(camera.viewMatrix);
      look.worldMatrix.copy(camera.worldMatrix);
      look.projectionType = camera.projectionType;
      look.projectionMatrix.copy(camera.projectionMatrix);
      look.viewProjectionMatrix.copy(camera.viewProjectionMatrix);
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = camera_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([camera_component_Camera]),
            _srcNode$getComponent2 = camera_system_slicedToArray(_srcNode$getComponent, 1),
            srcCamera = _srcNode$getComponent2[0];

      if (srcCamera === null) {
        continue;
      }

      const dstCamera = srcCamera.clone();
      dstNode.attach(dstCamera);
    }
  }

}
camera_system_CameraSystem.ID = 'camera';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/cube-camera-component/index.js


class cube_camera_component_CubeCamera extends component_Component {
  constructor({
    name = '',
    zfar = 10,
    znear = 0.1
  }) {
    super();
    this.yfov = 90 * Math.PI / 180;
    this.aspect = 1;
    this.cubeSideIndex = 0;
    this.lastFrameUpdate = 0;
    this.needsUpdateProjection = true;
    this.viewMatrices = Array(...Array(6)).map(() => {
      return new lib["b" /* AffineMatrix3 */]();
    });
    this.projectionMatrix = new lib["g" /* HomogeneousMatrix3 */]();
    this.viewProjectionMatrices = Array(...Array(6)).map(() => {
      return new lib["g" /* HomogeneousMatrix3 */]();
    });
    this.name = name;
    this.zfar = zfar;
    this.znear = znear;
  }

  get viewMatrix() {
    const viewMatrices = this.viewMatrices,
          cubeSideIndex = this.cubeSideIndex;
    return viewMatrices[cubeSideIndex];
  }

  get viewProjectionMatrix() {
    const viewProjectionMatrices = this.viewProjectionMatrices,
          cubeSideIndex = this.cubeSideIndex;
    return viewProjectionMatrices[cubeSideIndex];
  }

  clone() {
    const name = this.name,
          zfar = this.zfar,
          znear = this.znear;
    return new cube_camera_component_CubeCamera({
      name,
      zfar,
      znear
    });
  }

}
cube_camera_component_CubeCamera.ID = 'cubeCamera';
Object.defineProperty(cube_camera_component_CubeCamera.prototype, 'isCubeCamera', {
  value: true
});
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/cube-camera-system/index.js
function cube_camera_system_slicedToArray(arr, i) { return cube_camera_system_arrayWithHoles(arr) || cube_camera_system_iterableToArrayLimit(arr, i) || cube_camera_system_unsupportedIterableToArray(arr, i) || cube_camera_system_nonIterableRest(); }

function cube_camera_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function cube_camera_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return cube_camera_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return cube_camera_system_arrayLikeToArray(o, minLen); }

function cube_camera_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function cube_camera_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function cube_camera_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const cube_camera_system_lateUpdateClasses = [transform_component_Transform];
class cube_camera_system_CubeCameraSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    this._tempMatrix = new lib["b" /* AffineMatrix3 */]();
    this._perCubeFaceMatrices = [new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](+1, 0, 0), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](-1, 0, 0), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, -1, 0), new lib["n" /* Vector3 */](0, 0, -1)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, +1, 0), new lib["n" /* Vector3 */](0, 0, +1)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, 0, +1), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, 0, -1), new lib["n" /* Vector3 */](0, -1, 0))];
    this.onEarlyUpdateEnd = new _wgetemp_event["a" /* Event */]();
    this.onLateUpdateEnd = new _wgetemp_event["a" /* Event */]();
  }

  onUpdate(core) {
    const scene = core.currentRequest.scene;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(cube_camera_component_CubeCamera)) {
      return;
    }

    const storage = entityManager.getComponentStorage(cube_camera_component_CubeCamera);

    for (const cubeCamera of storage.components()) {
      const needsUpdateProjection = cubeCamera.needsUpdateProjection;

      if (needsUpdateProjection) {
        cubeCamera.projectionMatrix.fromWebGLPerspectiveProjection(cubeCamera.aspect, cubeCamera.yfov, cubeCamera.znear, cubeCamera.zfar);
      }
    }

    this.onEarlyUpdateEnd.emit(core.currentRequest);
  }

  onLateUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          frameNumber = _core$currentRequest.frameNumber;
    const entityManager = scene.entityManager;

    if (!entityManager.isComponent(cube_camera_component_CubeCamera)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(cube_camera_component_CubeCamera);

    for (const _ref of storage.entries()) {
      var _ref2 = cube_camera_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const cubeCamera = _ref2[1];

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, cube_camera_system_lateUpdateClasses, components),
            _entityManager$getEnt2 = cube_camera_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      const state = transform.state,
            worldMatrix = transform.worldMatrix;
      const needsUpdateProjection = cubeCamera.needsUpdateProjection,
            projectionMatrix = cubeCamera.projectionMatrix,
            viewMatrices = cubeCamera.viewMatrices,
            viewProjectionMatrices = cubeCamera.viewProjectionMatrices;

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0) {
        const _perCubeFaceMatrices = this._perCubeFaceMatrices,
              _tempMatrix = this._tempMatrix;

        _tempMatrix.copy(worldMatrix).invert();

        for (const _ref3 of viewMatrices.entries()) {
          var _ref4 = cube_camera_system_slicedToArray(_ref3, 2);

          const i = _ref4[0];
          const viewMatrix = _ref4[1];
          viewMatrix.copy(_tempMatrix).multiply(_perCubeFaceMatrices[i]);
        }

        cubeCamera.lastFrameUpdate = frameNumber;
      }

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0 || needsUpdateProjection) {
        for (const _ref5 of viewProjectionMatrices.entries()) {
          var _ref6 = cube_camera_system_slicedToArray(_ref5, 2);

          const i = _ref6[0];
          const viewProjectionMatrix = _ref6[1];
          viewProjectionMatrix.fromAffine(viewMatrices[i]).multiply(projectionMatrix);
        }

        cubeCamera.needsUpdateProjection = false;
        cubeCamera.lastFrameUpdate = frameNumber;
      }

      const look = core.currentRequest.look;
      look.projectionMatrix.copy(cubeCamera.projectionMatrix);

      for (let it = 0; it < 6; it++) {
        look.viewMatrices[it].copy(cubeCamera.viewMatrices[it]);
        look.viewProjectionMatrices[it].copy(cubeCamera.viewProjectionMatrices[it]);
      }
    }

    this.onLateUpdateEnd.emit(core.currentRequest);
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref7 of nodeToNode.entries()) {
      var _ref8 = cube_camera_system_slicedToArray(_ref7, 2);

      const srcNode = _ref8[0];
      const dstNode = _ref8[1];

      const _srcNode$getComponent = srcNode.getComponents([cube_camera_component_CubeCamera]),
            _srcNode$getComponent2 = cube_camera_system_slicedToArray(_srcNode$getComponent, 1),
            srcCamera = _srcNode$getComponent2[0];

      if (srcCamera === null) {
        continue;
      }

      const dstCamera = srcCamera.clone();
      dstNode.attach(dstCamera);
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

}
cube_camera_system_CubeCameraSystem.ID = 'cubeCamera';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/draw-system/index.js

class draw_system_DrawSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onDraw', this);
  }

  onDraw(core) {
    core.renderer.render(core.currentRequest);
  }

}
draw_system_DrawSystem.ID = 'draw';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/input-system/pointer.js
class Pointer {
  constructor() {
    this.type = 'mouse';
    this.id = 0;
    this.x = 0;
    this.y = 0;
    this.dx = 0;
    this.dy = 0;
    this.up = 0;
    this.down = 0;
    this.state = 0;
    this.delete = false;
    this.primary = false;
    this.asyncX = 0;
    this.asyncY = 0;
    this.asyncUp = 0;
    this.asyncDown = 0;
    this.asyncState = 0;
  }

  update() {
    this.dx = this.asyncX - this.x;
    this.dy = this.asyncY - this.y;
    this.x = this.asyncX;
    this.y = this.asyncY;
    this.up = this.asyncUp;
    this.down = this.asyncDown;
    this.state = this.asyncState;
    this.asyncUp = 0;
    this.asyncDown = 0;
  }

  static sort(a, b) {
    if (a.type > b.type) {
      return -1;
    }

    if (a.type < b.type) {
      return 1;
    }

    if (a.primary && !b.primary) {
      return 1;
    }

    if (!a.primary && b.primary) {
      return -1;
    }

    return 0;
  }

}
Pointer.LBUTTON = 0x01;
Pointer.RBUTTON = 0x02;
Pointer.MBUTTON = 0x04;
Pointer.X1BUTTON = 0x08;
Pointer.X2BUTTON = 0x10;
Pointer.EBUTTON = 0x20;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/input-system/index.js



let keyCode = 0;
let keyMask = 0;
let keyElement = 0;
class input_system_InputSystem extends System {
  constructor(core) {
    super();
    this._keyUp = new Uint32Array(8);
    this._keyDown = new Uint32Array(8);
    this._keyState = new Uint32Array(8);
    this.wheelX = 0;
    this.wheelY = 0;
    this.wheelZ = 0;
    this.pointers = [];
    this._asyncKeyUp = new Uint32Array(8);
    this._asyncKeyDown = new Uint32Array(8);
    this._asyncKeyState = new Uint32Array(8);
    this._asyncWheelX = 0;
    this._asyncWheelY = 0;
    this._asyncWheelZ = 0;

    this._handleKeyUp = e => {
      keyCode = this._keyCode(e.code);
      keyMask = 1 << keyCode % 32;
      keyElement = Math.floor(keyCode / 32);
      this._asyncKeyUp[keyElement] |= keyMask;
      this._asyncKeyState[keyElement] &= ~keyMask;
    };

    this._handleKeyDown = e => {
      if (e.repeat) {
        return;
      }

      keyCode = this._keyCode(e.code);
      keyMask = 1 << keyCode % 32;
      keyElement = Math.floor(keyCode / 32);
      this._asyncKeyDown[keyElement] |= keyMask;
      this._asyncKeyState[keyElement] |= keyMask;
    };

    this._handleContextMenu = e => {
      e.preventDefault();
    };

    this._handleWheel = e => {
      this._asyncWheelX += e.deltaX;
      this._asyncWheelY += e.deltaY;
      this._asyncWheelZ += e.deltaZ;
    };

    this._handlePointerMove = e => {
      const rect = e.target.getBoundingClientRect();

      const pointer = this._getPointer(e.pointerId);

      pointer.type = e.pointerType;
      pointer.delete = false;
      pointer.asyncX = e.clientX - rect.left;
      pointer.asyncY = e.clientY - rect.top;
      pointer.asyncUp |= ~e.buttons & pointer.asyncState;
      pointer.asyncDown |= e.buttons & ~pointer.asyncState;
      pointer.asyncState = e.buttons;
      e.preventDefault();
    };

    this._handlePointerUp = e => {
      const rect = e.target.getBoundingClientRect();

      const pointer = this._getPointer(e.pointerId);

      pointer.type = e.pointerType;
      pointer.delete = false;
      pointer.asyncX = e.clientX - rect.left;
      pointer.asyncY = e.clientY - rect.top;
      pointer.asyncUp |= e.buttons ^ pointer.asyncState;
      pointer.asyncState = e.buttons;
      e.preventDefault();
    };

    this._handlePointerDown = e => {
      const rect = e.target.getBoundingClientRect();

      const pointer = this._getPointer(e.pointerId);

      pointer.type = e.pointerType;
      pointer.delete = false;
      pointer.asyncX = e.clientX - rect.left;
      pointer.asyncY = e.clientY - rect.top;
      pointer.asyncDown |= e.buttons ^ pointer.asyncState;
      pointer.asyncState = e.buttons;
      e.preventDefault();

      this._canvas.focus();
    };

    this._handlePointerCreate = e => {
      const rect = e.target.getBoundingClientRect();

      const pointer = this._getPointer(e.pointerId);

      pointer.type = e.pointerType;
      pointer.delete = false;
      pointer.asyncX = e.clientX - rect.left;
      pointer.asyncY = e.clientY - rect.top;
      pointer.x = pointer.asyncX;
      pointer.y = pointer.asyncY;
      e.preventDefault();

      this._canvas.focus();
    };

    this._handlePointerDelete = e => {
      const pointer = this._getPointer(e.pointerId);

      pointer.delete = true;
      e.preventDefault();
    };

    core.regSystemEvent('onLoopEnd', this);
    core.regSystemEvent('onLoopStart', this);
    core.regSystemEvent('onFrameEnd', this, -1000);
    core.regSystemEvent('onFrameStart', this, -1000);
    core.renderer.canvas.setAttribute('tabindex', '1');
    core.renderer.canvas.style.touchAction = 'none';
    this._canvas = core.renderer.canvas;
  }

  onLoopEnd(core) {
    const canvas = core.renderer.canvas;
    canvas.removeEventListener('keyup', this._handleKeyUp);
    canvas.removeEventListener('keydown', this._handleKeyDown);
    canvas.removeEventListener('contextmenu', this._handleContextMenu);
    canvas.removeEventListener('wheel', this._handleWheel);
    canvas.removeEventListener('pointerup', this._handlePointerUp);
    canvas.removeEventListener('pointerdown', this._handlePointerDown);
    canvas.removeEventListener('pointermove', this._handlePointerMove);
    canvas.removeEventListener('pointerover', this._handlePointerCreate);
    canvas.removeEventListener('pointerout', this._handlePointerDelete);
  }

  onLoopStart(core) {
    const canvas = core.renderer.canvas;
    canvas.addEventListener('keyup', this._handleKeyUp);
    canvas.addEventListener('keydown', this._handleKeyDown);
    canvas.addEventListener('contextmenu', this._handleContextMenu);
    canvas.addEventListener('wheel', this._handleWheel);
    canvas.addEventListener('pointerup', this._handlePointerUp, {
      passive: false
    });
    canvas.addEventListener('pointerdown', this._handlePointerDown, {
      passive: false
    });
    canvas.addEventListener('pointermove', this._handlePointerMove, {
      passive: false
    });
    canvas.addEventListener('pointerover', this._handlePointerCreate, {
      passive: false
    });
    canvas.addEventListener('pointerout', this._handlePointerDelete, {
      passive: false
    });
  }

  onFrameEnd() {
    this.pointers = this.pointers.filter(p => !p.delete);
    this.pointers.sort(Pointer.sort);
  }

  onFrameStart() {
    for (let it = 0; it < 8; it++) {
      this._keyUp[it] = this._asyncKeyUp[it];
      this._keyDown[it] = this._asyncKeyDown[it];
      this._keyState[it] = this._asyncKeyState[it];
      this._asyncKeyUp[it] = 0;
      this._asyncKeyDown[it] = 0;
    }

    this.wheelX = this._asyncWheelX;
    this.wheelY = this._asyncWheelY;
    this.wheelZ = this._asyncWheelZ;
    this._asyncWheelX = 0;
    this._asyncWheelY = 0;
    this._asyncWheelZ = 0;

    for (const pointer of this.pointers) {
      pointer.update();
    }
  }

  keyUp(key) {
    return !!(this._keyUp[Math.floor(key / 32)] >> key % 32 & 0x1);
  }

  keyDown(key) {
    return !!(this._keyDown[Math.floor(key / 32)] >> key % 32 & 0x1);
  }

  keyState(key) {
    return !!(this._keyState[Math.floor(key / 32)] >> key % 32 & 0x1);
  }

  _keyCode(code) {
    switch (code) {
      case 'Backspace':
        return 8;

      case 'Tab':
        return 9;

      case 'Escape':
        return 27;

      case 'Space':
        return 32;

      case 'PageUp':
        return 33;

      case 'PageDown':
        return 34;

      case 'End':
        return 35;

      case 'Home':
        return 36;

      case 'ArrowLeft':
        return 37;

      case 'ArrowUp':
        return 38;

      case 'ArrowRight':
        return 39;

      case 'ArrowDown':
        return 40;

      case 'Digit0':
        return 48;

      case 'Digit1':
        return 49;

      case 'Digit2':
        return 50;

      case 'Digit3':
        return 51;

      case 'Digit4':
        return 52;

      case 'Digit5':
        return 53;

      case 'Digit6':
        return 54;

      case 'Digit7':
        return 55;

      case 'Digit8':
        return 56;

      case 'Digit9':
        return 57;

      case 'KeyA':
        return 65;

      case 'KeyB':
        return 66;

      case 'KeyC':
        return 67;

      case 'KeyD':
        return 68;

      case 'KeyE':
        return 69;

      case 'KeyF':
        return 70;

      case 'KeyG':
        return 71;

      case 'KeyH':
        return 72;

      case 'KeyI':
        return 73;

      case 'KeyJ':
        return 74;

      case 'KeyK':
        return 75;

      case 'KeyL':
        return 76;

      case 'KeyM':
        return 77;

      case 'KeyN':
        return 78;

      case 'KeyO':
        return 79;

      case 'KeyP':
        return 80;

      case 'KeyQ':
        return 81;

      case 'KeyR':
        return 82;

      case 'KeyS':
        return 83;

      case 'KeyT':
        return 84;

      case 'KeyU':
        return 85;

      case 'KeyV':
        return 86;

      case 'KeyW':
        return 87;

      case 'KeyX':
        return 88;

      case 'KeyY':
        return 89;

      case 'KeyZ':
        return 90;

      case 'Numpad0':
        return 96;

      case 'Numpad1':
        return 97;

      case 'Numpad2':
        return 98;

      case 'Numpad3':
        return 99;

      case 'Numpad4':
        return 100;

      case 'Numpad5':
        return 101;

      case 'Numpad6':
        return 102;

      case 'Numpad7':
        return 103;

      case 'Numpad8':
        return 104;

      case 'Numpad9':
        return 105;

      default:
        return 0;
    }
  }

  _getPointer(id) {
    let pointer;

    for (pointer of this.pointers) {
      if (pointer.id === id) {
        return pointer;
      }
    }

    pointer = new Pointer();
    pointer.id = id;
    this.pointers.push(pointer);
    this.pointers.sort(Pointer.sort);
    return pointer;
  }

}
input_system_InputSystem.ID = 'input';
input_system_InputSystem.VK_BACK = 8;
input_system_InputSystem.VK_TAB = 9;
input_system_InputSystem.VK_ESCAPE = 27;
input_system_InputSystem.VK_SPACE = 32;
input_system_InputSystem.VK_PAGEUP = 33;
input_system_InputSystem.VK_PAGEDOWN = 34;
input_system_InputSystem.VK_END = 35;
input_system_InputSystem.VK_HOME = 36;
input_system_InputSystem.VK_LEFT = 37;
input_system_InputSystem.VK_UP = 38;
input_system_InputSystem.VK_RIGHT = 39;
input_system_InputSystem.VK_DOWN = 40;
input_system_InputSystem.VK_0 = 48;
input_system_InputSystem.VK_1 = 49;
input_system_InputSystem.VK_2 = 50;
input_system_InputSystem.VK_3 = 51;
input_system_InputSystem.VK_4 = 52;
input_system_InputSystem.VK_5 = 53;
input_system_InputSystem.VK_6 = 54;
input_system_InputSystem.VK_7 = 55;
input_system_InputSystem.VK_8 = 56;
input_system_InputSystem.VK_9 = 57;
input_system_InputSystem.VK_A = 65;
input_system_InputSystem.VK_B = 66;
input_system_InputSystem.VK_C = 67;
input_system_InputSystem.VK_D = 68;
input_system_InputSystem.VK_E = 69;
input_system_InputSystem.VK_F = 70;
input_system_InputSystem.VK_G = 71;
input_system_InputSystem.VK_H = 72;
input_system_InputSystem.VK_I = 73;
input_system_InputSystem.VK_J = 74;
input_system_InputSystem.VK_K = 75;
input_system_InputSystem.VK_L = 76;
input_system_InputSystem.VK_M = 77;
input_system_InputSystem.VK_N = 78;
input_system_InputSystem.VK_O = 79;
input_system_InputSystem.VK_P = 80;
input_system_InputSystem.VK_Q = 81;
input_system_InputSystem.VK_R = 82;
input_system_InputSystem.VK_S = 83;
input_system_InputSystem.VK_T = 84;
input_system_InputSystem.VK_U = 85;
input_system_InputSystem.VK_V = 86;
input_system_InputSystem.VK_W = 87;
input_system_InputSystem.VK_X = 88;
input_system_InputSystem.VK_Y = 89;
input_system_InputSystem.VK_Z = 90;
input_system_InputSystem.VK_N0 = 96;
input_system_InputSystem.VK_N1 = 97;
input_system_InputSystem.VK_N2 = 98;
input_system_InputSystem.VK_N3 = 99;
input_system_InputSystem.VK_N4 = 100;
input_system_InputSystem.VK_N5 = 101;
input_system_InputSystem.VK_N6 = 102;
input_system_InputSystem.VK_N7 = 103;
input_system_InputSystem.VK_N8 = 104;
input_system_InputSystem.VK_N9 = 105;
input_system_InputSystem.VK_F1 = 112;
input_system_InputSystem.VK_F2 = 113;
input_system_InputSystem.VK_F3 = 114;
input_system_InputSystem.VK_F4 = 115;
input_system_InputSystem.VK_F5 = 116;
input_system_InputSystem.VK_F6 = 117;
input_system_InputSystem.VK_F7 = 118;
input_system_InputSystem.VK_F8 = 119;
input_system_InputSystem.VK_F9 = 120;
input_system_InputSystem.VK_F10 = 121;
input_system_InputSystem.VK_F11 = 122;
input_system_InputSystem.VK_F12 = 123;
input_system_InputSystem.VK_F13 = 124;
input_system_InputSystem.VK_F14 = 125;
input_system_InputSystem.VK_F15 = 126;
input_system_InputSystem.VK_F16 = 127;
input_system_InputSystem.VK_F17 = 128;
input_system_InputSystem.VK_F18 = 129;
input_system_InputSystem.VK_F19 = 130;
input_system_InputSystem.VK_F20 = 131;
input_system_InputSystem.VK_F21 = 132;
input_system_InputSystem.VK_F22 = 133;
input_system_InputSystem.VK_F23 = 134;
input_system_InputSystem.VK_F24 = 135;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/light-system/index.js
function light_system_slicedToArray(arr, i) { return light_system_arrayWithHoles(arr) || light_system_iterableToArrayLimit(arr, i) || light_system_unsupportedIterableToArray(arr, i) || light_system_nonIterableRest(); }

function light_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function light_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return light_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return light_system_arrayLikeToArray(o, minLen); }

function light_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function light_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function light_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








const identityMatrix = new lib["b" /* AffineMatrix3 */]().fromNumber(1.0);
const lightComponentClasses = [light_Light];
const lateUpdateComponentClasses = [transform_component_Transform, light_shadow_caster_LightShadowCaster];
const zeroTranslation = new lib["n" /* Vector3 */](0, 0, 0);
const frustumNearCorner = new lib["n" /* Vector3 */]();
const frustumFarCorner = new lib["n" /* Vector3 */]();
const multipliers = [new lib["n" /* Vector3 */](+1, +1, -1), new lib["n" /* Vector3 */](-1, +1, -1), new lib["n" /* Vector3 */](-1, -1, -1), new lib["n" /* Vector3 */](+1, -1, -1)];
const tempMatrix = new lib["b" /* AffineMatrix3 */]();
const tempVector = new lib["n" /* Vector3 */]();
const perCubeFaceMatrices = [new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](+1, 0, 0), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](-1, 0, 0), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, -1, 0), new lib["n" /* Vector3 */](0, 0, -1)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, +1, 0), new lib["n" /* Vector3 */](0, 0, +1)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, 0, +1), new lib["n" /* Vector3 */](0, -1, 0)), new lib["b" /* AffineMatrix3 */]().fromLookDirection(new lib["n" /* Vector3 */](0, 0, -1), new lib["n" /* Vector3 */](0, -1, 0))];
const positiveInf = new lib["n" /* Vector3 */]().fromNumber(+Infinity);
const negativeInf = new lib["n" /* Vector3 */]().fromNumber(-Infinity);
const zInverter = new lib["n" /* Vector3 */](1, 1, -1);
const bbox = new lib["e" /* Box */]();
class light_system_LightSystem extends System {
  constructor(core) {
    super();
    this._shadowMapSize = 2048;
    this._shadowMapSizeChanged = true;
    this._cascadesCount = 4;
    this._cascadesCountChanged = true;
    this.splitLambda = 0.64;
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    this._webgl2Support = core.renderer.capabilities.webgl2Support;
    EntityManager.onAttach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      if (index === light_shadow_caster_LightShadowCaster.index) {
        this._onAddLightShadowCaster(entityManager, entity, component);

        const storage = entityManager.getComponentStorage(mesh_component_Mesh);

        for (const mesh of storage.components()) {
          for (const subMesh of mesh.subMeshes()) {
            if (subMesh.material.lit) {
              subMesh.material.needsUpdate = true;
            }
          }
        }
      }
    });
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;
      const storage = entityManager.getComponentStorage(mesh_component_Mesh);

      switch (index) {
        case light_shadow_caster_LightShadowCaster.index:
          this._onDeleteShadowCaster(entityManager, entity, component);

          for (const mesh of storage.components()) {
            for (const subMesh of mesh.subMeshes()) {
              if (subMesh.material.lit) {
                subMesh.material.needsUpdate = true;
              }
            }
          }

          break;

        case light_Light.index:
          if (false) {}

          break;

        default:
      }
    });
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          look = _core$currentRequest.look;
    const entityManager = scene.entityManager;
    scene._shadowMapSize = this._shadowMapSize;
    scene._cascadesCount = this._cascadesCount;

    if (!entityManager.isComponent(light_Light) || !entityManager.isComponent(light_shadow_caster_LightShadowCaster)) {
      return;
    }

    const storage = entityManager.getComponentStorage(light_Light);
    let maxIlluminance = -1;

    for (const light of storage.components()) {
      const needsUpdate = light.needsUpdate;

      if (needsUpdate) {
        computeLightProperties(light);
        light.makeUpdated();
      }

      maxIlluminance = Math.max(maxIlluminance, light._illuminance);
    }

    scene._maxIlluminance = Math.max(scene._maxEnvIlluminance, maxIlluminance);
    const _perLookData = scene._perLookData;

    if (_perLookData.has(look)) {
      _perLookData.get(look).cameraDataNeedsUpdate = true;
    }
  }

  onLateUpdate(core) {
    const _core$currentRequest2 = core.currentRequest,
          scene = _core$currentRequest2.scene,
          look = _core$currentRequest2.look;
    const entityManager = scene.entityManager;
    const viewMatrix = look.viewMatrix;

    if (!entityManager.isComponent(light_Light) || !entityManager.isComponent(light_shadow_caster_LightShadowCaster)) {
      return;
    }

    this._preUpdateShadowCasters(scene, entityManager, look);

    const storage = entityManager.getComponentStorage(light_Light);

    for (const _ref of storage.entries()) {
      var _ref2 = light_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const light = _ref2[1];

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, lateUpdateComponentClasses),
            _entityManager$getEnt2 = light_system_slicedToArray(_entityManager$getEnt, 2),
            transform = _entityManager$getEnt2[0],
            lightShadowCaster = _entityManager$getEnt2[1];

      const worldMatrix = transform !== null ? transform.worldMatrix : identityMatrix;
      updateLightPositionAndDirection(light, worldMatrix, viewMatrix);

      this._updateShadowCaster(core.currentRequest, light, worldMatrix, lightShadowCaster);
    }

    this._shadowMapSizeChanged = false;
    this._cascadesCountChanged = false;
    scene._directShadowCastersCountChanged = false;
  }

  get cascadesCount() {
    return this._cascadesCount;
  }

  set cascadesCount(value) {
    this._cascadesCount = value;
    this._cascadesCountChanged = true;
  }

  get shadowMapSize() {
    return this._shadowMapSize;
  }

  set shadowMapSize(value) {
    this._shadowMapSize = value;
    this._shadowMapSizeChanged = true;
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _hasLight(entityManager, entity) {
    const _entityManager$getEnt3 = entityManager.getEntityComponents(entity, lightComponentClasses),
          _entityManager$getEnt4 = light_system_slicedToArray(_entityManager$getEnt3, 1),
          light = _entityManager$getEnt4[0];

    return light !== null;
  }

  _initializeSpotShadowCasterData(light, shadowCaster) {
    const name = shadowCaster.name;
    const camera = new camera_component_Camera({
      name: `spot-shadow-camera-${name}`,
      znear: 0.1,
      zfar: 100,
      perspectiveProjection: {
        aspect: 1.0,
        yfov: light.outerCone * 2
      }
    });
    camera.projectionType = camera_component_Camera.ProjectionTypes.PERSPECTIVE;
    camera.needsUpdateProjection = true;
    shadowCaster._spotShadowCasterData = {
      renderTarget: null,
      depthTexture: null,
      depthBuffer: null,
      camera
    };
  }

  _initializeOmniShadowCasterData(shadowCaster) {
    const name = shadowCaster.name;
    const cubeCamera = new cube_camera_component_CubeCamera({
      name: `omni-shadow-cube-camera-${name}`,
      znear: 0.1,
      zfar: 100
    });
    cubeCamera.needsUpdateProjection = true;
    shadowCaster._omniShadowCasterData = {
      depthTexture: null,
      depthBuffers: [],
      renderTarget: null,
      renderTargets: [],
      cubeCamera,
      invertedWorldMatrix: new lib["g" /* HomogeneousMatrix3 */]()
    };
  }

  _onAddLightShadowCaster(entityManager, entity, shadowCaster) {
    const _entityManager$getEnt5 = entityManager.getEntityComponents(entity, lightComponentClasses),
          _entityManager$getEnt6 = light_system_slicedToArray(_entityManager$getEnt5, 1),
          light = _entityManager$getEnt6[0];

    if (light.isDirectionalLight) {
      shadowCaster._cascades = [];
    } else if (light.isSpotLight) {
      this._initializeSpotShadowCasterData(light, shadowCaster);
    } else if (light.isPointLight) {
      this._initializeOmniShadowCasterData(shadowCaster);
    }
  }

  _onDeleteShadowCaster(entityManager, entity, shadowCaster) {
    const _entityManager$getEnt7 = entityManager.getEntityComponents(entity, lightComponentClasses),
          _entityManager$getEnt8 = light_system_slicedToArray(_entityManager$getEnt7, 1),
          light = _entityManager$getEnt8[0];

    if (light.isDirectionalLight) {
      for (const cascade of shadowCaster._cascades) {
        if (cascade.renderTarget) {
          cascade.renderTarget.release();
          cascade.renderTarget = null;
        }

        if (cascade.texture) {
          cascade.texture.release();
          cascade.texture = null;
        }

        if (cascade.depthTexture) {
          cascade.depthTexture.release();
          cascade.depthTexture = null;
        }
      }
    } else if (light.isSpotLight) {
      const _spotShadowCasterData = shadowCaster._spotShadowCasterData;

      if (_spotShadowCasterData.renderTarget) {
        _spotShadowCasterData.renderTarget.release();

        _spotShadowCasterData.renderTarget = null;
      }

      if (_spotShadowCasterData.depthTexture) {
        _spotShadowCasterData.depthTexture.release();

        _spotShadowCasterData.depthTexture = null;
      }

      if (_spotShadowCasterData.depthBuffer) {
        _spotShadowCasterData.depthBuffer.release();

        _spotShadowCasterData.depthBuffer = null;
      }
    } else if (light.isPointLight) {
      const _omniShadowCasterData = shadowCaster._omniShadowCasterData;

      if (_omniShadowCasterData.renderTarget) {
        _omniShadowCasterData.renderTarget.release();

        _omniShadowCasterData.renderTarget = null;
      }

      for (let renderTarget of _omniShadowCasterData.renderTargets) {
        renderTarget.release();
        renderTarget = null;
      }

      _omniShadowCasterData.renderTargets.length = 0;

      if (_omniShadowCasterData.depthTexture) {
        _omniShadowCasterData.depthTexture.release();

        _omniShadowCasterData.depthTexture = null;
      }

      for (let depthBuffer of _omniShadowCasterData.depthBuffers) {
        depthBuffer.release();
        depthBuffer = null;
      }

      _omniShadowCasterData.depthBuffers.length = 0;
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = light_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([light_Light]),
            _srcNode$getComponent2 = light_system_slicedToArray(_srcNode$getComponent, 1),
            srcLight = _srcNode$getComponent2[0];

      if (srcLight === null) {
        continue;
      }

      const dstLight = srcLight.clone();
      dstNode.attach(dstLight);
    }
  }

  _preUpdateShadowCasters(scene, entityManager, look) {
    const _directShadowCastersMask = scene._directShadowCastersMask,
          spotCastersDepthTextureArray = scene.spotCastersDepthTextureArray;
    const _spotShadowCasters = scene._spotShadowCasters,
          _spotShadowCastersMask = scene._spotShadowCastersMask;
    const _omniShadowCasters = scene._omniShadowCasters,
          _omniShadowCastersMask = scene._omniShadowCastersMask;
    _directShadowCastersMask.length = 0;
    _spotShadowCasters.length = 0;
    _spotShadowCastersMask.length = 0;
    _omniShadowCasters.length = 0;
    _omniShadowCastersMask.length = 0;
    {
      const _this$_countEnabledSh = this._countEnabledShadowCasters(entityManager),
            enabledDirectShadowCastersCount = _this$_countEnabledSh.enabledDirectShadowCastersCount,
            enabledSpotShadowCastersCount = _this$_countEnabledSh.enabledSpotShadowCastersCount,
            enabledOmniShadowCastersCount = _this$_countEnabledSh.enabledOmniShadowCastersCount;

      scene._directShadowCastersCountChanged = scene._enabledDirectShadowCastersCount !== enabledDirectShadowCastersCount;
      scene._enabledDirectShadowCastersCount = enabledDirectShadowCastersCount;
      scene._enabledSpotShadowCastersCount = enabledSpotShadowCastersCount;
      scene._enabledOmniShadowCastersCount = enabledOmniShadowCastersCount;
    }
    const _enabledDirectShadowCastersCount = scene._enabledDirectShadowCastersCount,
          _perLookData = scene._perLookData;

    if (_enabledDirectShadowCastersCount > 0) {
      const has = _perLookData.has(look);

      if (!has) {
        _perLookData.set(look, {
          cameraDataNeedsUpdate: true,
          directShadowCasters: [],
          frustumSplits: [],
          cascadesPlanes: []
        });
      }
    } else {
      _perLookData.delete(look);
    }

    const perCameraData = _perLookData.get(look);

    if (perCameraData) {
      if (this._webgl2Support) {
        const _cascadesCountChanged = this._cascadesCountChanged,
              _shadowMapSizeChanged = this._shadowMapSizeChanged;
        const _directShadowCastersCountChanged = scene._directShadowCastersCountChanged;

        if (_directShadowCastersCountChanged || _cascadesCountChanged || _shadowMapSizeChanged) {
          this._disposeResources(scene);

          this._updateDepthTextureArray(scene);
        }
      }

      if (perCameraData.cameraDataNeedsUpdate) {
        this._calculateFrustumSplits(look, perCameraData);

        this._calculateCameraAABBs(look, perCameraData);

        perCameraData.cameraDataNeedsUpdate = false;
      }

      perCameraData.directShadowCasters.length = 0;
    }

    const _shadowMapSizeChanged = this._shadowMapSizeChanged;

    if (this._webgl2Support && (_shadowMapSizeChanged || spotCastersDepthTextureArray === null && scene._enabledSpotShadowCastersCount !== 0)) {
      this._updateSpotShadowCasterAttachments(scene);
    }
  }

  _updateShadowCaster(renderRequest, light, worldMatrix, shadowCaster) {
    const scene = renderRequest.scene;
    const _enabledDirectShadowCastersCount = scene._enabledDirectShadowCastersCount,
          _enabledSpotShadowCastersCount = scene._enabledSpotShadowCastersCount,
          _enabledOmniShadowCastersCount = scene._enabledOmniShadowCastersCount;
    const _directShadowCastersMask = scene._directShadowCastersMask,
          _spotShadowCastersMask = scene._spotShadowCastersMask,
          _omniShadowCastersMask = scene._omniShadowCastersMask;

    if (_enabledDirectShadowCastersCount === 0 && _enabledOmniShadowCastersCount === 0 && _enabledSpotShadowCastersCount === 0) {
      return;
    }

    if (light.isDirectionalLight) {
      if (shadowCaster !== null) {
        this._updateDirectShadowCaster(renderRequest, light, worldMatrix, shadowCaster);
      } else {
        _directShadowCastersMask.push(-1);
      }
    } else if (light.isSpotLight) {
      if (shadowCaster !== null) {
        this._updateSpotShadowCaster(renderRequest, light, worldMatrix, shadowCaster);
      } else {
        _spotShadowCastersMask.push(-1);
      }
    } else if (light.isPointLight) {
      if (shadowCaster !== null) {
        this._updateOmniShadowCaster(renderRequest, light, worldMatrix, shadowCaster);
      } else {
        _omniShadowCastersMask.push(-1);
      }
    }
  }

  _updateDirectShadowCaster(renderRequest, light, worldMatrix, shadowCaster) {
    const cascadesCount = this.cascadesCount;
    const scene = renderRequest.scene;

    if (renderRequest.look.isCamera && shadowCaster.castShadow) {
      const perLookData = scene._perLookData.get(renderRequest.look);

      const cascadesPlanes = perLookData.cascadesPlanes,
            directShadowCasters = perLookData.directShadowCasters;
      const directShadowCastersIndex = directShadowCasters.length;
      shadowCaster._casterIndex = directShadowCastersIndex;
      const _directShadowCastersMask = scene._directShadowCastersMask,
            _directShadowCastersCountChanged = scene._directShadowCastersCountChanged;
      const _cascadesCountChanged = this._cascadesCountChanged,
            _shadowMapSizeChanged = this._shadowMapSizeChanged;

      if (_directShadowCastersCountChanged || _cascadesCountChanged || _shadowMapSizeChanged) {
        shadowCaster._cascades = new Array(cascadesCount).fill(0).map(() => ({}));

        if (!this._webgl2Support) {
          this._updateDepthTextures(shadowCaster, light.name);
        }

        this._updateRenderTargets(scene, shadowCaster);

        this._createCascadeCameras(shadowCaster, light.name);
      }

      const _cascades = shadowCaster._cascades;

      for (const _ref5 of _cascades.entries()) {
        var _ref6 = light_system_slicedToArray(_ref5, 2);

        const i = _ref6[0];
        const camera = _ref6[1].camera;
        camera.worldMatrix.copy(worldMatrix);
        camera.worldMatrix.translationCopy(zeroTranslation);
        camera.viewMatrix.copy(camera.worldMatrix).invert();

        this._calculateCascadeCameraProjection(camera, cascadesPlanes[i]);
      }

      directShadowCasters.push({
        light,
        _cascades
      });

      _directShadowCastersMask.push(directShadowCastersIndex);
    } else {
      const _directShadowCastersMask = scene._directShadowCastersMask;

      _directShadowCastersMask.push(-1);
    }
  }

  _updateDepthTextures(shadowCaster, name) {
    const shadowMapSize = this.shadowMapSize;
    const _cascades = shadowCaster._cascades;

    for (const _ref7 of _cascades.entries()) {
      var _ref8 = light_system_slicedToArray(_ref7, 2);

      const i = _ref8[0];
      const cascade = _ref8[1];
      cascade.texture = new texture_resource_Texture({
        name: `shadow-map-${name}-cascade${i}`,
        width: shadowMapSize,
        height: shadowMapSize,
        bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D,
        magFilter: texture_resource_Texture.Filter.NEAREST,
        minFilter: texture_resource_Texture.Filter.NEAREST,
        wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        format: PixelDataFormat.RGBA,
        internalFormat: InternalFormat.RGBA,
        componentType: dataTypes_DataType.UNSIGNED_BYTE,
        levels: 1
      });
      cascade.depthTexture = new texture_resource_Texture({
        name: `shadow-map-${name}-cascade${i}`,
        width: shadowMapSize,
        height: shadowMapSize,
        bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D,
        magFilter: texture_resource_Texture.Filter.NEAREST,
        minFilter: texture_resource_Texture.Filter.NEAREST,
        wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        format: PixelDataFormat.DEPTH_COMPONENT,
        internalFormat: InternalFormat.DEPTH_COMPONENT,
        componentType: dataTypes_DataType.UNSIGNED_INT,
        levels: 1
      });
    }
  }

  _updateDepthTextureArray(scene) {
    const cascadesCount = this.cascadesCount,
          shadowMapSize = this.shadowMapSize;

    scene._updateDepthTextureArray(cascadesCount, shadowMapSize);
  }

  _updateRenderTargets(scene, shadowCaster) {
    const cascadesCount = this.cascadesCount;
    const _cascades = shadowCaster._cascades,
          _casterIndex = shadowCaster._casterIndex;

    if (this._webgl2Support) {
      const _shadowTextureArray = scene._shadowTextureArray;
      const width = _shadowTextureArray.width,
            height = _shadowTextureArray.height;

      for (const _ref9 of _cascades.entries()) {
        var _ref10 = light_system_slicedToArray(_ref9, 2);

        const cascadeIndex = _ref10[0];
        const cascade = _ref10[1];
        const offsetIndex = _casterIndex * cascadesCount + cascadeIndex;
        cascade.renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({
          width,
          height
        });
        cascade.renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, _shadowTextureArray, texture_resource_Texture.BindingPoint.TEXTURE_2D, offsetIndex);
      }
    } else {
      for (const cascade of _cascades) {
        const texture = cascade.texture,
              depthTexture = cascade.depthTexture;
        const width = texture.width,
              height = texture.height;
        cascade.renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({
          width,
          height
        });
        cascade.renderTarget.setColorAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0, texture);
        cascade.renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthTexture, texture_resource_Texture.BindingPoint.TEXTURE_2D);
      }
    }
  }

  _calculateFrustumSplits(look, perCameraData) {
    const cascadesCount = this.cascadesCount,
          _this$splitLambda = this.splitLambda,
          splitLambda = _this$splitLambda === void 0 ? 0.47 : _this$splitLambda;
    const znear = look.znear,
          zfar = look.zfar;
    const frustumSplits = perCameraData.frustumSplits;
    frustumSplits.length = 0;
    const clipRange = zfar - znear;
    const minZ = znear;
    const maxZ = znear + clipRange;
    const range = maxZ - minZ;
    const ratio = maxZ / minZ;

    for (let i = 0; i < cascadesCount; ++i) {
      const p = (i + 1) / cascadesCount;
      const log = minZ * Math.pow(ratio, p);
      const uniform = minZ + range * p;
      const d = splitLambda * (log - uniform) + uniform;
      frustumSplits.push((d - znear) / clipRange);
    }
  }

  _updateSpotShadowCaster(renderRequest, light, worldMatrix, shadowCaster) {
    const scene = renderRequest.scene;
    const _spotShadowCastersMask = scene._spotShadowCastersMask,
          spotCastersDepthTextureArray = scene.spotCastersDepthTextureArray;

    if (shadowCaster.castShadow) {
      const _shadowMapSizeChanged = this._shadowMapSizeChanged;
      const _spotShadowCasters = scene._spotShadowCasters;
      shadowCaster._casterIndex = _spotShadowCasters.length;

      if (_shadowMapSizeChanged || spotCastersDepthTextureArray === null) {
        if (!this._webgl2Support) {
          this._updateSpotShadowCasterAttachments(scene, shadowCaster);
        }

        this._updateSpotShadowCasterRenderTarget(scene, shadowCaster);
      } else if (shadowCaster._spotShadowCasterData.renderTarget === null) {
        this._updateSpotShadowCasterRenderTarget(scene, shadowCaster);
      }

      this._updateSpotShadowCasterCamera(shadowCaster, worldMatrix);

      shadowCaster._casterIndex = _spotShadowCasters.length;

      _spotShadowCasters.push({
        light,
        shadowCaster
      });

      _spotShadowCastersMask.push(shadowCaster._casterIndex);
    } else {
      _spotShadowCastersMask.push(-1);
    }
  }

  _updateSpotShadowCasterAttachments(scene, shadowCaster) {
    const shadowMapSize = this.shadowMapSize;

    if (this._webgl2Support) {
      scene._updateSpotCastersDepthTextureArray(shadowMapSize);
    } else {
      const name = shadowCaster.name,
            _spotShadowCasterData = shadowCaster._spotShadowCasterData;

      if (_spotShadowCasterData.depthTexture) {
        _spotShadowCasterData.depthTexture.release();

        _spotShadowCasterData.depthTexture = null;
      }

      if (_spotShadowCasterData.depthBuffer) {
        _spotShadowCasterData.depthBuffer.release();

        _spotShadowCasterData.depthBuffer = null;
      }

      const depthTexture = new texture_resource_Texture({
        name: `spot-shadow-map-${name}`,
        width: shadowMapSize,
        height: shadowMapSize,
        bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_2D,
        magFilter: texture_resource_Texture.Filter.NEAREST,
        minFilter: texture_resource_Texture.Filter.NEAREST,
        wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
        format: PixelDataFormat.RGBA,
        internalFormat: InternalFormat.RGBA,
        componentType: dataTypes_DataType.UNSIGNED_BYTE,
        levels: 1
      });
      const depthBuffer = new renderBuffer_RenderBuffer({
        width: shadowMapSize,
        height: shadowMapSize,
        internalFormat: InternalFormat.DEPTH_COMPONENT16
      });
      _spotShadowCasterData.depthTexture = depthTexture;
      _spotShadowCasterData.depthBuffer = depthBuffer;
    }
  }

  _updateSpotShadowCasterRenderTarget(scene, shadowCaster) {
    const shadowMapSize = this.shadowMapSize;
    const _casterIndex = shadowCaster._casterIndex,
          _spotShadowCasterData = shadowCaster._spotShadowCasterData;

    if (_spotShadowCasterData.renderTarget) {
      _spotShadowCasterData.renderTarget.release();

      _spotShadowCasterData.renderTarget = null;
    }

    const renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({
      width: shadowMapSize,
      height: shadowMapSize
    });

    if (this._webgl2Support) {
      const spotCastersDepthTextureArray = scene.spotCastersDepthTextureArray;
      renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, spotCastersDepthTextureArray, texture_resource_Texture.BindingPoint.TEXTURE_2D, _casterIndex);
    } else {
      const depthTexture = _spotShadowCasterData.depthTexture,
            depthBuffer = _spotShadowCasterData.depthBuffer;
      renderTarget.setColorAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0, depthTexture);
      renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthBuffer);
    }

    _spotShadowCasterData.renderTarget = renderTarget;
  }

  _updateOmniShadowCaster(renderRequest, light, worldMatrix, shadowCaster) {
    const scene = renderRequest.scene;

    if (shadowCaster.castShadow) {
      const _shadowMapSizeChanged = this._shadowMapSizeChanged;
      const _omniShadowCasters = scene._omniShadowCasters,
            _omniShadowCastersMask = scene._omniShadowCastersMask;
      const _omniShadowCasterData = shadowCaster._omniShadowCasterData;
      const depthTexture = _omniShadowCasterData.depthTexture;

      if (_shadowMapSizeChanged || depthTexture === null) {
        this._updateOmniShadowCasterAttachments(shadowCaster);

        this._updateOmniShadowCasterRenderTarget(shadowCaster);
      }

      this._updateOmniShadowCasterCamera(shadowCaster, worldMatrix);

      shadowCaster._casterIndex = _omniShadowCasters.length;

      _omniShadowCasters.push({
        light,
        shadowCaster
      });

      _omniShadowCastersMask.push(shadowCaster._casterIndex);
    } else {
      const _omniShadowCastersMask = scene._omniShadowCastersMask;

      _omniShadowCastersMask.push(-1);
    }
  }

  _updateOmniShadowCasterAttachments(shadowCaster) {
    const shadowMapSize = this.shadowMapSize;
    const name = shadowCaster.name,
          _omniShadowCasterData = shadowCaster._omniShadowCasterData;
    const depthBuffers = _omniShadowCasterData.depthBuffers;

    if (_omniShadowCasterData.depthTexture) {
      _omniShadowCasterData.depthTexture.release();

      _omniShadowCasterData.depthTexture = null;
    }

    _omniShadowCasterData.depthTexture = new texture_resource_Texture({
      name: `omni-shadow-depth-cube-map-${name}`,
      width: shadowMapSize,
      height: shadowMapSize,
      bindingPoint: texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP,
      magFilter: this._webgl2Support ? texture_resource_Texture.Filter.LINEAR : texture_resource_Texture.Filter.NEAREST,
      minFilter: this._webgl2Support ? texture_resource_Texture.Filter.LINEAR : texture_resource_Texture.Filter.NEAREST,
      wrapS: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      wrapT: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      wrapR: texture_resource_Texture.WrappingMode.CLAMP_TO_EDGE,
      format: this._webgl2Support ? PixelDataFormat.DEPTH_COMPONENT : PixelDataFormat.RGBA,
      internalFormat: this._webgl2Support ? InternalFormat.DEPTH_COMPONENT32F : InternalFormat.RGBA,
      componentType: this._webgl2Support ? dataTypes_DataType.FLOAT : dataTypes_DataType.UNSIGNED_BYTE,
      levels: 1
    });

    if (this._webgl2Support) {
      _omniShadowCasterData.depthTexture.compareFunc = texture_resource_Texture.CompareFunc.LESS;
      _omniShadowCasterData.depthTexture.compareMode = texture_resource_Texture.CompareMode.COMPARE_REF_TO_TEXTURE;
    } else {
      for (let depthBuffer of depthBuffers) {
        depthBuffer.release();
        depthBuffer = null;
      }

      depthBuffers.length = 0;

      for (let face = 0; face < 6; ++face) {
        const depthBuffer = new renderBuffer_RenderBuffer({
          width: shadowMapSize,
          height: shadowMapSize,
          internalFormat: InternalFormat.DEPTH_COMPONENT16
        });
        depthBuffers.push(depthBuffer);
      }
    }
  }

  _updateOmniShadowCasterRenderTarget(shadowCaster) {
    const _omniShadowCasterData = shadowCaster._omniShadowCasterData;
    const depthTexture = _omniShadowCasterData.depthTexture;
    const width = depthTexture.width,
          height = depthTexture.height;

    if (this._webgl2Support) {
      if (_omniShadowCasterData.renderTarget) {
        _omniShadowCasterData.renderTarget.release();

        _omniShadowCasterData.renderTarget = null;
      }

      const renderTarget = new renderTargetCube_RenderTargetCube({
        width,
        height
      });
      renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthTexture, texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X);
      _omniShadowCasterData.renderTarget = renderTarget;
    } else {
      const depthBuffers = _omniShadowCasterData.depthBuffers,
            renderTargets = _omniShadowCasterData.renderTargets;

      for (let renderTarget of renderTargets) {
        renderTarget.release();
        renderTarget = null;
      }

      renderTargets.length = 0;

      for (const _ref11 of depthBuffers.entries()) {
        var _ref12 = light_system_slicedToArray(_ref11, 2);

        const face = _ref12[0];
        const depthBuffer = _ref12[1];
        const renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({
          width,
          height
        });
        renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthBuffer);
        renderTarget.setColorAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0, depthTexture, 0, texture_resource_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + face);
        renderTargets.push(renderTarget);
      }
    }
  }

  _disposeResources(scene) {
    scene._disposeShadowTextureArray();

    scene._disposePerCameraData();

    scene._disposeSpotCastersDepthTextureArray();
  }

  _updateSpotShadowCasterCamera(shadowCaster, worldMatrix) {
    const _spotShadowCasterData = shadowCaster._spotShadowCasterData;
    const camera = _spotShadowCasterData.camera;
    const viewMatrix = camera.viewMatrix,
          viewProjectionMatrix = camera.viewProjectionMatrix;
    camera.worldMatrix.copy(worldMatrix);
    viewMatrix.copy(worldMatrix).invert();
    const needsUpdateProjection = camera.needsUpdateProjection,
          projectionMatrix = camera.projectionMatrix;

    if (needsUpdateProjection) {
      projectionMatrix.fromWebGLPerspectiveProjection(camera.aspect, camera.yfov, camera.znear, camera.zfar);
      camera.needsUpdateProjection = false;
    }

    viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);
  }

  _createCascadeCameras(shadowCaster, name) {
    const _cascades = shadowCaster._cascades;

    for (const _ref13 of _cascades.entries()) {
      var _ref14 = light_system_slicedToArray(_ref13, 2);

      const i = _ref14[0];
      const cascade = _ref14[1];
      cascade.camera = new camera_component_Camera({
        name: `shadow-caster-camera-${name}-cascade${i}`,
        znear: -1,
        zfar: 1,
        orthographicProjection: {
          xmag: 1,
          ymag: 1
        }
      });
      cascade.camera.projectionType = camera_component_Camera.ProjectionTypes.ORTHOGRAPHIC;
    }
  }

  _countEnabledShadowCasters(entityManager) {
    let enabledDirectShadowCastersCount = 0;
    let enabledSpotShadowCastersCount = 0;
    let enabledOmniShadowCastersCount = 0;
    const storage = entityManager.getComponentStorage(light_shadow_caster_LightShadowCaster);

    for (const _ref15 of storage.entries()) {
      var _ref16 = light_system_slicedToArray(_ref15, 2);

      const entity = _ref16[0];
      const lightShadowCaster = _ref16[1];

      const _entityManager$getEnt9 = entityManager.getEntityComponents(entity, lightComponentClasses),
            _entityManager$getEnt10 = light_system_slicedToArray(_entityManager$getEnt9, 1),
            light = _entityManager$getEnt10[0];

      if (!lightShadowCaster.castShadow) {
        continue;
      }

      if (light.isDirectionalLight) {
        ++enabledDirectShadowCastersCount;
      } else if (light.isSpotLight) {
        ++enabledSpotShadowCastersCount;
      } else if (light.isPointLight) {
        ++enabledOmniShadowCastersCount;
      }
    }

    return {
      enabledDirectShadowCastersCount,
      enabledSpotShadowCastersCount,
      enabledOmniShadowCastersCount
    };
  }

  _calculateCameraAABBs(look, perCameraData) {
    if (false) {}

    const aspect = look.aspect,
          yfov = look.yfov,
          worldMatrix = look.worldMatrix;
    const range = look.zfar - look.znear;
    let znear = look.znear;
    const halfFovY = Math.tan(yfov * 0.5);
    const halfFovX = halfFovY * aspect;
    const frustumSplits = perCameraData.frustumSplits,
          cascadesPlanes = perCameraData.cascadesPlanes;
    cascadesPlanes.length = 0;

    for (const depth of frustumSplits) {
      const zfar = Math.ceil(range * depth) * 1.1;
      const xnear = znear * halfFovX;
      const xfar = zfar * halfFovX;
      const ynear = znear * halfFovY;
      const yfar = zfar * halfFovY;
      frustumNearCorner.set(xnear, ynear, znear);
      frustumFarCorner.set(xfar, yfar, zfar);
      const planes = [];

      for (const multiplier of multipliers) {
        const cascadeNearPoint = new lib["n" /* Vector3 */]();
        const cascadeFarPoint = new lib["n" /* Vector3 */]();
        cascadeNearPoint.copy(frustumNearCorner);
        cascadeNearPoint.multiplyVector(multiplier);
        cascadeNearPoint.applyAffineMatrix(worldMatrix);
        cascadeFarPoint.copy(frustumFarCorner);
        cascadeFarPoint.multiplyVector(multiplier);
        cascadeFarPoint.applyAffineMatrix(worldMatrix);
        planes.push([cascadeNearPoint, cascadeFarPoint]);
      }

      znear = Math.floor(range * depth);
      cascadesPlanes.push(planes);
    }
  }

  _updateOmniShadowCasterCamera(shadowCaster, worldMatrix) {
    const _omniShadowCasterData = shadowCaster._omniShadowCasterData;
    const cubeCamera = _omniShadowCasterData.cubeCamera;

    if (false) {}

    worldMatrix.translationPaste(tempVector);
    tempMatrix.translationCopy(tempVector);
    tempMatrix.invert();
    const viewMatrices = cubeCamera.viewMatrices,
          viewProjectionMatrices = cubeCamera.viewProjectionMatrices;

    for (const _ref17 of viewMatrices.entries()) {
      var _ref18 = light_system_slicedToArray(_ref17, 2);

      const i = _ref18[0];
      const viewMatrix = _ref18[1];
      viewMatrix.copy(tempMatrix).multiply(perCubeFaceMatrices[i]);
    }

    const needsUpdateProjection = cubeCamera.needsUpdateProjection,
          projectionMatrix = cubeCamera.projectionMatrix;

    if (needsUpdateProjection) {
      cubeCamera.projectionMatrix.fromWebGLPerspectiveProjection(cubeCamera.aspect, cubeCamera.yfov, cubeCamera.znear, cubeCamera.zfar);
      cubeCamera.needsUpdateProjection = false;
    }

    for (const _ref19 of viewProjectionMatrices.entries()) {
      var _ref20 = light_system_slicedToArray(_ref19, 2);

      const i = _ref20[0];
      const viewProjectionMatrix = _ref20[1];
      viewProjectionMatrix.fromAffine(viewMatrices[i]).multiply(projectionMatrix);
    }
  }

  _calculateCascadeCameraProjection(camera, cascadePlanes) {
    if (false) {}

    let minZ = +Infinity;
    bbox.set(positiveInf, negativeInf);
    const viewMatrix = camera.viewMatrix,
          projectionMatrix = camera.projectionMatrix,
          viewProjectionMatrix = camera.viewProjectionMatrix;

    for (const _ref21 of cascadePlanes) {
      var _ref22 = light_system_slicedToArray(_ref21, 2);

      const nearPoint = _ref22[0];
      const farPoint = _ref22[1];
      {
        const clone = nearPoint.clone();
        clone.applyAffineMatrix(viewMatrix);
        clone.multiplyVector(zInverter);
        bbox.consumePoint(clone);
      }
      {
        const clone = farPoint.clone();
        clone.applyAffineMatrix(viewMatrix);
        clone.multiplyVector(zInverter);
        bbox.consumePoint(clone);
      }
    }

    const min = bbox.min,
          max = bbox.max;
    minZ = min.z < minZ ? min.z : minZ;
    const w = Math.max(Math.abs(min.x), Math.abs(max.x));
    const h = Math.max(Math.abs(min.y), Math.abs(max.y));
    projectionMatrix.fromWebGLOrthographicProjection(w * 2, h * 2, minZ, max.z);
    viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);
    camera.needsUpdateProjection = false;
  }

}
light_system_LightSystem.ID = 'light';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/line-component/index.js


class line_component_LineRenderable extends renderable_Renderable {
  get needsUpdate() {
    return this.geometry !== null ? this.geometry.needsUpdateBoundingBox : false;
  }

}
class line_component_Line extends component_Component {
  constructor({
    geometry,
    material,
    name = ''
  }) {
    super();
    this.name = name;
    this._lineRenderable = new line_component_LineRenderable(geometry, material);
  }

  getInstancedAttribute(semantic, outVal) {
    return this._lineRenderable.getInstancedAttribute(semantic, outVal);
  }

  setInstancedAttribute(semantic, inVal) {
    this._lineRenderable.setInstancedAttribute(semantic, inVal);
  }

  get material() {
    return this._lineRenderable.material;
  }

  clone(newName) {
    const name = this.name,
          _lineRenderable = this._lineRenderable;
    const geometry = _lineRenderable.geometry,
          material = _lineRenderable.material;
    return new line_component_Line({
      geometry,
      material,
      name: newName || name
    });
  }

  unload() {
    this._lineRenderable.unload();

    super.unload();
  }

  _dispose() {
    this._lineRenderable.dispose();

    this._lineRenderable = null;

    super._dispose();
  }

}
line_component_Line.ID = 'line';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/line-system/index.js
function line_system_slicedToArray(arr, i) { return line_system_arrayWithHoles(arr) || line_system_iterableToArrayLimit(arr, i) || line_system_unsupportedIterableToArray(arr, i) || line_system_nonIterableRest(); }

function line_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function line_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return line_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return line_system_arrayLikeToArray(o, minLen); }

function line_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function line_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function line_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const lateUpdateComponents = [transform_component_Transform];
const line_system_worldBoundingBox = new lib["e" /* Box */]();
const line_system_center = new lib["n" /* Vector3 */]();
class line_system_LineSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      if (line_component_Line.index === index) {
        const _scene = entityManager._scene;
        const instanceDataManager = _scene.instanceDataManager,
              _instanceKeys = _scene._instanceKeys,
              spatialIndex = _scene.spatialIndex;
        const _lineRenderable = component._lineRenderable;

        if (_lineRenderable.instanceId !== null) {
          instanceDataManager.deleteInstance(_lineRenderable);
        }

        const instanceKey = _instanceKeys.get(_lineRenderable);

        _instanceKeys.delete(_lineRenderable);

        spatialIndex.remove(instanceKey);
        _scene._forceUpdateRenderQueue = true;
      }
    });
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          frameNumber = _core$currentRequest.frameNumber;
    const entityManager = scene.entityManager,
          instanceDataManager = scene.instanceDataManager,
          _instanceKeys = scene._instanceKeys,
          _forceUpdateRenderQueue = scene._forceUpdateRenderQueue;

    if (_forceUpdateRenderQueue) {
      scene._lastFrameSceneGraphUpdate = frameNumber;
      scene._forceUpdateRenderQueue = false;
    }

    if (!entityManager.isComponent(line_component_Line)) {
      return;
    }

    const storage = entityManager.getComponentStorage(line_component_Line);
    let needsValidateInstanceKeys = false;

    for (const line of storage.components()) {
      if (line.unloaded) {
        continue;
      }

      const _lineRenderable = line._lineRenderable;

      if (_lineRenderable.instanceId === null || _lineRenderable._instanceIdentifierExpired) {
        instanceDataManager.addInstance(_lineRenderable);
        _lineRenderable._lastUpdateFrameNumber = frameNumber;

        if (_lineRenderable._instanceIdentifierExpired) {
          this._validateInstanceKey(instanceDataManager, scene, _lineRenderable, _instanceKeys.get(_lineRenderable));
        } else {
          needsValidateInstanceKeys = false;
        }

        instanceDataManager.setInstanceVisibility(_lineRenderable, true, true);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }

      if (_lineRenderable.geometry.needsUpdateBoundingBox) {
        _lineRenderable.geometry.updateBoundingBox();
      }

      const _customAttributesToWrite = _lineRenderable._customAttributesToWrite,
            _customAttributesToRead = _lineRenderable._customAttributesToRead;

      for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
        const _customAttributesToWr = _customAttributesToWrite.pop(),
              semantic = _customAttributesToWr.semantic,
              inVal = _customAttributesToWr.inVal;

        instanceDataManager.setInstancedAttribute(_lineRenderable, semantic, inVal);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }

      for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
        const _customAttributesToRe = _customAttributesToRead.pop(),
              resolve = _customAttributesToRe.resolve,
              semantic = _customAttributesToRe.semantic,
              outVal = _customAttributesToRe.outVal;

        resolve(instanceDataManager.getInstancedAttribute(_lineRenderable, semantic, outVal));
      }
    }

    if (needsValidateInstanceKeys) {
      this._validateInstanceKeys(instanceDataManager, scene);
    }
  }

  onLateUpdate(core) {
    const _core$currentRequest2 = core.currentRequest,
          scene = _core$currentRequest2.scene,
          frameNumber = _core$currentRequest2.frameNumber;
    const instanceDataManager = scene.instanceDataManager,
          _instanceKeys = scene._instanceKeys,
          entityManager = scene.entityManager,
          spatialIndex = scene.spatialIndex;

    if (!entityManager.isComponent(line_component_Line)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(line_component_Line);

    for (const _ref of storage.entries()) {
      var _ref2 = line_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const line = _ref2[1];

      if (line.unloaded) {
        continue;
      }

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, lateUpdateComponents, components),
            _entityManager$getEnt2 = line_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      const state = transform.state,
            worldMatrix = transform.worldMatrix;
      const _lineRenderable = line._lineRenderable;

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0 || _lineRenderable.lastUpdateFrameNumber === frameNumber) {
        const instanceId = _lineRenderable.instanceId,
              instanceIndex = _lineRenderable.instanceIndex,
              geometry = _lineRenderable.geometry,
              id = _lineRenderable.id;
        const boundingBox = geometry.boundingBox;

        const _instanceDataManager$ = instanceDataManager.getInstanceRenderable(instanceId),
              batchIdx = _instanceDataManager$.batchIdx;

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
        instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
        instanceDataManager.storeRenderableIdentifier(globalIndex, id);

        let instanceKey = _instanceKeys.get(_lineRenderable);

        if (instanceKey === undefined) {
          instanceKey = {
            node: scene._entityToNode.get(entity),
            renderable: _lineRenderable,
            batchSetIdx: 0,
            globalIndex
          };

          _instanceKeys.set(_lineRenderable, instanceKey);
        }

        line_system_worldBoundingBox.copy(boundingBox).applyAffineMatrix(worldMatrix);
        spatialIndex.insert(instanceKey, line_system_worldBoundingBox);
        line_system_worldBoundingBox.centerPaste(line_system_center);
        instanceDataManager.storeCenter(line_system_center, globalIndex);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const _copyContext$nodeToNo = copyContext.nodeToNode,
          nodeToNode = _copyContext$nodeToNo === void 0 ? new Map() : _copyContext$nodeToNo,
          _copyContext$cloneMat = copyContext.cloneMaterials,
          cloneMaterials = _copyContext$cloneMat === void 0 ? false : _copyContext$cloneMat;
    const materialToMaterial = new Map();

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = line_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([line_component_Line]),
            _srcNode$getComponent2 = line_system_slicedToArray(_srcNode$getComponent, 1),
            srcLine = _srcNode$getComponent2[0];

      if (srcLine === null) {
        continue;
      }

      const dstLine = srcLine.clone();

      if (cloneMaterials) {
        const _lineRenderable = srcLine._lineRenderable;
        const srcMaterial = _lineRenderable.material;
        let dstMaterial = materialToMaterial.get(srcMaterial);

        if (dstMaterial === undefined) {
          dstMaterial = srcMaterial.clone();
          materialToMaterial.set(srcMaterial, dstMaterial);
        }

        dstLine._lineRenderable.material = dstMaterial;
      }

      dstNode.attach(dstLine);
    }
  }

  _validateInstanceKey(instanceDataManager, scene, renderable, instanceKey) {
    const instanceId = renderable.instanceId,
          instanceIndex = renderable.instanceIndex;
    const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

    if (batchRenderable === undefined) {
      scene._instanceKeys.delete(renderable);

      scene.spatialIndex.remove(instanceKey);
    } else if (instanceKey !== undefined) {
      const batchIdx = batchRenderable.batchIdx;
      const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
      instanceKey.batchSetIdx = 0;
      instanceKey.globalIndex = globalIndex;
    }
  }

  _validateInstanceKeys(instanceDataManager, scene) {
    for (const _ref5 of scene._instanceKeys.entries()) {
      var _ref6 = line_system_slicedToArray(_ref5, 2);

      const r = _ref6[0];
      const ik = _ref6[1];

      this._validateInstanceKey(instanceDataManager, scene, r, ik);
    }
  }

}
line_system_LineSystem.ID = 'line';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/mesh-system/index.js
function mesh_system_slicedToArray(arr, i) { return mesh_system_arrayWithHoles(arr) || mesh_system_iterableToArrayLimit(arr, i) || mesh_system_unsupportedIterableToArray(arr, i) || mesh_system_nonIterableRest(); }

function mesh_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function mesh_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mesh_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mesh_system_arrayLikeToArray(o, minLen); }

function mesh_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function mesh_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function mesh_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








const mesh_system_lateUpdateComponents = [mesh_component_Mesh];
const mesh_system_worldBoundingBox = new lib["e" /* Box */]();
const mesh_system_center = new lib["n" /* Vector3 */]();

function _onLightCountChanged(entityManager) {
  const storage = entityManager.getComponentStorage(mesh_component_Mesh);

  for (const mesh of storage.components()) {
    for (const subMesh of mesh.subMeshes()) {
      if (subMesh.material.lit) {
        subMesh.material.needsUpdate = true;
      }
    }
  }
}

function _onDetachMesh(entityManager, mesh) {
  const _scene = entityManager._scene;
  const instanceDataManager = _scene.instanceDataManager,
        _instanceKeys = _scene._instanceKeys,
        spatialIndex = _scene.spatialIndex;
  const subMeshCount = mesh.subMeshCount;

  for (let i = 0; i < subMeshCount; i++) {
    const subMesh = mesh.getSubMesh(i);

    if (subMesh.instanceId !== null) {
      instanceDataManager.deleteInstance(subMesh);
    }

    const instanceKey = _instanceKeys.get(subMesh);

    _instanceKeys.delete(subMesh);

    spatialIndex.remove(instanceKey);
  }

  _scene._forceUpdateRenderQueue = true;
}

class mesh_system_MeshSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    this._depthMaterials = new WeakMap();
    EntityManager.onAttach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      if (light_Light.index === index) {
        _onLightCountChanged(entityManager);
      }
    });
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      switch (index) {
        case light_Light.index:
          _onLightCountChanged(entityManager);

          break;

        case mesh_component_Mesh.index:
          _onDetachMesh(entityManager, component);

          break;

        default:
      }
    });
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          frameNumber = _core$currentRequest.frameNumber;
    const entityManager = scene.entityManager,
          instanceDataManager = scene.instanceDataManager,
          _instanceKeys = scene._instanceKeys,
          _forceUpdateRenderQueue = scene._forceUpdateRenderQueue;

    if (_forceUpdateRenderQueue) {
      scene._lastFrameSceneGraphUpdate = frameNumber;
      scene._forceUpdateRenderQueue = false;
    }

    if (!entityManager.isComponent(mesh_component_Mesh)) {
      return;
    }

    const storage = entityManager.getComponentStorage(mesh_component_Mesh);
    let needsValidateInstanceKeys = false;

    for (const mesh of storage.components()) {
      const subMeshCount = mesh.subMeshCount;

      for (let i = 0; i < subMeshCount; i++) {
        const subMesh = mesh.getSubMesh(i);

        if (subMesh.unloaded) {
          continue;
        }

        if (subMesh.instanceId === null || subMesh._instanceIdentifierExpired) {
          instanceDataManager.addInstance(subMesh);
          subMesh._lastUpdateFrameNumber = frameNumber;
          mesh._lastUpdateFrameNumber = frameNumber;

          if (subMesh._instanceIdentifierExpired) {
            this._validateInstanceKey(instanceDataManager, scene, subMesh, _instanceKeys.get(subMesh));
          } else {
            needsValidateInstanceKeys = true;
          }

          instanceDataManager.setInstanceVisibility(subMesh, true, true);
          scene._lastFrameSceneGraphUpdate = frameNumber;
        }

        if (subMesh.geometry.needsUpdateBoundingBox) {
          subMesh.geometry.updateBoundingBox();
        }

        const _customAttributesToWrite = subMesh._customAttributesToWrite,
              _customAttributesToRead = subMesh._customAttributesToRead;

        for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
          const _customAttributesToWr = _customAttributesToWrite.shift(),
                semantic = _customAttributesToWr.semantic,
                inVal = _customAttributesToWr.inVal;

          instanceDataManager.setInstancedAttribute(subMesh, semantic, inVal);
          scene._lastFrameSceneGraphUpdate = frameNumber;
        }

        for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
          const _customAttributesToRe = _customAttributesToRead.pop(),
                resolve = _customAttributesToRe.resolve,
                semantic = _customAttributesToRe.semantic,
                outVal = _customAttributesToRe.outVal;

          resolve(instanceDataManager.getInstancedAttribute(subMesh, semantic, outVal));
        }

        this._updateDepthMaterial(core.renderer, instanceDataManager, subMesh);
      }
    }

    if (needsValidateInstanceKeys) {
      this._validateInstanceKeys(instanceDataManager, scene);
    }
  }

  onLateUpdate(core) {
    const _core$currentRequest2 = core.currentRequest,
          scene = _core$currentRequest2.scene,
          frameNumber = _core$currentRequest2.frameNumber;
    const instanceDataManager = scene.instanceDataManager,
          _instanceKeys = scene._instanceKeys,
          entityManager = scene.entityManager,
          spatialIndex = scene.spatialIndex;

    if (!entityManager.isComponent(transform_component_Transform)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(transform_component_Transform);

    for (const _ref of storage.entries()) {
      var _ref2 = mesh_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const transform = _ref2[1];

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, mesh_system_lateUpdateComponents, components),
            _entityManager$getEnt2 = mesh_system_slicedToArray(_entityManager$getEnt, 1),
            mesh = _entityManager$getEnt2[0];

      if (mesh === null) {
        continue;
      }

      const skeleton = mesh.skeleton,
            _lastUpdateFrameNumber = mesh._lastUpdateFrameNumber;

      const _ref3 = skeleton !== null ? skeleton.root : transform,
            state = _ref3.state,
            worldMatrix = _ref3.worldMatrix;

      const needsUpdateWorldMatrix = (state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0;

      if (!needsUpdateWorldMatrix && _lastUpdateFrameNumber < frameNumber) {
        continue;
      }

      mesh._lastUpdateFrameNumber = frameNumber;
      const subMeshCount = mesh.subMeshCount;

      for (let i = 0; i < subMeshCount; i++) {
        const subMesh = mesh.getSubMesh(i);

        if (subMesh.unloaded) {
          continue;
        }

        const instanceId = subMesh.instanceId,
              instanceIndex = subMesh.instanceIndex,
              geometry = subMesh.geometry,
              id = subMesh.id;
        const boundingBox = geometry.boundingBox;

        const _instanceDataManager$ = instanceDataManager.getInstanceRenderable(instanceId),
              batchIdx = _instanceDataManager$.batchIdx;

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
        instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
        instanceDataManager.storeRenderableIdentifier(globalIndex, id);

        let instanceKey = _instanceKeys.get(subMesh);

        if (instanceKey === undefined) {
          instanceKey = {
            node: scene._entityToNode.get(entity),
            renderable: subMesh,
            batchSetIdx: 0,
            globalIndex
          };

          _instanceKeys.set(subMesh, instanceKey);
        }

        mesh_system_worldBoundingBox.copy(boundingBox).applyAffineMatrix(worldMatrix);
        spatialIndex.insert(instanceKey, mesh_system_worldBoundingBox);
        mesh_system_worldBoundingBox.centerPaste(mesh_system_center);
        instanceDataManager.storeCenter(mesh_system_center, globalIndex);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    srcScene,
    dstScene,
    copyContext
  }) {
    const _copyContext$nodeToNo = copyContext.nodeToNode,
          nodeToNode = _copyContext$nodeToNo === void 0 ? new Map() : _copyContext$nodeToNo,
          _copyContext$skeleton = copyContext.skeletonToSkeleton,
          skeletonToSkeleton = _copyContext$skeleton === void 0 ? new Map() : _copyContext$skeleton,
          _copyContext$cloneMat = copyContext.cloneMaterials,
          cloneMaterials = _copyContext$cloneMat === void 0 ? false : _copyContext$cloneMat;
    const materialToMaterial = new Map();

    for (const _ref4 of nodeToNode.entries()) {
      var _ref5 = mesh_system_slicedToArray(_ref4, 2);

      const srcNode = _ref5[0];
      const dstNode = _ref5[1];

      const _srcNode$getComponent = srcNode.getComponents([mesh_component_Mesh]),
            _srcNode$getComponent2 = mesh_system_slicedToArray(_srcNode$getComponent, 1),
            srcMesh = _srcNode$getComponent2[0];

      if (srcMesh === null) {
        continue;
      }

      const dstMesh = srcMesh.clone();

      if (cloneMaterials) {
        const subMeshCount = srcMesh.subMeshCount;

        for (let i = 0; i < subMeshCount; i++) {
          const srcSubMesh = srcMesh.getSubMesh(i);
          const srcMaterial = srcSubMesh.material;
          const dstSubMesh = dstMesh.getSubMesh(i);
          let dstMaterial = materialToMaterial.get(srcMaterial);

          if (dstMaterial === undefined) {
            dstMaterial = srcMaterial.clone();
            materialToMaterial.set(srcMaterial, dstMaterial);
          }

          dstSubMesh.material = dstMaterial;
        }
      }

      const srcSkeleton = srcMesh.skeleton;
      const srcSkeletonIndex = srcScene.getSkeletonIndex(srcSkeleton);
      const dstSkeletonIndex = skeletonToSkeleton.get(srcSkeletonIndex);
      const dstSkeleton = dstSkeletonIndex !== undefined ? dstScene.getSkeleton(dstSkeletonIndex) : null;
      dstMesh.skeleton = dstSkeleton;
      dstNode.attach(dstMesh);
    }
  }

  _validateInstanceKey(instanceDataManager, scene, renderable, instanceKey) {
    const instanceId = renderable.instanceId,
          instanceIndex = renderable.instanceIndex;
    const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

    if (batchRenderable === undefined) {
      scene._instanceKeys.delete(renderable);

      scene.spatialIndex.remove(instanceKey);
    } else if (instanceKey !== undefined) {
      const batchIdx = batchRenderable.batchIdx;
      const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
      instanceKey.batchSetIdx = 0;
      instanceKey.globalIndex = globalIndex;
    }
  }

  _validateInstanceKeys(instanceDataManager, scene) {
    for (const _ref6 of scene._instanceKeys.entries()) {
      var _ref7 = mesh_system_slicedToArray(_ref6, 2);

      const r = _ref7[0];
      const ik = _ref7[1];

      this._validateInstanceKey(instanceDataManager, scene, r, ik);
    }
  }

  _updateDepthMaterial(renderer, instanceDataManager, subMesh) {
    const material = subMesh.material;
    const castShadow = material.castShadow;

    if (castShadow) {
      for (const _ref8 of subMesh._depthMaterials.entries()) {
        var _ref9 = mesh_system_slicedToArray(_ref8, 2);

        const i = _ref9[0];
        const _depthMaterial = _ref9[1];

        if (_depthMaterial === null) {
          const _depthMaterials = renderer._depthMaterials;
          const _subMesh$skeleton = subMesh.skeleton,
                skeleton = _subMesh$skeleton === void 0 ? null : _subMesh$skeleton,
                instanceId = subMesh.instanceId,
                depthMaterials = subMesh.depthMaterials;
          const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);
          const morphWeights = batchRenderable.morphWeights;

          if (skeleton === null && morphWeights === null) {
            depthMaterials[i] = _depthMaterials[i];
          } else {
            let depthMaterials_ = this._depthMaterials.get(material);

            if (depthMaterials_ === undefined) {
              depthMaterials_ = [null, null];

              this._depthMaterials.set(material, depthMaterials_);
            }

            if (depthMaterials_[i] !== null) {
              depthMaterials[i] = depthMaterials_[i];
            } else {
              const depthMaterial = _depthMaterials[i].clone();

              depthMaterial.name = `${subMesh.name}_depthmat${i}`;
              depthMaterials[i] = depthMaterial;
              depthMaterials_[i] = depthMaterial;
            }
          }

          batchRenderable.depthMaterials[i] = depthMaterials[i];
        }
      }
    } else {
      for (const _ref10 of subMesh._depthMaterials.entries()) {
        var _ref11 = mesh_system_slicedToArray(_ref10, 2);

        const i = _ref11[0];
        const _depthMaterial = _ref11[1];

        if (_depthMaterial !== null) {
          const instanceId = subMesh.instanceId;
          const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);
          subMesh._depthMaterials[i] = null;
          batchRenderable.depthMaterials[i] = null;
        }
      }
    }
  }

}
mesh_system_MeshSystem.ID = 'mesh';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/morph-system/index.js
function morph_system_slicedToArray(arr, i) { return morph_system_arrayWithHoles(arr) || morph_system_iterableToArrayLimit(arr, i) || morph_system_unsupportedIterableToArray(arr, i) || morph_system_nonIterableRest(); }

function morph_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function morph_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return morph_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return morph_system_arrayLikeToArray(o, minLen); }

function morph_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function morph_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function morph_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const _lateUpdateClasses = [mesh_component_Mesh];
const _positionMorphTargets = [AttributeSemantic.POSITION_MORPH_0, AttributeSemantic.POSITION_MORPH_1, AttributeSemantic.POSITION_MORPH_2, AttributeSemantic.POSITION_MORPH_3, AttributeSemantic.POSITION_MORPH_4, AttributeSemantic.POSITION_MORPH_5, AttributeSemantic.POSITION_MORPH_6, AttributeSemantic.POSITION_MORPH_7];
const _normalMorphTargets = [AttributeSemantic.NORMAL_MORPH_0, AttributeSemantic.NORMAL_MORPH_1, AttributeSemantic.NORMAL_MORPH_2, AttributeSemantic.NORMAL_MORPH_3, AttributeSemantic.NORMAL_MORPH_4, AttributeSemantic.NORMAL_MORPH_5, AttributeSemantic.NORMAL_MORPH_6, AttributeSemantic.NORMAL_MORPH_7];

class _WeightImportance {
  constructor(weights) {
    this.sortedIndices = new Int8Array(weights.length);
    this.importantIndices = new Int8Array(3);
    this.importantWeights = new Float32Array(3);
    this.prevImportantIndices = new Int8Array(3);
  }

  update(weights) {
    this.importantIndices.forEach((value, index) => {
      this.prevImportantIndices[index] = value;
    });
    this.sortedIndices.forEach((value, index) => {
      this.sortedIndices[index] = index;
    });
    this.sortedIndices.sort((a, b) => Math.abs(weights[b]) - Math.abs(weights[a]));
    this.importantIndices.forEach((value, index) => {
      this.importantIndices[index] = this.sortedIndices[index];
    });
    this.importantIndices.sort((a, b) => a - b);
    this.importantWeights.forEach((value, index) => {
      this.importantWeights[index] = weights[this.importantIndices[index]];
    });
  }

  get isConsistent() {
    return this.importantIndices.every((value, index) => {
      return value === this.prevImportantIndices[index];
    });
  }

}

class _WeightImportanceMap {
  constructor() {
    this._map = new Map();
  }

  has(morph) {
    return this._map.has(morph);
  }

  add(morph) {
    this._map.set(morph, new _WeightImportance(morph.weights));
  }

  get(morph) {
    return this._map.get(morph);
  }

}

class morph_system_MorphSystem extends System {
  constructor(core) {
    super();
    this.weightImportanceMap = new _WeightImportanceMap();
    core.regSystemEvent('onUpdate', this);
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      if (index === morph_component_Morph.index) {
        const _scene = entityManager._scene;
        const instanceDataManager = _scene.instanceDataManager;

        const _entityManager$getEnt = entityManager.getEntityComponents(entity, _lateUpdateClasses),
              _entityManager$getEnt2 = morph_system_slicedToArray(_entityManager$getEnt, 1),
              mesh = _entityManager$getEnt2[0];

        for (const subMesh of mesh.subMeshes()) {
          const instanceId = subMesh.instanceId,
                material = subMesh.material;
          const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);
          batchRenderable.positionMorphTargetCount = 0;
          batchRenderable.normalMorphTargetCount = 0;
          batchRenderable.morphWeights = null;
          material.needsUpdate = true;
        }
      }
    });
  }

  onUpdate(core) {
    const scene = core.currentRequest.scene;
    const entityManager = scene.entityManager,
          instanceDataManager = scene.instanceDataManager;
    const weightImportanceMap = this.weightImportanceMap;

    if (!entityManager.isComponent(morph_component_Morph)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(morph_component_Morph);

    for (const _ref of storage.entries()) {
      var _ref2 = morph_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const morph = _ref2[1];

      if (!morph.needsUpdate) {
        continue;
      }

      const weights = morph.weights;

      if (weights.length > 3) {
        if (!weightImportanceMap.has(morph)) {
          weightImportanceMap.add(morph);
        }

        const weightImportance = weightImportanceMap.get(morph);
        weightImportance.update(weights);
      }

      const _entityManager$getEnt3 = entityManager.getEntityComponents(entity, _lateUpdateClasses, components),
            _entityManager$getEnt4 = morph_system_slicedToArray(_entityManager$getEnt3, 1),
            mesh = _entityManager$getEnt4[0];

      for (const subMesh of mesh.subMeshes()) {
        const instanceId = subMesh.instanceId,
              material = subMesh.material;
        const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

        if (batchRenderable.morphWeights === null) {
          material.needsUpdate = true;
          const geometry = batchRenderable.geometry;
          const attributes = geometry.attributes;
          let positionMorphTargetCount = 0;
          let normalMorphTargetCount = 0;

          for (const semantic of attributes.keys()) {
            if (_positionMorphTargets.includes(semantic)) {
              positionMorphTargetCount++;
            } else if (_normalMorphTargets.includes(semantic)) {
              normalMorphTargetCount++;
            }
          }

          if (weights.length > 3) {
            const weightImportance = weightImportanceMap.get(morph);
            batchRenderable.morphWeights = weightImportance.importantWeights;
          } else {
            batchRenderable.morphWeights = weights;
          }

          batchRenderable.positionMorphTargetCount = positionMorphTargetCount;
          batchRenderable.normalMorphTargetCount = normalMorphTargetCount;
        }

        if (weights.length > 3) {
          const weightImportance = weightImportanceMap.get(morph);

          if (!weightImportance.isConsistent) {
            const geometry = batchRenderable.geometry;
            const attributes = geometry.attributes,
                  morphTargets = geometry.morphTargets;
            const vertexStaging = core.renderer.vertexStaging;
            const importantIndices = weightImportance.importantIndices;

            for (let idx = 0; idx < 3; idx++) {
              const positionMorphAttribute = attributes.get(AttributeSemantic.POSITION_MORPH_0 + idx);
              const positionMorphTarget = morphTargets.get(AttributeSemantic.POSITION_MORPH_0 + importantIndices[idx]);
              const normalMorphAttribute = attributes.get(AttributeSemantic.NORMAL_MORPH_0 + idx);
              const normalMorphTarget = morphTargets.get(AttributeSemantic.NORMAL_MORPH_0 + importantIndices[idx]);

              this._copyMorphTargetToMorphAttribute(positionMorphTarget, positionMorphAttribute, vertexStaging);

              this._copyMorphTargetToMorphAttribute(normalMorphTarget, normalMorphAttribute, vertexStaging);
            }
          }
        }
      }

      morph.needsUpdate = false;
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = morph_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([morph_component_Morph]),
            _srcNode$getComponent2 = morph_system_slicedToArray(_srcNode$getComponent, 1),
            srcMorph = _srcNode$getComponent2[0];

      if (srcMorph === null) {
        continue;
      }

      const dstMorph = srcMorph.clone();
      dstNode.attach(dstMorph);
    }
  }

  _copyMorphTargetToMorphAttribute(morphTarget, morphAttribute, vertexStaging) {
    const attrView = morphAttribute.view,
          stride = morphAttribute.stride,
          countComponents = morphAttribute.countComponents,
          countElements = morphAttribute.countElements;

    if (stride === countComponents * Float32Array.BYTES_PER_ELEMENT) {
      attrView.set(morphTarget.view);
    } else {
      for (let elementIdx = 0; elementIdx < countElements; elementIdx++) {
        const dstArrayIdx = elementIdx * stride / Float32Array.BYTES_PER_ELEMENT;
        const srcArrayIdx = elementIdx * countComponents;

        for (let componentIdx = 0; componentIdx < countComponents; componentIdx++) {
          attrView[dstArrayIdx + componentIdx] = morphTarget.view[srcArrayIdx + componentIdx];
        }
      }
    }

    vertexStaging.subdatas.push({
      offset: attrView.byteOffset,
      size: attrView.byteLength
    });
  }

}
morph_system_MorphSystem.ID = 'morph';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/time-system/index.js

class time_system_TimeSystem extends System {
  constructor(core) {
    super();
    this._oldTime = 0;
    this._start = true;
    this.dt = 0;
    this.time = 0;
    this.timeScale = 1;
    core.regSystemEvent('onLoopStart', this);
    core.regSystemEvent('onFrameStart', this, -1100);
    core.regSystemEvent('onStart', this);
  }

  onLoopStart() {
    this._start = true;
  }

  onFrameStart(core) {
    if (this._start) {
      this._start = false;
      this.dt = 0;
    } else {
      this.dt = (core.time - this._oldTime) * this.timeScale * 0.001;
    }

    this.time += this.dt;
    this._oldTime = core.time;
  }

  onStart(core) {
    core.currentRequest.dt = this.dt;
  }

}
time_system_TimeSystem.ID = 'time';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/orbit-component/index.js

const PI = Math.PI;
const PI05 = Math.PI * 0.5;
class orbit_component_Orbit extends component_Component {
  constructor(options) {
    super();
    const _options$polar = options.polar,
          polar = _options$polar === void 0 ? 0 : _options$polar,
          _options$azimuthal = options.azimuthal,
          azimuthal = _options$azimuthal === void 0 ? 0 : _options$azimuthal,
          _options$distance = options.distance,
          distance = _options$distance === void 0 ? 0 : _options$distance,
          _options$target = options.target,
          target = _options$target === void 0 ? {
      x: 0,
      y: 0,
      z: 0
    } : _options$target,
          _options$minPolar = options.minPolar,
          minPolar = _options$minPolar === void 0 ? -PI05 : _options$minPolar,
          _options$maxPolar = options.maxPolar,
          maxPolar = _options$maxPolar === void 0 ? PI05 : _options$maxPolar,
          _options$minAzimuthal = options.minAzimuthal,
          minAzimuthal = _options$minAzimuthal === void 0 ? -PI * 3 : _options$minAzimuthal,
          _options$maxAzimuthal = options.maxAzimuthal,
          maxAzimuthal = _options$maxAzimuthal === void 0 ? PI * 3 : _options$maxAzimuthal,
          _options$minDistance = options.minDistance,
          minDistance = _options$minDistance === void 0 ? 0 : _options$minDistance,
          _options$maxDistance = options.maxDistance,
          maxDistance = _options$maxDistance === void 0 ? Infinity : _options$maxDistance,
          _options$rotateSpeed = options.rotateSpeed,
          rotateSpeed = _options$rotateSpeed === void 0 ? 1 : _options$rotateSpeed,
          _options$movingSpeed = options.movingSpeed,
          movingSpeed = _options$movingSpeed === void 0 ? 1 : _options$movingSpeed,
          _options$dollyingSpee = options.dollyingSpeed,
          dollyingSpeed = _options$dollyingSpee === void 0 ? 1 : _options$dollyingSpee,
          _options$dampingFacto = options.dampingFactor,
          dampingFactor = _options$dampingFacto === void 0 ? 0.8 : _options$dampingFacto;
    this.polar = polar;
    this.azimuthal = azimuthal;
    this.distance = distance;
    this.target = target;
    this.minPolar = minPolar;
    this.maxPolar = maxPolar;
    this.minAzimuthal = minAzimuthal;
    this.maxAzimuthal = maxAzimuthal;
    this.minDistance = minDistance;
    this.maxDistance = maxDistance;
    this.rotateSpeed = rotateSpeed;
    this.movingSpeed = movingSpeed;
    this.dollyingSpeed = dollyingSpeed;
    this.dampingFactor = dampingFactor;
    this.dampingMX = 0;
    this.dampingMY = 0;
    this.dampingMZ = 0;
    this.dampingRP = 0;
    this.dampingRA = 0;
    this.dampingDG = 0;
    this.state = 0xFF01;
  }

  clone() {
    return new orbit_component_Orbit({
      polar: this.polar,
      azimuthal: this.azimuthal,
      distance: this.distance,
      target: this.target,
      minPolar: this.minPolar,
      maxPolar: this.maxPolar,
      minAzimuthal: this.minAzimuthal,
      maxAzimuthal: this.maxAzimuthal,
      minDistance: this.minDistance,
      maxDistance: this.maxDistance,
      rotateSpeed: this.rotateSpeed,
      movingSpeed: this.movingSpeed,
      dollyingSpeed: this.dollyingSpeed,
      dampingFactor: this.dampingFactor
    });
  }

}
orbit_component_Orbit.ID = 'orbit';
orbit_component_Orbit.POLAR = 0x0100;
orbit_component_Orbit.AZIMUTHAL = 0x0200;
orbit_component_Orbit.MOVING = 0x0400;
orbit_component_Orbit.DOLLYING = 0x0800;
orbit_component_Orbit.DAMPING = 0x1000;
orbit_component_Orbit.KEYBOARD = 0x2000;
orbit_component_Orbit.DAMPED = 0x4000;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/orbit-system/index.js
function orbit_system_slicedToArray(arr, i) { return orbit_system_arrayWithHoles(arr) || orbit_system_iterableToArrayLimit(arr, i) || orbit_system_unsupportedIterableToArray(arr, i) || orbit_system_nonIterableRest(); }

function orbit_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function orbit_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return orbit_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return orbit_system_arrayLikeToArray(o, minLen); }

function orbit_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function orbit_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function orbit_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








const orbit_system_lateUpdateClasses = [transform_component_Transform];
const upVector = new lib["n" /* Vector3 */](0, 1, 0);
const leftVector = new lib["n" /* Vector3 */](-1, 0, 0);
const targetVector = new lib["n" /* Vector3 */](0, 0, 0);
const orbit_system_tempVector = new lib["n" /* Vector3 */](0, 0, 0);
const orbit_system_components = [];
const PI2 = Math.PI * 2;
class orbit_system_OrbitSystem extends System {
  constructor(core) {
    super();
    this._dMoveX = 0;
    this._dMoveY = 0;
    this._dMoveZ = 0;
    this._dPolar = 0;
    this._dDollying = 0;
    this._dAzimuthal = 0;
    this._dKeyMoveX = 0;
    this._dKeyMoveY = 0;
    this._dKeyMoveZ = 0;
    core.regSystemEvent('onLoopStart', this);
    core.regSystemEvent('onFrameStart', this, -900);
    core.regSystemEvent('onUpdate', this, -100);
  }

  onLoopStart(core) {
    this._inputSystem = core.getSystem(input_system_InputSystem);
    this._timeSystem = core.getSystem(time_system_TimeSystem);
  }

  onFrameStart() {
    const time = this._timeSystem,
          input = this._inputSystem;
    this._dPolar = 0;
    this._dAzimuthal = 0;
    this._dMoveX = 0;
    this._dMoveY = 0;
    this._dMoveZ = 0;
    this._dKeyMoveX = (Number(input.keyState(input_system_InputSystem.VK_D)) - Number(input.keyState(input_system_InputSystem.VK_A))) * time.dt;
    this._dKeyMoveY = (Number(input.keyState(input_system_InputSystem.VK_E)) - Number(input.keyState(input_system_InputSystem.VK_Q))) * time.dt;
    this._dKeyMoveZ = (Number(input.keyState(input_system_InputSystem.VK_W)) - Number(input.keyState(input_system_InputSystem.VK_S))) * time.dt;
    this._dDollying = input.wheelY * 0.0005;
    this.state &= ~orbit_system_OrbitSystem.ALL;

    if (input.pointers.length === 0) {
      return;
    }

    const pointer = input.pointers[0];

    if (pointer.type === 'mouse') {
      if (pointer.state & Pointer.LBUTTON && pointer.state & Pointer.RBUTTON) {
        this._dDollying = pointer.dy * 0.005;
      } else if (pointer.state & Pointer.LBUTTON) {
        this._dPolar = pointer.dy * 0.005;
        this._dAzimuthal = -pointer.dx * 0.005;
      } else if (pointer.state & Pointer.RBUTTON) {
        this._dMoveX = -pointer.dx * 0.001;
        this._dMoveY = pointer.dy * 0.001;
      }
    }

    if (pointer.type === 'touch') {
      if (input.pointers[1] === undefined || input.pointers[1].type !== 'touch') {
        this._dPolar = pointer.dy * 0.005;
        this._dAzimuthal = -pointer.dx * 0.005;
      } else {
        const pointer2 = input.pointers[1];
        const gestureTypeMove = pointer.dx * pointer2.dx + pointer.dy * pointer2.dy >= 0;

        if (gestureTypeMove) {
          this._dMoveX = -pointer.dx * 0.001;
          this._dMoveY = pointer.dy * 0.001;
        } else {
          let x = pointer2.x - pointer.x;
          let y = pointer2.y - pointer.y;
          const startDistance = Math.sqrt(x * x + y * y);
          x += pointer2.dx - pointer.dx;
          y += pointer2.dy - pointer.dy;
          const endDistance = Math.sqrt(x * x + y * y);
          this._dDollying = (startDistance - endDistance) * 0.005;
        }
      }
    }

    if (this._dMoveX !== 0 || this._dMoveY !== 0 || this._dMoveZ !== 0) {
      this.state |= orbit_system_OrbitSystem.MOVED;
    }

    if (this._dKeyMoveX !== 0 || this._dKeyMoveY !== 0 || this._dKeyMoveZ !== 0) {
      this.state |= orbit_system_OrbitSystem.KEYMOVED;
    }

    if (this._dPolar !== 0 || this._dAzimuthal !== 0) {
      this.state |= orbit_system_OrbitSystem.ROTATED;
    }

    if (this._dDollying !== 0) {
      this.state |= orbit_system_OrbitSystem.DOLLIED;
    }
  }

  onUpdate(core) {
    const entityManager = core.currentRequest.scene.entityManager;
    const storage = entityManager.getComponentStorage(orbit_component_Orbit);

    for (const _ref of storage.entries()) {
      var _ref2 = orbit_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const orbit = _ref2[1];

      if (!(orbit.state & orbit_component_Orbit.ENABLED)) {
        continue;
      }

      if (orbit.state & orbit_component_Orbit.KEYBOARD) {
        this._dMoveX += this._dKeyMoveX;
        this._dMoveY += this._dKeyMoveY;
        this._dMoveZ += this._dKeyMoveZ;
      }

      if (!(orbit.state & orbit_component_Orbit.MOVING)) {
        this._dMoveX = 0;
        this._dMoveY = 0;
        this._dMoveZ = 0;
      }

      orbit.state &= ~orbit_component_Orbit.DAMPED;

      if (orbit.state & orbit_component_Orbit.DAMPING) {
        const dtFactor = Math.pow(orbit.dampingFactor, this._timeSystem.dt * 60);
        const esc = 0.0001;

        if (this._dMoveX !== 0) {
          orbit.dampingMX = this._dMoveX;
        } else {
          orbit.dampingMX *= dtFactor;

          if (Math.abs(orbit.dampingMX) < esc) {
            orbit.dampingMX = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dMoveX = orbit.dampingMX;
        }

        if (this._dMoveY !== 0) {
          orbit.dampingMY = this._dMoveY;
        } else {
          orbit.dampingMY *= dtFactor;

          if (Math.abs(orbit.dampingMY) < esc) {
            orbit.dampingMY = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dMoveY = orbit.dampingMY;
        }

        if (this._dMoveZ !== 0) {
          orbit.dampingMZ = this._dMoveZ;
        } else {
          orbit.dampingMZ *= dtFactor;

          if (Math.abs(orbit.dampingMZ) < esc) {
            orbit.dampingMZ = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dMoveZ = orbit.dampingMZ;
        }

        if (this._dPolar !== 0) {
          orbit.dampingRP = this._dPolar;
        } else {
          orbit.dampingRP *= dtFactor;

          if (Math.abs(orbit.dampingRP) < esc) {
            orbit.dampingRP = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dPolar = orbit.dampingRP;
        }

        if (this._dAzimuthal !== 0) {
          orbit.dampingRA = this._dAzimuthal;
        } else {
          orbit.dampingRA *= dtFactor;

          if (Math.abs(orbit.dampingRA) < esc) {
            orbit.dampingRA = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dAzimuthal = orbit.dampingRA;
        }

        if (this._dDollying !== 0) {
          orbit.dampingDG = this._dDollying;
        } else {
          orbit.dampingDG *= dtFactor;

          if (Math.abs(orbit.dampingDG) < esc) {
            orbit.dampingDG = 0;
          } else {
            orbit.state |= orbit_component_Orbit.DAMPED;
          }

          this._dDollying = orbit.dampingDG;
        }
      }

      if (orbit.state & orbit_component_Orbit.POLAR) {
        orbit.polar += this._dPolar * orbit.rotateSpeed;
      }

      if (orbit.state & orbit_component_Orbit.AZIMUTHAL) {
        orbit.azimuthal += this._dAzimuthal * orbit.rotateSpeed;
      }

      orbit.polar %= PI2;
      orbit.azimuthal %= PI2;
      orbit.polar = Math.max(Math.min(orbit.polar, orbit.maxPolar), orbit.minPolar);
      orbit.azimuthal = Math.max(Math.min(orbit.azimuthal, orbit.maxAzimuthal), orbit.minAzimuthal);

      if (orbit.state & orbit_component_Orbit.DOLLYING) {
        const dollying = Math.log(orbit.distance) + this._dDollying * orbit.dollyingSpeed;
        orbit.distance = Math.pow(Math.E, dollying);
      }

      orbit.distance = Math.max(Math.min(orbit.distance, orbit.maxDistance), orbit.minDistance);

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, orbit_system_lateUpdateClasses, orbit_system_components),
            _entityManager$getEnt2 = orbit_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      transform.orientation.fromRotation(orbit.polar, leftVector).rotate(orbit.azimuthal, upVector);
      targetVector.set(1, 0, 0).applyQuaternion(transform.orientation).multiplyNumber(this._dMoveX * orbit.movingSpeed * orbit.distance);
      orbit_system_tempVector.set(0, 1, 0).applyQuaternion(transform.orientation).multiplyNumber(this._dMoveY * orbit.movingSpeed * orbit.distance);
      targetVector.add(orbit_system_tempVector);
      orbit_system_tempVector.set(0, 0, -1).applyQuaternion(transform.orientation).multiplyNumber(this._dMoveZ * orbit.movingSpeed * orbit.distance);
      targetVector.add(orbit_system_tempVector);
      orbit.target.x += targetVector.x;
      orbit.target.y += targetVector.y;
      orbit.target.z += targetVector.z;
      transform.position.set(0, 0, 1).applyQuaternion(transform.orientation).multiplyNumber(orbit.distance).add(orbit.target);
      transform.state |= transform_component_Transform.StateMask.UPDATE_LOCAL | transform_component_Transform.StateMask.UPDATE_WORLD;
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = orbit_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([orbit_component_Orbit]),
            _srcNode$getComponent2 = orbit_system_slicedToArray(_srcNode$getComponent, 1),
            srcOrbit = _srcNode$getComponent2[0];

      if (srcOrbit === null) {
        continue;
      }

      const dstOrbit = srcOrbit.clone();
      dstNode.attach(dstOrbit);
    }
  }

  static positionToSpherical(position, target) {
    orbit_system_tempVector.copy(target).subtract(position);
    const result = {
      polar: 0,
      azimuthal: 0,
      distance: 0
    };
    result.distance = orbit_system_tempVector.length;
    result.polar = -Math.asin(orbit_system_tempVector.y / result.distance);
    result.azimuthal = -Math.atan2(orbit_system_tempVector.x, -orbit_system_tempVector.z);
    return result;
  }

}
orbit_system_OrbitSystem.ID = 'orbit';
orbit_system_OrbitSystem.ALL = 0x0F00;
orbit_system_OrbitSystem.MOVED = 0x0100;
orbit_system_OrbitSystem.ROTATED = 0x0200;
orbit_system_OrbitSystem.DOLLIED = 0x0400;
orbit_system_OrbitSystem.KEYMOVED = 0x0800;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/screen-system/utils.js
const parseSize = (computedStyleSize, pixelRatio = 1) => Math.round(parseFloat(computedStyleSize) * pixelRatio);
const scalePixelSize = (styleSize, pixelRatio = 1) => {
  return styleSize.replace(/([\d.]+)px/g, (match, value) => `${value * pixelRatio}px`);
};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/screen-system/index.js


class screen_system_ScreenSystem extends System {
  constructor(core) {
    super();
    this._clientBrowserWidth = 0;
    this._clientBrowserHeight = 0;
    this._browserWidth = 0;
    this._browserHeight = 0;
    this._deviceWidth = 1;
    this._deviceHeight = 1;
    this._devicePixelRatio = window.devicePixelRatio || 1;

    this._getRestrictedDeviceSize = (() => {
      const sizeTuple = [0, 0];
      return renderRequest => {
        const supposedWidth = this._deviceWidth;
        const supposedHeight = this._deviceHeight;

        if (supposedWidth <= renderRequest.maxResolutionSize && supposedHeight <= renderRequest.maxResolutionSize) {
          sizeTuple[0] = Math.round(supposedWidth);
          sizeTuple[1] = Math.round(supposedHeight);
          return sizeTuple;
        }

        const aspect = supposedWidth / supposedHeight;

        if (supposedWidth > supposedHeight) {
          const finalWidth = renderRequest.maxResolutionSize;
          const finalHeight = finalWidth / aspect;
          sizeTuple[0] = Math.round(finalWidth);
          sizeTuple[1] = Math.round(finalHeight);
          return sizeTuple;
        }

        const finalHeight = renderRequest.maxResolutionSize;
        const finalWidth = finalHeight * aspect;
        sizeTuple[0] = Math.round(finalWidth);
        sizeTuple[1] = Math.round(finalHeight);
        return sizeTuple;
      };
    })();

    core.regSystemEvent('onFrameStart', this, -900);

    this._prepareHtmlElements(core.domContainer, core.renderer.canvas);

    this._viewportElement = this._createViewportElement(core.domContainer);
  }

  get pixelRatio() {
    return this._devicePixelRatio;
  }

  get browserWidth() {
    return this._browserWidth;
  }

  get browserHeight() {
    return this._browserHeight;
  }

  get deviceWidth() {
    return this._deviceWidth;
  }

  get deviceHeight() {
    return this._deviceHeight;
  }

  onFrameStart(core) {
    core.renderer._pixelRatio = 1;
    const canvas = core.renderer.canvas;

    const isScreenResized = this._updateSizes(canvas);

    if (isScreenResized) {
      this.state |= screen_system_ScreenSystem.RESIZED;
    } else {
      this.state &= ~screen_system_ScreenSystem.RESIZED;
    }

    for (const renderRequest of core.renderRequests) {
      if (!renderRequest.enabled) {
        continue;
      }

      if (!renderRequest.autoResize) {
        continue;
      }

      const extraPixelRatio = renderRequest.extraPixelRatio;

      const restrictedDeviceSize = this._getRestrictedDeviceSize(renderRequest);

      const finalWidth = restrictedDeviceSize[0] * extraPixelRatio;
      const finalHeight = restrictedDeviceSize[1] * extraPixelRatio;
      const isRequestResized = renderRequest.width !== finalWidth || renderRequest.height !== finalHeight;
      renderRequest.width = finalWidth;
      renderRequest.height = finalHeight;

      if (renderRequest.renderTarget === null) {
        if (canvas.width !== finalWidth || canvas.height !== finalHeight) {
          core.renderer.resize(finalWidth, finalHeight, false);
        }
      } else if (renderRequest.renderTarget.width !== finalWidth || renderRequest.renderTarget.height !== finalHeight) {
        renderRequest.renderTarget.resize(finalWidth, finalHeight);
      }

      if (isRequestResized || renderRequest.needsViewportUpdate) {
        renderRequest.needsViewportUpdate = false;

        this._updateViewport(renderRequest, restrictedDeviceSize);
      }
    }
  }

  _updateSizes(canvas) {
    const isClientSizeChanged = this._clientBrowserWidth !== canvas.clientWidth || this._clientBrowserHeight !== canvas.clientHeight;
    this._clientBrowserWidth = canvas.clientWidth;
    this._clientBrowserHeight = canvas.clientHeight;
    let browserWidth;
    let browserHeight;

    if (isClientSizeChanged) {
      const computedStyle = window.getComputedStyle(canvas);
      browserWidth = parseFloat(computedStyle.width);
      browserHeight = parseFloat(computedStyle.height);
    } else {
      browserWidth = this._browserWidth;
      browserHeight = this._browserHeight;
    }

    const devicePixelRatio = window.devicePixelRatio || 1;
    const isResized = browserWidth !== this._browserWidth || browserHeight !== this._browserHeight || this._devicePixelRatio !== devicePixelRatio;
    this._browserWidth = browserWidth;
    this._browserHeight = browserHeight;
    this._devicePixelRatio = devicePixelRatio;
    const deviceWidth = Math.max(Math.round(browserWidth * devicePixelRatio), 1);
    const deviceHeight = Math.max(Math.round(browserHeight * devicePixelRatio), 1);
    this._deviceWidth = deviceWidth;
    this._deviceHeight = deviceHeight;
    return isResized;
  }

  _updateViewport(renderRequest, restrictedDeviceSize) {
    const viewportElement = this._viewportElement;
    const extraPixelRatio = renderRequest.extraPixelRatio;
    Object.assign(viewportElement.parentElement.style, {
      pointerEvents: 'none',
      position: 'absolute',
      visibility: 'hidden',
      left: '0',
      top: '0',
      width: restrictedDeviceSize[0] * extraPixelRatio + 'px',
      height: restrictedDeviceSize[1] * extraPixelRatio + 'px'
    });
    const restrictedSizeAspect = restrictedDeviceSize[0] / this._deviceWidth;
    const cssPixelRatio = renderRequest.viewportStyle.pixelMode === 'browser' ? restrictedSizeAspect * this._devicePixelRatio * extraPixelRatio : extraPixelRatio;
    const preparedStyle = Object.entries(renderRequest.viewportStyle).reduce((result, [key, value]) => {
      if (value !== undefined) {
        result[key] = scalePixelSize(value, cssPixelRatio);
      }

      return result;
    }, {});
    viewportElement.style.cssText = '';
    Object.assign(viewportElement.style, {
      pointerEvents: 'none',
      position: 'absolute',
      visibility: 'hidden',
      ...preparedStyle
    });
    const computedStyle = window.getComputedStyle(viewportElement);
    const x = parseSize(computedStyle.left);
    const y = parseSize(computedStyle.bottom);
    const width = parseSize(computedStyle.width);
    const height = parseSize(computedStyle.height);
    renderRequest.setViewport(x, y, width, height, false);
  }

  _prepareHtmlElements(domContainer, canvas) {
    domContainer.style.position = 'relative';
    domContainer.style.padding = '0';
    domContainer.style.boxSizing = 'content-box';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';

    if (domContainer.children.length > 1) {
      console.warn('Container DOM element for the canvas should be empty to avoid problems');
    }
  }

  _createViewportElement(domContainer) {
    const viewportContainerElement = document.createElement('div');
    viewportContainerElement.className = 'wge-screen-system-viewport-container';
    domContainer.appendChild(viewportContainerElement);
    const viewportElement = document.createElement('div');
    viewportElement.className = 'wge-screen-system-viewport-inner';
    viewportContainerElement.appendChild(viewportElement);
    return viewportElement;
  }

}
screen_system_ScreenSystem.ID = 'screen';
screen_system_ScreenSystem.RESIZED = 0x0100;
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/sprite-component/index.js



class sprite_component_SpriteRenderable extends renderable_Renderable {
  constructor(material) {
    super(null, material);
    this.renderQueueGroup = RenderQueueGroup.SPRITES;
    this._needsUpdate = true;
  }

  get needsUpdate() {
    return this._needsUpdate;
  }

  set needsUpdate(value) {
    this._needsUpdate = value;
  }

}
class sprite_component_Sprite extends component_Component {
  constructor({
    name = '',
    material
  }) {
    super();
    this.name = name;
    this.extras = undefined;
    this._spriteRenderable = new sprite_component_SpriteRenderable(material);
  }

  getInstancedAttribute(semantic, outVal) {
    return this._spriteRenderable.getInstancedAttribute(semantic, outVal);
  }

  setInstancedAttribute(semantic, inVal) {
    this._spriteRenderable.setInstancedAttribute(semantic, inVal);
  }

  get renderable() {
    return this._spriteRenderable;
  }

  get material() {
    return this._spriteRenderable.material;
  }

  set material(value) {
    this._spriteRenderable.material = value;
  }

  clone(newName) {
    const name = this.name,
          extras = this.extras,
          material = this.material;
    const name_ = newName || name;
    const clone = new sprite_component_Sprite({
      name: name_,
      material
    });
    clone.extras = extras;
    return clone;
  }

  _dispose() {
    this._spriteRenderable.dispose();

    this._spriteRenderable = null;

    super._dispose();
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), this._spriteRenderable.load()]);
  }

  _actuallyUnload() {
    this._spriteRenderable.unload();

    super._actuallyUnload();
  }

}
sprite_component_Sprite.ID = 'sprite';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/sprite-system/index.js
function sprite_system_slicedToArray(arr, i) { return sprite_system_arrayWithHoles(arr) || sprite_system_iterableToArrayLimit(arr, i) || sprite_system_unsupportedIterableToArray(arr, i) || sprite_system_nonIterableRest(); }

function sprite_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sprite_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sprite_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sprite_system_arrayLikeToArray(o, minLen); }

function sprite_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function sprite_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function sprite_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const sprite_system_lateUpdateComponents = [transform_component_Transform];
const sprite_system_position = new lib["n" /* Vector3 */]();
class sprite_system_SpriteSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
    EntityManager.onDetach.subscribe((entityManager, entity, component) => {
      const index = component.index;

      if (sprite_component_Sprite.index === index) {
        const _scene = entityManager._scene;
        const instanceDataManager = _scene.instanceDataManager;
        const _spriteRenderable = component._spriteRenderable;

        if (_spriteRenderable.instanceId !== null) {
          instanceDataManager.deleteInstance(_spriteRenderable);
        }

        _scene._forceUpdateRenderQueue = true;
      }
    });
  }

  onUpdate(core) {
    const screenSquare = core.renderer.screenSquare;
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          frameNumber = _core$currentRequest.frameNumber;
    const instanceDataManager = scene.instanceDataManager,
          entityManager = scene.entityManager,
          _forceUpdateRenderQueue = scene._forceUpdateRenderQueue;

    if (_forceUpdateRenderQueue) {
      scene._lastFrameSceneGraphUpdate = frameNumber;
      scene._forceUpdateRenderQueue = false;
    }

    if (!entityManager.isComponent(sprite_component_Sprite)) {
      return;
    }

    const storage = entityManager.getComponentStorage(sprite_component_Sprite);

    for (const sprite of storage.components()) {
      if (sprite.unloaded) {
        continue;
      }

      const _spriteRenderable = sprite._spriteRenderable;
      const needsUpdate = _spriteRenderable.needsUpdate;

      if (needsUpdate) {
        _spriteRenderable.geometry = screenSquare;
        _spriteRenderable.needsUpdate = false;
      }

      if (_spriteRenderable.instanceId === null || _spriteRenderable._instanceIdentifierExpired) {
        instanceDataManager.addInstance(_spriteRenderable);
        instanceDataManager.setInstanceVisibility(_spriteRenderable, true, false);
        _spriteRenderable._lastUpdateFrameNumber = frameNumber;
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }

      const _customAttributesToWrite = _spriteRenderable._customAttributesToWrite,
            _customAttributesToRead = _spriteRenderable._customAttributesToRead;

      for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
        const _customAttributesToWr = _customAttributesToWrite.pop(),
              semantic = _customAttributesToWr.semantic,
              inVal = _customAttributesToWr.inVal;

        instanceDataManager.setInstancedAttribute(_spriteRenderable, semantic, inVal);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }

      for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
        const _customAttributesToRe = _customAttributesToRead.pop(),
              resolve = _customAttributesToRe.resolve,
              semantic = _customAttributesToRe.semantic,
              outVal = _customAttributesToRe.outVal;

        resolve(instanceDataManager.getInstancedAttribute(_spriteRenderable, semantic, outVal));
      }
    }
  }

  onLateUpdate(core) {
    const _core$currentRequest2 = core.currentRequest,
          scene = _core$currentRequest2.scene,
          frameNumber = _core$currentRequest2.frameNumber;
    const instanceDataManager = scene.instanceDataManager,
          entityManager = scene.entityManager;

    if (!entityManager.isComponent(sprite_component_Sprite)) {
      return;
    }

    const components = [];
    const storage = entityManager.getComponentStorage(sprite_component_Sprite);

    for (const _ref of storage.entries()) {
      var _ref2 = sprite_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const sprite = _ref2[1];

      if (sprite.unloaded) {
        continue;
      }

      const _entityManager$getEnt = entityManager.getEntityComponents(entity, sprite_system_lateUpdateComponents, components),
            _entityManager$getEnt2 = sprite_system_slicedToArray(_entityManager$getEnt, 1),
            transform = _entityManager$getEnt2[0];

      const state = transform.state,
            worldMatrix = transform.worldMatrix;
      const _spriteRenderable = sprite._spriteRenderable;

      if ((state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0 || _spriteRenderable.lastUpdateFrameNumber === frameNumber) {
        const instanceId = _spriteRenderable.instanceId,
              instanceIndex = _spriteRenderable.instanceIndex,
              id = _spriteRenderable.id;

        const _instanceDataManager$ = instanceDataManager.getInstanceRenderable(instanceId),
              batchIdx = _instanceDataManager$.batchIdx;

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
        instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
        instanceDataManager.storeRenderableIdentifier(globalIndex, id);
        worldMatrix.translationPaste(sprite_system_position);
        instanceDataManager.storeCenter(sprite_system_position, globalIndex);
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const _copyContext$nodeToNo = copyContext.nodeToNode,
          nodeToNode = _copyContext$nodeToNo === void 0 ? new Map() : _copyContext$nodeToNo,
          _copyContext$cloneMat = copyContext.cloneMaterials,
          cloneMaterials = _copyContext$cloneMat === void 0 ? false : _copyContext$cloneMat;
    const materialToMaterial = new Map();

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = sprite_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([sprite_component_Sprite]),
            _srcNode$getComponent2 = sprite_system_slicedToArray(_srcNode$getComponent, 1),
            srcSprite = _srcNode$getComponent2[0];

      if (srcSprite === null) {
        continue;
      }

      const dstSprite = srcSprite.clone();

      if (cloneMaterials) {
        const srcMaterial = srcSprite.material;
        let dstMaterial = materialToMaterial.get(srcMaterial);

        if (dstMaterial === undefined) {
          dstMaterial = srcMaterial.clone();
          materialToMaterial.set(srcMaterial, dstMaterial);
        }

        dstSprite._spriteRenderable.material = dstMaterial;
      }

      dstNode.attach(dstSprite);
    }
  }

}
sprite_system_SpriteSystem.ID = 'sprite';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/transform-system/index.js
function transform_system_slicedToArray(arr, i) { return transform_system_arrayWithHoles(arr) || transform_system_iterableToArrayLimit(arr, i) || transform_system_unsupportedIterableToArray(arr, i) || transform_system_nonIterableRest(); }

function transform_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function transform_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return transform_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transform_system_arrayLikeToArray(o, minLen); }

function transform_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function transform_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function transform_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






const transform_system_splitTransform = new lib["d" /* AffineSplitTransform3 */]();
const reverseTransform = new lib["b" /* AffineMatrix3 */]();

class transform_system_Visitor {
  constructor(visitCallback) {
    this._renderables = [];
    this._matrix = new lib["b" /* AffineMatrix3 */]();
    this._visit = visitCallback;
    this._classes = [transform_component_Transform];
    this._renderableClasses = [mesh_component_Mesh, sprite_component_Sprite];
    this._components = [];
    this._renderables = [];
    this._matrix = new lib["b" /* AffineMatrix3 */]();
  }

  _apply(node, entities, instances) {
    const _classes = this._classes,
          _components = this._components,
          _visit = this._visit,
          _matrix = this._matrix;
    const entity = node.entity,
          children = node.children,
          parent = node.parent;

    const _entities$getEntityCo = entities.getEntityComponents(entity, _classes, _components),
          _entities$getEntityCo2 = transform_system_slicedToArray(_entities$getEntityCo, 1),
          _entities$getEntityCo3 = _entities$getEntityCo2[0],
          xfrm = _entities$getEntityCo3 === void 0 ? null : _entities$getEntityCo3;

    if (xfrm === null) {
      return;
    }

    const _ref = parent !== null ? entities.getEntityComponents(parent.entity, _classes, _components) : (_components[0] = null, _components),
          _ref2 = transform_system_slicedToArray(_ref, 1),
          parentXfrm = _ref2[0];

    if (xfrm.state === transform_component_Transform.StateMask.UPDATE_ALL) {
      const _renderableClasses = this._renderableClasses,
            _renderables = this._renderables;

      const _entities$getEntityCo4 = entities.getEntityComponents(entity, _renderableClasses, _renderables),
            _entities$getEntityCo5 = transform_system_slicedToArray(_entities$getEntityCo4, 2),
            mesh = _entities$getEntityCo5[0],
            sprite = _entities$getEntityCo5[1];

      if (mesh !== null) {
        const sm = mesh.getSubMesh(0);
        const instanceId = sm.instanceId,
              instanceIdentifierExpired = sm.instanceIdentifierExpired,
              instanceIndex = sm.instanceIndex;

        this._readWorldMatrix(_matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex);
      } else if (sprite !== null) {
        const renderable = sprite.renderable;
        const instanceId = renderable.instanceId,
              instanceIdentifierExpired = renderable.instanceIdentifierExpired,
              instanceIndex = renderable.instanceIndex;

        this._readWorldMatrix(_matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex);
      } else {
        this._readWorldMatrix(_matrix, instances, null, false, 0);
      }
    }

    _visit(xfrm, parentXfrm, _matrix);

    for (const child of children) {
      this._apply(child, entities, instances);
    }
  }

  apply(scene) {
    const root = scene.root,
          entityManager = scene.entityManager,
          instanceDataManager = scene.instanceDataManager;

    this._apply(root, entityManager, instanceDataManager);
  }

  _readWorldMatrix(matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex) {
    if (instanceId === null || instanceIdentifierExpired) {
      matrix.fromNumber(1.0);
    } else {
      const _instances$getInstanc = instances.getInstanceRenderable(instanceId),
            batchIdx = _instances$getInstanc.batchIdx;

      const globalIndex = instances.getInstanceGlobalIndex(batchIdx, instanceIndex);
      instances.readWorldTransform(matrix, globalIndex);
    }
  }

}

const visitor = new transform_system_Visitor((xfrm, xfrmParent, _matrix) => {
  if (xfrm.state === transform_component_Transform.StateMask.UPDATE_ALL) {
    xfrm.worldMatrix.copy(_matrix);
    xfrm.state = transform_component_Transform.StateMask.UPDATE_LOCAL | transform_component_Transform.StateMask.UPDATE_COMPONENTS;
  }

  if ((xfrm.state & transform_component_Transform.StateMask.UPDATE_LOCAL) !== 0 && (xfrm.state & transform_component_Transform.StateMask.UPDATE_COMPONENTS) === 0) {
    const position = xfrm.position,
          scale = xfrm.scale,
          orientation = xfrm.orientation,
          matrix = xfrm.matrix;
    transform_system_splitTransform.translation.copy(position);
    transform_system_splitTransform.scaling.copy(scale);
    transform_system_splitTransform.quaternion.copy(orientation);
    matrix.fromSplitTransform(transform_system_splitTransform);
    xfrm.state = transform_component_Transform.StateMask.UPDATE_WORLD;
  } else if ((xfrm.state & transform_component_Transform.StateMask.UPDATE_LOCAL) === 0 && (xfrm.state & transform_component_Transform.StateMask.UPDATE_COMPONENTS) !== 0) {
    const position = xfrm.position,
          scale = xfrm.scale,
          orientation = xfrm.orientation,
          matrix = xfrm.matrix;
    transform_system_splitTransform.fromMatrix(matrix);
    position.copy(transform_system_splitTransform.translation);
    scale.copy(transform_system_splitTransform.scaling);
    orientation.copy(transform_system_splitTransform.quaternion);
    xfrm.state = transform_component_Transform.StateMask.UPDATE_WORLD;
  } else if ((xfrm.state & transform_component_Transform.StateMask.UPDATE_LOCAL) !== 0 && (xfrm.state & transform_component_Transform.StateMask.UPDATE_COMPONENTS) !== 0 && (xfrm.state & transform_component_Transform.StateMask.UPDATE_WORLD) === 0) {
    const position = xfrm.position,
          scale = xfrm.scale,
          orientation = xfrm.orientation,
          matrix = xfrm.matrix,
          worldMatrix = xfrm.worldMatrix;

    if (xfrmParent === null) {
      matrix.copy(worldMatrix);
    } else {
      reverseTransform.copy(xfrmParent.worldMatrix).invert();
      matrix.copy(worldMatrix);
      matrix.preMultiply(reverseTransform);
    }

    transform_system_splitTransform.fromMatrix(matrix);
    position.copy(transform_system_splitTransform.translation);
    scale.copy(transform_system_splitTransform.scaling);
    orientation.copy(transform_system_splitTransform.quaternion);
    xfrm.state = transform_component_Transform.StateMask.UPDATE_NOTHING;
  }

  const parentUpdated = xfrmParent === null ? false : (xfrmParent.state & transform_component_Transform.StateMask.UPDATE_WORLD) !== 0;

  if (xfrm.state === transform_component_Transform.StateMask.UPDATE_WORLD || parentUpdated) {
    const matrix = xfrm.matrix,
          worldMatrix = xfrm.worldMatrix;

    if (xfrmParent === null) {
      worldMatrix.copy(matrix);
    } else {
      worldMatrix.copy(matrix).multiply(xfrmParent.worldMatrix);
    }

    xfrm.state = transform_component_Transform.StateMask.UPDATE_WORLD;
  }
});
class transform_system_TransformSystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
    core.regSystemEvent('onLateUpdate', this);
  }

  onUpdate(core) {
    const scene = core.currentRequest.scene;
    visitor.apply(scene);
  }

  onLateUpdate(core) {
    const scene = core.currentRequest.scene;
    const entityManager = scene.entityManager;
    const storage = entityManager.getComponentStorage(transform_component_Transform);

    for (const transform of storage.components()) {
      transform.state = transform_component_Transform.StateMask.UPDATE_NOTHING;
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const nodeToNode = copyContext.nodeToNode;

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = transform_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents([transform_component_Transform]),
            _srcNode$getComponent2 = transform_system_slicedToArray(_srcNode$getComponent, 1),
            srcTransform = _srcNode$getComponent2[0];

      const _dstNode$getComponent = dstNode.getComponents([transform_component_Transform]),
            _dstNode$getComponent2 = transform_system_slicedToArray(_dstNode$getComponent, 1),
            dstTransform = _dstNode$getComponent2[0];

      if (dstTransform === null && srcTransform !== null) {
        dstNode.attach(srcTransform.clone());
      } else if (dstTransform !== null && srcTransform !== null) {
        dstTransform.position.copy(srcTransform.position);
        dstTransform.scale.copy(srcTransform.scale);
        dstTransform.orientation.copy(srcTransform.orientation);
        dstTransform.matrix.copy(srcTransform.matrix);
        dstTransform.state = srcTransform.state | transform_component_Transform.StateMask.UPDATE_WORLD;
      }
    }
  }

}
transform_system_TransformSystem.ID = 'transform';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/components/visibility-component/index.js

class visibility_component_Visibility extends component_Component {
  constructor(options = {}) {
    super();
    const _options$enableCullin = options.enableCulling,
          enableCulling = _options$enableCullin === void 0 ? true : _options$enableCullin,
          _options$visible = options.visible,
          visible = _options$visible === void 0 ? true : _options$visible;
    this._enableCulling = enableCulling;
    this._visible = visible;
    this._needsUpdate = true;
  }

  get needsUpdate() {
    return this._needsUpdate;
  }

  get visible() {
    return this._visible;
  }

  set visible(value) {
    this._visible = value;
    this._needsUpdate = true;
  }

  get enableCulling() {
    return this._enableCulling;
  }

  set enableCulling(value) {
    this._enableCulling = value;
    this._needsUpdate = true;
  }

  clone() {
    const visible = this.visible,
          enableCulling = this.enableCulling;
    return new visibility_component_Visibility({
      enableCulling,
      visible
    });
  }

}
visibility_component_Visibility.ID = 'visibility';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/systems/visibility-system/index.js
function visibility_system_slicedToArray(arr, i) { return visibility_system_arrayWithHoles(arr) || visibility_system_iterableToArrayLimit(arr, i) || visibility_system_unsupportedIterableToArray(arr, i) || visibility_system_nonIterableRest(); }

function visibility_system_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function visibility_system_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return visibility_system_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return visibility_system_arrayLikeToArray(o, minLen); }

function visibility_system_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function visibility_system_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function visibility_system_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






const updateComponemts1 = [mesh_component_Mesh];
const updateComponemts2 = [sprite_component_Sprite];
const updateComponemts3 = [line_component_Line];
class visibility_system_VisibilitySystem extends System {
  constructor(core) {
    super();
    core.regSystemEvent('onUpdate', this);
  }

  onUpdate(core) {
    const _core$currentRequest = core.currentRequest,
          scene = _core$currentRequest.scene,
          frameNumber = _core$currentRequest.frameNumber;
    const entityManager = scene.entityManager,
          instanceDataManager = scene.instanceDataManager;

    if (!entityManager.isComponent(visibility_component_Visibility)) {
      return;
    }

    const hasMeshes = entityManager.isComponent(mesh_component_Mesh);
    const hasSprites = entityManager.isComponent(sprite_component_Sprite);
    const hasLines = entityManager.isComponent(line_component_Line);
    const components = [];
    const storage = entityManager.getComponentStorage(visibility_component_Visibility);

    for (const _ref of storage.entries()) {
      var _ref2 = visibility_system_slicedToArray(_ref, 2);

      const entity = _ref2[0];
      const visibility = _ref2[1];
      const needsUpdate = visibility.needsUpdate;

      if (needsUpdate) {
        scene._lastFrameSceneGraphUpdate = frameNumber;
      }

      if (hasMeshes) {
        const _entityManager$getEnt = entityManager.getEntityComponents(entity, updateComponemts1, components),
              _entityManager$getEnt2 = visibility_system_slicedToArray(_entityManager$getEnt, 1),
              mesh = _entityManager$getEnt2[0];

        if (mesh !== null) {
          const subMeshCount = mesh.subMeshCount;

          for (let i = 0; i < subMeshCount; i++) {
            const subMesh = mesh.getSubMesh(i);
            const lastUpdateFrameNumber = subMesh.lastUpdateFrameNumber,
                  unloaded = subMesh.unloaded;

            if (unloaded) {
              continue;
            }

            if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
              const visible = visibility.visible,
                    enabled = visibility.enableCulling;
              instanceDataManager.setInstanceVisibility(subMesh, visible, enabled);
            }
          }
        }
      }

      if (hasSprites) {
        const _entityManager$getEnt3 = entityManager.getEntityComponents(entity, updateComponemts2, components),
              _entityManager$getEnt4 = visibility_system_slicedToArray(_entityManager$getEnt3, 1),
              sprite = _entityManager$getEnt4[0];

        if (sprite !== null && !sprite.unloaded) {
          const _spriteRenderable = sprite._spriteRenderable;
          const lastUpdateFrameNumber = _spriteRenderable.lastUpdateFrameNumber;

          if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
            const visible = visibility.visible;
            instanceDataManager.setInstanceVisibility(_spriteRenderable, visible, false);
          }
        }
      }

      if (hasLines) {
        const _entityManager$getEnt5 = entityManager.getEntityComponents(entity, updateComponemts3, components),
              _entityManager$getEnt6 = visibility_system_slicedToArray(_entityManager$getEnt5, 1),
              line = _entityManager$getEnt6[0];

        if (line !== null && !line.unloaded) {
          const _lineRenderable = line._lineRenderable;
          const lastUpdateFrameNumber = _lineRenderable.lastUpdateFrameNumber;

          if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
            const visible = visibility.visible,
                  enabled = visibility.enableCulling;
            instanceDataManager.setInstanceVisibility(_lineRenderable, visible, enabled);
          }
        }
      }

      visibility._needsUpdate = false;
    }
  }

  updateScene(task) {
    const type = task.type,
          data = task.data;

    switch (type) {
      case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
      case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
        this._copyFromScene(data);

        break;

      default:
    }
  }

  _copyFromScene({
    copyContext
  }) {
    const _copyContext$nodeToNo = copyContext.nodeToNode,
          nodeToNode = _copyContext$nodeToNo === void 0 ? new Map() : _copyContext$nodeToNo;
    const classes = [visibility_component_Visibility];

    for (const _ref3 of nodeToNode.entries()) {
      var _ref4 = visibility_system_slicedToArray(_ref3, 2);

      const srcNode = _ref4[0];
      const dstNode = _ref4[1];

      const _srcNode$getComponent = srcNode.getComponents(classes),
            _srcNode$getComponent2 = visibility_system_slicedToArray(_srcNode$getComponent, 1),
            srcVisibility = _srcNode$getComponent2[0];

      let _dstNode$getComponent = dstNode.getComponents(classes),
          _dstNode$getComponent2 = visibility_system_slicedToArray(_dstNode$getComponent, 1),
          dstVisibility = _dstNode$getComponent2[0];

      if (srcVisibility === null) {
        continue;
      }

      dstVisibility = srcVisibility.clone();
      dstNode.attach(dstVisibility);
    }
  }

}
visibility_system_VisibilitySystem.ID = 'visibility';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/loaders/image-loader/index.js

class image_loader_ImageLoader extends Loader {
  async load(url) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.addEventListener('load', () => resolve(image));
      image.addEventListener('error', e => reject(e));
      image.src = url;
    });
  }

  async parse(id, object) {
    this.core.addResource('image', id, object);
    return Promise.resolve(object);
  }

}
image_loader_ImageLoader.ID = 'image';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/loaders/json-loader/index.js

class json_loader_JSONLoader extends Loader {
  async load(url) {
    return super.load(url);
  }

  async parse(id, object) {
    this.core.addResource('json', id, object);
    return Promise.resolve(object);
  }

}
json_loader_JSONLoader.ID = 'json';
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/resources/vertex-buffer-resource/index.js
function vertex_buffer_resource_slicedToArray(arr, i) { return vertex_buffer_resource_arrayWithHoles(arr) || vertex_buffer_resource_iterableToArrayLimit(arr, i) || vertex_buffer_resource_unsupportedIterableToArray(arr, i) || vertex_buffer_resource_nonIterableRest(); }

function vertex_buffer_resource_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function vertex_buffer_resource_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return vertex_buffer_resource_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return vertex_buffer_resource_arrayLikeToArray(o, minLen); }

function vertex_buffer_resource_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function vertex_buffer_resource_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function vertex_buffer_resource_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



class vertex_buffer_resource_VertexBuffer extends resource_Resource {
  constructor({
    buffer,
    byteOffset = 0,
    byteLength,
    createEmpty = false
  }) {
    super();
    this.empty = createEmpty;
    this.ranges = [];
    this.subdatas = [];
    this.byteOffset = byteOffset;
    this.size = byteLength - byteOffset;
    this.ranges.push({
      offset: 0,
      size: this.size
    });
    this.buffer = createEmpty ? null : buffer instanceof ArrayBuffer ? buffer : new ArrayBuffer(byteLength);
  }

  allocMemory(type, countElements) {
    let size = type.BYTES_PER_ELEMENT * countElements;
    const align = 8;
    size += size % align === 0 ? 0 : align - size % align;
    const i = search_bounds_default.a.ge(this.ranges, size, (lhs, rhs) => {
      return lhs.size - rhs;
    });

    if (i >= this.ranges.length) {
      throw new Error(`${this.constructor.name} can not allocate ${size} bytes of memory`);
    }

    const _this$ranges$splice = this.ranges.splice(i, 1),
          _this$ranges$splice2 = vertex_buffer_resource_slicedToArray(_this$ranges$splice, 1),
          range = _this$ranges$splice2[0];

    if (range.size > size) {
      const offset = range.offset + size;
      const newSize = range.size - size;
      const j = search_bounds_default.a.ge(this.ranges, newSize, (lhs, rhs) => {
        return lhs.size - rhs;
      });

      if (j < this.ranges.length) {
        this.ranges.splice(j, 0, {
          offset,
          size: newSize
        });
      } else {
        this.ranges.push({
          offset,
          size: newSize
        });
      }
    }

    const subdatas = this.subdatas,
          empty = this.empty;

    if (!empty) {
      let subdataRangeFound = false;

      for (const subdata of subdatas) {
        if (subdata.offset + subdata.size === range.offset + this.byteOffset) {
          subdata.size += size;
          subdataRangeFound = true;
          break;
        }
      }

      if (!subdataRangeFound) {
        this.subdatas.push({
          offset: this.byteOffset + range.offset,
          size
        });
      }
    }

    return empty ? {
      byteOffset: this.byteOffset + range.offset,
      byteLength: size
    } : new type(this.buffer, this.byteOffset + range.offset, countElements);
  }

  releaseMemory(memoryBlock) {
    let size = memoryBlock.byteLength;
    const align = 8;
    size += size % align === 0 ? 0 : align - size % align;
    const offset = memoryBlock.byteOffset - this.byteOffset;
    let prevRangeIdx = -1;
    let nextRangeIdx = -1;

    for (let i = 0, len = this.ranges.length; i < len; i++) {
      const range = this.ranges[i];

      if (range.offset + range.size === offset) {
        prevRangeIdx = i;
      }

      if (offset + size === range.offset) {
        nextRangeIdx = i;
      }

      if (prevRangeIdx >= 0 && nextRangeIdx >= 0) {
        break;
      }
    }

    let newOffset = 0;
    let newSize = 0;

    if (prevRangeIdx >= 0 && nextRangeIdx >= 0) {
      const prevRange = this.ranges[prevRangeIdx];
      const nextRange = this.ranges[nextRangeIdx];
      this.ranges.splice(prevRangeIdx, 1);
      this.ranges.splice(prevRangeIdx < nextRangeIdx ? nextRangeIdx - 1 : nextRangeIdx, 1);
      newOffset = prevRange.offset;
      newSize = size + prevRange.size + nextRange.size;
    } else if (prevRangeIdx < 0 && nextRangeIdx >= 0) {
      const _this$ranges$splice3 = this.ranges.splice(nextRangeIdx, 1),
            _this$ranges$splice4 = vertex_buffer_resource_slicedToArray(_this$ranges$splice3, 1),
            nextRange = _this$ranges$splice4[0];

      newOffset = offset;
      newSize = size + nextRange.size;
    } else if (prevRangeIdx >= 0 && nextRangeIdx < 0) {
      const _this$ranges$splice5 = this.ranges.splice(prevRangeIdx, 1),
            _this$ranges$splice6 = vertex_buffer_resource_slicedToArray(_this$ranges$splice5, 1),
            prevRange = _this$ranges$splice6[0];

      newOffset = prevRange.offset;
      newSize = size + prevRange.size;
    } else {
      newOffset = offset;
      newSize = size;
    }

    const i = search_bounds_default.a.ge(this.ranges, newSize, (lhs, rhs) => {
      return lhs.size - rhs;
    });

    if (i < this.ranges.length) {
      this.ranges.splice(i, 0, {
        offset: newOffset,
        size: newSize
      });
    } else {
      this.ranges.push({
        offset: newOffset,
        size: newSize
      });
    }
  }

  dispose() {
    this.buffer = null;
  }

  get freeMemorySize() {
    let byteCount = 0;

    for (const r of this.ranges) {
      byteCount += r.size;
    }

    return byteCount;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js


































/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "t", function() { return /* reexport */ functions["s" /* isNaN */]; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ functions["q" /* isFinite */]; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* reexport */ functions["r" /* isInteger */]; });
__webpack_require__.d(__webpack_exports__, "y", function() { return /* reexport */ functions["E" /* sign */]; });
__webpack_require__.d(__webpack_exports__, "x", function() { return /* reexport */ functions["D" /* round */]; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* reexport */ functions["A" /* max */]; });
__webpack_require__.d(__webpack_exports__, "w", function() { return /* reexport */ functions["B" /* min */]; });
__webpack_require__.d(__webpack_exports__, "z", function() { return /* reexport */ functions["H" /* sqrt */]; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ functions["g" /* clamp */]; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ functions["k" /* exp2 */]; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* reexport */ functions["u" /* isPow2 */]; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ functions["f" /* ceilPow2 */]; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ vectors["a" /* Vector2 */]; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ vectors["b" /* Vector3 */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ matrices["a" /* AffineMatrix2 */]; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ matrices["d" /* LinearMatrix3 */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ matrices["b" /* AffineMatrix3 */]; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ matrices["c" /* HomogeneousMatrix3 */]; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ lib_quaternion["a" /* Quaternion */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ AffineSplitTransform2; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ AffineSplitTransform3; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ rectangle_and_box_Box; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ HalfSpace3; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ Ray3; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ rgb_color_RGBColor; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ quaternion_slerper_QuaternionSlerper; });

// UNUSED EXPORTS: MIN_POSITIVE_NUMBER, MAX_FINITE_NUMBER, MIN_SAFE_INTEGER, MAX_SAFE_INTEGER, PI, E, TAU, isSafeInteger, abs, floor, ceil, trunc, fround, hypot, cbrt, pow, exp, expm1, log, log1p, log2, log10, sin, cos, tan, asin, acos, atan, atan2, sinh, cosh, tanh, asinh, acosh, atanh, imul, clz32, rt, sq, cb, exp10, isPow10, floorPow2, floorPow10, ceilPow10, ldexp, frexp, LinearMatrix2, HomogeneousMatrix2, Complex, LinearSplitTransform2, LinearSplitTransform3, Rectangle, Circle, Sphere, HalfSpace2, Ray2, SphericalCoords, NumberCubicHermiteInterpolator, makeCubicHermiteInterpolator, Vector2CubicHermiteInterpolator, Vector3CubicHermiteInterpolator, ComplexCubicHermiteInterpolator, QuaternionCubicHermiteInterpolator, RGBColorCubicHermiteInterpolator, NumberLerper, makeLerper, Vector2Lerper, Vector3Lerper, ComplexLerper, QuaternionLerper, RGBColorLerper

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/constants.js
const MIN_POSITIVE_NUMBER = Number.MIN_VALUE,
      MAX_FINITE_NUMBER = Number.MAX_VALUE,
      MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER,
      MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

const PI = Math.PI,
      E = Math.E;
/**
 * @constant module:@wgetemp/math.TAU
 * @summary 2
 * @type {number}
 */


const TAU = PI * 2;
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/functions.js
var functions = __webpack_require__(5);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/vectors.js
var vectors = __webpack_require__(8);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/matrices.js
var matrices = __webpack_require__(82);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/complex.js
var complex = __webpack_require__(44);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/quaternion.js
var lib_quaternion = __webpack_require__(37);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/generate-function.js
var generate_function = __webpack_require__(96);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/function-property-definer-makers.js
var function_property_definer_makers = __webpack_require__(67);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/make-property-aliaser.js
var make_property_aliaser = __webpack_require__(97);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/to-title-case.js
var to_title_case = __webpack_require__(11);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/split-transforms.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const KINDS = {
  LINEAR: {
    name: 'Linear',
    order: 0
  },
  AFFINE: {
    name: 'Affine',
    order: 1
  }
};

function makeClass(kind, d) {
  const as = [...'xyz'].slice(0, d);

  function defineSet(fg) {
    Object.assign(fg.ctx, d === 2 ? {
      Vector2: vectors["a" /* Vector2 */],
      Complex: complex["a" /* Complex */]
    } : {
      Vector3: vectors["b" /* Vector3 */],
      Quaternion: lib_quaternion["a" /* Quaternion */]
    });
    fg.emit`var scaling=components.scaling`;
    fg.emit`this.scaling=scaling===undefined?${`new Vector${d}().fromNumber(1):scaling.clone()`}`;
    fg.emit`var shearing=components.shearing`;
    fg.emit`this.shearing=shearing===undefined?${d === 2 ? '0:shearing' : 'new Vector3():shearing.clone()'}`;

    if (d === 2) {
      fg.emit`var complex=components.complex`;
      fg.emit`this.complex=complex===undefined?${'new Complex():complex.clone()'}`;
    } else {
      fg.emit`var quaternion=components.quaternion`;
      fg.emit`this.quaternion=quaternion===undefined?${'new Quaternion():quaternion.clone()'}`;
    }

    if (kind !== KINDS.LINEAR) {
      fg.emit`var translation=components.translation`;
      fg.emit`this.translation=translation===undefined?${`new Vector${d}():translation.clone()`}`;
    }
  }

  const Transform = generate_function["a" /* generateFunction */](fg => {
    fg.ctx.none = {};
    fg.name = `${kind.name}SplitTransform${d}`;
    fg.params = ['components'];
    fg.emit`if(components===undefined){components=none}`;
    defineSet(fg);
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Transform.prototype);
  const defineGetter = function_property_definer_makers["a" /* makeGetterDefiner */](Transform.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Transform.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = ['components'];
    defineSet(fg);
    fg.emit`return this`;
  });
  defineMethod(fg => {
    if (d === 2) {
      fg.name = 'fromComplex';
      fg.params = ['complex'];
      fg.emit`var scaling=complex.uniformScaling`;
      fg.emit`this.scaling.fromNumber(scaling)`;
      fg.emit`this.shearing=0`;
      fg.emit`this.complex.copy(complex).divideNumber(scaling)`;
    } else {
      Object.assign(fg.ctx, {
        sqrt: functions["H" /* sqrt */]
      });
      fg.name = 'fromQuaternion';
      fg.params = ['quaternion'];
      fg.emit`var scaling=quaternion.uniformScaling`;
      fg.emit`this.scaling.fromNumber(scaling)`;
      fg.emit`this.shearing.fromNumber(0)`;
      fg.emit`this.quaternion.copy(quaternion).divideNumber(${'sqrt(scaling)'})`;
    }

    if (kind !== KINDS.LINEAR) {
      fg.emit`this.translation.fromNumber(0)`;
    }

    fg.emit`return this`;
  });

  for (const matrixKind of Object.values(KINDS)) {
    if (matrixKind.order > kind.order) {
      continue;
    }

    defineMethod(fg => {
      if (d === 2) {
        Object.assign(fg.ctx, {
          max: functions["A" /* max */],
          abs: functions["a" /* abs */],
          x: new vectors["a" /* Vector2 */](),
          y: new vectors["a" /* Vector2 */](),
          tmp: new vectors["a" /* Vector2 */]()
        });
      } else {
        Object.assign(fg.ctx, {
          max: functions["A" /* max */],
          abs: functions["a" /* abs */],
          sqrt: functions["H" /* sqrt */],
          x: new vectors["b" /* Vector3 */](),
          y: new vectors["b" /* Vector3 */](),
          z: new vectors["b" /* Vector3 */](),
          tmp: new vectors["b" /* Vector3 */]()
        });
      }

      fg.name = `from${matrixKind.name}Matrix`;
      fg.params = ['matrix'];

      for (const a of as) {
        fg.emit`matrix.axis${a.toUpperCase()}Paste(${a})`;
      }

      fg.emit`var maxAbs=max(${as.map(ra => as.map(ca => {
        return `abs(${ra}.${ca})`;
      }))}),invMaxAbs=1/maxAbs`;

      for (const a of as) {
        fg.emit`${a}.multiply(invMaxAbs)`;
      }

      fg.emit`var scaling=this.scaling`;
      fg.emit`scaling.x=x.length`;
      fg.emit`x.divide(scaling.x)`;

      if (d === 2) {
        fg.emit`var shearing=x.dot(y)`;
        fg.emit`y.subtract(tmp.copy(x).multiply(shearing))`;
        fg.emit`scaling.y=y.length`;
        fg.emit`var invScalingY=1/scaling.y`;
        fg.emit`y.multiply(invScalingY)`;
        fg.emit`shearing*=invScalingY`;
        fg.emit`scaling.multiply(maxAbs)`;
        fg.emit`if(x.cross(y)<0){`;
        fg.emit`scaling.y=-scaling.y`;
        fg.emit`shearing=-shearing`;
        fg.emit`}`;
        fg.emit`this.shearing=shearing`;
        fg.emit`this.complex.fromVector(x)`;
      } else {
        fg.emit`var shearing=this.shearing`;
        fg.emit`shearing.z=x.dot(y)`;
        fg.emit`y.subtract(tmp.copy(x).multiply(shearing.z))`;
        fg.emit`scaling.y=y.length`;
        fg.emit`var invScalingY=1/scaling.y`;
        fg.emit`y.multiply(invScalingY)`;
        fg.emit`shearing.z*=invScalingY`;
        fg.emit`shearing.y=x.dot(z)`;
        fg.emit`z.subtract(tmp.copy(x).multiply(shearing.y))`;
        fg.emit`shearing.x=y.dot(z)`;
        fg.emit`z.subtract(tmp.copy(y).multiply(shearing.x))`;
        fg.emit`scaling.z=z.length`;
        fg.emit`var invScalingZ=1/scaling.z`;
        fg.emit`z.multiply(invScalingZ)`;
        fg.emit`shearing.y*=invScalingZ`;
        fg.emit`shearing.x*=invScalingZ`;
        fg.emit`scaling.multiply(maxAbs)`;
        fg.emit`if(x.dot(tmp.copy(y).cross(z))<0){`;
        fg.emit`x.negate()`;
        fg.emit`y.negate()`;
        fg.emit`z.negate()`;
        fg.emit`scaling.negate()`;
        fg.emit`}`; // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        fg.emit`var trace=x.x+y.y+z.z`;
        fg.emit`if(trace>=0){`;
        fg.emit`var a=sqrt(1+trace)`;
        fg.emit`b=0.5/a`;
        fg.emit`this.quaternion.set(a*0.5,`;
        fg.emit`(z.y-y.z)*b,`;
        fg.emit`(x.z-z.x)*b,`;
        fg.emit`(y.x-x.y)*b)`;
        fg.emit`}else if(x.x>y.y&&x.x>z.z){`;
        fg.emit`var a=sqrt(1+x.x-y.y-z.z)`;
        fg.emit`b=0.5/a`;
        fg.emit`this.quaternion.set((z.y-y.z)*b,`;
        fg.emit`a*0.5,`;
        fg.emit`(x.y+y.x)*b,`;
        fg.emit`(x.z+z.x)*b)`;
        fg.emit`}else if(y.y>z.z){`;
        fg.emit`var a=sqrt(1-x.x+y.y-z.z)`;
        fg.emit`b=0.5/a`;
        fg.emit`this.quaternion.set((x.z-z.x)*b,`;
        fg.emit`(x.y+y.x)*b,`;
        fg.emit`a*0.5,`;
        fg.emit`(y.z+z.y)*b)`;
        fg.emit`}else{`;
        fg.emit`var a=sqrt(1-x.x-y.y+z.z),`;
        fg.emit`b=0.5/a;`;
        fg.emit`this.quaternion.set((y.x-x.y)*b,`;
        fg.emit`(x.z+z.x)*b,`;
        fg.emit`(y.z+z.y)*b,`;
        fg.emit`a*0.5)`;
        fg.emit`}`;
      }

      if (kind !== KINDS.LINEAR) {
        if (matrixKind === KINDS.LINEAR) {
          fg.emit`this.translation.fromNumber(0)`;
        } else {
          fg.emit`matrix.translationPaste(this.translation)`;
        }
      }

      fg.emit`return this`;
    });

    if (matrixKind === kind) {
      aliasProperty(`from${matrixKind.name}Matrix`, 'fromMatrix');
    }
  }

  for (const srcKind of Object.values(KINDS)) {
    if (srcKind.order > kind.order) {
      continue;
    }

    defineMethod(fg => {
      fg.name = `from${srcKind.name}SplitTransform`;
      fg.params = ['transform'];
      fg.emit`this.scaling.copy(transform.scaling)`;

      if (d === 2) {
        fg.emit`this.shearing=transform.shearing`;
        fg.emit`this.complex.copy(transform.complex)`;
      } else {
        fg.emit`this.shearing.copy(transform.shearing)`;
        fg.emit`this.quaternion.copy(transform.quaternion)`;
      }

      if (kind !== KINDS.LINEAR) {
        if (srcKind === KINDS.LINEAR) {
          fg.emit`this.translation.fromNumber(0)`;
        } else {
          fg.emit`this.translation.copy(transform.translation)`;
        }
      }

      fg.emit`return this`;
    });
    aliasProperty(`from${srcKind.name}SplitTransform`, `from${srcKind.name}`);
  }

  aliasProperty(`from${kind.name}SplitTransform`, 'copy');
  defineMethod(fg => {
    fg.ctx[Transform.name] = Transform;
    fg.name = 'clone';
    fg.emit`return new ${Transform.name}().copy(this)`;
  });

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);

    for (const _ref of [['some', '||'], ['every', '&&']]) {
      var _ref2 = _slicedToArray(_ref, 2);

      const joiner = _ref2[0];
      const joinOp = _ref2[1];
      const tests = [`this.scaling.${joiner}${Name}`];

      if (d === 2) {
        tests.push(`${name}(this.shearing)`);
        tests.push(`this.complex.${joiner}${Name}`);
      } else {
        tests.push(`this.shearing.${joiner}${Name}`);
        tests.push(`this.quaternion.${joiner}${Name}`);
      }

      if (kind !== KINDS.LINEAR) {
        tests.push(`this.translation.${joiner}${Name}`);
      }

      defineGetter(fg => {
        fg.ctx[name] = fn;
        fg.name = `${joiner}${Name}`;
        fg.emit`return ${tests.join(joinOp)}`;
      });
    }
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return this.scaling.equals(that.scaling)`;

    if (d === 2) {
      fg.emit`&&this.shearing===that.shearing`;
      fg.emit`&&this.complex.equals(that.complex)`;
    } else {
      fg.emit`&&this.shearing.equals(that.shearing)`;
      fg.emit`&&this.quaternion.equals(that.quaternion)`;
    }

    if (kind !== KINDS.LINEAR) {
      fg.emit`&&this.translation.equals(that.translation)`;
    }
  });
  return Transform;
}

const LinearSplitTransform2 = makeClass(KINDS.LINEAR, 2);
const AffineSplitTransform2 = makeClass(KINDS.AFFINE, 2);
const LinearSplitTransform3 = makeClass(KINDS.LINEAR, 3);
const AffineSplitTransform3 = makeClass(KINDS.AFFINE, 3);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/rectangle-and-box.js
function _toArray(arr) { return rectangle_and_box_arrayWithHoles(arr) || _iterableToArray(arr) || rectangle_and_box_unsupportedIterableToArray(arr) || rectangle_and_box_nonIterableRest(); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function rectangle_and_box_slicedToArray(arr, i) { return rectangle_and_box_arrayWithHoles(arr) || rectangle_and_box_iterableToArrayLimit(arr, i) || rectangle_and_box_unsupportedIterableToArray(arr, i) || rectangle_and_box_nonIterableRest(); }

function rectangle_and_box_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function rectangle_and_box_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rectangle_and_box_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rectangle_and_box_arrayLikeToArray(o, minLen); }

function rectangle_and_box_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function rectangle_and_box_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function rectangle_and_box_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function rectangle_and_box_makeClass(d) {
  const name = d === 2 ? 'rectangle' : 'box',
        Name = Object(to_title_case["a" /* toTitleCase */])(name);
  const as = [...'xyz'].slice(0, d);
  const sphereName = d === 2 ? 'circle' : 'sphere',
        SphereName = Object(to_title_case["a" /* toTitleCase */])(sphereName);
  const tmp0 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const tmp1 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const tmp2 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const Box = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, d === 2 ? {
      Vector2: vectors["a" /* Vector2 */]
    } : {
      Vector3: vectors["b" /* Vector3 */]
    });
    fg.name = Name;
    fg.params = ['min', 'max'];

    for (const p of fg.params) {
      fg.emit`this.${p}=new Vector${d}()`;
      fg.emit`if(${p}===undefined){`;
      fg.emit`this.${p}.fromNumber(${'-'.slice(p !== 'min')}0.5)`;
      fg.emit`}else{`;
      fg.emit`this.${p}.copy(${p})`;
      fg.emit`}`;
    }
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Box.prototype);
  const defineGetter = function_property_definer_makers["a" /* makeGetterDefiner */](Box.prototype);
  const defineSetter = function_property_definer_makers["c" /* makeSetterDefiner */](Box.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Box.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = ['min', 'max'];
    fg.emit`this.min.copy(min)`;
    fg.emit`this.max.copy(max)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `from${Name}`;
    fg.params = [name];
    fg.emit`return this.set(${name}.min,${name}.max)`;
  });
  aliasProperty(`from${Name}`, 'copy');
  defineMethod(fg => {
    fg.name = 'fromCenterAndSize';
    fg.params = ['center', 'size'];
    fg.emit`this.min.copy(size).multiply(-0.5).add(center)`;
    fg.emit`this.max.copy(size).multiply(0.5).add(center)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'fromCenterAndUniformSize';
    fg.params = ['center', 'size'];
    fg.emit`this.min.copy(center).addNumber(-0.5*size)`;
    fg.emit`this.max.copy(center).addNumber(0.5*size)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `fromSupporting${SphereName}`;
    fg.params = [sphereName];
    fg.emit`return this.fromCenterAndUniformSize(${`${sphereName}.center,${sphereName}.radius*2`})`;
  });
  defineMethod(fg => {
    fg.ctx[Name] = Box;
    fg.name = 'clone';
    fg.emit`return new ${Name}().copy(this)`;
  });

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);

    for (const _ref of [['some', '||'], ['every', '&&']]) {
      var _ref2 = rectangle_and_box_slicedToArray(_ref, 2);

      const joiner = _ref2[0];
      const joinOp = _ref2[1];
      defineGetter(fg => {
        fg.ctx[name] = fn;
        fg.name = `${joiner}${Name}`;
        fg.emit`return ${[`this.min.${joiner}${Name}`, `this.max.${joiner}${Name}`].join(joinOp)}`;
      });
    }
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return this.min.equals(that.min)&&this.max.equals(that.max)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      min: functions["B" /* min */],
      max: functions["A" /* max */],
      minDistances: tmp0,
      maxDistances: tmp1
    });
    fg.name = 'pointDistance';
    fg.params = ['point'];
    fg.emit`minDistances.copy(this.min).subtract(point)`;
    fg.emit`maxDistances.copy(point).subtract(this.max)`;
    fg.emit`var distances = minDistances.max(maxDistances)`;
    fg.emit`return min(max(${as.map(a => `distances.${a}`)}),0)+distances.maxNumber(0).length`;
  });
  defineMethod(fg => {
    fg.name = 'centerPaste';
    fg.params = ['center'];
    fg.emit`return center.copy(this.min).add(this.max).multiply(0.5)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      size: tmp0
    });
    fg.name = 'centerCopy';
    fg.params = ['center'];
    fg.emit`return this.fromCenterAndSize(center,this.sizePaste(size))`;
  });
  defineMethod(fg => {
    fg.name = 'sizePaste';
    fg.params = ['size'];
    fg.emit`return size.copy(this.max).subtract(this.min)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      center: tmp0
    });
    fg.name = 'sizeCopy';
    fg.params = ['size'];
    fg.emit`return this.fromCenterAndSize(this.centerPaste(center),size)`;
  });
  defineSetter(fg => {
    Object.assign(fg.ctx, {
      center: tmp0
    });
    fg.name = 'uniformSize';
    fg.params = ['size'];
    fg.emit`return this.fromCenterAndUniformSize(${`this.centerPaste(center),size`})`;
  });
  defineMethod(fg => {
    fg.name = 'consumePoint';
    fg.params = ['point'];
    fg.emit`this.min.min(point)`;
    fg.emit`this.max.max(point)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `consume${Name}`;
    fg.params = [name];
    fg.emit`this.min.min(${name}.min)`;
    fg.emit`this.max.max(${name}.max)`;
    fg.emit`return this`;
  });
  aliasProperty(`consume${Name}`, 'consume');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      corner: tmp0
    });
    fg.name = `consume${SphereName}`;
    fg.params = [sphereName];
    fg.emit`this.min.min(${sphereName}.minPaste(corner))`;
    fg.emit`this.max.max(${sphereName}.maxPaste(corner))`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'containsPoint';
    fg.params = ['point'];
    fg.emit`var min=this.min,max=this.max`;
    fg.emit`return ${as.map(a => {
      return `min.${a}<=point.${a}&&point.${a}<=max.${a}`;
    }).join('&&')}`;
  });
  defineMethod(fg => {
    fg.name = `contains${Name}`;
    fg.params = [name];
    fg.emit`return ${[`this.containsPoint(${name}.min)`, `this.containsPoint(${name}.max)`].join('&&')}`;
  });
  aliasProperty(`contains${Name}`, 'contains');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      corner: tmp0
    });
    fg.name = `contains${SphereName}`;
    fg.params = [sphereName];
    fg.emit`return ${[`this.containsPoint(${sphereName}.minPaste(corner))`, `this.containsPoint(${sphereName}.maxPaste(corner))`].join('&&')}`;
  });
  aliasProperty('containsPoint', 'intersectsPoint');
  defineMethod(fg => {
    fg.name = `intersects${Name}`;
    fg.params = [name];
    fg.emit`var minA=this.min,maxA=this.max`;
    fg.emit`var minB=${name}.min,maxB=${name}.max`;
    fg.emit`return ${as.map(a => {
      return `minA.${a}<=maxB.${a}&&maxA.${a}>=minB.${a}`;
    }).join('&&')}`;
  });
  aliasProperty(`intersects${Name}`, 'intersects');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */]
    });
    fg.name = `intersects${SphereName}`;
    fg.params = [sphereName];
    fg.emit`var min=this.min,max=this.max,`;
    fg.emit`center=${sphereName}.center,`;
    fg.emit`negSqDistance=sq(${sphereName}.radius)`;

    for (const a of as) {
      fg.emit`if(center.${a}<min.${a}){`;
      fg.emit`negSqDistance-=sq(min.${a}-center.${a})`;
      fg.emit`}else if(max.${a}<center.${a}){`;
      fg.emit`negSqDistance-=sq(center.${a}-max.${a})`;
      fg.emit`}`;
    }

    fg.emit`return negSqDistance>=0`;
  });
  defineMethod(fg => {
    fg.name = `intersectsHalfSpace`;
    fg.params = ['halfSpace'];
    fg.emit`return halfSpace.intersects${Name}(this)`;
  });
  defineMethod(fg => {
    fg.name = 'translate';
    fg.params = ['translation'];
    fg.emit`this.min.translate(translation)`;
    fg.emit`this.max.translate(translation)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'scale';
    fg.params = ['scaling'];
    fg.emit`var min=this.min,max=this.max`;
    fg.emit`min.scale(scaling)`;
    fg.emit`max.scale(scaling)`;

    for (const a of as) {
      fg.emit`if(scaling.${a}<0){`;
      fg.emit`var t=min.${a}`;
      fg.emit`min.${a}=max.${a}`;
      fg.emit`max.${a}=t`;
      fg.emit`}`;
    }

    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'scaleUniform';
    fg.params = ['scaling'];
    fg.emit`var min=this.min,max=this.max`;
    fg.emit`min.scaleUniform(scaling)`;
    fg.emit`max.scaleUniform(scaling)`;
    fg.emit`if(scaling<0){`;

    for (const a of as) {
      fg.emit`${['var '].slice(a !== 'x')}t=min.${a}`;
      fg.emit`min.${a}=max.${a}`;
      fg.emit`max.${a}=t`;
    }

    fg.emit`}`;
    fg.emit`return this`;
  });

  for (const _ref3 of function* () {
    yield ['shear', 'shearing'];
    yield ['reflect', 'normal'];
    yield ['rotateBetween', 'from', 'to'];

    if (d === 2) {
      yield ['rotate', 'angle'];
      yield ['applyComplex', 'complex'];
    } else {
      yield ['rotate', 'angle', 'axis'];
      yield ['applyComplex', 'complex', 'axis'];
      yield ['applyQuaternion', 'quaternion'];
    }

    yield ['applyLinearMatrix', 'matrix'];
    yield ['applyAffineMatrix', 'matrix'];
  }()) {
    var _ref4 = _toArray(_ref3);

    const name = _ref4[0];

    const params = _ref4.slice(1);

    defineMethod(fg => {
      Object.assign(fg.ctx, {
        center: tmp0,
        corner: tmp1,
        halfSize: tmp2
      });
      fg.name = name;
      fg.params = params;
      fg.emit`var min=this.min,max=this.max`;
      fg.emit`this.centerPaste(center).${name}(${params})`;
      fg.emit`corner.copy(max).${name}(${params}).subtract(center)`;
      fg.emit`halfSize.fromNumber(0).max(corner.abs())`;

      for (let i = 0; i < 2 ** (d - 1) - 1; ++i) {
        fg.emit`corner.set(${as.map((a, j) => {
          return `m${['in', 'ax'][+(j === i)]}.${a}`;
        })}).${name}(${params}).subtract(center)`;
        fg.emit`halfSize.max(corner.abs())`;
      }

      fg.emit`min.copy(center).subtract(halfSize)`;
      fg.emit`max.copy(center).add(halfSize)`;
      fg.emit`return this`;
    });
  }

  defineMethod(fg => {
    Object.assign(fg.ctx, {
      oldMin: tmp0,
      oldMax: tmp1,
      corner: tmp2
    });
    fg.name = 'applyHomogeneousMatrix';
    fg.params = ['matrix'];
    fg.emit`var min=this.min,max=this.max`;
    fg.emit`oldMin.copy(min)`;
    fg.emit`oldMax.copy(max)`;
    fg.emit`min.${fg.name}(${fg.params})`;
    fg.emit`max.copy(min)`;

    for (let i = 1; i < 2 ** d - 1; ++i) {
      fg.emit`corner.set(${as.map((a, j) => {
        return `oldM${['in', 'ax'][i >>> j & 1]}.${a}`;
      })}).${fg.name}(${fg.params})`;
      fg.emit`min.min(corner)`;
      fg.emit`max.max(corner)`;
    }

    fg.emit`corner.copy(oldMax).${fg.name}(${fg.params})`;
    fg.emit`min.min(corner)`;
    fg.emit`max.max(corner)`;
    fg.emit`return this`;
  });
  return Box;
}

const Rectangle = rectangle_and_box_makeClass(2);
const rectangle_and_box_Box = rectangle_and_box_makeClass(3);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/circle-and-sphere.js
function circle_and_sphere_toArray(arr) { return circle_and_sphere_arrayWithHoles(arr) || circle_and_sphere_iterableToArray(arr) || circle_and_sphere_unsupportedIterableToArray(arr) || circle_and_sphere_nonIterableRest(); }

function circle_and_sphere_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function circle_and_sphere_slicedToArray(arr, i) { return circle_and_sphere_arrayWithHoles(arr) || circle_and_sphere_iterableToArrayLimit(arr, i) || circle_and_sphere_unsupportedIterableToArray(arr, i) || circle_and_sphere_nonIterableRest(); }

function circle_and_sphere_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function circle_and_sphere_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return circle_and_sphere_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return circle_and_sphere_arrayLikeToArray(o, minLen); }

function circle_and_sphere_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function circle_and_sphere_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function circle_and_sphere_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function circle_and_sphere_makeClass(d) {
  const name = d === 2 ? 'circle' : 'sphere',
        Name = Object(to_title_case["a" /* toTitleCase */])(name);
  const as = [...'xyz'].slice(0, d);
  const boxName = d === 2 ? 'rectangle' : 'box',
        BoxName = Object(to_title_case["a" /* toTitleCase */])(boxName);
  const tmp0 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const tmp1 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const tmp2 = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const Sphere = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, d === 2 ? {
      Vector2: vectors["a" /* Vector2 */]
    } : {
      Vector3: vectors["b" /* Vector3 */]
    });
    fg.name = Name;
    fg.params = ['center', 'radius'];
    fg.emit`this.center=new Vector${d}()`;
    fg.emit`if(center!==undefined){this.center.copy(center)}`;
    fg.emit`if(radius===undefined){`;
    fg.emit`this.radius=1`;
    fg.emit`}else{`;
    fg.emit`this.radius=radius`;
    fg.emit`}`;
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Sphere.prototype);
  const defineGetter = function_property_definer_makers["a" /* makeGetterDefiner */](Sphere.prototype);
  const defineSetter = function_property_definer_makers["c" /* makeSetterDefiner */](Sphere.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Sphere.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = ['center', 'radius'];
    fg.emit`this.center.copy(center)`;
    fg.emit`this.radius=radius`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `from${Name}`;
    fg.params = [name];
    fg.emit`return this.set(${name}.center,${name}.radius)`;
  });
  aliasProperty(`from${Name}`, 'copy');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      center: tmp0,
      size: tmp1
    });
    fg.name = `fromSupporting${BoxName}`;
    fg.params = [boxName];
    fg.emit`return this.set(${[`${boxName}.centerPaste(center)`, `${boxName}.sizePaste(size).length*0.5`]})`;
  });
  defineMethod(fg => {
    fg.ctx[Name] = Sphere;
    fg.name = 'clone';
    fg.emit`return new ${Name}().copy(this)`;
  });

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);

    for (const _ref of [['some', '||'], ['every', '&&']]) {
      var _ref2 = circle_and_sphere_slicedToArray(_ref, 2);

      const joiner = _ref2[0];
      const joinOp = _ref2[1];
      defineGetter(fg => {
        fg.ctx[name] = fn;
        fg.name = `${joiner}${Name}`;
        fg.emit`return ${[`this.center.${joiner}${Name}`, `${name}(this.radius)`].join(joinOp)}`;
      });
    }
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return ${[`this.center.equals(that.center)`, `this.radius===that.radius`].join('&&')}`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      minDistances: tmp0,
      maxDistances: tmp1
    });
    fg.name = 'pointDistance';
    fg.params = ['point'];
    fg.emit`return this.center.distance(point)-this.radius`;
  });
  defineMethod(fg => {
    fg.name = 'minPaste';
    fg.params = ['min'];
    fg.emit`return min.copy(this.center).subtractNumber(this.radius)`;
  });
  defineMethod(fg => {
    fg.name = 'maxPaste';
    fg.params = ['max'];
    fg.emit`return max.copy(this.center).addNumber(this.radius)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sqrt: functions["H" /* sqrt */],
      direction: tmp0
    });
    fg.name = 'consumePoint';
    fg.params = ['point'];
    fg.emit`var center=this.center,radius=this.radius`;
    fg.emit`direction.copy(point).subtract(center)`;
    fg.emit`var sqDistance=direction.sqLength`;
    fg.emit`if(sqDistance>radius*radius){`;
    fg.emit`var distance=sqrt(distance)`;
    fg.emit`direction.multiply(0.5*(distance-radius)/distance)`;
    fg.emit`center.add(direction)`;
    fg.emit`this.radius=0.5*(distance+radius)`;
    fg.emit`}`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */],
      sqrt: functions["H" /* sqrt */],
      direction: tmp0
    });
    fg.name = `consume${Name}`;
    fg.params = [name];
    fg.emit`var centerA=this.center,radiusA=this.radius,`;
    fg.emit`centerB=${name}.center,radiusB=${name}.radius`;
    fg.emit`direction.copy(centerB).subtract(centerA)`;
    fg.emit`var sqDistance=direction.sqLength`;
    fg.emit`if(sqDistance>sq(radiusB-radiusA)){`;
    fg.emit`var distance=sqrt(distance),t=distance+radiusB`;
    fg.emit`direction.multiply(0.5*(t-radiusA)/distance)`;
    fg.emit`centerA.add(direction)`;
    fg.emit`this.radius=0.5*(t+radiusA)`;
    fg.emit`}else if(radiusB>radiusA){`;
    fg.emit`centerA.copy(centerB)`;
    fg.emit`this.radius=radiusB`;
    fg.emit`}`;
    fg.emit`return this`;
  });
  aliasProperty(`consume${Name}`, 'consume');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */],
      sqrt: functions["H" /* sqrt */],
      [name]: new Sphere()
    });
    fg.name = `consume${BoxName}`;
    fg.params = [boxName];
    fg.emit`return this.consume(${`${name}.fromSupporting${BoxName}(${boxName})`})`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */]
    });
    fg.name = 'containsPoint';
    fg.params = ['point'];
    fg.emit`return this.center.sqDistance(point)<=sq(this.radius)`;
  });
  defineMethod(fg => {
    fg.name = `contains${Name}`;
    fg.params = [name];
    fg.emit`var radiusDifference=this.radius-${name}.radius`;
    fg.emit`return ${[`radiusDifference>=0`, `this.center.sqDistance(${name}.center)<=sq(radiusDifference)`].join('&&')}`;
  });
  aliasProperty(`contains${Name}`, 'contains');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      direction: tmp0,
      farCorner: tmp1
    });
    fg.name = `contains${BoxName}`;
    fg.params = [boxName];
    fg.emit`var min=${boxName}.min,max=${boxName}.max`;
    fg.emit`${boxName}.centerPaste(direction).subtract(this.center)`;

    for (const a of as) {
      fg.emit`farCorner.${a}=direction.${a}<0?min.${a}:max.${a}`;
    }

    fg.emit`return this.containsPoint(farCorner)`;
  });
  aliasProperty('containsPoint', 'intersectsPoint');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */]
    });
    fg.name = `intersects${Name}`;
    fg.params = [name];
    fg.emit`return this.center.sqDistance(${name}.center)<=`;
    fg.emit`sq(this.radius+${name}.radius)`;
  });
  aliasProperty(`intersects${Name}`, 'intersects');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */]
    });
    fg.name = `intersects${BoxName}`;
    fg.params = [boxName];
    fg.emit`return ${boxName}.intersects${Name}(this)`;
  });
  defineMethod(fg => {
    fg.name = `intersectsHalfSpace`;
    fg.params = ['halfSpace'];
    fg.emit`return halfSpace.intersects${Name}(this)`;
  });
  defineMethod(fg => {
    fg.name = 'translate';
    fg.params = ['translation'];
    fg.emit`this.center.translate(translation)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      max: functions["A" /* max */]
    });
    fg.name = 'scale';
    fg.params = ['scaling'];
    fg.emit`this.center.scale(scaling)`;
    fg.emit`this.radius*=max(${as.map(a => `scaling.${a}`)})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      max: functions["A" /* max */]
    });
    fg.name = 'scaleUniform';
    fg.params = ['scaling'];
    fg.emit`this.center.scaleUniform(scaling)`;
    fg.emit`this.radius*=scaling`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'reflect';
    fg.params = ['normal'];
    fg.emit`this.center.reflect(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'rotate';
    fg.params = ['angle'];

    if (d === 3) {
      fg.params.push('axis');
    }

    fg.emit`this.center.rotate(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'rotateBetween';
    fg.params = ['from', 'to'];
    fg.emit`this.center.rotateBetween(${fg.params})`;
    fg.emit`return this`;
  });

  for (const _ref3 of function* () {
    if (d === 2) {
      yield ['applyComplex', 'complex'];
    } else {
      yield ['applyComplex', 'complex', 'axis'];
      yield ['applyQuaternion', 'quaternion'];
    }
  }()) {
    var _ref4 = circle_and_sphere_toArray(_ref3);

    const name = _ref4[0];

    const params = _ref4.slice(1);

    defineMethod(fg => {
      fg.name = name;
      fg.params = params;
      fg.emit`this.center.${name}(${params})`;
      fg.emit`this.radius*=${params[0]}.uniformScaling`;
      fg.emit`return this`;
    });
  }

  for (const _ref5 of function* () {
    yield ['shear', 'shearing'];
    yield ['applyLinearMatrix', 'matrix'];
    yield ['applyAffineMatrix', 'matrix'];
  }()) {
    var _ref6 = circle_and_sphere_toArray(_ref5);

    const name = _ref6[0];

    const params = _ref6.slice(1);

    defineMethod(fg => {
      Object.assign(fg.ctx, {
        max: functions["A" /* max */],
        sqrt: functions["H" /* sqrt */],
        lo: tmp0,
        hi: tmp1,
        corner: tmp2
      });
      fg.name = name;
      fg.params = params;
      fg.emit`this.minPaste(lo)`;
      fg.emit`this.maxPaste(hi)`;
      fg.emit`var center=this.center`;
      fg.emit`center.${name}(${params})`;
      fg.emit`corner.copy(hi).${name}(${params}).subtract(center)`;
      fg.emit`var sqRadius=corner.sqLength`;

      for (let i = 0; i < 2 ** (d - 1) - 1; ++i) {
        fg.emit`corner.set(${as.map((a, j) => {
          return `${['lo', 'hi'][+(j === i)]}.${a}`;
        })}).${name}(${params}).subtract(center)`;
        fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
      }

      fg.emit`this.radius=sqrt(sqRadius)`;
      fg.emit`return this`;
    });
  }

  defineMethod(fg => {
    Object.assign(fg.ctx, {
      max: functions["A" /* max */],
      sqrt: functions["H" /* sqrt */],
      lo: tmp0,
      hi: tmp1,
      corner: tmp2
    });
    fg.name = 'applyHomogeneousMatrix';
    fg.params = ['matrix'];
    fg.emit`this.minPaste(lo)`;
    fg.emit`this.maxPaste(hi)`;
    fg.emit`var center=this.center`;
    fg.emit`center.${fg.name}(${fg.params})`;
    fg.emit`corner.copy(lo).${fg.name}(${fg.params}).subtract(center)`;
    fg.emit`var sqRadius=corner.sqLength`;

    for (let i = 1; i < 2 ** d - 1; ++i) {
      fg.emit`corner.set(${as.map((a, j) => {
        return `${['lo', 'hi'][i >>> j & 1]}.${a}`;
      })}).${fg.name}(${fg.params}).subtract(center)`;
      fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
    }

    fg.emit`corner.copy(hi).${fg.name}(${fg.params}).subtract(center)`;
    fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
    fg.emit`this.radius=sqrt(sqRadius)`;
    fg.emit`return this`;
  });
  return Sphere;
}

const Circle = circle_and_sphere_makeClass(2);
const circle_and_sphere_Sphere = circle_and_sphere_makeClass(3);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/half-spaces.js
function half_spaces_slicedToArray(arr, i) { return half_spaces_arrayWithHoles(arr) || half_spaces_iterableToArrayLimit(arr, i) || half_spaces_unsupportedIterableToArray(arr, i) || half_spaces_nonIterableRest(); }

function half_spaces_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function half_spaces_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return half_spaces_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return half_spaces_arrayLikeToArray(o, minLen); }

function half_spaces_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function half_spaces_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function half_spaces_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function half_spaces_makeClass(d) {
  const as = [...'xyz'].slice(0, d);
  const boxName = d === 2 ? 'rectangle' : 'box',
        BoxName = Object(to_title_case["a" /* toTitleCase */])(boxName);
  const sphereName = d === 2 ? 'circle' : 'sphere',
        SphereName = Object(to_title_case["a" /* toTitleCase */])(sphereName);
  const tmp = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const HalfSpace = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, d === 2 ? {
      Vector2: vectors["a" /* Vector2 */]
    } : {
      Vector3: vectors["b" /* Vector3 */]
    });
    fg.name = `HalfSpace${d}`;
    fg.params = ['normal', 'offset'];
    fg.emit`if(normal===undefined){`;
    fg.emit`this.normal=new Vector${d}(${as.map((a, i) => +(i === d - 1))})`;
    fg.emit`}else{`;
    fg.emit`this.normal=normal.clone()`;
    fg.emit`}`;
    fg.emit`if(offset===undefined){`;
    fg.emit`this.offset=0`;
    fg.emit`}else{`;
    fg.emit`this.offset=offset`;
    fg.emit`}`;
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](HalfSpace.prototype);
  const defineGetter = function_property_definer_makers["a" /* makeGetterDefiner */](HalfSpace.prototype);
  const defineSetter = function_property_definer_makers["c" /* makeSetterDefiner */](HalfSpace.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](HalfSpace.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = ['normal', 'offset'];
    fg.emit`this.normal.copy(normal)`;
    fg.emit`this.offset=offset`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'fromHalfSpace';
    fg.params = ['halfSpace'];
    fg.emit`return this.set(halfSpace.normal, halfSpace.offset)`;
  });
  aliasProperty('fromHalfSpace', 'copy');
  defineMethod(fg => {
    fg.name = 'fromNormalAndPoint';
    fg.params = ['normal', 'point'];
    fg.emit`this.normal.copy(normal)`;
    fg.emit`this.offset=normal.dot(point)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'fromBoundaryPoints';
    fg.params = [as.map((a, i) => `point${i}`)];
    fg.emit`var normal=this.normal`;

    if (d === 2) {
      fg.emit`normal.copy(point1).subtract(point0).orthogonalize()`;
    } else {
      Object.assign(fg.ctx, {
        edge12: tmp
      });
      fg.emit`edge12.copy(point2).subtract(point1)`;
      fg.emit`normal.copy(point1).subtract(point0).cross(edge12)`;
    }

    fg.emit`this.offset=normal.dot(point0)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      [HalfSpace.name]: HalfSpace
    });
    fg.name = 'clone';
    fg.emit`return new ${HalfSpace.name}().copy(this)`;
  });

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);

    for (const _ref of [['some', '||'], ['every', '&&']]) {
      var _ref2 = half_spaces_slicedToArray(_ref, 2);

      const joiner = _ref2[0];
      const joinOp = _ref2[1];
      defineGetter(fg => {
        fg.ctx[name] = fn;
        fg.name = `${joiner}${Name}`;
        fg.emit`return ${[`this.normal.${joiner}${Name}`, `${name}(this.offset)`].join(joinOp)}`;
      });
    }
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return ${[`this.normal.equals(that.normal)`, `this.offset===that.offset`].join('&&')}`;
  });
  defineMethod(fg => {
    fg.name = 'flip';
    fg.emit`this.normal.negate()`;
    fg.emit`this.offset=-this.offset`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'normalize';
    fg.emit`var normal=this.normal,invNormalLength=1/normal.length`;
    fg.emit`normal.multiply(invNormalLength)`;
    fg.emit`this.offset*=invNormalLength`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'pointDistance';
    fg.params = ['point'];
    fg.emit`return this.normal.dot(point)-this.offset`;
  });
  defineMethod(fg => {
    fg.name = 'centerPaste';
    fg.params = ['center'];
    fg.emit`var normal=this.normal`;
    fg.emit`center.copy(normal).multiply(this.offset/normal.dot(normal))`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'consumePoint';
    fg.params = ['point'];
    fg.emit`var offset=this.normal.dot(point)`;
    fg.emit`if(offset>this.offset){this.offset=offset}`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      farCorner: tmp
    });
    fg.name = `consume${BoxName}`;
    fg.params = [boxName];
    fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;

    for (const a of as) {
      fg.emit`farCorner.${a}=normal.${a}<0?min.${a}:max.${a}`;
    }

    fg.emit`return this.consumePoint(farCorner)`;
  });
  defineMethod(fg => {
    fg.name = `consume${SphereName}`;
    fg.params = [sphereName];
    fg.emit`var normal=this.normal,`;
    fg.emit`offset=normal.dot(${sphereName}.center)`;
    fg.emit`offset+=${sphereName}.radius*normal.length`;
    fg.emit`if(offset>this.offset){this.offset=offset}`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'containsPoint';
    fg.params = ['point'];
    fg.emit`return this.normal.dot(point)<=this.offset`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      farCorner: tmp
    });
    fg.name = `contains${BoxName}`;
    fg.params = [boxName];
    fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;

    for (const a of as) {
      fg.emit`farCorner.${a}=normal.${a}<0?min.${a}:max.${a}`;
    }

    fg.emit`return this.containsPoint(farCorner)`;
  });
  defineMethod(fg => {
    fg.name = `contains${SphereName}`;
    fg.params = [sphereName];
    fg.emit`var normal=this.normal,`;
    fg.emit`offset=normal.dot(${sphereName}.center)`;
    fg.emit`offset+=${sphereName}.radius*normal.length`;
    fg.emit`return offset<=this.offset`;
  });
  aliasProperty('containsPoint', 'intersectsPoint');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      nearCorner: tmp
    });
    fg.name = `intersects${BoxName}`;
    fg.params = [boxName];
    fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;

    for (const a of as) {
      fg.emit`nearCorner.${a}=normal.${a}>0?min.${a}:max.${a}`;
    }

    fg.emit`return this.intersectsPoint(nearCorner)`;
  });
  defineMethod(fg => {
    fg.name = `intersects${SphereName}`;
    fg.params = [sphereName];
    fg.emit`var normal=this.normal,`;
    fg.emit`offset=normal.dot(${sphereName}.center)`;
    fg.emit`offset-=${sphereName}.radius*normal.length`;
    fg.emit`return offset<=this.offset`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      center: tmp
    });
    fg.name = 'translate';
    fg.params = ['translation'];
    fg.emit`this.centerPaste(center).translate(translation)`;
    fg.emit`this.offset=this.normal.dot(center)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'scale';
    fg.params = ['scaling'];
    fg.emit`this.normal.divideVector(scaling)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'scaleUniform';
    fg.params = ['scaling'];
    fg.emit`this.normal.divide(scaling)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'reflect';
    fg.params = ['normal'];
    fg.emit`this.normal.reflect(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'rotate';
    fg.params = ['angle'];

    if (d === 3) {
      fg.params.push('axis');
    }

    fg.emit`this.normal.rotate(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'rotateBetween';
    fg.params = ['from', 'to'];
    fg.emit`this.normal.rotateBetween(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'applyComplex';
    fg.params = ['complex'];

    if (d === 3) {
      fg.params.push('axis');
    }

    fg.emit`this.normal.applyComplex(${fg.params}).divide(complex.sqAbs)`;
    fg.emit`return this`;
  });

  if (d === 3) {
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        sq: functions["G" /* sq */]
      });
      fg.name = 'applyQuaternion';
      fg.params = ['quaternion'];
      fg.emit`this.normal.applyQuaternion(quaternion).divide(${'sq(quaternion.uniformScaling)'})`;
      fg.emit`return this`;
    });
  }

  for (const _ref3 of [['shear', 'shearing'], ['applyLinearMatrix', 'matrix'], ['applyAffineMatrix', 'matrix'], ['applyHomogeneousMatrix', 'matrix']]) {
    var _ref4 = half_spaces_slicedToArray(_ref3, 2);

    const name = _ref4[0];
    const param = _ref4[1];
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        center: tmp
      });
      fg.name = name;
      fg.params = [param];
      fg.emit`var normal=this.normal`;
      fg.emit`this.centerPaste(center)`;
      fg.emit`normal.add(center)`;
      fg.emit`.${name}(${param})`;
      fg.emit`.subtract(center.${name}(${param}))`;
      fg.emit`this.offset=normal.dot(center)`;
      fg.emit`return this`;
    });
  }

  return HalfSpace;
}

const HalfSpace2 = half_spaces_makeClass(2);
const HalfSpace3 = half_spaces_makeClass(3);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/rays.js
function rays_toArray(arr) { return rays_arrayWithHoles(arr) || rays_iterableToArray(arr) || rays_unsupportedIterableToArray(arr) || rays_nonIterableRest(); }

function rays_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function rays_slicedToArray(arr, i) { return rays_arrayWithHoles(arr) || rays_iterableToArrayLimit(arr, i) || rays_unsupportedIterableToArray(arr, i) || rays_nonIterableRest(); }

function rays_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function rays_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rays_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rays_arrayLikeToArray(o, minLen); }

function rays_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function rays_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function rays_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function rays_makeClass(d) {
  const as = [...'xyz'].slice(0, d);
  const boxName = d === 2 ? 'rectangle' : 'box',
        BoxName = Object(to_title_case["a" /* toTitleCase */])(boxName);
  const sphereName = d === 2 ? 'circle' : 'sphere',
        SphereName = Object(to_title_case["a" /* toTitleCase */])(sphereName);
  const tmp = new (d === 2 ? vectors["a" /* Vector2 */] : vectors["b" /* Vector3 */])();
  const Ray = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, d === 2 ? {
      Vector2: vectors["a" /* Vector2 */]
    } : {
      Vector3: vectors["b" /* Vector3 */]
    });
    fg.name = `Ray${d}`;
    fg.params = ['origin', 'direction'];
    fg.emit`if(origin===undefined){`;
    fg.emit`this.origin=new Vector${d}()`;
    fg.emit`}else{`;
    fg.emit`this.origin=origin.clone()`;
    fg.emit`}`;
    fg.emit`if(direction===undefined){`;
    fg.emit`this.direction=new Vector${d}(${as.map((a, i) => -(i === d - 1))})`;
    fg.emit`}else{`;
    fg.emit`this.direction=direction.clone()`;
    fg.emit`}`;
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Ray.prototype);
  const defineGetter = function_property_definer_makers["a" /* makeGetterDefiner */](Ray.prototype);
  const defineSetter = function_property_definer_makers["c" /* makeSetterDefiner */](Ray.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Ray.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = ['origin', 'direction'];
    fg.emit`this.origin.copy(origin)`;
    fg.emit`this.direction.copy(direction)`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'fromRay';
    fg.params = ['ray'];
    fg.emit`return this.set(ray.origin, ray.direction)`;
  });
  aliasProperty('fromRay', 'copy');
  defineMethod(fg => {
    fg.name = 'fromOriginAndTarget';
    fg.params = ['origin', 'target'];
    fg.emit`this.origin.copy(origin)`;
    fg.emit`this.direction.copy(target).subtract(origin).normalize()`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      [Ray.name]: Ray
    });
    fg.name = 'clone';
    fg.emit`return new ${Ray.name}().copy(this)`;
  });

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);

    for (const _ref of [['some', '||'], ['every', '&&']]) {
      var _ref2 = rays_slicedToArray(_ref, 2);

      const joiner = _ref2[0];
      const joinOp = _ref2[1];
      defineGetter(fg => {
        fg.ctx[name] = fn;
        fg.name = `${joiner}${Name}`;
        fg.emit`return ${[`this.origin.${joiner}${Name}`, `this.direction.${joiner}${Name}`].join(joinOp)}`;
      });
    }
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return ${[`this.origin.equals(that.origin)`, `this.direction.equals(that.direction)`].join('&&')}`;
  });
  defineMethod(fg => {
    fg.name = 'flip';
    fg.emit`this.direction.negate()`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = 'normalize';
    fg.emit`this.direction.normalize()`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      isNaN: functions["s" /* isNaN */],
      min: functions["B" /* min */],
      max: functions["A" /* max */]
    });
    fg.name = `intersects${BoxName}`;
    fg.params = [boxName];
    fg.emit`var origin=this.origin,direction=this.direction,`;
    fg.emit`lo=${boxName}.min,hi=${boxName}.max`;

    for (const a of as) {
      const A = a.toUpperCase();
      fg.emit`var invDirection${A}=1/direction.${a},`;
      fg.emit`tMin${A}=(lo.${a}-origin.${a})*invDirection${A},`;
      fg.emit`tMax${A}=(hi.${a}-origin.${a})*invDirection${A}`;
      fg.emit`if(isNaN(tMin${A})){`;
      fg.emit`tMin${A}=0`;
      fg.emit`}`;
      fg.emit`if(isNaN(tMax${A})){`;
      fg.emit`tMax${A}=0`;
      fg.emit`}`;
      fg.emit`if(tMin${A}>tMax${A}){`;
      fg.emit`var t=tMin${A}`;
      fg.emit`tMin${A}=tMax${A}`;
      fg.emit`tMax${A}=t`;
      fg.emit`}`;
    }

    fg.emit`return max(${as.map(a => `tMin${a.toUpperCase()}`)},0)<=min(${as.map(a => `tMax${a.toUpperCase()}`)})`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */],
      difference: tmp
    });
    fg.name = `intersects${SphereName}`;
    fg.params = [sphereName];
    fg.emit`var origin=this.origin,direction=this.direction`;
    fg.emit`difference.copy(${sphereName}.center).subtract(origin)`;
    fg.emit`if(difference.dot(direction)<=0){`;
    fg.emit`return difference.sqLength<=sq(${sphereName}.radius)`;
    fg.emit`}`;
    fg.emit`return ${['difference.cross(direction).sqLength', `sq(${sphereName}.radius)*direction.sqLength`].join('<=')}`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sq: functions["G" /* sq */],
      difference: tmp
    });
    fg.name = `intersectsHalfSpace`;
    fg.params = ['halfSpace'];
    fg.emit`if(halfSpace.containsPoint(this.origin)){return true}`;
    fg.emit`return halfSpace.normal.dot(this.direction)<0`;
  });
  defineMethod(fg => {
    fg.name = 'translate';
    fg.params = ['translation'];
    fg.emit`this.origin.translate(translation)`;
    fg.emit`return this`;
  });

  for (const _ref3 of function* () {
    yield ['scale', 'scaling'];
    yield ['scaleUniform', 'scaling'];
    yield ['shear', 'shearing'];
    yield ['reflect', 'normal'];
    yield ['rotateBetween', 'from', 'to'];

    if (d === 2) {
      yield ['rotate', 'angle'];
      yield ['applyComplex', 'complex'];
    } else {
      yield ['rotate', 'angle', 'axis'];
      yield ['applyComplex', 'complex', 'axis'];
      yield ['applyQuaternion', 'quaternion'];
    }

    yield ['applyLinearMatrix', 'matrix'];
  }()) {
    var _ref4 = rays_toArray(_ref3);

    const name = _ref4[0];

    const params = _ref4.slice(1);

    defineMethod(fg => {
      fg.name = name;
      fg.params = params;
      fg.emit`this.origin.${name}(${params})`;
      fg.emit`this.direction.${name}(${params})`;
      fg.emit`return this`;
    });
  }

  defineMethod(fg => {
    fg.name = 'applyAffineMatrix';
    fg.params = ['matrix'];
    fg.emit`this.origin.${fg.name}(${fg.params})`;
    fg.emit`this.direction.applyLinearMatrix(${fg.params})`;
    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      center: tmp
    });
    fg.name = 'applyHomogeneousMatrix';
    fg.params = ['matrix'];
    fg.emit`var origin=this.origin`;
    fg.emit`this.direction.add(origin)`;
    fg.emit`.${fg.name}(${fg.params})`;
    fg.emit`.subtract(origin.${fg.name}(${fg.params}))`;
    fg.emit`return this`;
  });
  return Ray;
}

const Ray2 = rays_makeClass(2);
const Ray3 = rays_makeClass(3);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/spherical-coords.js



const spherical_coords_SphericalCoords = (() => {
  class SphericalCoords {
    constructor(radius = 0, longitude = 0, colatitude = 0) {
      this.radius = radius;
      this.longitude = longitude;
      this.colatitude = colatitude;
    }

    set(radius, longitude, colatitude) {
      this.radius = radius;
      this.longitude = longitude;
      this.colatitude = colatitude;
      return this;
    }

    fromSphericalCoords(sphericalCoords) {
      return this.set(sphericalCoords.radius, sphericalCoords.longitude, sphericalCoords.colatitude);
    }

    fromVector(vector) {
      this.radius = vector.length;
      this.longitude = Object(functions["c" /* atan2 */])(vector.x, vector.z);
      this.colatitude = Object(functions["b" /* acos */])(vector.y / this.radius);

      if (Object(functions["s" /* isNaN */])(this.colatitude)) {
        this.colatitude = 0;
      }

      return this;
    }

    toVector(vector) {
      const radius = this.radius,
            longitude = this.longitude,
            colatitude = this.colatitude;
      const radiusSinColatitude = radius * Object(functions["F" /* sin */])(colatitude);
      vector.x = radiusSinColatitude * Object(functions["F" /* sin */])(longitude);
      vector.y = radius * Object(functions["h" /* cos */])(colatitude);
      vector.z = radiusSinColatitude * Object(functions["h" /* cos */])(longitude);
      return vector;
    }

    clone() {
      return new SphericalCoords().copy(this);
    }

    equals(that) {
      return this.radius === that.radius && this.longitude === that.longitude && this.colatitude === that.colatitude;
    }

  }

  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](SphericalCoords.prototype);
  aliasProperty('fromSphericalCoords', 'copy');

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const Name = Object(to_title_case["a" /* toTitleCase */])(fn.name);
    Object.defineProperties(SphericalCoords.prototype, {
      [`some${Name}`]: {
        configurable: true,

        get() {
          return fn(this.radius) || fn(this.longitude) || fn(this.colatitude);
        }

      },
      [`every${Name}`]: {
        configurable: true,

        get() {
          return fn(this.radius) && fn(this.longitude) && fn(this.colatitude);
        }

      }
    });
  }

  return SphericalCoords;
})();
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/rgb-color.js
function rgb_color_slicedToArray(arr, i) { return rgb_color_arrayWithHoles(arr) || rgb_color_iterableToArrayLimit(arr, i) || rgb_color_unsupportedIterableToArray(arr, i) || rgb_color_nonIterableRest(); }

function rgb_color_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function rgb_color_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rgb_color_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rgb_color_arrayLikeToArray(o, minLen); }

function rgb_color_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function rgb_color_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function rgb_color_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




const rgb_color_RGBColor = (() => {
  class RGBColor {
    constructor(r = 0, g = 0, b = 0) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    set(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    }

    fromNumber(number) {
      return this.set(number, number, number);
    }

    toGrayscale() {
      return this.r * 0.2126 + this.g * 0.7152 + this.b * 0.0722;
    }

    fromVector(vector) {
      this.r = vector.x;
      this.g = vector.y;
      this.b = vector.z;
      return this;
    }

    toVector(vector) {
      vector.x = this.r;
      vector.y = this.g;
      vector.z = this.b;
      return vector;
    }

    fromPackedInteger(value) {
      // 0.00392156862745098 == 1 / 255
      return this.set((value >> 16 & 0xFF) * 0.00392156862745098, (value >> 8 & 0xFF) * 0.00392156862745098, (value & 0xFF) * 0.00392156862745098);
    }

    toPackedInteger() {
      return Object(functions["D" /* round */])(this.r * 255) << 16 | Object(functions["D" /* round */])(this.g * 255) << 8 | Object(functions["D" /* round */])(this.b * 255);
    }

    fromRGBColor(rgbColor) {
      return this.set(rgbColor.r, rgbColor.g, rgbColor.b);
    }

    fromArray(array) {
      this.r = array[0];
      this.g = array[1];
      this.b = array[2];
      return this;
    }

    fromArrayAt(offset, array) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }

    toArray(array) {
      array[0] = this.r;
      array[1] = this.g;
      array[2] = this.b;
      return array;
    }

    toArrayAt(offset, array) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }

    clone() {
      return new RGBColor().copy(this);
    }

    equals(that) {
      return this.r === that.r && this.g === that.g && this.b === that.b;
    }

  }

  const cs = [...'rgb'];
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](RGBColor.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](RGBColor.prototype);
  aliasProperty('fromNumber', 'fromGrayscale');
  aliasProperty('fromRGBColor', 'copy');

  for (const fn of [functions["s" /* isNaN */], functions["q" /* isFinite */]]) {
    const Name = Object(to_title_case["a" /* toTitleCase */])(fn.name);
    Object.defineProperties(RGBColor.prototype, {
      [`some${Name}`]: {
        configurable: true,

        get() {
          return fn(this.r) || fn(this.g) || fn(this.b);
        }

      },
      [`every${Name}`]: {
        configurable: true,

        get() {
          return fn(this.r) || fn(this.g) || fn(this.b);
        }

      }
    });
  }

  function defineUnaryOperation(name, rgb) {
    defineMethod(fg => {
      fg.name = name;
      rgb(fg);
      fg.emit`return this`;
    });
  }

  for (const _ref of [['negate', '-']]) {
    var _ref2 = rgb_color_slicedToArray(_ref, 2);

    const name = _ref2[0];
    const op = _ref2[1];
    defineUnaryOperation(name, fg => {
      for (const c of cs) {
        fg.emit`this.${c}=${op}this.${c}`;
      }
    });
  }

  for (const fn of [functions["i" /* exp */], functions["l" /* expm1 */], functions["k" /* exp2 */], functions["j" /* exp10 */], functions["w" /* log */], functions["y" /* log1p */], functions["z" /* log2 */], functions["x" /* log10 */]]) {
    const name = fn.name;
    defineUnaryOperation(name, fg => {
      fg.ctx[name] = fn;

      for (const c of cs) {
        fg.emit`this.${c}=${name}(this.${c})`;
      }
    });
  }

  function defineBinaryOperartion(name, commutative, {
    rgb,
    number,
    preNumber
  }) {
    const Name = Object(to_title_case["a" /* toTitleCase */])(name);
    defineMethod(fg => {
      fg.name = `${name}RGBColor`;
      fg.params = ['right'];
      rgb(fg, 'this', 'right');
      fg.emit`return this`;
    });
    defineMethod(fg => {
      fg.name = `${name}Number`;
      fg.params = ['right'];
      number(fg);
      fg.emit`return this`;
    });

    if (!commutative) {
      defineMethod(fg => {
        fg.name = `pre${Name}RGBColor`;
        fg.params = ['left'];
        rgb(fg, 'left', 'this');
        fg.emit`return this`;
      });
      defineMethod(fg => {
        fg.name = `pre${Name}Number`;
        fg.params = ['left'];
        preNumber(fg);
        fg.emit`return this`;
      });
    }
  }

  for (const _ref3 of [['add', '+', 1], ['subtract', '-', 0], ['multiply', '*', 1], ['divide', '/', 0]]) {
    var _ref4 = rgb_color_slicedToArray(_ref3, 3);

    const name = _ref4[0];
    const op = _ref4[1];
    const commutative = _ref4[2];
    const Name = Object(to_title_case["a" /* toTitleCase */])(name);
    defineBinaryOperartion(name, commutative, {
      rgb(fg, left, right) {
        for (const c of cs) {
          fg.emit`this.${c}=${left}.${c}${op}${right}.${c}`;
        }
      },

      number(fg) {
        if (op === '/') {
          fg.emit`var invRight=1/right`;
        }

        for (const c of cs) {
          if (op === '/') {
            fg.emit`this.${c}=this.${c}*invRight`;
          } else {
            fg.emit`this.${c}=this.${c}${op}right`;
          }
        }
      },

      preNumber(fg) {
        for (const c of cs) {
          fg.emit`this.${c}=left${op}this.${c}`;
        }
      }

    });

    if (['+', '-'].includes(op)) {
      aliasProperty(`${name}RGBColor`, name);
      aliasProperty(`${name}Number`, `${name}Grayscale`);

      if (!commutative) {
        aliasProperty(`pre${Name}RGBColor`, `pre${Name}`);
        aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
      }
    }

    if (['*', '/'].includes(op)) {
      aliasProperty(`${name}Number`, `${name}Grayscale`);

      if (!commutative) {
        aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
      }
    }
  }

  for (const _ref5 of [[functions["C" /* pow */], 0], [functions["B" /* min */], 1], [functions["A" /* max */], 1]]) {
    var _ref6 = rgb_color_slicedToArray(_ref5, 2);

    const fn = _ref6[0];
    const commutative = _ref6[1];
    const name = fn.name,
          Name = Object(to_title_case["a" /* toTitleCase */])(name);
    defineBinaryOperartion(name, commutative, {
      rgb(fg, left, right) {
        fg.ctx[name] = fn;

        for (const c of cs) {
          fg.emit`this.${c}=${name}(${left}.${c},${right}.${c})`;
        }
      },

      number(fg) {
        fg.ctx[name] = fn;

        for (const c of cs) {
          fg.emit`this.${c}=${name}(this.${c},right)`;
        }
      },

      preNumber(fg) {
        fg.ctx[name] = fn;

        for (const c of cs) {
          fg.emit`this.${c}=${name}(left,this.${c})`;
        }
      }

    });

    if (fn === functions["C" /* pow */]) {
      aliasProperty(`${name}Number`, name);
      aliasProperty(`${name}Number`, `${name}Grayscale`);
      aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
    }

    if ([functions["B" /* min */], functions["A" /* max */]].includes(fn)) {
      aliasProperty(`${name}Number`, name);
      aliasProperty(`${name}Number`, `${name}Grayscale`);
    }
  }

  defineMethod(fg => {
    Object.assign(fg.ctx, {
      clamp: functions["g" /* clamp */]
    });
    fg.name = `clampRGBColors`;
    fg.params = ['low', 'high'];

    for (const c of cs) {
      fg.emit`this.${c}=clamp(this.${c},low.${c},high.${c})`;
    }

    fg.emit`return this`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      clamp: functions["g" /* clamp */]
    });
    fg.name = `clampNumbers`;
    fg.params = ['low', 'high'];

    for (const c of cs) {
      fg.emit`this.${c}=clamp(this.${c},low,high)`;
    }

    fg.emit`return this`;
  });
  aliasProperty('clampNumbers', 'clamp');
  aliasProperty('clampNumbers', 'clampGrayscales');
  return RGBColor;
})();
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/cubic-hermite-interpolators.js





const cubic_hermite_interpolators_NumberCubicHermiteInterpolator = (() => {
  class NumberCubicHermiteInterpolator {
    constructor(start = 0, startTangent = 0, end = 0, endTangent = 0) {
      this.start = start;
      this.startTangent = startTangent;
      this.end = end;
      this.endTangent = endTangent;
    }

    set(start, startTangent, end, endTangent) {
      this.start = start;
      this.startTangent = startTangent;
      this.end = end;
      this.endTangent = endTangent;
      return this;
    }

    fromNumberCubicHermiteInterpolator(interpolator) {
      return this.set(interpolator.start, interpolator.startTangent, interpolator.end, interpolator.endTangent);
    }

    fromBezierValues(p0, p1, p2, p3) {
      return this.set(p0, (p1 - p0) * 3, (p3 - p2) * 3, p3);
    }

    clone() {
      return new NumberCubicHermiteInterpolator().copy(this);
    }

    evaluate(alpha) {
      const alpha2 = alpha * alpha,
            alpha3 = alpha * alpha2;
      const c = 3 * alpha2 - 2 * alpha3,
            a = 1 - c,
            b = alpha3 - 2 * alpha2 + alpha,
            d = alpha3 - alpha2;
      return a * this.start + b * this.startTangent + c * this.end + d * this.endTangent;
    }

  }

  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](NumberCubicHermiteInterpolator.prototype);
  aliasProperty('fromNumberCubicHermiteInterpolator', 'copy');
  return NumberCubicHermiteInterpolator;
})();
function makeCubicHermiteInterpolator(Value, {
  create = (fg, a) => {
    fg.emit`${a}=new ${Value.name}()`;
  },
  initialize = fg => {},
  copy = (fg, a, b) => {
    fg.emit`${a}.copy(${b})`;
  },
  multiplyNumber = (fg, a, b) => {
    fg.emit`${a}.multiplyNumber(${b})`;
  },
  add = (fg, a, b) => {
    fg.emit`${a}.add(${b})`;
  },
  subtract = (fg, a, b) => {
    fg.emit`${a}.subtract(${b})`;
  }
} = {}) {
  const params = ['start', 'startTangent', 'end', 'endTangent'];
  const tmp = new Value();
  const Interpolator = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, {
      [Value.name]: Value
    });
    fg.name = `${Value.name}CubicHermiteInterpolator`;
    fg.params = params;

    for (const p of params) {
      create(fg, `this.${p}`);
      fg.emit`if(${p}===undefined){`;
      initialize(fg, `this.${p}`);
      fg.emit`}else{`;
      copy(fg, `this.${p}`, p);
      fg.emit`}`;
    }
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Interpolator.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Interpolator.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = params;

    for (const p of params) {
      copy(fg, `this.${p}`, p);
    }

    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `from${Interpolator.name}`;
    fg.params = ['interpolator'];
    fg.emit`return this.set(${params.map(p => `interpolator.${p}`)})`;
  });
  aliasProperty(`from${Interpolator.name}`, `from${Interpolator.name.slice(Value.name.length)}`);
  aliasProperty(`from${Interpolator.name}`, 'copy');
  defineMethod(fg => {
    fg.name = `fromBezierValues`;
    fg.params = ['p0', 'p1', 'p2', 'p3'];
    copy(fg, 'this.start', 'p0');
    copy(fg, 'this.startTangent', 'p1');
    subtract(fg, 'this.startTangent', 'p0');
    multiplyNumber(fg, 'this.startTangent', 3);
    copy(fg, 'this.end', 'p3');
    copy(fg, 'this.endTangent', 'p3');
    subtract(fg, 'this.endTangent', 'p2');
    multiplyNumber(fg, 'this.endTangent', 3);
    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.ctx[Interpolator.name] = Interpolator;
    fg.name = 'clone';
    fg.emit`return new ${Interpolator.name}().copy(this)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      tmp
    });
    fg.name = 'evaluate';
    fg.params = ['alpha', 'result'];
    fg.emit`var alpha2=alpha*alpha,alpha3=alpha2*alpha,`;
    fg.emit`c=3*alpha2-2*alpha3,`;
    fg.emit`a=1-c,`;
    fg.emit`b=alpha3-2*alpha2+alpha,`;
    fg.emit`d=alpha3-alpha2`;
    copy(fg, 'result', 'this.start');
    multiplyNumber(fg, 'result', 'a');
    copy(fg, 'tmp', 'this.startTangent');
    multiplyNumber(fg, 'tmp', 'b');
    add(fg, 'result', 'tmp');
    copy(fg, 'tmp', 'this.end');
    multiplyNumber(fg, 'tmp', 'c');
    add(fg, 'result', 'tmp');
    copy(fg, 'tmp', 'this.endTangent');
    multiplyNumber(fg, 'tmp', 'd');
    add(fg, 'result', 'tmp');
    fg.emit`return result`;
  });
  return Interpolator;
}
const Vector2CubicHermiteInterpolator = makeCubicHermiteInterpolator(vectors["a" /* Vector2 */]);
const Vector3CubicHermiteInterpolator = makeCubicHermiteInterpolator(vectors["b" /* Vector3 */]);
const ComplexCubicHermiteInterpolator = makeCubicHermiteInterpolator(complex["a" /* Complex */]);
const QuaternionCubicHermiteInterpolator = makeCubicHermiteInterpolator(lib_quaternion["a" /* Quaternion */]);
const RGBColorCubicHermiteInterpolator = makeCubicHermiteInterpolator(rgb_color_RGBColor);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/quaternion-slerper.js



const quaternion_slerper_QuaternionSlerper = (() => {
  const VALID = 0x01;
  const CLOSE = 0x02;

  function dot(a, b) {
    return a.re * b.re + a.imX * b.imX + a.imY * b.imY + a.imZ * b.imZ;
  }

  class QuaternionSlerper {
    constructor(start, end) {
      this._start = start === undefined ? new lib_quaternion["a" /* Quaternion */]() : start.clone();
      this._end = start === undefined ? new lib_quaternion["a" /* Quaternion */]() : end.clone();
      this._startFactor = 1;
      this._endFactor = 1;
      this._flags = 0;
      this._angle = 0;
    }

    set(start, end) {
      this._start.copy(start);

      this._end.copy(end);

      this._startFactor = 1;
      this._endFactor = 1;
      this._flags = 0;
      this._angle = 0;
      return this;
    }

    fromQuaternionSlerper(slerper) {
      this._start.copy(slerper._start);

      this._end.copy(slerper._end);

      this._startFactor = slerper._startFactor;
      this._endFactor = slerper._endFactor;
      this._flags = slerper._flags;
      this._angle = slerper._angle;
      return this;
    }

    clone() {
      return new QuaternionSlerper().copy(this);
    }

    startPaste(start) {
      return start.copy(this._start).multiply(this._startFactor);
    }

    startCopy(start) {
      this._start.copy(start);

      this._startFactor = 1;
      this._flags &= ~VALID;
      return this;
    }

    endPaste(end) {
      return end.copy(this._end).multiply(this._endFactor);
    }

    endCopy(end) {
      this._end.copy(end);

      this._endFactor = 1;
      this._flags &= ~VALID;
      return this;
    }

    _precompute() {
      const start = this._start;
      const end = this._end;
      let c = dot(start, end) / Object(functions["H" /* sqrt */])(start.sqAbs * end.sqAbs);

      if (c < 0) {
        c = -c;
        end.negate();
        this._endFactor = -this._endFactor;
      }

      if (c > 0.999999) {
        this._flags |= CLOSE;
      } else {
        this._flags &= ~CLOSE;
        this._angle = Object(functions["b" /* acos */])(c);
        const s = Object(functions["H" /* sqrt */])(1 - c * c);
        const invSin = 1 / s;
        start.multiplyNumber(invSin);
        end.multiplyNumber(invSin);
        this._startFactor *= s;
        this._endFactor *= s;
      }
    }

    evaluate(alpha, quaternion) {
      let flags = this._flags;

      if (!(flags & VALID)) {
        this._precompute();

        flags = this._flags |= VALID;
      }

      const start = this._start;
      const end = this._end;
      let a, b;

      if (flags & CLOSE) {
        a = 1 - alpha;
        b = alpha;
      } else {
        const angle = this._angle;
        a = Object(functions["F" /* sin */])((1 - alpha) * angle);
        b = Object(functions["F" /* sin */])(alpha * angle);
      }

      quaternion.re = start.re * a + end.re * b;
      quaternion.imX = start.imX * a + end.imX * b;
      quaternion.imY = start.imY * a + end.imY * b;
      quaternion.imZ = start.imZ * a + end.imZ * b;
      return quaternion;
    }

  }

  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](QuaternionSlerper.prototype);
  aliasProperty('fromQuaternionSlerper', 'copy');
  return QuaternionSlerper;
})();
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/lerpers.js





const lerpers_NumberLerper = (() => {
  class NumberLerper {
    constructor(start = 0, end = 0) {
      this.start = start;
      this.end = end;
    }

    set(start, end) {
      this.start = start;
      this.end = end;
      return this;
    }

    fromNumberLerper(lerper) {
      return this.set(lerper.start, lerper.end);
    }

    clone() {
      return new NumberLerper().copy(this);
    }

    evaluate(alpha) {
      return this.start * (1 - alpha) + this.end * alpha;
    }

  }

  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](NumberLerper.prototype);
  aliasProperty('fromNumberLerper', 'copy');
  return NumberLerper;
})();
function makeLerper(Value, {
  create = (fg, a) => {
    fg.emit`${a}=new ${Value.name}()`;
  },
  initialize = fg => {},
  copy = (fg, a, b) => {
    fg.emit`${a}.copy(${b})`;
  },
  multiplyNumber = (fg, a, b) => {
    fg.emit`${a}.multiplyNumber(${b})`;
  },
  add = (fg, a, b) => {
    fg.emit`${a}.add(${b})`;
  }
} = {}) {
  const params = ['start', 'end'];
  const tmp = new Value();
  const Lerper = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, {
      [Value.name]: Value
    });
    fg.name = `${Value.name}Lerper`;
    fg.params = params;

    for (const p of params) {
      create(fg, `this.${p}`);
      fg.emit`if(${p}===undefined){`;
      initialize(fg, `this.${p}`);
      fg.emit`}else{`;
      copy(fg, `this.${p}`, p);
      fg.emit`}`;
    }
  });
  const defineMethod = function_property_definer_makers["b" /* makeMethodDefiner */](Lerper.prototype);
  const aliasProperty = make_property_aliaser["a" /* makePropertyAliaser */](Lerper.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = params;

    for (const p of params) {
      copy(fg, `this.${p}`, p);
    }

    fg.emit`return this`;
  });
  defineMethod(fg => {
    fg.name = `from${Lerper.name}`;
    fg.params = ['lerper'];
    fg.emit`return this.set(${params.map(p => `lerper.${p}`)})`;
  });
  aliasProperty(`from${Lerper.name}`, `from${Lerper.name.slice(Value.name.length)}`);
  aliasProperty(`from${Lerper.name}`, 'copy');
  defineMethod(fg => {
    fg.ctx[Lerper.name] = Lerper;
    fg.name = 'clone';
    fg.emit`return new ${Lerper.name}().copy(this)`;
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      tmp
    });
    fg.name = 'evaluate';
    fg.params = ['alpha', 'result'];
    copy(fg, 'result', 'this.start');
    multiplyNumber(fg, 'result', '(1-alpha)');
    copy(fg, 'tmp', 'this.end');
    multiplyNumber(fg, 'tmp', 'alpha');
    add(fg, 'result', 'tmp');
    fg.emit`return result`;
  });
  return Lerper;
}
const Vector2Lerper = makeLerper(vectors["a" /* Vector2 */]);
const Vector3Lerper = makeLerper(vectors["b" /* Vector3 */]);
const ComplexLerper = makeLerper(complex["a" /* Complex */]);
const QuaternionLerper = makeLerper(lib_quaternion["a" /* Quaternion */]);
const RGBColorLerper = makeLerper(rgb_color_RGBColor);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js
/**
 * @module @wgetemp/math
 */

















/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {/* unused harmony export $mobx */
/* unused harmony export FlowCancellationError */
/* unused harmony export IDerivationState */
/* unused harmony export ObservableMap */
/* unused harmony export ObservableSet */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Reaction; });
/* unused harmony export _allowStateChanges */
/* unused harmony export _allowStateChangesInsideComputed */
/* unused harmony export _allowStateReadsEnd */
/* unused harmony export _allowStateReadsStart */
/* unused harmony export _endAction */
/* unused harmony export _getAdministration */
/* unused harmony export _getGlobalState */
/* unused harmony export _interceptReads */
/* unused harmony export _isComputingDerivation */
/* unused harmony export _resetGlobalState */
/* unused harmony export _startAction */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return autorun; });
/* unused harmony export comparer */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return computed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return configure; });
/* unused harmony export createAtom */
/* unused harmony export decorate */
/* unused harmony export entries */
/* unused harmony export extendObservable */
/* unused harmony export extendShallowObservable */
/* unused harmony export flow */
/* unused harmony export get */
/* unused harmony export getAtom */
/* unused harmony export getDebugName */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDependencyTree; });
/* unused harmony export getObserverTree */
/* unused harmony export has */
/* unused harmony export intercept */
/* unused harmony export isAction */
/* unused harmony export isArrayLike */
/* unused harmony export isBoxedObservable */
/* unused harmony export isComputed */
/* unused harmony export isComputedProp */
/* unused harmony export isFlowCancellationError */
/* unused harmony export isObservable */
/* unused harmony export isObservableArray */
/* unused harmony export isObservableMap */
/* unused harmony export isObservableObject */
/* unused harmony export isObservableProp */
/* unused harmony export isObservableSet */
/* unused harmony export keys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return observable; });
/* unused harmony export observe */
/* unused harmony export onBecomeObserved */
/* unused harmony export onBecomeUnobserved */
/* unused harmony export onReactionError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return reaction; });
/* unused harmony export remove */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return runInAction; });
/* unused harmony export set */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return spy; });
/* unused harmony export toJS */
/* unused harmony export trace */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return transaction; });
/* unused harmony export untracked */
/* unused harmony export values */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return when; });
/** MobX - (c) Michel Weststrate 2015 - 2020 - MIT Licensed */
var OBFUSCATED_ERROR = "An invariant failed, however the error is obfuscated because this is an production build.";
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var mockGlobal = {};
function getGlobal() {
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    return mockGlobal;
}
function getNextId() {
    return ++globalState.mobxGuid;
}
function fail(message) {
    invariant(false, message);
    throw "X"; // unreachable
}
function invariant(check, message) {
    if (!check)
        throw new Error("[mobx] " + (message || OBFUSCATED_ERROR));
}
/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */
var deprecatedMessages = [];
function deprecated(msg, thing) {
    if (true)
        return false;
    if (thing) {
        return deprecated("'" + msg + "', use '" + thing + "' instead.");
    }
    if (deprecatedMessages.indexOf(msg) !== -1)
        return false;
    deprecatedMessages.push(msg);
    console.error("[mobx] Deprecated: " + msg);
    return true;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */
function once(func) {
    var invoked = false;
    return function () {
        if (invoked)
            return;
        invoked = true;
        return func.apply(this, arguments);
    };
}
var noop = function () { };
function unique(list) {
    var res = [];
    list.forEach(function (item) {
        if (res.indexOf(item) === -1)
            res.push(item);
    });
    return res;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isPlainObject(value) {
    if (value === null || typeof value !== "object")
        return false;
    var proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
}
function convertToMap(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
        return dataStructure;
    }
    else if (Array.isArray(dataStructure)) {
        return new Map(dataStructure);
    }
    else if (isPlainObject(dataStructure)) {
        var map = new Map();
        for (var key in dataStructure) {
            map.set(key, dataStructure[key]);
        }
        return map;
    }
    else {
        return fail("Cannot convert to map from '" + dataStructure + "'");
    }
}
function makeNonEnumerable(object, propNames) {
    for (var i = 0; i < propNames.length; i++) {
        addHiddenProp(object, propNames[i], object[propNames[i]]);
    }
}
function addHiddenProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value: value
    });
}
function addHiddenFinalProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: value
    });
}
function isPropertyConfigurable(object, prop) {
    var descriptor = Object.getOwnPropertyDescriptor(object, prop);
    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);
}
function assertPropertyConfigurable(object, prop) {
    if (false)
        {}
}
function createInstanceofPredicate(name, clazz) {
    var propName = "isMobX" + name;
    clazz.prototype[propName] = true;
    return function (x) {
        return isObject(x) && x[propName] === true;
    };
}
function areBothNaN(a, b) {
    return typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
/**
 * Returns whether the argument is an array, disregarding observability.
 */
function isArrayLike(x) {
    return Array.isArray(x) || isObservableArray(x);
}
function isES6Map(thing) {
    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map)
        return true;
    return false;
}
function isES6Set(thing) {
    return thing instanceof Set;
}
// use Array.from in Mobx 5
function iteratorToArray(it) {
    var res = [];
    while (true) {
        var r = it.next();
        if (r.done)
            break;
        res.push(r.value);
    }
    return res;
}
function primitiveSymbol() {
    // es-disable-next-line
    return (typeof Symbol === "function" && Symbol.toPrimitive) || "@@toPrimitive";
}
function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
}
// Use "for of" in V5
function forOf(iter, callback) {
    var next = iter.next();
    while (!next.done) {
        callback(next.value);
        next = iter.next();
    }
}

function iteratorSymbol() {
    return (typeof Symbol === "function" && Symbol.iterator) || "@@iterator";
}
function declareIterator(prototType, iteratorFactory) {
    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);
}
function makeIterable(iterator) {
    iterator[iteratorSymbol()] = getSelf;
    return iterator;
}
function toStringTagSymbol() {
    return (typeof Symbol === "function" && Symbol.toStringTag) || "@@toStringTag";
}
function getSelf() {
    return this;
}

/**
 * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs
 *
 * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used
 * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom.
 */
var Atom = /** @class */ (function () {
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */
    function Atom(name) {
        if (name === void 0) { name = "Atom@" + getNextId(); }
        this.name = name;
        this.isPendingUnobservation = false; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
        this.isBeingObserved = false;
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.NOT_TRACKING;
    }
    Atom.prototype.onBecomeUnobserved = function () {
        // noop
    };
    Atom.prototype.onBecomeObserved = function () {
        /* noop */
    };
    /**
     * Invoke this method to notify mobx that your atom has been used somehow.
     * Returns true if there is currently a reactive context.
     */
    Atom.prototype.reportObserved = function () {
        return reportObserved(this);
    };
    /**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */
    Atom.prototype.reportChanged = function () {
        startBatch();
        propagateChanged(this);
        endBatch();
    };
    Atom.prototype.toString = function () {
        return this.name;
    };
    return Atom;
}());
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var atom = new Atom(name);
    onBecomeObserved(atom, onBecomeObservedHandler);
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    return atom;
}

function identityComparer(a, b) {
    return a === b;
}
function structuralComparer(a, b) {
    return deepEqual(a, b);
}
function shallowComparer(a, b) {
    return deepEqual(a, b, 1);
}
function defaultComparer(a, b) {
    return areBothNaN(a, b) || identityComparer(a, b);
}
var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    default: defaultComparer,
    shallow: shallowComparer
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var enumerableDescriptorCache = {};
var nonEnumerableDescriptorCache = {};
function createPropertyInitializerDescriptor(prop, enumerable) {
    var cache = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
    return (cache[prop] ||
        (cache[prop] = {
            configurable: true,
            enumerable: enumerable,
            get: function () {
                initializeInstance(this);
                return this[prop];
            },
            set: function (value) {
                initializeInstance(this);
                this[prop] = value;
            }
        }));
}
function initializeInstance(target) {
    if (target.__mobxDidRunLazyInitializers === true)
        return;
    var decorators = target.__mobxDecorators;
    if (decorators) {
        addHiddenProp(target, "__mobxDidRunLazyInitializers", true);
        for (var key in decorators) {
            var d = decorators[key];
            d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments);
        }
    }
}
function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
    return function decoratorFactory() {
        var decoratorArguments;
        var decorator = function decorate(target, prop, descriptor, applyImmediately
        // This is a special parameter to signal the direct application of a decorator, allow extendObservable to skip the entire type decoration part,
        // as the instance to apply the decorator to equals the target
        ) {
            if (applyImmediately === true) {
                propertyCreator(target, prop, descriptor, target, decoratorArguments);
                return null;
            }
            if (false)
                {}
            if (!Object.prototype.hasOwnProperty.call(target, "__mobxDecorators")) {
                var inheritedDecorators = target.__mobxDecorators;
                addHiddenProp(target, "__mobxDecorators", __assign({}, inheritedDecorators));
            }
            target.__mobxDecorators[prop] = {
                prop: prop,
                propertyCreator: propertyCreator,
                descriptor: descriptor,
                decoratorTarget: target,
                decoratorArguments: decoratorArguments
            };
            return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
        };
        if (quacksLikeADecorator(arguments)) {
            // @decorator
            decoratorArguments = EMPTY_ARRAY;
            return decorator.apply(null, arguments);
        }
        else {
            // @decorator(args)
            decoratorArguments = Array.prototype.slice.call(arguments);
            return decorator;
        }
    };
}
function quacksLikeADecorator(args) {
    return (((args.length === 2 || args.length === 3) && typeof args[1] === "string") ||
        (args.length === 4 && args[3] === true));
}

function deepEnhancer(v, _, name) {
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    if (Array.isArray(v))
        return observable.array(v, { name: name });
    if (isPlainObject(v))
        return observable.object(v, undefined, { name: name });
    if (isES6Map(v))
        return observable.map(v, { name: name });
    if (isES6Set(v))
        return observable.set(v, { name: name });
    return v;
}
function shallowEnhancer(v, _, name) {
    if (v === undefined || v === null)
        return v;
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v))
        return v;
    if (Array.isArray(v))
        return observable.array(v, { name: name, deep: false });
    if (isPlainObject(v))
        return observable.object(v, undefined, { name: name, deep: false });
    if (isES6Map(v))
        return observable.map(v, { name: name, deep: false });
    if (isES6Set(v))
        return observable.set(v, { name: name, deep: false });
    return fail( false &&
        false);
}
function referenceEnhancer(newValue) {
    // never turn into an observable
    return newValue;
}
function refStructEnhancer(v, oldValue, name) {
    if (false)
        {}
    if (deepEqual(v, oldValue))
        return oldValue;
    return v;
}

function createDecoratorForEnhancer(enhancer) {
    invariant(enhancer);
    var decorator = createPropDecorator(true, function (target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
        if (false) {}
        var initialValue = descriptor
            ? descriptor.initializer
                ? descriptor.initializer.call(target)
                : descriptor.value
            : undefined;
        defineObservableProperty(target, propertyName, initialValue, enhancer);
    });
    var res = 
    // Extra process checks, as this happens during module initialization
    typeof process !== "undefined" && process.env && "production" !== "production"
        ? function observableDecorator() {
            // This wrapper function is just to detect illegal decorator invocations, deprecate in a next version
            // and simply return the created prop decorator
            if (arguments.length < 2)
                return fail("Incorrect decorator invocation. @observable decorator doesn't expect any arguments");
            return decorator.apply(null, arguments);
        }
        : decorator;
    res.enhancer = enhancer;
    return res;
}

// Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases
var defaultCreateObservableOptions = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined
};
var shallowCreateObservableOptions = {
    deep: false,
    name: undefined,
    defaultDecorator: undefined
};
Object.freeze(defaultCreateObservableOptions);
Object.freeze(shallowCreateObservableOptions);
function assertValidOption(key) {
    if (!/^(deep|name|equals|defaultDecorator)$/.test(key))
        fail("invalid option for (extend)observable: " + key);
}
function asCreateObservableOptions(thing) {
    if (thing === null || thing === undefined)
        return defaultCreateObservableOptions;
    if (typeof thing === "string")
        return { name: thing, deep: true };
    if (false) {}
    return thing;
}
function getEnhancerFromOptions(options) {
    return options.defaultDecorator
        ? options.defaultDecorator.enhancer
        : options.deep === false
            ? referenceEnhancer
            : deepEnhancer;
}
var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */
function createObservable(v, arg2, arg3) {
    // @observable someProp;
    if (typeof arguments[1] === "string") {
        return deepDecorator.apply(null, arguments);
    }
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    var res = isPlainObject(v)
        ? observable.object(v, arg2, arg3)
        : Array.isArray(v)
            ? observable.array(v, arg2)
            : isES6Map(v)
                ? observable.map(v, arg2)
                : isES6Set(v)
                    ? observable.set(v, arg2)
                    : v;
    // this value could be converted to a new observable data structure, return it
    if (res !== v)
        return res;
    // otherwise, just box it
    fail( false &&
        false);
}
var observableFactories = {
    box: function (value, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("box");
        var o = asCreateObservableOptions(options);
        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    shallowBox: function (value, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowBox");
        deprecated("observable.shallowBox", "observable.box(value, { deep: false })");
        return observable.box(value, { name: name, deep: false });
    },
    array: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("array");
        var o = asCreateObservableOptions(options);
        return new ObservableArray(initialValues, getEnhancerFromOptions(o), o.name);
    },
    shallowArray: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowArray");
        deprecated("observable.shallowArray", "observable.array(values, { deep: false })");
        return observable.array(initialValues, { name: name, deep: false });
    },
    map: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("map");
        var o = asCreateObservableOptions(options);
        return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
    },
    shallowMap: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowMap");
        deprecated("observable.shallowMap", "observable.map(values, { deep: false })");
        return observable.map(initialValues, { name: name, deep: false });
    },
    set: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("set");
        var o = asCreateObservableOptions(options);
        return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
    },
    object: function (props, decorators, options) {
        if (typeof arguments[1] === "string")
            incorrectlyUsedAsDecorator("object");
        var o = asCreateObservableOptions(options);
        return extendObservable({}, props, decorators, o);
    },
    shallowObject: function (props, name) {
        if (typeof arguments[1] === "string")
            incorrectlyUsedAsDecorator("shallowObject");
        deprecated("observable.shallowObject", "observable.object(values, {}, { deep: false })");
        return observable.object(props, {}, { name: name, deep: false });
    },
    ref: refDecorator,
    shallow: shallowDecorator,
    deep: deepDecorator,
    struct: refStructDecorator
};
var observable = createObservable;
// weird trick to keep our typings nicely with our funcs, and still extend the observable function
Object.keys(observableFactories).forEach(function (name) { return (observable[name] = observableFactories[name]); });
function incorrectlyUsedAsDecorator(methodName) {
    fail(
    // process.env.NODE_ENV !== "production" &&
    "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}

var computedDecorator = createPropDecorator(false, function (instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
    if (false) {}
    var get = descriptor.get, set = descriptor.set; // initialValue is the descriptor for get / set props
    // Optimization: faster on decorator target or instance? Assuming target
    // Optimization: find out if declaring on instance isn't just faster. (also makes the property descriptor simpler). But, more memory usage..
    // Forcing instance now, fixes hot reloadig issues on React Native:
    var options = decoratorArgs[0] || {};
    defineComputedProperty(instance, propertyName, __assign({ get: get, set: set }, options));
});
var computedStructDecorator = computedDecorator({ equals: comparer.structural });
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */
var computed = function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        // @computed
        return computedDecorator.apply(null, arguments);
    }
    if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) {
        // @computed({ options })
        return computedDecorator.apply(null, arguments);
    }
    // computed(expr, options?)
    if (false) {}
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.get = arg1;
    opts.set = typeof arg2 === "function" ? arg2 : opts.set;
    opts.name = opts.name || arg1.name || ""; /* for generated name */
    return new ComputedValue(opts);
};
computed.struct = computedStructDecorator;

var IDerivationState;
(function (IDerivationState) {
    // before being run or (outside batch and not being observed)
    // at this point derivation is not holding any data about dependency tree
    IDerivationState[IDerivationState["NOT_TRACKING"] = -1] = "NOT_TRACKING";
    // no shallow dependency changed since last computation
    // won't recalculate derivation
    // this is what makes mobx fast
    IDerivationState[IDerivationState["UP_TO_DATE"] = 0] = "UP_TO_DATE";
    // some deep dependency changed, but don't know if shallow dependency changed
    // will require to check first if UP_TO_DATE or POSSIBLY_STALE
    // currently only ComputedValue will propagate POSSIBLY_STALE
    //
    // having this state is second big optimization:
    // don't have to recompute on every dependency change, but only when it's needed
    IDerivationState[IDerivationState["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
    // A shallow dependency has changed since last computation and the derivation
    // will need to recompute when it's needed next.
    IDerivationState[IDerivationState["STALE"] = 2] = "STALE";
})(IDerivationState || (IDerivationState = {}));
var TraceMode;
(function (TraceMode) {
    TraceMode[TraceMode["NONE"] = 0] = "NONE";
    TraceMode[TraceMode["LOG"] = 1] = "LOG";
    TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = /** @class */ (function () {
    function CaughtException(cause) {
        this.cause = cause;
        // Empty
    }
    return CaughtException;
}());
function isCaughtException(e) {
    return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */
function shouldCompute(derivation) {
    switch (derivation.dependenciesState) {
        case IDerivationState.UP_TO_DATE:
            return false;
        case IDerivationState.NOT_TRACKING:
        case IDerivationState.STALE:
            return true;
        case IDerivationState.POSSIBLY_STALE: {
            // state propagation can occur outside of action/reactive context #2195
            var prevAllowStateReads = allowStateReadsStart(true);
            var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
            var obs = derivation.observing, l = obs.length;
            for (var i = 0; i < l; i++) {
                var obj = obs[i];
                if (isComputedValue(obj)) {
                    if (globalState.disableErrorBoundaries) {
                        obj.get();
                    }
                    else {
                        try {
                            obj.get();
                        }
                        catch (e) {
                            // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                            untrackedEnd(prevUntracked);
                            allowStateReadsEnd(prevAllowStateReads);
                            return true;
                        }
                    }
                    // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
                    // and `derivation` is an observer of `obj`
                    // invariantShouldCompute(derivation)
                    if (derivation.dependenciesState === IDerivationState.STALE) {
                        untrackedEnd(prevUntracked);
                        allowStateReadsEnd(prevAllowStateReads);
                        return true;
                    }
                }
            }
            changeDependenciesStateTo0(derivation);
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return false;
        }
    }
}
// function invariantShouldCompute(derivation: IDerivation) {
//     const newDepState = (derivation as any).dependenciesState
//     if (
//         process.env.NODE_ENV === "production" &&
//         (newDepState === IDerivationState.POSSIBLY_STALE ||
//             newDepState === IDerivationState.NOT_TRACKING)
//     )
//         fail("Illegal dependency state")
// }
function isComputingDerivation() {
    return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {
    var hasObservers = atom.observers.length > 0;
    // Should never be possible to change an observed observable from inside computed, see #798
    if (globalState.computationDepth > 0 && hasObservers)
        fail( false &&
            false);
    // Should not be possible to change observed state outside strict mode, except during initialization, see #563
    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "strict"))
        fail( false &&
            false);
}
function checkIfStateReadsAreAllowed(observable) {
    if (false) {}
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */
function trackDerivedFunction(derivation, f, context) {
    var prevAllowStateReads = allowStateReadsStart(true);
    // pre allocate array allocation + room for variation in deps
    // array will be trimmed by bindDependencies
    changeDependenciesStateTo0(derivation);
    derivation.newObserving = new Array(derivation.observing.length + 100);
    derivation.unboundDepsCount = 0;
    derivation.runId = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    var result;
    if (globalState.disableErrorBoundaries === true) {
        result = f.call(context);
    }
    else {
        try {
            result = f.call(context);
        }
        catch (e) {
            result = new CaughtException(e);
        }
    }
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    if (derivation.observing.length === 0) {
        warnAboutDerivationWithoutDependencies(derivation);
    }
    allowStateReadsEnd(prevAllowStateReads);
    return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
    if (true)
        return;
    if (globalState.reactionRequiresObservable || derivation.requiresObservable) {
        console.warn("[mobx] Derivation " + derivation.name + " is created/updated without reading any observable value");
    }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */
function bindDependencies(derivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    var prevObserving = derivation.observing;
    var observing = (derivation.observing = derivation.newObserving);
    var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE;
    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    var i0 = 0, l = derivation.unboundDepsCount;
    for (var i = 0; i < l; i++) {
        var dep = observing[i];
        if (dep.diffValue === 0) {
            dep.diffValue = 1;
            if (i0 !== i)
                observing[i0] = dep;
            i0++;
        }
        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if (dep.dependenciesState > lowestNewObservingDerivationState) {
            lowestNewObservingDerivationState = dep.dependenciesState;
        }
    }
    observing.length = i0;
    derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    l = prevObserving.length;
    while (l--) {
        var dep = prevObserving[l];
        if (dep.diffValue === 0) {
            removeObserver(dep, derivation);
        }
        dep.diffValue = 0;
    }
    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    while (i0--) {
        var dep = observing[i0];
        if (dep.diffValue === 1) {
            dep.diffValue = 0;
            addObserver(dep, derivation);
        }
    }
    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
        derivation.dependenciesState = lowestNewObservingDerivationState;
        derivation.onBecomeStale();
    }
}
function clearObserving(derivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
    var obs = derivation.observing;
    derivation.observing = [];
    var i = obs.length;
    while (i--)
        removeObserver(obs[i], derivation);
    derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}
function untrackedStart() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
}
function untrackedEnd(prev) {
    globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
    var prev = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev;
}
function allowStateReadsEnd(prev) {
    globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */
function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE)
        return;
    derivation.dependenciesState = IDerivationState.UP_TO_DATE;
    var obs = derivation.observing;
    var i = obs.length;
    while (i--)
        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
}

// we don't use globalState for these in order to avoid possible issues with multiple
// mobx versions
var currentActionId = 0;
var nextActionId = 1;
var functionNameDescriptor = Object.getOwnPropertyDescriptor(function () { }, "name");
var isFunctionNameConfigurable = functionNameDescriptor && functionNameDescriptor.configurable;
function createAction(actionName, fn) {
    if (false) {}
    var res = function () {
        return executeAction(actionName, fn, this, arguments);
    };
    if (false) {}
    res.isMobxAction = true;
    return res;
}
function executeAction(actionName, fn, scope, args) {
    var runInfo = _startAction(actionName, scope, args);
    try {
        return fn.apply(scope, args);
    }
    catch (err) {
        runInfo.error = err;
        throw err;
    }
    finally {
        _endAction(runInfo);
    }
}
function _startAction(actionName, scope, args) {
    var notifySpy = isSpyEnabled() && !!actionName;
    var startTime = 0;
    if (notifySpy) {
        startTime = Date.now();
        var l = (args && args.length) || 0;
        var flattendArgs = new Array(l);
        if (l > 0)
            for (var i = 0; i < l; i++)
                flattendArgs[i] = args[i];
        spyReportStart({
            type: "action",
            name: actionName,
            object: scope,
            arguments: flattendArgs
        });
    }
    var prevDerivation = untrackedStart();
    startBatch();
    var prevAllowStateChanges = allowStateChangesStart(true);
    var prevAllowStateReads = allowStateReadsStart(true);
    var runInfo = {
        prevDerivation: prevDerivation,
        prevAllowStateChanges: prevAllowStateChanges,
        prevAllowStateReads: prevAllowStateReads,
        notifySpy: notifySpy,
        startTime: startTime,
        actionId: nextActionId++,
        parentActionId: currentActionId
    };
    currentActionId = runInfo.actionId;
    return runInfo;
}
function _endAction(runInfo) {
    if (currentActionId !== runInfo.actionId) {
        fail("invalid action stack. did you forget to finish an action?");
    }
    currentActionId = runInfo.parentActionId;
    if (runInfo.error !== undefined) {
        globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges);
    allowStateReadsEnd(runInfo.prevAllowStateReads);
    endBatch();
    untrackedEnd(runInfo.prevDerivation);
    if (runInfo.notifySpy) {
        spyReportEnd({ time: Date.now() - runInfo.startTime });
    }
    globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
    var prev = allowStateChangesStart(allowStateChanges);
    var res;
    try {
        res = func();
    }
    finally {
        allowStateChangesEnd(prev);
    }
    return res;
}
function allowStateChangesStart(allowStateChanges) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges;
    return prev;
}
function allowStateChangesEnd(prev) {
    globalState.allowStateChanges = prev;
}
function allowStateChangesInsideComputed(func) {
    var prev = globalState.computationDepth;
    globalState.computationDepth = 0;
    var res;
    try {
        res = func();
    }
    finally {
        globalState.computationDepth = prev;
    }
    return res;
}

var ObservableValue = /** @class */ (function (_super) {
    __extends(ObservableValue, _super);
    function ObservableValue(value, enhancer, name, notifySpy, equals) {
        if (name === void 0) { name = "ObservableValue@" + getNextId(); }
        if (notifySpy === void 0) { notifySpy = true; }
        if (equals === void 0) { equals = comparer.default; }
        var _this = _super.call(this, name) || this;
        _this.enhancer = enhancer;
        _this.name = name;
        _this.equals = equals;
        _this.hasUnreportedChange = false;
        _this.value = enhancer(value, undefined, name);
        if (notifySpy && isSpyEnabled()) {
            // only notify spy if this is a stand-alone observable
            spyReport({ type: "create", name: _this.name, newValue: "" + _this.value });
        }
        return _this;
    }
    ObservableValue.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableValue.prototype.set = function (newValue) {
        var oldValue = this.value;
        newValue = this.prepareNewValue(newValue);
        if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            if (notifySpy) {
                spyReportStart({
                    type: "update",
                    name: this.name,
                    newValue: newValue,
                    oldValue: oldValue
                });
            }
            this.setNewValue(newValue);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableValue.prototype.prepareNewValue = function (newValue) {
        checkIfStateModificationsAreAllowed(this);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this,
                type: "update",
                newValue: newValue
            });
            if (!change)
                return globalState.UNCHANGED;
            newValue = change.newValue;
        }
        // apply modifier
        newValue = this.enhancer(newValue, this.value, this.name);
        return this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
    };
    ObservableValue.prototype.setNewValue = function (newValue) {
        var oldValue = this.value;
        this.value = newValue;
        this.reportChanged();
        if (hasListeners(this)) {
            notifyListeners(this, {
                type: "update",
                object: this,
                newValue: newValue,
                oldValue: oldValue
            });
        }
    };
    ObservableValue.prototype.get = function () {
        this.reportObserved();
        return this.dehanceValue(this.value);
    };
    ObservableValue.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableValue.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately)
            listener({
                object: this,
                type: "update",
                newValue: this.value,
                oldValue: undefined
            });
        return registerListener(this, listener);
    };
    ObservableValue.prototype.toJSON = function () {
        return this.get();
    };
    ObservableValue.prototype.toString = function () {
        return this.name + "[" + this.value + "]";
    };
    ObservableValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    return ObservableValue;
}(Atom));
ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);

/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */
var ComputedValue = /** @class */ (function () {
    /**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce a new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */
    function ComputedValue(options) {
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = null; // during tracking it's an array with new observed observers
        this.isBeingObserved = false;
        this.isPendingUnobservation = false;
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.runId = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.UP_TO_DATE;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.value = new CaughtException(null);
        this.isComputing = false; // to check for cycles
        this.isRunningSetter = false;
        this.isTracing = TraceMode.NONE;
        invariant(options.get, "missing option for computed: get");
        this.derivation = options.get;
        this.name = options.name || "ComputedValue@" + getNextId();
        if (options.set)
            this.setter = createAction(this.name + "-setter", options.set);
        this.equals =
            options.equals ||
                (options.compareStructural || options.struct
                    ? comparer.structural
                    : comparer.default);
        this.scope = options.context;
        this.requiresReaction = !!options.requiresReaction;
        this.keepAlive = !!options.keepAlive;
    }
    ComputedValue.prototype.onBecomeStale = function () {
        propagateMaybeChanged(this);
    };
    ComputedValue.prototype.onBecomeUnobserved = function () { };
    ComputedValue.prototype.onBecomeObserved = function () { };
    /**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */
    ComputedValue.prototype.get = function () {
        if (this.isComputing)
            fail("Cycle detected in computation " + this.name + ": " + this.derivation);
        if (globalState.inBatch === 0 && this.observers.length === 0 && !this.keepAlive) {
            if (shouldCompute(this)) {
                this.warnAboutUntrackedRead();
                startBatch(); // See perf test 'computed memoization'
                this.value = this.computeValue(false);
                endBatch();
            }
        }
        else {
            reportObserved(this);
            if (shouldCompute(this))
                if (this.trackAndCompute())
                    propagateChangeConfirmed(this);
        }
        var result = this.value;
        if (isCaughtException(result))
            throw result.cause;
        return result;
    };
    ComputedValue.prototype.peek = function () {
        var res = this.computeValue(false);
        if (isCaughtException(res))
            throw res.cause;
        return res;
    };
    ComputedValue.prototype.set = function (value) {
        if (this.setter) {
            invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
            this.isRunningSetter = true;
            try {
                this.setter.call(this.scope, value);
            }
            finally {
                this.isRunningSetter = false;
            }
        }
        else
            invariant(false,  false &&
                false);
    };
    ComputedValue.prototype.trackAndCompute = function () {
        if (isSpyEnabled()) {
            spyReport({
                object: this.scope,
                type: "compute",
                name: this.name
            });
        }
        var oldValue = this.value;
        var wasSuspended = 
        /* see #1208 */ this.dependenciesState === IDerivationState.NOT_TRACKING;
        var newValue = this.computeValue(true);
        var changed = wasSuspended ||
            isCaughtException(oldValue) ||
            isCaughtException(newValue) ||
            !this.equals(oldValue, newValue);
        if (changed) {
            this.value = newValue;
        }
        return changed;
    };
    ComputedValue.prototype.computeValue = function (track) {
        this.isComputing = true;
        globalState.computationDepth++;
        var res;
        if (track) {
            res = trackDerivedFunction(this, this.derivation, this.scope);
        }
        else {
            if (globalState.disableErrorBoundaries === true) {
                res = this.derivation.call(this.scope);
            }
            else {
                try {
                    res = this.derivation.call(this.scope);
                }
                catch (e) {
                    res = new CaughtException(e);
                }
            }
        }
        globalState.computationDepth--;
        this.isComputing = false;
        return res;
    };
    ComputedValue.prototype.suspend = function () {
        if (!this.keepAlive) {
            clearObserving(this);
            this.value = undefined; // don't hold on to computed value!
        }
    };
    ComputedValue.prototype.observe = function (listener, fireImmediately) {
        var _this = this;
        var firstTime = true;
        var prevValue = undefined;
        return autorun(function () {
            var newValue = _this.get();
            if (!firstTime || fireImmediately) {
                var prevU = untrackedStart();
                listener({
                    type: "update",
                    object: _this,
                    newValue: newValue,
                    oldValue: prevValue
                });
                untrackedEnd(prevU);
            }
            firstTime = false;
            prevValue = newValue;
        });
    };
    ComputedValue.prototype.warnAboutUntrackedRead = function () {
        if (true)
            return;
        if (this.requiresReaction === true) {
            fail("[mobx] Computed value " + this.name + " is read outside a reactive context");
        }
        if (this.isTracing !== TraceMode.NONE) {
            console.log("[mobx.trace] '" + this.name + "' is being read outside a reactive context. Doing a full recompute");
        }
        if (globalState.computedRequiresReaction) {
            console.warn("[mobx] Computed value " + this.name + " is being read outside a reactive context. Doing a full recompute");
        }
    };
    ComputedValue.prototype.toJSON = function () {
        return this.get();
    };
    ComputedValue.prototype.toString = function () {
        return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    return ComputedValue;
}());
ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);

/**
 * These values will persist if global state is reset
 */
var persistentKeys = [
    "mobxGuid",
    "spyListeners",
    "enforceActions",
    "computedRequiresReaction",
    "reactionRequiresObservable",
    "observableRequiresReaction",
    "allowStateReads",
    "disableErrorBoundaries",
    "runId",
    "UNCHANGED"
];
var MobXGlobals = /** @class */ (function () {
    function MobXGlobals() {
        /**
         * MobXGlobals version.
         * MobX compatiblity with other versions loaded in memory as long as this version matches.
         * It indicates that the global state still stores similar information
         *
         * N.B: this version is unrelated to the package version of MobX, and is only the version of the
         * internal state storage of MobX, and can be the same across many different package versions
         */
        this.version = 5;
        /**
         * globally unique token to signal unchanged
         */
        this.UNCHANGED = {};
        /**
         * Currently running derivation
         */
        this.trackingDerivation = null;
        /**
         * Are we running a computation currently? (not a reaction)
         */
        this.computationDepth = 0;
        /**
         * Each time a derivation is tracked, it is assigned a unique run-id
         */
        this.runId = 0;
        /**
         * 'guid' for general purpose. Will be persisted amongst resets.
         */
        this.mobxGuid = 0;
        /**
         * Are we in a batch block? (and how many of them)
         */
        this.inBatch = 0;
        /**
         * Observables that don't have observers anymore, and are about to be
         * suspended, unless somebody else accesses it in the same batch
         *
         * @type {IObservable[]}
         */
        this.pendingUnobservations = [];
        /**
         * List of scheduled, not yet executed, reactions.
         */
        this.pendingReactions = [];
        /**
         * Are we currently processing reactions?
         */
        this.isRunningReactions = false;
        /**
         * Is it allowed to change observables at this point?
         * In general, MobX doesn't allow that when running computations and React.render.
         * To ensure that those functions stay pure.
         */
        this.allowStateChanges = true;
        /**
         * Is it allowed to read observables at this point?
         * Used to hold the state needed for `observableRequiresReaction`
         */
        this.allowStateReads = true;
        /**
         * If strict mode is enabled, state changes are by default not allowed
         */
        this.enforceActions = false;
        /**
         * Spy callbacks
         */
        this.spyListeners = [];
        /**
         * Globally attached error handlers that react specifically to errors in reactions
         */
        this.globalReactionErrorHandlers = [];
        /**
         * Warn if computed values are accessed outside a reactive context
         */
        this.computedRequiresReaction = false;
        /**
         * (Experimental)
         * Warn if you try to create to derivation / reactive context without accessing any observable.
         */
        this.reactionRequiresObservable = false;
        /**
         * (Experimental)
         * Warn if observables are accessed outside a reactive context
         */
        this.observableRequiresReaction = false;
        /**
         * Allows overwriting of computed properties, useful in tests but not prod as it can cause
         * memory leaks. See https://github.com/mobxjs/mobx/issues/1867
         */
        this.computedConfigurable = false;
        /*
         * Don't catch and rethrow exceptions. This is useful for inspecting the state of
         * the stack when an exception occurs while debugging.
         */
        this.disableErrorBoundaries = false;
        /*
         * If true, we are already handling an exception in an action. Any errors in reactions should be supressed, as
         * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
         */
        this.suppressReactionErrors = false;
    }
    return MobXGlobals;
}());
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = (function () {
    var global = getGlobal();
    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals)
        canMergeGlobalState = false;
    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version)
        canMergeGlobalState = false;
    if (!canMergeGlobalState) {
        setTimeout(function () {
            if (!isolateCalled) {
                fail("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
            }
        }, 1);
        return new MobXGlobals();
    }
    else if (global.__mobxGlobals) {
        global.__mobxInstanceCount += 1;
        if (!global.__mobxGlobals.UNCHANGED)
            global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible
        return global.__mobxGlobals;
    }
    else {
        global.__mobxInstanceCount = 1;
        return (global.__mobxGlobals = new MobXGlobals());
    }
})();
function isolateGlobalState() {
    if (globalState.pendingReactions.length ||
        globalState.inBatch ||
        globalState.isRunningReactions)
        fail("isolateGlobalState should be called before MobX is running any reactions");
    isolateCalled = true;
    if (canMergeGlobalState) {
        if (--getGlobal().__mobxInstanceCount === 0)
            getGlobal().__mobxGlobals = undefined;
        globalState = new MobXGlobals();
    }
}
function getGlobalState() {
    return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */
function resetGlobalState() {
    var defaultGlobals = new MobXGlobals();
    for (var key in defaultGlobals)
        if (persistentKeys.indexOf(key) === -1)
            globalState[key] = defaultGlobals[key];
    globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
    return observable.observers && observable.observers.length > 0;
}
function getObservers(observable) {
    return observable.observers;
}
// function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }
function addObserver(observable, node) {
    // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
    // invariantObservers(observable);
    var l = observable.observers.length;
    if (l) {
        // because object assignment is relatively expensive, let's not store data about index 0.
        observable.observersIndexes[node.__mapid] = l;
    }
    observable.observers[l] = node;
    if (observable.lowestObserverState > node.dependenciesState)
        observable.lowestObserverState = node.dependenciesState;
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
    // invariantObservers(observable);
    if (observable.observers.length === 1) {
        // deleting last observer
        observable.observers.length = 0;
        queueForUnobservation(observable);
    }
    else {
        // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element
        var list = observable.observers;
        var map = observable.observersIndexes;
        var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesn't have holes
        if (filler !== node) {
            // otherwise node was the last element, which already got removed from array
            var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map.
            if (index) {
                // map store all indexes but 0, see comment in `addObserver`
                map[filler.__mapid] = index;
            }
            else {
                delete map[filler.__mapid];
            }
            list[index] = filler;
        }
        delete map[node.__mapid];
    }
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}
function queueForUnobservation(observable) {
    if (observable.isPendingUnobservation === false) {
        // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
        observable.isPendingUnobservation = true;
        globalState.pendingUnobservations.push(observable);
    }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */
function startBatch() {
    globalState.inBatch++;
}
function endBatch() {
    if (--globalState.inBatch === 0) {
        runReactions();
        // the batch is actually about to finish, all unobserving should happen here.
        var list = globalState.pendingUnobservations;
        for (var i = 0; i < list.length; i++) {
            var observable = list[i];
            observable.isPendingUnobservation = false;
            if (observable.observers.length === 0) {
                if (observable.isBeingObserved) {
                    // if this observable had reactive observers, trigger the hooks
                    observable.isBeingObserved = false;
                    observable.onBecomeUnobserved();
                }
                if (observable instanceof ComputedValue) {
                    // computed values are automatically teared down when the last observer leaves
                    // this process happens recursively, this computed might be the last observable of another, etc..
                    observable.suspend();
                }
            }
        }
        globalState.pendingUnobservations = [];
    }
}
function reportObserved(observable) {
    checkIfStateReadsAreAllowed(observable);
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
        /**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */
        if (derivation.runId !== observable.lastAccessedBy) {
            observable.lastAccessedBy = derivation.runId;
            derivation.newObserving[derivation.unboundDepsCount++] = observable;
            if (!observable.isBeingObserved) {
                observable.isBeingObserved = true;
                observable.onBecomeObserved();
            }
        }
        return true;
    }
    else if (observable.observers.length === 0 && globalState.inBatch > 0) {
        queueForUnobservation(observable);
    }
    return false;
}
// function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }
/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes
function propagateChanged(observable) {
    // invariantLOS(observable, "changed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
        d.dependenciesState = IDerivationState.STALE;
    }
    // invariantLOS(observable, "changed end");
}
// Called by ComputedValue when it recalculate and its value changed
function propagateChangeConfirmed(observable) {
    // invariantLOS(observable, "confirmed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE)
            d.dependenciesState = IDerivationState.STALE;
        else if (d.dependenciesState === IDerivationState.UP_TO_DATE // this happens during computing of `d`, just keep lowestObserverState up to date.
        )
            observable.lowestObserverState = IDerivationState.UP_TO_DATE;
    }
    // invariantLOS(observable, "confirmed end");
}
// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
function propagateMaybeChanged(observable) {
    // invariantLOS(observable, "maybe start");
    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE)
        return;
    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            d.dependenciesState = IDerivationState.POSSIBLY_STALE;
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
    }
    // invariantLOS(observable, "maybe end");
}
function logTraceInfo(derivation, observable) {
    console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable.name + "'");
    if (derivation.isTracing === TraceMode.BREAK) {
        var lines = [];
        printDepTree(getDependencyTree(derivation), lines, 1);
        // prettier-ignore
        new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
}
function printDepTree(tree, lines, depth) {
    if (lines.length >= 1000) {
        lines.push("(and many more)");
        return;
    }
    lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)
    if (tree.dependencies)
        tree.dependencies.forEach(function (child) { return printDepTree(child, lines, depth + 1); });
}

var Reaction = /** @class */ (function () {
    function Reaction(name, onInvalidate, errorHandler, requiresObservable) {
        if (name === void 0) { name = "Reaction@" + getNextId(); }
        if (requiresObservable === void 0) { requiresObservable = false; }
        this.name = name;
        this.onInvalidate = onInvalidate;
        this.errorHandler = errorHandler;
        this.requiresObservable = requiresObservable;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = [];
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.diffValue = 0;
        this.runId = 0;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.isDisposed = false;
        this._isScheduled = false;
        this._isTrackPending = false;
        this._isRunning = false;
        this.isTracing = TraceMode.NONE;
    }
    Reaction.prototype.onBecomeStale = function () {
        this.schedule();
    };
    Reaction.prototype.schedule = function () {
        if (!this._isScheduled) {
            this._isScheduled = true;
            globalState.pendingReactions.push(this);
            runReactions();
        }
    };
    Reaction.prototype.isScheduled = function () {
        return this._isScheduled;
    };
    /**
     * internal, use schedule() if you intend to kick off a reaction
     */
    Reaction.prototype.runReaction = function () {
        if (!this.isDisposed) {
            startBatch();
            this._isScheduled = false;
            if (shouldCompute(this)) {
                this._isTrackPending = true;
                try {
                    this.onInvalidate();
                    if (this._isTrackPending && isSpyEnabled()) {
                        // onInvalidate didn't trigger track right away..
                        spyReport({
                            name: this.name,
                            type: "scheduled-reaction"
                        });
                    }
                }
                catch (e) {
                    this.reportExceptionInDerivation(e);
                }
            }
            endBatch();
        }
    };
    Reaction.prototype.track = function (fn) {
        startBatch();
        var notify = isSpyEnabled();
        var startTime;
        if (notify) {
            startTime = Date.now();
            spyReportStart({
                name: this.name,
                type: "reaction"
            });
        }
        this._isRunning = true;
        var result = trackDerivedFunction(this, fn, undefined);
        this._isRunning = false;
        this._isTrackPending = false;
        if (this.isDisposed) {
            // disposed during last run. Clean up everything that was bound after the dispose call.
            clearObserving(this);
        }
        if (isCaughtException(result))
            this.reportExceptionInDerivation(result.cause);
        if (notify) {
            spyReportEnd({
                time: Date.now() - startTime
            });
        }
        endBatch();
    };
    Reaction.prototype.reportExceptionInDerivation = function (error) {
        var _this = this;
        if (this.errorHandler) {
            this.errorHandler(error, this);
            return;
        }
        if (globalState.disableErrorBoundaries)
            throw error;
        var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
        if (globalState.suppressReactionErrors) {
            console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)"); // prettier-ignore
        }
        else {
            console.error(message, error);
            /** If debugging brought you here, please, read the above message :-). Tnx! */
        }
        if (isSpyEnabled()) {
            spyReport({
                type: "error",
                name: this.name,
                message: message,
                error: "" + error
            });
        }
        globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); });
    };
    Reaction.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (!this._isRunning) {
                // if disposed while running, clean up later. Maybe not optimal, but rare case
                startBatch();
                clearObserving(this);
                endBatch();
            }
        }
    };
    Reaction.prototype.getDisposer = function () {
        var r = this.dispose.bind(this);
        r.$mobx = this;
        return r;
    };
    Reaction.prototype.toString = function () {
        return "Reaction[" + this.name + "]";
    };
    Reaction.prototype.trace = function (enterBreakPoint) {
        if (enterBreakPoint === void 0) { enterBreakPoint = false; }
        trace(this, enterBreakPoint);
    };
    return Reaction;
}());
function onReactionError(handler) {
    globalState.globalReactionErrorHandlers.push(handler);
    return function () {
        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
        if (idx >= 0)
            globalState.globalReactionErrorHandlers.splice(idx, 1);
    };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function (f) { return f(); };
function runReactions() {
    // Trampolining, if runReactions are already running, new reactions will be picked up
    if (globalState.inBatch > 0 || globalState.isRunningReactions)
        return;
    reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    // While running reactions, new reactions might be triggered.
    // Hence we work with two variables and check whether
    // we converge to no remaining reactions after a while.
    while (allReactions.length > 0) {
        if (++iterations === MAX_REACTION_ITERATIONS) {
            console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." +
                (" Probably there is a cycle in the reactive function: " + allReactions[0]));
            allReactions.splice(0); // clear reactions
        }
        var remainingReactions = allReactions.splice(0);
        for (var i = 0, l = remainingReactions.length; i < l; i++)
            remainingReactions[i].runReaction();
    }
    globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function (f) { return fn(function () { return baseScheduler(f); }); };
}

function isSpyEnabled() {
    return !!globalState.spyListeners.length;
}
function spyReport(event) {
    if (!globalState.spyListeners.length)
        return;
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length; i < l; i++)
        listeners[i](event);
}
function spyReportStart(event) {
    var change = __assign(__assign({}, event), { spyReportStart: true });
    spyReport(change);
}
var END_EVENT = { spyReportEnd: true };
function spyReportEnd(change) {
    if (change)
        spyReport(__assign(__assign({}, change), { spyReportEnd: true }));
    else
        spyReport(END_EVENT);
}
function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        globalState.spyListeners = globalState.spyListeners.filter(function (l) { return l !== listener; });
    });
}

function dontReassignFields() {
    fail( false && false);
}
function namedActionDecorator(name) {
    return function (target, prop, descriptor) {
        if (descriptor) {
            if (false) {}
            // babel / typescript
            // @action method() { }
            if (descriptor.value) {
                // typescript
                return {
                    value: createAction(name, descriptor.value),
                    enumerable: false,
                    configurable: true,
                    writable: true // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)
                };
            }
            // babel only: @action method = () => {}
            var initializer_1 = descriptor.initializer;
            return {
                enumerable: false,
                configurable: true,
                writable: true,
                initializer: function () {
                    // N.B: we can't immediately invoke initializer; this would be wrong
                    return createAction(name, initializer_1.call(this));
                }
            };
        }
        // bound instance methods
        return actionFieldDecorator(name).apply(this, arguments);
    };
}
function actionFieldDecorator(name) {
    // Simple property that writes on first invocation to the current instance
    return function (target, prop, descriptor) {
        Object.defineProperty(target, prop, {
            configurable: true,
            enumerable: false,
            get: function () {
                return undefined;
            },
            set: function (value) {
                addHiddenProp(this, prop, action(name, value));
            }
        });
    };
}
function boundActionDecorator(target, propertyName, descriptor, applyToInstance) {
    if (applyToInstance === true) {
        defineBoundAction(target, propertyName, descriptor.value);
        return null;
    }
    if (descriptor) {
        // if (descriptor.value)
        // Typescript / Babel: @action.bound method() { }
        // also: babel @action.bound method = () => {}
        return {
            configurable: true,
            enumerable: false,
            get: function () {
                defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this));
                return this[propertyName];
            },
            set: dontReassignFields
        };
    }
    // field decorator Typescript @action.bound method = () => {}
    return {
        enumerable: false,
        configurable: true,
        set: function (v) {
            defineBoundAction(this, propertyName, v);
        },
        get: function () {
            return undefined;
        }
    };
}

var action = function action(arg1, arg2, arg3, arg4) {
    // action(fn() {})
    if (arguments.length === 1 && typeof arg1 === "function")
        return createAction(arg1.name || "<unnamed action>", arg1);
    // action("name", fn() {})
    if (arguments.length === 2 && typeof arg2 === "function")
        return createAction(arg1, arg2);
    // @action("name") fn() {}
    if (arguments.length === 1 && typeof arg1 === "string")
        return namedActionDecorator(arg1);
    // @action fn() {}
    if (arg4 === true) {
        // apply to instance immediately
        arg1[arg2] = createAction(arg1.name || arg2, arg3.value);
    }
    else {
        return namedActionDecorator(arg2).apply(null, arguments);
    }
};
action.bound = boundActionDecorator;
function runInAction(arg1, arg2) {
    // TODO: deprecate?
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    if (false) {}
    return executeAction(actionName, fn, this, undefined);
}
function isAction(thing) {
    return typeof thing === "function" && thing.isMobxAction === true;
}
function defineBoundAction(target, propertyName, fn) {
    addHiddenProp(target, propertyName, createAction(propertyName, fn.bind(target)));
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */
function autorun(view, opts) {
    if (opts === void 0) { opts = EMPTY_OBJECT; }
    if (false) {}
    var name = (opts && opts.name) || view.name || "Autorun@" + getNextId();
    var runSync = !opts.scheduler && !opts.delay;
    var reaction;
    if (runSync) {
        // normal autorun
        reaction = new Reaction(name, function () {
            this.track(reactionRunner);
        }, opts.onError, opts.requiresObservable);
    }
    else {
        var scheduler_1 = createSchedulerFromOptions(opts);
        // debounced autorun
        var isScheduled_1 = false;
        reaction = new Reaction(name, function () {
            if (!isScheduled_1) {
                isScheduled_1 = true;
                scheduler_1(function () {
                    isScheduled_1 = false;
                    if (!reaction.isDisposed)
                        reaction.track(reactionRunner);
                });
            }
        }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}
var run = function (f) { return f(); };
function createSchedulerFromOptions(opts) {
    return opts.scheduler
        ? opts.scheduler
        : opts.delay
            ? function (f) { return setTimeout(f, opts.delay); }
            : run;
}
function reaction(expression, effect, opts) {
    if (opts === void 0) { opts = EMPTY_OBJECT; }
    if (typeof opts === "boolean") {
        opts = { fireImmediately: opts };
        deprecated("Using fireImmediately as argument is deprecated. Use '{ fireImmediately: true }' instead");
    }
    if (false) {}
    var name = opts.name || "Reaction@" + getNextId();
    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
    var runSync = !opts.scheduler && !opts.delay;
    var scheduler = createSchedulerFromOptions(opts);
    var firstTime = true;
    var isScheduled = false;
    var value;
    var equals = opts.compareStructural
        ? comparer.structural
        : opts.equals || comparer.default;
    var r = new Reaction(name, function () {
        if (firstTime || runSync) {
            reactionRunner();
        }
        else if (!isScheduled) {
            isScheduled = true;
            scheduler(reactionRunner);
        }
    }, opts.onError, opts.requiresObservable);
    function reactionRunner() {
        isScheduled = false; // Q: move into reaction runner?
        if (r.isDisposed)
            return;
        var changed = false;
        r.track(function () {
            var nextValue = expression(r);
            changed = firstTime || !equals(value, nextValue);
            value = nextValue;
        });
        if (firstTime && opts.fireImmediately)
            effectAction(value, r);
        if (!firstTime && changed === true)
            effectAction(value, r);
        if (firstTime)
            firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}
function wrapErrorHandler(errorHandler, baseFn) {
    return function () {
        try {
            return baseFn.apply(this, arguments);
        }
        catch (e) {
            errorHandler.call(this, e);
        }
    };
}

function onBecomeObserved(thing, arg2, arg3) {
    return interceptHook("onBecomeObserved", thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
    return interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = typeof arg3 === "function" ? arg3 : arg2;
    var orig = atom[hook];
    if (typeof orig !== "function")
        return fail( false && false);
    atom[hook] = function () {
        orig.call(this);
        cb.call(this);
    };
    return function () {
        atom[hook] = orig;
    };
}

function configure(options) {
    var enforceActions = options.enforceActions, computedRequiresReaction = options.computedRequiresReaction, computedConfigurable = options.computedConfigurable, disableErrorBoundaries = options.disableErrorBoundaries, arrayBuffer = options.arrayBuffer, reactionScheduler = options.reactionScheduler, reactionRequiresObservable = options.reactionRequiresObservable, observableRequiresReaction = options.observableRequiresReaction;
    if (options.isolateGlobalState === true) {
        isolateGlobalState();
    }
    if (enforceActions !== undefined) {
        if (typeof enforceActions === "boolean" || enforceActions === "strict")
            deprecated("Deprecated value for 'enforceActions', use 'false' => '\"never\"', 'true' => '\"observed\"', '\"strict\"' => \"'always'\" instead");
        var ea = void 0;
        switch (enforceActions) {
            case true:
            case "observed":
                ea = true;
                break;
            case false:
            case "never":
                ea = false;
                break;
            case "strict":
            case "always":
                ea = "strict";
                break;
            default:
                fail("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
        }
        globalState.enforceActions = ea;
        globalState.allowStateChanges = ea === true || ea === "strict" ? false : true;
    }
    if (computedRequiresReaction !== undefined) {
        globalState.computedRequiresReaction = !!computedRequiresReaction;
    }
    if (reactionRequiresObservable !== undefined) {
        globalState.reactionRequiresObservable = !!reactionRequiresObservable;
    }
    if (observableRequiresReaction !== undefined) {
        globalState.observableRequiresReaction = !!observableRequiresReaction;
        globalState.allowStateReads = !globalState.observableRequiresReaction;
    }
    if (computedConfigurable !== undefined) {
        globalState.computedConfigurable = !!computedConfigurable;
    }
    if (disableErrorBoundaries !== undefined) {
        if (disableErrorBoundaries === true)
            console.warn("WARNING: Debug feature only. MobX will NOT recover from errors if this is on.");
        globalState.disableErrorBoundaries = !!disableErrorBoundaries;
    }
    if (typeof arrayBuffer === "number") {
        reserveArrayBuffer(arrayBuffer);
    }
    if (reactionScheduler) {
        setReactionScheduler(reactionScheduler);
    }
}

function decorate(thing, decorators) {
    if (false)
        {}
    var target = typeof thing === "function" ? thing.prototype : thing;
    var _loop_1 = function (prop) {
        var propertyDecorators = decorators[prop];
        if (!Array.isArray(propertyDecorators)) {
            propertyDecorators = [propertyDecorators];
        }
        // prettier-ignore
        if (false)
            {}
        var descriptor = Object.getOwnPropertyDescriptor(target, prop);
        var newDescriptor = propertyDecorators.reduce(function (accDescriptor, decorator) { return decorator(target, prop, accDescriptor); }, descriptor);
        if (newDescriptor)
            Object.defineProperty(target, prop, newDescriptor);
    };
    for (var prop in decorators) {
        _loop_1(prop);
    }
    return thing;
}

function extendShallowObservable(target, properties, decorators) {
    deprecated("'extendShallowObservable' is deprecated, use 'extendObservable(target, props, { deep: false })' instead");
    return extendObservable(target, properties, decorators, shallowCreateObservableOptions);
}
function extendObservable(target, properties, decorators, options) {
    if (false) { var key; }
    options = asCreateObservableOptions(options);
    var defaultDecorator = options.defaultDecorator || (options.deep === false ? refDecorator : deepDecorator);
    initializeInstance(target);
    asObservableObject(target, options.name, defaultDecorator.enhancer); // make sure object is observable, even without initial props
    startBatch();
    try {
        var keys = Object.getOwnPropertyNames(properties);
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            var descriptor = Object.getOwnPropertyDescriptor(properties, key);
            if (false) {}
            var decorator = decorators && key in decorators
                ? decorators[key]
                : descriptor.get
                    ? computedDecorator
                    : defaultDecorator;
            if (false)
                {}
            var resultDescriptor = decorator(target, key, descriptor, true);
            if (resultDescriptor // otherwise, assume already applied, due to `applyToInstance`
            )
                Object.defineProperty(target, key, resultDescriptor);
        }
    }
    finally {
        endBatch();
    }
    return target;
}

function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
    var result = {
        name: node.name
    };
    if (node.observing && node.observing.length > 0)
        result.dependencies = unique(node.observing).map(nodeToDependencyTree);
    return result;
}
function getObserverTree(thing, property) {
    return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
    var result = {
        name: node.name
    };
    if (hasObservers(node))
        result.observers = getObservers(node).map(nodeToObserverTree);
    return result;
}

var generatorId = 0;
function FlowCancellationError() {
    this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = Object.create(Error.prototype);
function isFlowCancellationError(error) {
    return error instanceof FlowCancellationError;
}
function flow(generator) {
    if (arguments.length !== 1)
        fail( true && "Flow expects one 1 argument and cannot be used as decorator");
    var name = generator.name || "<unnamed flow>";
    // Implementation based on https://github.com/tj/co/blob/master/index.js
    return function () {
        var ctx = this;
        var args = arguments;
        var runId = ++generatorId;
        var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
        var rejector;
        var pendingPromise = undefined;
        var res = new Promise(function (resolve, reject) {
            var stepId = 0;
            rejector = reject;
            function onFulfilled(res) {
                pendingPromise = undefined;
                var ret;
                try {
                    ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
                }
                catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function onRejected(err) {
                pendingPromise = undefined;
                var ret;
                try {
                    ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.throw).call(gen, err);
                }
                catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function next(ret) {
                if (ret && typeof ret.then === "function") {
                    // an async iterator
                    ret.then(next, reject);
                    return;
                }
                if (ret.done)
                    return resolve(ret.value);
                pendingPromise = Promise.resolve(ret.value);
                return pendingPromise.then(onFulfilled, onRejected);
            }
            onFulfilled(undefined); // kick off the process
        });
        res.cancel = action(name + " - runid: " + runId + " - cancel", function () {
            try {
                if (pendingPromise)
                    cancelPromise(pendingPromise);
                // Finally block can return (or yield) stuff..
                var res_1 = gen.return(undefined);
                // eat anything that promise would do, it's cancelled!
                var yieldedPromise = Promise.resolve(res_1.value);
                yieldedPromise.then(noop, noop);
                cancelPromise(yieldedPromise); // maybe it can be cancelled :)
                // reject our original promise
                rejector(new FlowCancellationError());
            }
            catch (e) {
                rejector(e); // there could be a throwing finally block
            }
        });
        return res;
    };
}
function cancelPromise(promise) {
    if (typeof promise.cancel === "function")
        promise.cancel();
}

function interceptReads(thing, propOrHandler, handler) {
    var target;
    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
        target = getAdministration(thing);
    }
    else if (isObservableObject(thing)) {
        if (typeof propOrHandler !== "string")
            return fail( false &&
                false);
        target = getAdministration(thing, propOrHandler);
    }
    else {
        return fail( false &&
            false);
    }
    if (target.dehancer !== undefined)
        return fail( false && false);
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
    return function () {
        target.dehancer = undefined;
    };
}

function intercept(thing, propOrHandler, handler) {
    if (typeof handler === "function")
        return interceptProperty(thing, propOrHandler, handler);
    else
        return interceptInterceptable(thing, propOrHandler);
}
function interceptInterceptable(thing, handler) {
    return getAdministration(thing).intercept(handler);
}
function interceptProperty(thing, property, handler) {
    return getAdministration(thing, property).intercept(handler);
}

function _isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        if (!value.$mobx.values[property])
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}
function isComputed(value) {
    if (arguments.length > 1)
        return fail( false &&
            false);
    return _isComputed(value);
}
function isComputedProp(value, propName) {
    if (typeof propName !== "string")
        return fail( false &&
            false);
    return _isComputed(value, propName);
}

function _isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (false)
            {}
        if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values && !!o.values[property];
        }
        return false;
    }
    // For first check, see #701
    return (isObservableObject(value) ||
        !!value.$mobx ||
        isAtom(value) ||
        isReaction(value) ||
        isComputedValue(value));
}
function isObservable(value) {
    if (arguments.length !== 1)
        fail( false &&
            false);
    return _isObservable(value);
}
function isObservableProp(value, propName) {
    if (typeof propName !== "string")
        return fail( false && false);
    return _isObservable(value, propName);
}

function keys(obj) {
    if (isObservableObject(obj)) {
        return obj.$mobx.getKeys();
    }
    if (isObservableMap(obj)) {
        return iteratorToArray(obj.keys());
    }
    if (isObservableSet(obj)) {
        return iteratorToArray(obj.keys());
    }
    if (isObservableArray(obj)) {
        return obj.map(function (_, index) { return index; });
    }
    return fail( false &&
        false);
}
function values(obj) {
    if (isObservableObject(obj)) {
        return keys(obj).map(function (key) { return obj[key]; });
    }
    if (isObservableMap(obj)) {
        return keys(obj).map(function (key) { return obj.get(key); });
    }
    if (isObservableSet(obj)) {
        return iteratorToArray(obj.values());
    }
    if (isObservableArray(obj)) {
        return obj.slice();
    }
    return fail( false &&
        false);
}
function entries(obj) {
    if (isObservableObject(obj)) {
        return keys(obj).map(function (key) { return [key, obj[key]]; });
    }
    if (isObservableMap(obj)) {
        return keys(obj).map(function (key) { return [key, obj.get(key)]; });
    }
    if (isObservableSet(obj)) {
        return iteratorToArray(obj.entries());
    }
    if (isObservableArray(obj)) {
        return obj.map(function (key, index) { return [index, key]; });
    }
    return fail( false &&
        false);
}
function set(obj, key, value) {
    if (arguments.length === 2 && !isObservableSet(obj)) {
        startBatch();
        var values_1 = key;
        try {
            for (var key_1 in values_1)
                set(obj, key_1, values_1[key_1]);
        }
        finally {
            endBatch();
        }
        return;
    }
    if (isObservableObject(obj)) {
        var adm = obj.$mobx;
        var existingObservable = adm.values[key];
        if (existingObservable) {
            adm.write(obj, key, value);
        }
        else {
            defineObservableProperty(obj, key, value, adm.defaultEnhancer);
        }
    }
    else if (isObservableMap(obj)) {
        obj.set(key, value);
    }
    else if (isObservableSet(obj)) {
        obj.add(key);
    }
    else if (isObservableArray(obj)) {
        if (typeof key !== "number")
            key = parseInt(key, 10);
        invariant(key >= 0, "Not a valid index: '" + key + "'");
        startBatch();
        if (key >= obj.length)
            obj.length = key + 1;
        obj[key] = value;
        endBatch();
    }
    else {
        return fail( false &&
            false);
    }
}
function remove(obj, key) {
    if (isObservableObject(obj)) {
        obj.$mobx.remove(key);
    }
    else if (isObservableMap(obj)) {
        obj.delete(key);
    }
    else if (isObservableSet(obj)) {
        obj.delete(key);
    }
    else if (isObservableArray(obj)) {
        if (typeof key !== "number")
            key = parseInt(key, 10);
        invariant(key >= 0, "Not a valid index: '" + key + "'");
        obj.splice(key, 1);
    }
    else {
        return fail( false &&
            false);
    }
}
function has(obj, key) {
    if (isObservableObject(obj)) {
        // return keys(obj).indexOf(key) >= 0
        var adm = getAdministration(obj);
        adm.getKeys(); // make sure we get notified of key changes, but for performance, use the values map to look up existence
        return !!adm.values[key];
    }
    else if (isObservableMap(obj)) {
        return obj.has(key);
    }
    else if (isObservableSet(obj)) {
        return obj.has(key);
    }
    else if (isObservableArray(obj)) {
        return key >= 0 && key < obj.length;
    }
    else {
        return fail( false &&
            false);
    }
}
function get(obj, key) {
    if (!has(obj, key))
        return undefined;
    if (isObservableObject(obj)) {
        return obj[key];
    }
    else if (isObservableMap(obj)) {
        return obj.get(key);
    }
    else if (isObservableArray(obj)) {
        return obj[key];
    }
    else {
        return fail( false &&
            false);
    }
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function")
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
        return observeObservable(thing, propOrCb, cbOrFire);
}
function observeObservable(thing, listener, fireImmediately) {
    return getAdministration(thing).observe(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
    return getAdministration(thing, property).observe(listener, fireImmediately);
}

var defaultOptions = {
    detectCycles: true,
    exportMapsAsObjects: true,
    recurseEverything: false
};
function cache(map, key, value, options) {
    if (options.detectCycles)
        map.set(key, value);
    return value;
}
function toJSHelper(source, options, __alreadySeen) {
    if (!options.recurseEverything && !isObservable(source))
        return source;
    if (typeof source !== "object")
        return source;
    // Directly return null if source is null
    if (source === null)
        return null;
    // Directly return the Date object itself if contained in the observable
    if (source instanceof Date)
        return source;
    if (isObservableValue(source))
        return toJSHelper(source.get(), options, __alreadySeen);
    // make sure we track the keys of the object
    if (isObservable(source))
        keys(source);
    var detectCycles = options.detectCycles === true;
    if (detectCycles && source !== null && __alreadySeen.has(source)) {
        return __alreadySeen.get(source);
    }
    if (isObservableArray(source) || Array.isArray(source)) {
        var res_1 = cache(__alreadySeen, source, [], options);
        var toAdd = source.map(function (value) { return toJSHelper(value, options, __alreadySeen); });
        res_1.length = toAdd.length;
        for (var i = 0, l = toAdd.length; i < l; i++)
            res_1[i] = toAdd[i];
        return res_1;
    }
    if (isObservableSet(source) || Object.getPrototypeOf(source) === Set.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_2 = cache(__alreadySeen, source, new Set(), options);
            source.forEach(function (value) {
                res_2.add(toJSHelper(value, options, __alreadySeen));
            });
            return res_2;
        }
        else {
            var res_3 = cache(__alreadySeen, source, [], options);
            source.forEach(function (value) {
                res_3.push(toJSHelper(value, options, __alreadySeen));
            });
            return res_3;
        }
    }
    if (isObservableMap(source) || Object.getPrototypeOf(source) === Map.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_4 = cache(__alreadySeen, source, new Map(), options);
            source.forEach(function (value, key) {
                res_4.set(key, toJSHelper(value, options, __alreadySeen));
            });
            return res_4;
        }
        else {
            var res_5 = cache(__alreadySeen, source, {}, options);
            source.forEach(function (value, key) {
                res_5[key] = toJSHelper(value, options, __alreadySeen);
            });
            return res_5;
        }
    }
    // Fallback to the situation that source is an ObservableObject or a plain object
    var res = cache(__alreadySeen, source, {}, options);
    for (var key in source) {
        res[key] = toJSHelper(source[key], options, __alreadySeen);
    }
    return res;
}
function toJS(source, options) {
    // backward compatibility
    if (typeof options === "boolean")
        options = { detectCycles: options };
    if (!options)
        options = defaultOptions;
    options.detectCycles =
        options.detectCycles === undefined
            ? options.recurseEverything === true
            : options.detectCycles === true;
    var __alreadySeen;
    if (options.detectCycles)
        __alreadySeen = new Map();
    return toJSHelper(source, options, __alreadySeen);
}

function trace() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var enterBreakPoint = false;
    if (typeof args[args.length - 1] === "boolean")
        enterBreakPoint = args.pop();
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
        return fail( false &&
            false);
    }
    if (derivation.isTracing === TraceMode.NONE) {
        console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
    }
    derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
    switch (args.length) {
        case 0:
            return globalState.trackingDerivation;
        case 1:
            return getAtom(args[0]);
        case 2:
            return getAtom(args[0], args[1]);
    }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */
function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    startBatch();
    try {
        return action.apply(thisArg);
    }
    finally {
        endBatch();
    }
}

function when(predicate, arg1, arg2) {
    if (arguments.length === 1 || (arg1 && typeof arg1 === "object"))
        return whenPromise(predicate, arg1);
    return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect, opts) {
    var timeoutHandle;
    if (typeof opts.timeout === "number") {
        timeoutHandle = setTimeout(function () {
            if (!disposer.$mobx.isDisposed) {
                disposer();
                var error = new Error("WHEN_TIMEOUT");
                if (opts.onError)
                    opts.onError(error);
                else
                    throw error;
            }
        }, opts.timeout);
    }
    opts.name = opts.name || "When@" + getNextId();
    var effectAction = createAction(opts.name + "-effect", effect);
    var disposer = autorun(function (r) {
        if (predicate()) {
            r.dispose();
            if (timeoutHandle)
                clearTimeout(timeoutHandle);
            effectAction();
        }
    }, opts);
    return disposer;
}
function whenPromise(predicate, opts) {
    if (false)
        {}
    var cancel;
    var res = new Promise(function (resolve, reject) {
        var disposer = _when(predicate, resolve, __assign(__assign({}, opts), { onError: reject }));
        cancel = function () {
            disposer();
            reject("WHEN_CANCELLED");
        };
    });
    res.cancel = cancel;
    return res;
}

function hasInterceptors(interceptable) {
    return interceptable.interceptors !== undefined && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
    interceptors.push(handler);
    return once(function () {
        var idx = interceptors.indexOf(handler);
        if (idx !== -1)
            interceptors.splice(idx, 1);
    });
}
function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
        var interceptors = interceptable.interceptors;
        if (interceptors)
            for (var i = 0, l = interceptors.length; i < l; i++) {
                change = interceptors[i](change);
                invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
                if (!change)
                    break;
            }
        return change;
    }
    finally {
        untrackedEnd(prevU);
    }
}

function hasListeners(listenable) {
    return listenable.changeListeners !== undefined && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners || (listenable.changeListeners = []);
    listeners.push(handler);
    return once(function () {
        var idx = listeners.indexOf(handler);
        if (idx !== -1)
            listeners.splice(idx, 1);
    });
}
function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners;
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}

var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
// Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364
var safariPrototypeSetterInheritanceBug = (function () {
    var v = false;
    var p = {};
    Object.defineProperty(p, "0", {
        set: function () {
            v = true;
        }
    });
    Object.create(p)["0"] = 1;
    return v === false;
})();
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
// Typescript workaround to make sure ObservableArray extends Array
var StubArray = /** @class */ (function () {
    function StubArray() {
    }
    return StubArray;
}());
function inherit(ctor, proto) {
    if (typeof Object["setPrototypeOf"] !== "undefined") {
        Object["setPrototypeOf"](ctor.prototype, proto);
    }
    else if (typeof ctor.prototype.__proto__ !== "undefined") {
        ctor.prototype.__proto__ = proto;
    }
    else {
        ctor["prototype"] = proto;
    }
}
inherit(StubArray, Array.prototype);
// Weex freeze Array.prototype
// Make them writeable and configurable in prototype chain
// https://github.com/alibaba/weex/pull/1529
if (Object.isFrozen(Array)) {
    [
        "constructor",
        "push",
        "shift",
        "concat",
        "pop",
        "unshift",
        "replace",
        "find",
        "findIndex",
        "splice",
        "reverse",
        "sort"
    ].forEach(function (key) {
        Object.defineProperty(StubArray.prototype, key, {
            configurable: true,
            writable: true,
            value: Array.prototype[key]
        });
    });
}
var ObservableArrayAdministration = /** @class */ (function () {
    function ObservableArrayAdministration(name, enhancer, array, owned) {
        this.array = array;
        this.owned = owned;
        this.values = [];
        this.lastKnownLength = 0;
        this.atom = new Atom(name || "ObservableArray@" + getNextId());
        this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + "[..]"); };
    }
    ObservableArrayAdministration.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableArrayAdministration.prototype.dehanceValues = function (values) {
        if (this.dehancer !== undefined && values.length > 0)
            return values.map(this.dehancer);
        return values;
    };
    ObservableArrayAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        if (fireImmediately) {
            listener({
                object: this.array,
                type: "splice",
                index: 0,
                added: this.values.slice(),
                addedCount: this.values.length,
                removed: [],
                removedCount: 0
            });
        }
        return registerListener(this, listener);
    };
    ObservableArrayAdministration.prototype.getArrayLength = function () {
        this.atom.reportObserved();
        return this.values.length;
    };
    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
        if (typeof newLength !== "number" || newLength < 0)
            throw new Error("[mobx.array] Out of range: " + newLength);
        var currentLength = this.values.length;
        if (newLength === currentLength)
            return;
        else if (newLength > currentLength) {
            var newItems = new Array(newLength - currentLength);
            for (var i = 0; i < newLength - currentLength; i++)
                newItems[i] = undefined; // No Array.fill everywhere...
            this.spliceWithArray(currentLength, 0, newItems);
        }
        else
            this.spliceWithArray(newLength, currentLength - newLength);
    };
    // adds / removes the necessary numeric properties to this object
    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {
        if (oldLength !== this.lastKnownLength)
            throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?");
        this.lastKnownLength += delta;
        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE)
            reserveArrayBuffer(oldLength + delta + 1);
    };
    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this.atom);
        var length = this.values.length;
        if (index === undefined)
            index = 0;
        else if (index > length)
            index = length;
        else if (index < 0)
            index = Math.max(0, length + index);
        if (arguments.length === 1)
            deleteCount = length - index;
        else if (deleteCount === undefined || deleteCount === null)
            deleteCount = 0;
        else
            deleteCount = Math.max(0, Math.min(deleteCount, length - index));
        if (newItems === undefined)
            newItems = EMPTY_ARRAY;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this.array,
                type: "splice",
                index: index,
                removedCount: deleteCount,
                added: newItems
            });
            if (!change)
                return EMPTY_ARRAY;
            deleteCount = change.removedCount;
            newItems = change.added;
        }
        newItems =
            newItems.length === 0 ? newItems : newItems.map(function (v) { return _this.enhancer(v, undefined); });
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength(length, lengthDelta); // create or remove new entries
        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
        if (deleteCount !== 0 || newItems.length !== 0)
            this.notifyArraySplice(index, newItems, res);
        return this.dehanceValues(res);
    };
    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {
        var _a;
        if (newItems.length < MAX_SPLICE_SIZE) {
            return (_a = this.values).splice.apply(_a, __spread([index, deleteCount], newItems));
        }
        else {
            var res = this.values.slice(index, index + deleteCount);
            this.values = this.values
                .slice(0, index)
                .concat(newItems, this.values.slice(index + deleteCount));
            return res;
        }
    };
    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "update",
                index: index,
                newValue: newValue,
                oldValue: oldValue
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign(__assign({}, change), { name: this.atom.name }));
        this.atom.reportChanged();
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "splice",
                index: index,
                removed: removed,
                added: added,
                removedCount: removed.length,
                addedCount: added.length
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign(__assign({}, change), { name: this.atom.name }));
        this.atom.reportChanged();
        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    return ObservableArrayAdministration;
}());
var ObservableArray = /** @class */ (function (_super) {
    __extends(ObservableArray, _super);
    function ObservableArray(initialValues, enhancer, name, owned) {
        if (name === void 0) { name = "ObservableArray@" + getNextId(); }
        if (owned === void 0) { owned = false; }
        var _this = _super.call(this) || this;
        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);
        addHiddenFinalProp(_this, "$mobx", adm);
        if (initialValues && initialValues.length) {
            var prev = allowStateChangesStart(true);
            _this.spliceWithArray(0, 0, initialValues);
            allowStateChangesEnd(prev);
        }
        if (safariPrototypeSetterInheritanceBug) {
            // Seems that Safari won't use numeric prototype setter untill any * numeric property is
            // defined on the instance. After that it works fine, even if this property is deleted.
            Object.defineProperty(adm.array, "0", ENTRY_0);
        }
        return _this;
    }
    ObservableArray.prototype.intercept = function (handler) {
        return this.$mobx.intercept(handler);
    };
    ObservableArray.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        return this.$mobx.observe(listener, fireImmediately);
    };
    ObservableArray.prototype.clear = function () {
        return this.splice(0);
    };
    ObservableArray.prototype.concat = function () {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        this.$mobx.atom.reportObserved();
        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return (isObservableArray(a) ? a.peek() : a); }));
    };
    ObservableArray.prototype.replace = function (newItems) {
        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
    };
    /**
     * Converts this array back to a (shallow) javascript structure.
     * For a deep clone use mobx.toJS
     */
    ObservableArray.prototype.toJS = function () {
        return this.slice();
    };
    ObservableArray.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toJS();
    };
    ObservableArray.prototype.peek = function () {
        this.$mobx.atom.reportObserved();
        return this.$mobx.dehanceValues(this.$mobx.values);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        if (arguments.length === 3)
            deprecated("The array.find fromIndex argument to find will not be supported anymore in the next major");
        var idx = this.findIndex.apply(this, arguments);
        return idx === -1 ? undefined : this.get(idx);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
    ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        if (arguments.length === 3)
            deprecated("The array.findIndex fromIndex argument to find will not be supported anymore in the next major");
        var items = this.peek(), l = items.length;
        for (var i = fromIndex; i < l; i++)
            if (predicate.call(thisArg, items[i], i, this))
                return i;
        return -1;
    };
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    ObservableArray.prototype.splice = function (index, deleteCount) {
        var newItems = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            newItems[_i - 2] = arguments[_i];
        }
        switch (arguments.length) {
            case 0:
                return [];
            case 1:
                return this.$mobx.spliceWithArray(index);
            case 2:
                return this.$mobx.spliceWithArray(index, deleteCount);
        }
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(adm.values.length, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.pop = function () {
        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];
    };
    ObservableArray.prototype.shift = function () {
        return this.splice(0, 1)[0];
    };
    ObservableArray.prototype.unshift = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(0, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.reverse = function () {
        // reverse by default mutates in place before returning the result
        // which makes it both a 'derivation' and a 'mutation'.
        // so we deviate from the default and just make it an dervitation
        var clone = this.slice();
        return clone.reverse.apply(clone, arguments);
    };
    ObservableArray.prototype.sort = function (compareFn) {
        // sort by default mutates in place before returning the result
        // which goes against all good practices. Let's not change the array in place!
        var clone = this.slice();
        return clone.sort.apply(clone, arguments);
    };
    ObservableArray.prototype.remove = function (value) {
        var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value);
        if (idx > -1) {
            this.splice(idx, 1);
            return true;
        }
        return false;
    };
    ObservableArray.prototype.move = function (fromIndex, toIndex) {
        deprecated("observableArray.move is deprecated, use .slice() & .replace() instead");
        function checkIndex(index) {
            if (index < 0) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
            }
            var length = this.$mobx.values.length;
            if (index >= length) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
            }
        }
        checkIndex.call(this, fromIndex);
        checkIndex.call(this, toIndex);
        if (fromIndex === toIndex) {
            return;
        }
        var oldItems = this.$mobx.values;
        var newItems;
        if (fromIndex < toIndex) {
            newItems = __spread(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [
                oldItems[fromIndex]
            ], oldItems.slice(toIndex + 1));
        }
        else {
            // toIndex < fromIndex
            newItems = __spread(oldItems.slice(0, toIndex), [
                oldItems[fromIndex]
            ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
        }
        this.replace(newItems);
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.get = function (index) {
        var impl = this.$mobx;
        if (impl) {
            if (index < impl.values.length) {
                impl.atom.reportObserved();
                return impl.dehanceValue(impl.values[index]);
            }
            console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + impl.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
        }
        return undefined;
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.set = function (index, newValue) {
        var adm = this.$mobx;
        var values = adm.values;
        if (index < values.length) {
            // update at index in range
            checkIfStateModificationsAreAllowed(adm.atom);
            var oldValue = values[index];
            if (hasInterceptors(adm)) {
                var change = interceptChange(adm, {
                    type: "update",
                    object: this,
                    index: index,
                    newValue: newValue
                });
                if (!change)
                    return;
                newValue = change.newValue;
            }
            newValue = adm.enhancer(newValue, oldValue);
            var changed = newValue !== oldValue;
            if (changed) {
                values[index] = newValue;
                adm.notifyArrayChildUpdate(index, newValue, oldValue);
            }
        }
        else if (index === values.length) {
            // add a new item
            adm.spliceWithArray(index, 0, [newValue]);
        }
        else {
            // out of bounds
            throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values.length);
        }
    };
    return ObservableArray;
}(StubArray));
declareIterator(ObservableArray.prototype, function () {
    this.$mobx.atom.reportObserved();
    var self = this;
    var nextIndex = 0;
    return makeIterable({
        next: function () {
            return nextIndex < self.length
                ? { value: self[nextIndex++], done: false }
                : { done: true, value: undefined };
        }
    });
});
Object.defineProperty(ObservableArray.prototype, "length", {
    enumerable: false,
    configurable: true,
    get: function () {
        return this.$mobx.getArrayLength();
    },
    set: function (newLength) {
        this.$mobx.setArrayLength(newLength);
    }
});
addHiddenProp(ObservableArray.prototype, toStringTagSymbol(), "Array");
["indexOf", "join", "lastIndexOf", "slice", "toString", "toLocaleString"].forEach(function (funcName) {
    var baseFunc = Array.prototype[funcName];
    invariant(typeof baseFunc === "function", "Base function not defined on Array prototype: '" + funcName + "'");
    addHiddenProp(ObservableArray.prototype, funcName, function () {
        return baseFunc.apply(this.peek(), arguments);
    });
});
[
    "every",
    "filter",
    //"find", // implemented individually (IE support)
    //"findIndex", // implemented individually (IE support)
    //"flatMap", // not supported
    "forEach",
    "map",
    "some"
].forEach(function (funcName) {
    var baseFunc = Array.prototype[funcName];
    invariant(typeof baseFunc === "function", "Base function not defined on Array prototype: '" + funcName + "'");
    addHiddenProp(ObservableArray.prototype, funcName, function (callback, thisArg) {
        var _this = this;
        var adm = this.$mobx;
        adm.atom.reportObserved();
        var dehancedValues = adm.dehanceValues(adm.values);
        return dehancedValues[funcName](function (element, index) {
            return callback.call(thisArg, element, index, _this);
        }, thisArg);
    });
});
["reduce", "reduceRight"].forEach(function (funcName) {
    addHiddenProp(ObservableArray.prototype, funcName, function () {
        var _this = this;
        var adm = this.$mobx;
        adm.atom.reportObserved();
        // #2432 - reduce behavior depends on arguments.length
        var callback = arguments[0];
        arguments[0] = function (accumulator, currentValue, index) {
            currentValue = adm.dehanceValue(currentValue);
            return callback(accumulator, currentValue, index, _this);
        };
        return adm.values[funcName].apply(adm.values, arguments);
    });
});
/**
 * We don't want those to show up in `for (const key in ar)` ...
 */
makeNonEnumerable(ObservableArray.prototype, [
    "constructor",
    "intercept",
    "observe",
    "clear",
    "concat",
    "get",
    "replace",
    "toJS",
    "toJSON",
    "peek",
    "find",
    "findIndex",
    "splice",
    "spliceWithArray",
    "push",
    "pop",
    "set",
    "shift",
    "unshift",
    "reverse",
    "sort",
    "remove",
    "move",
    "toString",
    "toLocaleString"
]);
// See #364
var ENTRY_0 = createArrayEntryDescriptor(0);
function createArrayEntryDescriptor(index) {
    return {
        enumerable: false,
        configurable: false,
        get: function () {
            return this.get(index);
        },
        set: function (value) {
            this.set(index, value);
        }
    };
}
function createArrayBufferItem(index) {
    Object.defineProperty(ObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)
        createArrayBufferItem(index);
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
}
reserveArrayBuffer(1000);
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);
}

var ObservableMapMarker = {};
var ObservableMap = /** @class */ (function () {
    function ObservableMap(initialData, enhancer, name) {
        if (enhancer === void 0) { enhancer = deepEnhancer; }
        if (name === void 0) { name = "ObservableMap@" + getNextId(); }
        this.enhancer = enhancer;
        this.name = name;
        this.$mobx = ObservableMapMarker;
        this._keysAtom = createAtom(this.name + ".keys()");
        if (typeof Map !== "function") {
            throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
        }
        this._data = new Map();
        this._hasMap = new Map();
        this.merge(initialData);
    }
    ObservableMap.prototype._has = function (key) {
        return this._data.has(key);
    };
    ObservableMap.prototype.has = function (key) {
        var _this = this;
        if (!globalState.trackingDerivation)
            return this._has(key);
        var entry = this._hasMap.get(key);
        if (!entry) {
            // todo: replace with atom (breaking change)
            var newEntry = (entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false));
            this._hasMap.set(key, newEntry);
            onBecomeUnobserved(newEntry, function () { return _this._hasMap.delete(key); });
        }
        return entry.get();
    };
    ObservableMap.prototype.set = function (key, value) {
        var hasKey = this._has(key);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: hasKey ? "update" : "add",
                object: this,
                newValue: value,
                name: key
            });
            if (!change)
                return this;
            value = change.newValue;
        }
        if (hasKey) {
            this._updateValue(key, value);
        }
        else {
            this._addValue(key, value);
        }
        return this;
    };
    ObservableMap.prototype.delete = function (key) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this._keysAtom);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "delete",
                object: this,
                name: key
            });
            if (!change)
                return false;
        }
        if (this._has(key)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "delete",
                    object: this,
                    oldValue: this._data.get(key).value,
                    name: key
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign(__assign({}, change), { name: this.name, key: key }));
            transaction(function () {
                _this._keysAtom.reportChanged();
                _this._updateHasMapEntry(key, false);
                var observable = _this._data.get(key);
                observable.setNewValue(undefined);
                _this._data.delete(key);
            });
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
            return true;
        }
        return false;
    };
    ObservableMap.prototype._updateHasMapEntry = function (key, value) {
        var entry = this._hasMap.get(key);
        if (entry) {
            entry.setNewValue(value);
        }
    };
    ObservableMap.prototype._updateValue = function (key, newValue) {
        var observable = this._data.get(key);
        newValue = observable.prepareNewValue(newValue);
        if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "update",
                    object: this,
                    oldValue: observable.value,
                    name: key,
                    newValue: newValue
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign(__assign({}, change), { name: this.name, key: key }));
            observable.setNewValue(newValue);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableMap.prototype._addValue = function (key, newValue) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this._keysAtom);
        transaction(function () {
            var observable = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);
            _this._data.set(key, observable);
            newValue = observable.value; // value might have been changed
            _this._updateHasMapEntry(key, true);
            _this._keysAtom.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                type: "add",
                object: this,
                name: key,
                newValue: newValue
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign(__assign({}, change), { name: this.name, key: key }));
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableMap.prototype.get = function (key) {
        if (this.has(key))
            return this.dehanceValue(this._data.get(key).get());
        return this.dehanceValue(undefined);
    };
    ObservableMap.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined) {
            return this.dehancer(value);
        }
        return value;
    };
    ObservableMap.prototype.keys = function () {
        this._keysAtom.reportObserved();
        return this._data.keys();
    };
    ObservableMap.prototype.values = function () {
        var self = this;
        var keys = this.keys();
        return makeIterable({
            next: function () {
                var _a = keys.next(), done = _a.done, value = _a.value;
                return {
                    done: done,
                    value: done ? undefined : self.get(value)
                };
            }
        });
    };
    ObservableMap.prototype.entries = function () {
        var self = this;
        var keys = this.keys();
        return makeIterable({
            next: function () {
                var _a = keys.next(), done = _a.done, value = _a.value;
                return {
                    done: done,
                    value: done ? undefined : [value, self.get(value)]
                };
            }
        });
    };
    ObservableMap.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        this._keysAtom.reportObserved();
        this._data.forEach(function (_, key) { return callback.call(thisArg, _this.get(key), key, _this); });
    };
    /** Merge another object into this object, returns this. */
    ObservableMap.prototype.merge = function (other) {
        var _this = this;
        if (isObservableMap(other)) {
            other = other.toJS();
        }
        transaction(function () {
            var prev = allowStateChangesStart(true);
            try {
                if (isPlainObject(other))
                    Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });
                else if (Array.isArray(other))
                    other.forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        return _this.set(key, value);
                    });
                else if (isES6Map(other)) {
                    if (other.constructor !== Map)
                        fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name); // prettier-ignore
                    else
                        other.forEach(function (value, key) { return _this.set(key, value); });
                }
                else if (other !== null && other !== undefined)
                    fail("Cannot initialize map from " + other);
            }
            finally {
                allowStateChangesEnd(prev);
            }
        });
        return this;
    };
    ObservableMap.prototype.clear = function () {
        var _this = this;
        transaction(function () {
            untracked(function () {
                // Note we are concurrently reading/deleting the same keys
                // forEach handles this properly
                _this._data.forEach(function (_, key) { return _this.delete(key); });
            });
        });
    };
    ObservableMap.prototype.replace = function (values) {
        var _this = this;
        // Implementation requirements:
        // - respect ordering of replacement map
        // - allow interceptors to run and potentially prevent individual operations
        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
        // - note that result map may differ from replacement map due to the interceptors
        transaction(function () {
            // Convert to map so we can do quick key lookups
            var replacementMap = convertToMap(values);
            var orderedData = new Map();
            // Used for optimization
            var keysReportChangedCalled = false;
            // Delete keys that don't exist in replacement map
            // if the key deletion is prevented by interceptor
            // add entry at the beginning of the result map
            forOf(_this._data.keys(), function (key) {
                // Concurrently iterating/deleting keys
                // iterator should handle this correctly
                if (!replacementMap.has(key)) {
                    var deleted = _this.delete(key);
                    // Was the key removed?
                    if (deleted) {
                        // _keysAtom.reportChanged() was already called
                        keysReportChangedCalled = true;
                    }
                    else {
                        // Delete prevented by interceptor
                        var value = _this._data.get(key);
                        orderedData.set(key, value);
                    }
                }
            });
            // Merge entries
            forOf(replacementMap.entries(), function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                // We will want to know whether a new key is added
                var keyExisted = _this._data.has(key);
                // Add or update value
                _this.set(key, value);
                // The addition could have been prevent by interceptor
                if (_this._data.has(key)) {
                    // The update could have been prevented by interceptor
                    // and also we want to preserve existing values
                    // so use value from _data map (instead of replacement map)
                    var value_1 = _this._data.get(key);
                    orderedData.set(key, value_1);
                    // Was a new key added?
                    if (!keyExisted) {
                        // _keysAtom.reportChanged() was already called
                        keysReportChangedCalled = true;
                    }
                }
            });
            // Check for possible key order change
            if (!keysReportChangedCalled) {
                if (_this._data.size !== orderedData.size) {
                    // If size differs, keys are definitely modified
                    _this._keysAtom.reportChanged();
                }
                else {
                    var iter1 = _this._data.keys();
                    var iter2 = orderedData.keys();
                    var next1 = iter1.next();
                    var next2 = iter2.next();
                    while (!next1.done) {
                        if (next1.value !== next2.value) {
                            _this._keysAtom.reportChanged();
                            break;
                        }
                        next1 = iter1.next();
                        next2 = iter2.next();
                    }
                }
            }
            // Use correctly ordered map
            _this._data = orderedData;
        });
        return this;
    };
    Object.defineProperty(ObservableMap.prototype, "size", {
        get: function () {
            this._keysAtom.reportObserved();
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */
    ObservableMap.prototype.toPOJO = function () {
        var _this = this;
        var res = {};
        this.forEach(function (_, key) {
            return (res[typeof key === "symbol" ? key : stringifyKey(key)] = _this.get(key));
        });
        return res;
    };
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */
    ObservableMap.prototype.toJS = function () {
        return new Map(this);
    };
    ObservableMap.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toPOJO();
    };
    ObservableMap.prototype.toString = function () {
        var _this = this;
        return (this.name +
            "[{ " +
            iteratorToArray(this.keys())
                .map(function (key) { return stringifyKey(key) + ": " + ("" + _this.get(key)); })
                .join(", ") +
            " }]");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableMap.prototype.observe = function (listener, fireImmediately) {
         false &&
            false;
        return registerListener(this, listener);
    };
    ObservableMap.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    return ObservableMap;
}());
function stringifyKey(key) {
    if (key && key.toString)
        return key.toString();
    else
        return new String(key).toString();
}
declareIterator(ObservableMap.prototype, function () {
    return this.entries();
});
addHiddenFinalProp(ObservableMap.prototype, toStringTagSymbol(), "Map");
/* 'var' fixes small-build issue */
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);

var ObservableSetMarker = {};
var ObservableSet = /** @class */ (function () {
    function ObservableSet(initialData, enhancer, name) {
        if (enhancer === void 0) { enhancer = deepEnhancer; }
        if (name === void 0) { name = "ObservableSet@" + getNextId(); }
        this.name = name;
        this.$mobx = ObservableSetMarker;
        this._data = new Set();
        this._atom = createAtom(this.name);
        if (typeof Set !== "function") {
            throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
        }
        this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name); };
        if (initialData) {
            this.replace(initialData);
        }
    }
    ObservableSet.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined) {
            return this.dehancer(value);
        }
        return value;
    };
    ObservableSet.prototype.clear = function () {
        var _this = this;
        transaction(function () {
            untracked(function () {
                _this._data.forEach(function (value) {
                    _this.delete(value);
                });
            });
        });
    };
    ObservableSet.prototype.forEach = function (callbackFn, thisArg) {
        var _this = this;
        this._atom.reportObserved();
        this._data.forEach(function (value) {
            callbackFn.call(thisArg, value, value, _this);
        });
    };
    Object.defineProperty(ObservableSet.prototype, "size", {
        get: function () {
            this._atom.reportObserved();
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    ObservableSet.prototype.add = function (value) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this._atom);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "add",
                object: this,
                newValue: value
            });
            if (!change)
                return this;
            // TODO: ideally, value = change.value would be done here, so that values can be
            // changed by interceptor. Same applies for other Set and Map api's.
        }
        if (!this.has(value)) {
            transaction(function () {
                _this._data.add(_this.enhancer(value, undefined));
                _this._atom.reportChanged();
            });
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "add",
                    object: this,
                    newValue: value
                }
                : null;
            if (notifySpy && "production" !== "production")
                spyReportStart(change);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy && "production" !== "production")
                spyReportEnd();
        }
        return this;
    };
    ObservableSet.prototype.delete = function (value) {
        var _this = this;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "delete",
                object: this,
                oldValue: value
            });
            if (!change)
                return false;
        }
        if (this.has(value)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "delete",
                    object: this,
                    oldValue: value
                }
                : null;
            if (notifySpy && "production" !== "production")
                spyReportStart(__assign(__assign({}, change), { name: this.name }));
            transaction(function () {
                _this._atom.reportChanged();
                _this._data.delete(value);
            });
            if (notify)
                notifyListeners(this, change);
            if (notifySpy && "production" !== "production")
                spyReportEnd();
            return true;
        }
        return false;
    };
    ObservableSet.prototype.has = function (value) {
        this._atom.reportObserved();
        return this._data.has(this.dehanceValue(value));
    };
    ObservableSet.prototype.entries = function () {
        var nextIndex = 0;
        var keys = iteratorToArray(this.keys());
        var values = iteratorToArray(this.values());
        return makeIterable({
            next: function () {
                var index = nextIndex;
                nextIndex += 1;
                return index < values.length
                    ? { value: [keys[index], values[index]], done: false }
                    : { done: true };
            }
        });
    };
    ObservableSet.prototype.keys = function () {
        return this.values();
    };
    ObservableSet.prototype.values = function () {
        this._atom.reportObserved();
        var self = this;
        var nextIndex = 0;
        var observableValues;
        if (this._data.values !== undefined) {
            observableValues = iteratorToArray(this._data.values());
        }
        else {
            // There is no values function in IE11
            observableValues = [];
            this._data.forEach(function (e) { return observableValues.push(e); });
        }
        return makeIterable({
            next: function () {
                return nextIndex < observableValues.length
                    ? { value: self.dehanceValue(observableValues[nextIndex++]), done: false }
                    : { done: true };
            }
        });
    };
    ObservableSet.prototype.replace = function (other) {
        var _this = this;
        if (isObservableSet(other)) {
            other = other.toJS();
        }
        transaction(function () {
            var prev = allowStateChangesStart(true);
            try {
                if (Array.isArray(other)) {
                    _this.clear();
                    other.forEach(function (value) { return _this.add(value); });
                }
                else if (isES6Set(other)) {
                    _this.clear();
                    other.forEach(function (value) { return _this.add(value); });
                }
                else if (other !== null && other !== undefined) {
                    fail("Cannot initialize set from " + other);
                }
            }
            finally {
                allowStateChangesEnd(prev);
            }
        });
        return this;
    };
    ObservableSet.prototype.observe = function (listener, fireImmediately) {
        // TODO 'fireImmediately' can be true?
         false &&
            false;
        return registerListener(this, listener);
    };
    ObservableSet.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableSet.prototype.toJS = function () {
        return new Set(this);
    };
    ObservableSet.prototype.toString = function () {
        return this.name + "[ " + iteratorToArray(this.keys()).join(", ") + " ]";
    };
    return ObservableSet;
}());
declareIterator(ObservableSet.prototype, function () {
    return this.values();
});
addHiddenFinalProp(ObservableSet.prototype, toStringTagSymbol(), "Set");
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);

var ObservableObjectAdministration = /** @class */ (function () {
    function ObservableObjectAdministration(target, name, defaultEnhancer) {
        this.target = target;
        this.name = name;
        this.defaultEnhancer = defaultEnhancer;
        this.values = {};
    }
    ObservableObjectAdministration.prototype.read = function (owner, key) {
        if ( true && this.target !== owner) {
            this.illegalAccess(owner, key);
            if (!this.values[key])
                return undefined;
        }
        return this.values[key].get();
    };
    ObservableObjectAdministration.prototype.write = function (owner, key, newValue) {
        var instance = this.target;
        if ( true && instance !== owner) {
            this.illegalAccess(owner, key);
        }
        var observable = this.values[key];
        if (observable instanceof ComputedValue) {
            observable.set(newValue);
            return;
        }
        // intercept
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "update",
                object: instance,
                name: key,
                newValue: newValue
            });
            if (!change)
                return;
            newValue = change.newValue;
        }
        newValue = observable.prepareNewValue(newValue);
        // notify spy & observers
        if (newValue !== globalState.UNCHANGED) {
            var notify = hasListeners(this);
            var notifySpy = isSpyEnabled();
            var change = notify || notifySpy
                ? {
                    type: "update",
                    object: instance,
                    oldValue: observable.value,
                    name: key,
                    newValue: newValue
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign(__assign({}, change), { name: this.name, key: key }));
            observable.setNewValue(newValue);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableObjectAdministration.prototype.remove = function (key) {
        if (!this.values[key])
            return;
        var target = this.target;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: target,
                name: key,
                type: "remove"
            });
            if (!change)
                return;
        }
        try {
            startBatch();
            var notify = hasListeners(this);
            var notifySpy = isSpyEnabled();
            var oldValue = this.values[key].get();
            if (this.keys)
                this.keys.remove(key);
            delete this.values[key];
            delete this.target[key];
            var change = notify || notifySpy
                ? {
                    type: "remove",
                    object: target,
                    oldValue: oldValue,
                    name: key
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign(__assign({}, change), { name: this.name, key: key }));
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
        finally {
            endBatch();
        }
    };
    ObservableObjectAdministration.prototype.illegalAccess = function (owner, propName) {
        /**
         * This happens if a property is accessed through the prototype chain, but the property was
         * declared directly as own property on the prototype.
         *
         * E.g.:
         * class A {
         * }
         * extendObservable(A.prototype, { x: 1 })
         *
         * classB extens A {
         * }
         * console.log(new B().x)
         *
         * It is unclear whether the property should be considered 'static' or inherited.
         * Either use `console.log(A.x)`
         * or: decorate(A, { x: observable })
         *
         * When using decorate, the property will always be redeclared as own property on the actual instance
         */
        console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {
         false &&
            false;
        return registerListener(this, callback);
    };
    ObservableObjectAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableObjectAdministration.prototype.getKeys = function () {
        var _this = this;
        if (this.keys === undefined) {
            this.keys = (new ObservableArray(Object.keys(this.values).filter(function (key) { return _this.values[key] instanceof ObservableValue; }), referenceEnhancer, "keys(" + this.name + ")", true));
        }
        return this.keys.slice();
    };
    return ObservableObjectAdministration;
}());
function asObservableObject(target, name, defaultEnhancer) {
    if (name === void 0) { name = ""; }
    if (defaultEnhancer === void 0) { defaultEnhancer = deepEnhancer; }
    var adm = target.$mobx;
    if (adm)
        return adm;
     false &&
        false;
    if (!isPlainObject(target))
        name = (target.constructor.name || "ObservableObject") + "@" + getNextId();
    if (!name)
        name = "ObservableObject@" + getNextId();
    adm = new ObservableObjectAdministration(target, name, defaultEnhancer);
    addHiddenFinalProp(target, "$mobx", adm);
    return adm;
}
function defineObservableProperty(target, propName, newValue, enhancer) {
    var adm = asObservableObject(target);
    assertPropertyConfigurable(target, propName);
    if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
            object: target,
            name: propName,
            type: "add",
            newValue: newValue
        });
        if (!change)
            return;
        newValue = change.newValue;
    }
    var observable = (adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + "." + propName, false));
    newValue = observable.value; // observableValue might have changed it
    Object.defineProperty(target, propName, generateObservablePropConfig(propName));
    if (adm.keys)
        adm.keys.push(propName);
    notifyPropertyAddition(adm, target, propName, newValue);
}
function defineComputedProperty(target, // which objects holds the observable and provides `this` context?
propName, options) {
    var adm = asObservableObject(target);
    options.name = adm.name + "." + propName;
    options.context = target;
    adm.values[propName] = new ComputedValue(options);
    Object.defineProperty(target, propName, generateComputedPropConfig(propName));
}
var observablePropertyConfigs = Object.create(null);
var computedPropertyConfigs = Object.create(null);
function generateObservablePropConfig(propName) {
    return (observablePropertyConfigs[propName] ||
        (observablePropertyConfigs[propName] = {
            configurable: true,
            enumerable: true,
            get: function () {
                return this.$mobx.read(this, propName);
            },
            set: function (v) {
                this.$mobx.write(this, propName, v);
            }
        }));
}
function getAdministrationForComputedPropOwner(owner) {
    var adm = owner.$mobx;
    if (!adm) {
        // because computed props are declared on proty,
        // the current instance might not have been initialized yet
        initializeInstance(owner);
        return owner.$mobx;
    }
    return adm;
}
function generateComputedPropConfig(propName) {
    return (computedPropertyConfigs[propName] ||
        (computedPropertyConfigs[propName] = {
            configurable: globalState.computedConfigurable,
            enumerable: false,
            get: function () {
                return getAdministrationForComputedPropOwner(this).read(this, propName);
            },
            set: function (v) {
                getAdministrationForComputedPropOwner(this).write(this, propName, v);
            }
        }));
}
function notifyPropertyAddition(adm, object, key, newValue) {
    var notify = hasListeners(adm);
    var notifySpy = isSpyEnabled();
    var change = notify || notifySpy
        ? {
            type: "add",
            object: object,
            name: key,
            newValue: newValue
        }
        : null;
    if (notifySpy)
        spyReportStart(__assign(__assign({}, change), { name: adm.name, key: key }));
    if (notify)
        notifyListeners(adm, change);
    if (notifySpy)
        spyReportEnd();
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
    if (isObject(thing)) {
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        initializeInstance(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}

function getAtom(thing, property) {
    if (typeof thing === "object" && thing !== null) {
        if (isObservableArray(thing)) {
            if (property !== undefined)
                fail( false &&
                    false);
            return thing.$mobx.atom;
        }
        if (isObservableSet(thing)) {
            return thing.$mobx;
        }
        if (isObservableMap(thing)) {
            var anyThing = thing;
            if (property === undefined)
                return anyThing._keysAtom;
            var observable = anyThing._data.get(property) || anyThing._hasMap.get(property);
            if (!observable)
                fail( false &&
                    false);
            return observable;
        }
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        initializeInstance(thing);
        if (property && !thing.$mobx)
            thing[property]; // See #1072
        if (isObservableObject(thing)) {
            if (!property)
                return fail( false && false);
            var observable = thing.$mobx.values[property];
            if (!observable)
                fail( false &&
                    false);
            return observable;
        }
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
            return thing;
        }
    }
    else if (typeof thing === "function") {
        if (isReaction(thing.$mobx)) {
            // disposer function
            return thing.$mobx;
        }
    }
    return fail( false && false);
}
function getAdministration(thing, property) {
    if (!thing)
        fail("Expecting some object");
    if (property !== undefined)
        return getAdministration(getAtom(thing, property));
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
        return thing;
    if (isObservableMap(thing) || isObservableSet(thing))
        return thing;
    // Initializers run lazily when transpiling to babel, so make sure they are run...
    initializeInstance(thing);
    if (thing.$mobx)
        return thing.$mobx;
    fail( false && false);
}
function getDebugName(thing, property) {
    var named;
    if (property !== undefined)
        named = getAtom(thing, property);
    else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing))
        named = getAdministration(thing);
    else
        named = getAtom(thing); // valid for arrays as well
    return named.name;
}

var toString = Object.prototype.toString;
function deepEqual(a, b, depth) {
    if (depth === void 0) { depth = -1; }
    return eq(a, b, depth);
}
// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.
function eq(a, b, depth, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
        return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null)
        return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a)
        return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== "function" && type !== "object" && typeof b != "object")
        return false;
    // Unwrap any wrapped objects.
    a = unwrap(a);
    b = unwrap(b);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b))
        return false;
    switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case "[object RegExp]":
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case "[object String]":
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return "" + a === "" + b;
        case "[object Number]":
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a)
                return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case "[object Date]":
        case "[object Boolean]":
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case "[object Symbol]":
            return (
            // eslint-disable-next-line
            typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b));
    }
    var areArrays = className === "[object Array]";
    if (!areArrays) {
        if (typeof a != "object" || typeof b != "object")
            return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor &&
            !(typeof aCtor === "function" &&
                aCtor instanceof aCtor &&
                typeof bCtor === "function" &&
                bCtor instanceof bCtor) &&
            ("constructor" in a && "constructor" in b)) {
            return false;
        }
    }
    if (depth === 0) {
        return false;
    }
    else if (depth < 0) {
        depth = -1;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a)
            return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length)
            return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], depth - 1, aStack, bStack))
                return false;
        }
    }
    else {
        // Deep compare objects.
        var keys = Object.keys(a);
        var key = void 0;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (Object.keys(b).length !== length)
            return false;
        while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(has$1(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack)))
                return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function unwrap(a) {
    if (isObservableArray(a))
        return a.peek();
    if (isES6Map(a) || isObservableMap(a))
        return iteratorToArray(a.entries());
    if (isES6Set(a) || isObservableSet(a))
        return iteratorToArray(a.entries());
    return a;
}
function has$1(a, key) {
    return Object.prototype.hasOwnProperty.call(a, key);
}

/**
 * (c) Michel Weststrate 2015 - 2019
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
try {
    // define process.env if needed
    // if this is not a production build in the first place
    // (in which case the expression below would be substituted with 'production')
    // tslint:disable-next-line
    "production";
}
catch (e) {
    var g = getGlobal();
    if (typeof process === "undefined")
        g.process = {};
    g.process.env = {};
}
(function () {
    function testCodeMinification() { }
    if (testCodeMinification.name !== "testCodeMinification" &&
        "production" !== "production" &&
        typeof process !== 'undefined' && process.env.IGNORE_MOBX_MINIFY_WARNING !== "true") {
        // trick so it doesn't get replaced
        var varName = ["process", "env", "NODE_ENV"].join(".");
        console.warn("[mobx] you are running a minified build, but '" + varName + "' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle");
    }
})();
// forward compatibility with mobx, so that packages can easily support mobx 4 & 5
var $mobx = "$mobx";
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    // See: https://github.com/andykog/mobx-devtools/
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
        spy: spy,
        extras: {
            getDebugName: getDebugName
        },
        $mobx: $mobx
    });
}
// TODO: remove in some future build
if (false) { var warnedAboutDefaultExport_1; }



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46), __webpack_require__(50)))

/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return isFinite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return isInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return isSafeInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return trunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return fround; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return min; });
/* unused harmony export hypot */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return sqrt; });
/* unused harmony export cbrt */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return expm1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return log1p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return log2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return log10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return tan; });
/* unused harmony export asin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return acos; });
/* unused harmony export atan */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return atan2; });
/* unused harmony export sinh */
/* unused harmony export cosh */
/* unused harmony export tanh */
/* unused harmony export asinh */
/* unused harmony export acosh */
/* unused harmony export atanh */
/* unused harmony export imul */
/* unused harmony export clz32 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return clamp; });
/* unused harmony export rt */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return sq; });
/* unused harmony export cb */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return exp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return exp10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return isPow2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return isPow10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return floorPow2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ceilPow2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return floorPow10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ceilPow10; });
/* unused harmony export ldexp */
/* unused harmony export frexp */
const isNaN = Number.isNaN,
      isFinite = Number.isFinite,
      isInteger = Number.isInteger,
      isSafeInteger = Number.isSafeInteger;

const abs = Math.abs,
      sign = Math.sign,
      floor = Math.floor,
      ceil = Math.ceil,
      trunc = Math.trunc,
      round = Math.round,
      fround = Math.fround,
      max = Math.max,
      min = Math.min,
      hypot = Math.hypot,
      sqrt = Math.sqrt,
      cbrt = Math.cbrt,
      pow = Math.pow,
      exp = Math.exp,
      expm1 = Math.expm1,
      log = Math.log,
      log1p = Math.log1p,
      log2 = Math.log2,
      log10 = Math.log10,
      sin = Math.sin,
      cos = Math.cos,
      tan = Math.tan,
      asin = Math.asin,
      acos = Math.acos,
      atan = Math.atan,
      atan2 = Math.atan2,
      sinh = Math.sinh,
      cosh = Math.cosh,
      tanh = Math.tanh,
      asinh = Math.asinh,
      acosh = Math.acosh,
      atanh = Math.atanh,
      imul = Math.imul,
      clz32 = Math.clz32;
/**
 * @function module:@wgetemp/math.clamp
 * @param {number} x Value.
 * @param {number} a Lower bound.
 * @param {number} b Upper bound.
 * @returns {number} Value clamped between `a` and `b`.
 *    Equivalent to `{@link module:@wgetemp/math.min}({@link module:@wgetemp/math.max}(x, a), b)`.
 */


function clamp(x, a, b) {
  return min(max(x, a), b);
}
/**
 * @function module:@wgetemp/math.rt
 * @param {number} d Root degree.
 * @param {number} y Value.
 * @returns {number} `d`-degree root of number `y`.
 *    Equivalent to `{@link module:@wgetemp/math.pow}(y, 1 / d)`.
 */

function rt(d, y) {
  return pow(y, 1 / d);
}
/**
 * @function module:@wgetemp/math.sq
 * @param {number} x Value.
 * @returns {number} Square of `x`. Equivalent to `x * x`.
 */

function sq(x) {
  return x * x;
}
/**
 * @function module:@wgetemp/math.cb
 * @param {number} x Value.
 * @returns {number} Cube of `x`. Equivalent to `x * x * x`.
 */

function cb(x) {
  return x * x * x;
}
/**
 * @function module:@wgetemp/math.exp2
 * @param {number} x Value.
 * @returns {number} Base-2 exponent of `x`.
 *    Equivalent to `{@link module:@wgetemp/math.pow}(2, x)`.
 */

function exp2(x) {
  return pow(2, x);
}
/**
 * @function module:@wgetemp/math.exp10
 * @param {number} x Value.
 * @returns {number} Base-10 exponent of `x`.
 *    Equivalent to `{@link module:@wgetemp/math.pow}(10, x)`.
 */

function exp10(x) {
  return pow(10, x);
}
/**
 * @function module:@wgetemp/math.isPow2
 * @param {number} x Value.
 * @returns {boolean} Whether `x` is a power of 2, including negative powers.
 *    Equivalent to `{@link module:@wgetemp/math.isInteger}({@link module:@wgetemp/math.log2}(x))`.
 */

function isPow2(x) {
  return isInteger(log2(x));
}
/**
 * @function module:@wgetemp/math.isPow10
 * @param {number} x Value.
 * @returns {boolean} Whether `x` is a power of 10, including negative powers.
 *    Equivalent to `{@link module:@wgetemp/math.isInteger}({@link module:@wgetemp/math.log10}(x))`.
 */

function isPow10(x) {
  return isInteger(log10(x));
}
/**
 * @function module:@wgetemp/math.floorPow2
 * @param {number} x Value.
 * @returns {number} Biggest power of 2 not greater than `x`.
 *    Equivalent to `{@link module:@wgetemp/math.exp2}({@link module:@wgetemp/math.floor}({@link module:@wgetemp/math.log2}(x)))`.
 */

function floorPow2(x) {
  return exp2(floor(log2(x)));
}
/**
 * @function module:@wgetemp/math.ceilPow2
 * @param {number} x Value.
 * @returns {number} Smallest power of 2 not less than `x`.
 *    Equivalent to `{@link module:@wgetemp/math.exp2}({@link module:@wgetemp/math.ceil}({@link module:@wgetemp/math.log2}(x)))`.
 */

function ceilPow2(x) {
  return exp2(ceil(log2(x)));
}
/**
 * @function module:@wgetemp/math.floorPow10
 * @param {number} x Value.
 * @returns {number} Biggest power of 10 not greater than `x`.
 *    Equivalent to `{@link module:@wgetemp/math.exp10}({@link module:@wgetemp/math.floor}({@link module:@wgetemp/math.log10}(x)))`.
 */

function floorPow10(x) {
  return exp10(floor(log10(x)));
}
/**
 * @function module:@wgetemp/math.ceilPow10
 * @param {number} x Value.
 * @returns {number} Smallest power of 10 not less than `x`.
 *    Equivalent to `{@link module:@wgetemp/math.exp10}({@link module:@wgetemp/math.ceil}({@link module:@wgetemp/math.log10}(x)))`.
 */

function ceilPow10(x) {
  return exp10(ceil(log10(x)));
}
/**
 * @function module:@wgetemp/math.ldexp
 * @summary Compose normalized fraction and base-2 exponent into a number.
 * @desc Attempts to behave identically to corresponding C function.
 * @param {number} x Normalized fraction.
 * @param {number} e Base-2 exponent.
 * @returns {number} Effectively `x * {@link module:@wgetemp/math.exp2}(e)`,
 *    but with careful handling of edge cases.
 */
// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html

function ldexp(x, e) {
  if (x === 0 || !isFinite(x)) {
    return x;
  }

  const n = min(ceil(abs(e) / 1023), 3);

  for (let i = 0; i < n; ++i) {
    x *= pow(2, floor((e + i) / n));
  }

  return x;
}
/**
 * @function module:@wgetemp/math.frexp
 * @summary Decompose number into normalized fraction and base-2 exponent.
 * @desc Attempts to behave identically to corresponding C function.
 * @param {number} x Value.
 * @param {Array} [results] Result array.
 * @param {number} [results.0] Normalized fraction.
 * @param {number} [results.1] Base-2 exponent.
 * @returns {number} Filled `results`.
 */
// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html

const frexp = (() => {
  const f64 = new Float64Array(1);
  const hu32 = new Uint32Array(f64.buffer, (() => {
    return new Uint8Array(Uint16Array.of(4).buffer)[0];
  })(), 1);
  return function frexp(x, results = [0, 0]) {
    if (x === 0 || !isFinite(x)) {
      results[0] = x;
      results[1] = 0;
    } else {
      f64[0] = x;
      let be = hu32[0] >>> 20 & 0x7FF;

      if (be === 0) {
        f64[0] = x * 0x10000000000000000;
        be = (hu32[0] >>> 20 & 0x7FF) - 64;
      }

      const e = be - 1022;
      results[0] = ldexp(x, -e);
      results[1] = e;
    }

    return results;
  };
})();

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "w", function() { return /* reexport */ isEqualSet; });
__webpack_require__.d(__webpack_exports__, "K", function() { return /* reexport */ vectors3Equal; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ getVector3Like; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ getVector2Like; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ getNodeByName; });
__webpack_require__.d(__webpack_exports__, "G", function() { return /* reexport */ toRaycastFilterNode; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ getBinAssetBlobUrl; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ colorToString; });
__webpack_require__.d(__webpack_exports__, "z", function() { return /* reexport */ isPromise; });
__webpack_require__.d(__webpack_exports__, "A", function() { return /* reexport */ iterateAsync; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ instance_data_manager["b" /* getInstanceGlobalIndex */]; });
__webpack_require__.d(__webpack_exports__, "H", function() { return /* reexport */ instance_data_manager["d" /* updateInstanceCenter */]; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ instance_data_manager["a" /* getInstanceCenter */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ custom_animations_CustomAnimationManager; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* reexport */ ignoreAttribute; });
__webpack_require__.d(__webpack_exports__, "x", function() { return /* reexport */ isIgnoreRaycastNode; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* reexport */ ignoreRaycast; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* reexport */ ignoreRaycastNode; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ detectWebGl; });
__webpack_require__.d(__webpack_exports__, "y", function() { return /* reexport */ isNodeRaycastTransparent; });
__webpack_require__.d(__webpack_exports__, "D", function() { return /* reexport */ setNodeRaycastTransparent; });
__webpack_require__.d(__webpack_exports__, "E", function() { return /* reexport */ setNodeVisibilityTraverse; });
__webpack_require__.d(__webpack_exports__, "C", function() { return /* reexport */ setMaterialVisibility; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ disposeRenderableFromNode; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ dispose; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ global_helpers_event["a" /* Event */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ Mask; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ computeBBox; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ math["b" /* degToRad */]; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ math["d" /* getScreenPositionFrom3d */]; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ math["c" /* getPositionNdcFrom2d */]; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* reexport */ math["e" /* isBehindCamera */]; });
__webpack_require__.d(__webpack_exports__, "I", function() { return /* reexport */ updateStoreState; });
__webpack_require__.d(__webpack_exports__, "J", function() { return /* reexport */ updateStoreStateSync; });
__webpack_require__.d(__webpack_exports__, "F", function() { return /* reexport */ setUniform; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ transform["b" /* getWorldMatrixByRenderable */]; });
__webpack_require__.d(__webpack_exports__, "B", function() { return /* reexport */ mergeCopySync; });

// UNUSED EXPORTS: getUrlSibling, arraysEqual, checkLinedSubmesh, getComputedPropNames, getInstanceWorldBBox, CustomAnimation, $hiddenBy, $transparentHit, getNodeVisibility, forceNodeVisibility, setNodeVisibility, radToDeg, clamp, interpolation, smoothstep, debounce, exposeFromWorker, createWorker, setRenderableMatrix, getMatrixFromTransforms

// EXTERNAL MODULE: ./src/global-helpers/url.ts
var url = __webpack_require__(48);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/raycaster/index.js + 1 modules
var raycaster = __webpack_require__(77);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var lib = __webpack_require__(0);

// CONCATENATED MODULE: ./src/global-helpers/common.ts


// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEqualSet(set1, set2) {
  if (set1.size !== set2.size) {
    return false;
  }

  for (const element of set1) {
    if (!set2.has(element)) {
      return false;
    }
  }

  return true;
}
function vectors3Equal(v1, v2, threshold = 0.00001) {
  return v1.distance(v2) < threshold;
}
function arraysEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}
function getVector3Like(vector, result) {
  const output = result || {
    x: 0,
    y: 0,
    z: 0
  };
  output.x = vector.x;
  output.y = vector.y;
  output.z = vector.z;
  return output;
}
function getVector2Like(vector, result) {
  const output = result || {
    x: 0,
    y: 0
  };
  output.x = vector.x;
  output.y = vector.y;
  return output;
} // --- Others ---

function getNodeByName(parent, name) {
  let retNode = null;
  parent.traverse(node => {
    if (node.name === name) {
      retNode = node;
      return false;
    }

    return true;
  });
  return retNode;
}
function toRaycastFilterNode(oldFilterNode) {
  return node => {
    const isRaycast = oldFilterNode(node);
    return isRaycast ? raycaster["a" /* Raycaster */].NodeFilterDecision.CAST_NODE : raycaster["a" /* Raycaster */].NodeFilterDecision.SKIP_SUBTREE;
  };
}
function checkLinedSubmesh(renderable) {
  return renderable.geometry.primitiveType === lib["O" /* PrimitiveType */].LINES;
}
function getBinAssetBlobUrl(binAsset) {
  const [, base64] = binAsset.split(',');
  const glbString = atob(base64);
  const glbData = new Uint8Array(glbString.length);

  for (let i = 0; i < glbString.length; i++) {
    glbData[i] = glbString.charCodeAt(i);
  }

  return URL.createObjectURL(new Blob([glbData]));
}

const alignNumberString = (numberString, length) => {
  const delta = length - numberString.length;

  if (delta <= 0) {
    return numberString;
  }

  return '0'.repeat(delta) + numberString;
};

const colorToString = color => alignNumberString(Number(color.toPackedInteger()).toString(16), 6);
function getComputedPropNames(Target) {
  return Object.keys(Object.getOwnPropertyDescriptors(Target.prototype)).filter(methodName => methodName !== 'constructor' && !methodName.startsWith('_'));
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

function isPromise(data) {
  return data !== null && typeof data === 'object' && typeof data.then === 'function';
}
const iterateAsync = (elements, count, cycleBody) => {
  return new Promise(resolve => {
    let index = 0;

    for (const element of elements) {
      setTimeout(() => {
        cycleBody(element);
        index++;

        if (index === count) {
          resolve();
        }
      });
    }
  });
};
// EXTERNAL MODULE: ./src/global-helpers/instance-data-manager.ts
var instance_data_manager = __webpack_require__(64);

// CONCATENATED MODULE: ./src/global-helpers/custom-animations/animation.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const channelOutput = '__wg_channelOutput';

const getName = (() => {
  let id = 0;
  return prefix => prefix + id++;
})();

class animation_CustomAnimation {
  constructor(name = getName('simple'), internal, options) {
    _defineProperty(this, "name", void 0);

    _defineProperty(this, "index", void 0);

    _defineProperty(this, "channelsSet", void 0);

    _defineProperty(this, "_animation", void 0);

    _defineProperty(this, "_inputs", void 0);

    _defineProperty(this, "_outputs", void 0);

    _defineProperty(this, "_looped", void 0);

    _defineProperty(this, "_timeScale", void 0);

    _defineProperty(this, "_internal", void 0);

    const {
      looped = false,
      timeScale = 1
    } = options || {};
    this.name = name;
    this.index = 0;
    this.channelsSet = new Set();
    this._animation = null;
    this._inputs = [];
    this._outputs = [];
    this._looped = looped;
    this._timeScale = timeScale;
    this._internal = internal;
  }

  get channels() {
    return [...this.channelsSet];
  }

  get progress() {
    if (!this._animation) {
      return 0;
    }

    return this._animation.playtime / this._animation.duration;
  }

  get timeScale() {
    return this._timeScale;
  }

  set timeScale(value) {
    this._timeScale = value;

    if (this._animation) {
      this._animation.timescale = value;
    }
  }

  get looped() {
    return this._looped;
  }

  set looped(value) {
    this._looped = value;

    if (this._animation) {
      this._animation.looped = value;
    }
  }

  async play(timeScale = this._timeScale) {
    this._checkChannelsCreated();

    this._animation.timescale = timeScale;
    return new Promise(resolve => {
      this._animation.play();

      this._animation.onEnd.subscribe(() => resolve(this), {
        once: true
      });
    });
  }

  async playInversed() {
    // If it wasn't played we need to set playtime to the end
    // this._animation.playtime = this._animation.duration;
    return this.play(-1 * this._timeScale);
  }

  stop() {
    this._checkChannelsCreated();

    this._animation.stop();
  }

  pause() {
    this._checkChannelsCreated();

    this._animation.pause();
  }

  _checkChannelsCreated() {
    if (!this._animation) {
      throw new Error('Channels should be created first');
    }
  }

  _createAnimationWG() {
    const {
      scene,
      byName,
      animationComponent
    } = this._internal;
    const {
      name
    } = this;
    let index = scene.animationCount;

    if (byName.has(name)) {
      const oldAnimation = byName.get(name); // Replace old animation w/ new one

      index = oldAnimation.index; // Dispose old animation channels

      animationComponent.channels = animationComponent.channels.filter(channel => !oldAnimation.channelsSet.has(channel));
    }

    const inputs = [];
    const outputs = [];
    const animation = new lib["b" /* Animation */]({
      name,
      inputs,
      outputs
    });
    animation.looped = this._looped;
    animation.timescale = this._timeScale; // @ts-expect-error private, we have not access to animations map of scene

    scene._animations.set(index, animation);

    byName.set(name, this);
    this.index = index;
    this._inputs = inputs;
    this._outputs = outputs;
    this._animation = animation;
  }

  setChannels(channels) {
    // We need to create animation at the same time as creating channels
    this._createAnimationWG();

    const {
      index: animationIndex,
      name,
      _animation,
      _inputs,
      _outputs
    } = this;
    const channelsSet = new Set();
    channels.forEach(channel => {
      const {
        source,
        target,
        duration,
        delay = 0,
        onLateUpdate = () => undefined,
        interpolation = lib["b" /* Animation */].Sampler.Interpolation.LINEAR
      } = channel;

      if (typeof source !== 'object') {
        throw new Error(`CustomAnimation "${name.toString()}": source shoud be an object`);
      }

      if (typeof target !== 'object') {
        throw new Error(`CustomAnimation "${name.toString()}": target shoud be an object`);
      }

      if (typeof duration !== 'number') {
        throw new Error(`CustomAnimation "${name.toString()}": duration not set`);
      } // TODO Use same input for different channels if match?


      _inputs.push({
        view: new Float32Array([delay, delay + duration]),
        min: delay,
        max: delay + duration
      });

      const inputIndex = _inputs.length - 1;
      const propertyNames = Object.keys(target).filter(propertyName => typeof source[propertyName] === 'number');
      const toArray = propertyNames.map(propertyName => target[propertyName]);
      const fromArray = propertyNames.map(propertyName => source[propertyName]);

      const getOnUpdate = () => {
        if (typeof channel.onUpdate === 'function') {
          return channel.onUpdate;
        } // Default updater: apply new properties to source


        return (source_, typedArray) => {
          typedArray.forEach((value, index) => {
            const propertyName = propertyNames[index];
            source_[propertyName] = value;
          });
        };
      };

      const onUpdate = getOnUpdate();

      _outputs.push({
        view: new Float32Array([...fromArray, ...toArray]),
        countComponents: toArray.length
      });

      const outputIndex = _outputs.length - 1;
      const sampler = new lib["b" /* Animation */].Sampler(inputIndex, outputIndex, interpolation);

      _animation.samplers.push(sampler);

      const samplerIndex = _animation.samplers.length - 1;
      const nodeAnimationChannel = new lib["J" /* NodeAnimation */].Channel(source, samplerIndex, animationIndex); // Updater

      nodeAnimationChannel.update = (source_, typedArray) => {
        if (!typedArray) {
          return;
        } // Sometimes it happens
        // Main updater


        onUpdate(source_, typedArray); // Additional updater

        onLateUpdate(source_, typedArray);
      }; // @ts-expect-error mutate with symbol


      nodeAnimationChannel[channelOutput] = _outputs[outputIndex];
      channelsSet.add(nodeAnimationChannel);
    });

    _animation.stop(); // Calculate common animation duration


    _animation.duration = channels.reduce((result, {
      delay = 0,
      duration = 0
    }) => Math.max(result, delay + duration), 0);
    this.channelsSet = channelsSet;

    this._internal.animationComponent.channels.push(...channelsSet);
  }

}

_defineProperty(animation_CustomAnimation, "interpolations", lib["b" /* Animation */].Sampler.Interpolation);
// CONCATENATED MODULE: ./src/global-helpers/custom-animations/index.ts
function custom_animations_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class custom_animations_CustomAnimationManager {
  constructor(options) {
    custom_animations_defineProperty(this, "scene", void 0);

    custom_animations_defineProperty(this, "byName", void 0);

    custom_animations_defineProperty(this, "animationComponent", void 0);

    custom_animations_defineProperty(this, "nodeChannels", void 0);

    custom_animations_defineProperty(this, "animations", void 0);

    custom_animations_defineProperty(this, "animationNode", void 0);

    const {
      scene
    } = options;
    const animationComponent = new lib["J" /* NodeAnimation */]();
    this.scene = scene;
    this.byName = new Map();
    this.animationComponent = animationComponent;
    this.nodeChannels = animationComponent.channels;
    this.animations = scene.animations();
    this.animationNode = scene.root.createChild({
      name: 'Custom Animation Node'
    });
    this.animationNode.attach(animationComponent);
  }

  get interpolations() {
    return lib["b" /* Animation */].Sampler.Interpolation;
  }

  get updaters() {
    return custom_animations_CustomAnimationManager.updaters;
  }

  _getNewAnimation(name, options) {
    const {
      animationComponent,
      byName,
      scene
    } = this;
    return new animation_CustomAnimation(name, {
      animationComponent,
      byName,
      scene
    }, options);
  }

  create(name, options) {
    if (this.byName.has(name)) {
      throw new Error(`Animation "${name.toString()}" is already exists`);
    }

    return this._getNewAnimation(name, options);
  }
  /**
   * @example
   * ```js
   * await animation.run('animation name', [
   *     {
   *         source: cameraTransform.position,
   *         target: { x: 10, y: 10, z: 10 },
   *         onLateUpdate: () => {
   *             // Do stuff after update
   *             cameraTransform.needsUpdateLocalMatrix = true;
   *             cameraTransform.needsUpdateWorldMatrix = true;
   *         },
   *         duration: 2
   *     },
   *     {
   *         source: cameraController.target,
   *         target: { x: 0, y: 0, z: 0},
   *         delay: 1,
   *         duration: 2,
   *         interpolation: animation.interpolations.LINEAR
   *     },
   *     {
   *         source: objectTransform.position,
   *         target: { x: 10, y: 10, z: 10 },
   *         onUpdate: (_, typedArray) => {
   *              // Replace default updater
   *              _animation.updaters.translationUpdate(bodyTransform, typedArray);
   *         }
   *         duration: 2
   *     }
   * ]);
   * ```
   */


  async run(name, channels, options) {
    const animation = this._getNewAnimation(name, options);

    animation.setChannels(channels);
    await animation.play();
    return animation;
  }

}

custom_animations_defineProperty(custom_animations_CustomAnimationManager, "updaters", lib["J" /* NodeAnimation */].Channel);
// CONCATENATED MODULE: ./src/global-helpers/ignore-raycast.ts

const $ignoreRaycast = '__wg_ignoreRaycast';
const ignoreAttribute = lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_2;
function isIgnoreRaycastNode(node) {
  // @ts-expect-error mutate with symbol
  return Boolean(node[$ignoreRaycast]);
}
function ignoreRaycast(scene, renderables, enabled) {
  if (renderables instanceof lib["V" /* Renderable */]) {
    scene.instanceDataManager.setInstancedAttribute(renderables, ignoreAttribute, enabled ? 1 : 0);
    return;
  }

  for (const renderable of renderables) {
    scene.instanceDataManager.setInstancedAttribute(renderable, ignoreAttribute, enabled ? 1 : 0);
  }
}
function ignoreRaycastNode(nodeRoot, enabled) {
  nodeRoot.traverse(node => {
    const {
      instanceDataManager
    } = node.scene; // @ts-expect-error mutate with symbol

    node[$ignoreRaycast] = enabled;

    if (!instanceDataManager.customInstancedAttributeLayout.has(ignoreAttribute)) {
      return true;
    }

    const [mesh, sprite] = node.getComponents([lib["F" /* Mesh */], lib["cb" /* Sprite */]]);

    if (mesh) {
      for (const submesh of mesh.subMeshes()) {
        instanceDataManager.setInstancedAttribute(submesh, ignoreAttribute, enabled ? 1 : 0);
      }
    }

    if (sprite) {
      instanceDataManager.setInstancedAttribute(sprite.renderable, ignoreAttribute, enabled ? 1 : 0);
    }

    return true;
  });
}
// CONCATENATED MODULE: ./src/global-helpers/webgldetection.ts
/* eslint-disable */
const detectWebGl = () => {
  if (window.WebGLRenderingContext) {
    const canvas = document.createElement('canvas');
    const names = ['webgl', 'experimental-webgl', 'moz-webgl'];

    for (let i = 0; i < names.length; i++) {
      try {
        const gl = canvas.getContext(names[i]);

        if (gl && typeof gl.getParameter === 'function') {
          /* WebGL is enabled */
          return true;
        }
      } catch (e) {
        console.warn('Unable to initialize WebGL. Your browser may not support it.');
      }
    }
    /* WebGL is supported, but disabled */


    return false;
  }
  /* WebGL not supported*/


  console.warn('Your browser not supports WebGL.');
  return false;
};
// CONCATENATED MODULE: ./src/global-helpers/visibility.ts

const $hiddenBy = '__wg_hiddenBy';
const $transparentHit = Symbol('transparentHit');
const renderableSystemsRequest = [lib["F" /* Mesh */], lib["cb" /* Sprite */], lib["y" /* Line */]];
const visibilitySystemRequest = [lib["qb" /* Visibility */]];
let visibility_mesh;
let visibility_sprite;
let visibility_line;
let visibility;
function isNodeRaycastTransparent(node) {
  // @ts-ignore ts doesn't like this
  return node[$transparentHit];
}
function setNodeRaycastTransparent(node, value) {
  // @ts-ignore ts doesn't like this
  node[$transparentHit] = value;
}

const updateSharedVisibility = (entity, value, tag) => {
  if (!tag) {
    return;
  } // @ts-expect-error mutate with symbol hack


  entity[$hiddenBy] = entity[$hiddenBy] || new Set();

  if (value) {
    // @ts-expect-error mutate with symbol hack
    entity[$hiddenBy].delete(tag);
  } else {
    // @ts-expect-error mutate with symbol hack
    entity[$hiddenBy].add(tag);
  }
};

const isSharedVisible = entity => {
  // @ts-expect-error mutate with symbol hack
  if (!(entity[$hiddenBy] instanceof Set)) {
    return true;
  } // @ts-expect-error mutate with symbol hack


  return entity[$hiddenBy].size === 0;
};

function getNodeVisibility(node) {
  [visibility] = node.getComponents(visibilitySystemRequest);

  if (!visibility) {
    return true;
  }

  return visibility.visible;
}

function setRenderableVisibility(instanceDataManager, renderable, value) {
  if (renderable.unloaded || !renderable.instanceId) {
    return;
  }

  instanceDataManager.setInstanceVisibility(renderable, value, false);
} // Apply visibility directly without Mesh/Line/Sprite system updates


function forceNodeVisibility(node, value) {
  [visibility_mesh, visibility_sprite, visibility_line] = node.getComponents(renderableSystemsRequest);

  if (visibility_mesh) {
    for (const subMesh of visibility_mesh.subMeshes()) {
      setRenderableVisibility(node.scene.instanceDataManager, subMesh, value);
    }

    node.scene.forceUpdateRenderQueue = true;
  }

  if (visibility_line) {
    // @ts-expect-error private _lineRenderable
    setRenderableVisibility(node.scene.instanceDataManager, visibility_line._lineRenderable, value);
    node.scene.forceUpdateRenderQueue = true;
  }

  if (visibility_sprite) {
    setRenderableVisibility(node.scene.instanceDataManager, visibility_sprite.renderable, value);
    node.scene.forceUpdateRenderQueue = true;
  }
}
function setNodeVisibility(node, value = true, tag) {
  [visibility_mesh, visibility_sprite, visibility_line] = node.getComponents(renderableSystemsRequest);

  if (!visibility_mesh && !visibility_sprite && !visibility_line) {
    return;
  }

  updateSharedVisibility(node, value, tag);
  [visibility] = node.getComponents(visibilitySystemRequest);

  if (!visibility) {
    visibility = new lib["qb" /* Visibility */]();
    node.attach(visibility);
    visibility.visible = true;
  }

  const newValue = value && isSharedVisible(node);

  if (newValue === visibility.visible) {
    return;
  }

  visibility.visible = value && isSharedVisible(node);
  forceNodeVisibility(node, visibility.visible);
}
function setNodeVisibilityTraverse(rootNode, value = true, tag) {
  rootNode.traverse(node => {
    setNodeVisibility(node, value, tag);
    return true;
  });
}
function setMaterialVisibility(material, value = true, tag) {
  updateSharedVisibility(material, value, tag);
  material.visible = value && isSharedVisible(material);
}
// CONCATENATED MODULE: ./src/global-helpers/dispose.ts

function disposeRenderableFromNode(rootNode) {
  rootNode.traverse(node => {
    const [mesh, sprite, line] = node.getComponents([lib["F" /* Mesh */], lib["cb" /* Sprite */], lib["y" /* Line */]]);

    if (mesh) {
      node.detach(mesh);
    }

    if (sprite) {
      node.detach(sprite);
    }

    if (line) {
      node.detach(line);
    }

    return true;
  });
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

function dispose(instance) {
  Object.keys(instance).forEach(prop => {
    instance[prop] = null;
  });
}
// EXTERNAL MODULE: ./src/global-helpers/event.ts
var global_helpers_event = __webpack_require__(42);

// CONCATENATED MODULE: ./src/global-helpers/mask.ts
function mask_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Mask {
  constructor(value) {
    mask_defineProperty(this, "_value", void 0);

    this._value = value;
  }

  has(flag) {
    return Boolean(this._value & flag);
  }

  add(flag) {
    this._value |= flag;
  }

  remove(flag) {
    this._value &= ~flag;
  }

  clear() {
    this._value = 0;
  }

  isEmpty() {
    return this._value === 0;
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// CONCATENATED MODULE: ./src/global-helpers/bbox.ts


function computeBBox(renderables, filterRenderable = () => true) {
  const box = new math_lib["e" /* Box */](new math_lib["n" /* Vector3 */]().fromNumber(Infinity), new math_lib["n" /* Vector3 */]().fromNumber(-Infinity)); // Default min/max values are bad for us

  const tempBox = new math_lib["e" /* Box */]();
  const tempWorldMatrix = new math_lib["b" /* AffineMatrix3 */]();

  for (const renderable of renderables) {
    const scene = renderable.getScene();

    if (!filterRenderable(renderable)) {
      continue;
    }

    if (renderable.geometry.unloaded) {
      continue;
    }

    if (checkLinedSubmesh(renderable)) {
      continue;
    }

    scene.getWorldMatrix(renderable, tempWorldMatrix);
    tempBox.copy(renderable.geometry.boundingBox);
    tempBox.applyAffineMatrix(tempWorldMatrix);
    box.consumeBox(tempBox);
  }

  if (![box.min.x, box.min.y, box.min.z, box.max.x, box.max.y, box.max.z].every(Number.isFinite)) {
    throw new Error('Can\'t compute bounding box');
  }

  return box;
}
// EXTERNAL MODULE: ./src/global-helpers/math.ts
var math = __webpack_require__(73);

// CONCATENATED MODULE: ./src/global-helpers/debounce.ts
function debounce(func, delay) {
  let inDebounce;
  return function (...args) {
    clearTimeout(inDebounce);
    inDebounce = setTimeout(() => func.apply(this, args), delay);
  };
}
// CONCATENATED MODULE: ./src/global-helpers/store.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
function updateStoreState(anyFunction, store) {
  return async (...args) => {
    try {
      await anyFunction(...args);
      store.setReady();
    } catch (e) {
      store.setError(e);
      throw e;
    }
  };
}
function updateStoreStateSync(anyFunction, store) {
  return (...args) => {
    try {
      anyFunction(...args);
      store.setReady();
    } catch (e) {
      store.setError(e);
      throw e;
    }
  };
}
// CONCATENATED MODULE: ./src/global-helpers/uniform.ts
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setUniform(uniforms, name, value, warn = true) {
  const uniform = uniforms.get(name);

  if (uniform) {
    uniform.setValue(value);
  } else if (warn) {
    console.error(`uniform "${name}" is undefined`);
  }
}
// EXTERNAL MODULE: ./src/global-helpers/worker.ts
var worker = __webpack_require__(83);

// EXTERNAL MODULE: ./src/global-helpers/transform.ts
var transform = __webpack_require__(22);

// CONCATENATED MODULE: ./src/global-helpers/merge-copy-sync.ts

function mergeCopySync(dstNode, srcScene, core) {
  const copyContext = {
    nodeToNode: new Map(),
    skeletonToSkeleton: new Map(),
    animationToAnimation: new Map()
  };

  for (const child of srcScene.root.children) {
    // @ts-ignore
    dstNode._adoptForeignNode(child, copyContext);
  } // @ts-ignore


  for (const system of core._systems.values()) {
    // @ts-ignore
    system.updateScene({
      // @ts-ignore
      type: lib["Y" /* Scene */]._SceneManagementDeferredTask.TaskType.MERGE_COPY,
      data: {
        dstNode,
        copyContext,
        srcScene,
        dstScene: dstNode.scene
      }
    });
  }
}
// CONCATENATED MODULE: ./src/global-helpers/index.ts




















/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Vector3; });
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _to_title_case__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




const aas = [...'xyzw'];

function makeClass(d) {
  const as = aas.slice(0, d);
  const Vector = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__[/* generateFunction */ "a"](fg => {
    fg.name = `Vector${d}`;
    fg.params = as;

    for (const a of as) {
      fg.emit`this.${a}=${a}===undefined?0:${a}`;
    }

    if (false) {}
  });

  if (false) {}

  const defineMethod = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeMethodDefiner */ "b"](Vector.prototype);
  const defineGetter = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeGetterDefiner */ "a"](Vector.prototype);
  const defineSetter = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeSetterDefiner */ "c"](Vector.prototype);
  const aliasProperty = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_2__[/* makePropertyAliaser */ "a"](Vector.prototype);
  defineMethod(fg => {
    fg.name = 'set';
    fg.params = as;

    for (const a of as) {
      fg.emit`this.${a}=${a}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'fromNumber';
    fg.params = ['number'];

    for (const a of as) {
      fg.emit`this.${a}=number`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = `from${Vector.name}`;
    fg.params = ['vector'];

    for (const a of as) {
      fg.emit`this.${a}=vector.${a}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty(`from${Vector.name}`, 'fromVector');
  aliasProperty('fromVector', 'copy');

  if (d === 2) {
    defineMethod(fg => {
      fg.name = `fromComplex`;
      fg.params = ['complex'];
      fg.emit`this.x=complex.re`;
      fg.emit`this.y=complex.im`;
      fg.emit`return this`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = `fromArray`;
    fg.params = ['array'];

    for (const _ref of as.entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const i = _ref2[0];
      const a = _ref2[1];
      fg.emit`this.${a}=array[${i}]`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = `fromArrayAt`;
    fg.params = ['offset', 'array'];

    for (const _ref3 of as.entries()) {
      var _ref4 = _slicedToArray(_ref3, 2);

      const i = _ref4[0];
      const a = _ref4[1];
      fg.emit`this.${a}=array[offset+${i}]`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = `toArray`;
    fg.params = ['array'];

    for (const _ref5 of as.entries()) {
      var _ref6 = _slicedToArray(_ref5, 2);

      const i = _ref6[0];
      const a = _ref6[1];
      fg.emit`array[${i}]=this.${a}`;
    }

    fg.emit`return array`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = `toArrayAt`;
    fg.params = ['offset', 'array'];

    for (const _ref7 of as.entries()) {
      var _ref8 = _slicedToArray(_ref7, 2);

      const i = _ref8[0];
      const a = _ref8[1];
      fg.emit`array[offset+${i}]=this.${a}`;
    }

    fg.emit`return array`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.ctx[Vector.name] = Vector;
    fg.name = 'clone';
    fg.emit`return new ${Vector.name}().copy(this)`;

    if (false) {}
  });

  for (const fn of [_functions__WEBPACK_IMPORTED_MODULE_4__[/* isNaN */ "s"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isInteger */ "r"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isSafeInteger */ "v"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isFinite */ "q"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isPow2 */ "u"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isPow10 */ "t"]]) {
    const name = fn.name,
          Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name);
    defineGetter(fg => {
      fg.ctx[name] = fn;
      fg.name = `some${Name}`;
      fg.emit`return ${as.map(a => `${name}(this.${a})`).join('||')}`;

      if (false) {}
    });
    defineGetter(fg => {
      fg.ctx[name] = fn;
      fg.name = `every${Name}`;
      fg.emit`return ${as.map(a => `${name}(this.${a})`).join('&&')}`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return ${as.map(a => `this.${a}===that.${a}`).join('&&')}`;

    if (false) {}
  });

  function defineUnaryOperation(name, vector) {
    defineMethod(fg => {
      fg.name = name;
      vector(fg);
      fg.emit`return this`;
    });
  }

  for (const _ref9 of [['negate', '-']]) {
    var _ref10 = _slicedToArray(_ref9, 2);

    const name = _ref10[0];
    const op = _ref10[1];
    defineUnaryOperation(name, fg => {
      for (const a of as) {
        fg.emit`this.${a}=${op}this.${a}`;
      }

      if (false) {}
    });
  }

  for (const fn of [_functions__WEBPACK_IMPORTED_MODULE_4__[/* sign */ "E"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* abs */ "a"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* floor */ "m"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* ceil */ "d"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* trunc */ "J"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* round */ "D"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* fround */ "p"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* floorPow2 */ "o"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* ceilPow2 */ "f"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* floorPow10 */ "n"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* ceilPow10 */ "e"]]) {
    const name = fn.name;
    defineUnaryOperation(name, fg => {
      fg.ctx[name] = fn;

      for (const a of as) {
        fg.emit`this.${a}=${name}(this.${a})`;
      }

      if (false) {}
    });
  }

  function defineBinaryOperartion(name, commutative, {
    vector,
    number,
    preNumber
  }) {
    const Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name);
    defineMethod(fg => {
      fg.name = `${name}Vector`;
      fg.params = ['right'];
      vector(fg, 'this', 'right');
      fg.emit`return this`;
    });
    defineMethod(fg => {
      fg.name = `${name}Number`;
      fg.params = ['right'];
      number(fg);
      fg.emit`return this`;
    });

    if (!commutative) {
      defineMethod(fg => {
        fg.name = `pre${Name}Vector`;
        fg.params = ['left'];
        vector(fg, 'left', 'this');
        fg.emit`return this`;
      });
      defineMethod(fg => {
        fg.name = `pre${Name}Number`;
        fg.params = ['left'];
        preNumber(fg);
        fg.emit`return this`;
      });
    }
  }

  for (const _ref11 of [['add', '+', 1], ['subtract', '-', 0], ['multiply', '*', 1], ['divide', '/', 0], ['modulo', '%', 0]]) {
    var _ref12 = _slicedToArray(_ref11, 3);

    const name = _ref12[0];
    const op = _ref12[1];
    const commutative = _ref12[2];
    const Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name);
    defineBinaryOperartion(name, commutative, {
      vector(fg, left, right) {
        for (const a of as) {
          fg.emit`this.${a}=${left}.${a}${op}${right}.${a}`;
        }

        if (false) {}
      },

      number(fg) {
        if (['/', '%'].includes(op)) {
          if (op === '%') {
            Object.assign(fg.ctx, {
              trunc: _functions__WEBPACK_IMPORTED_MODULE_4__[/* trunc */ "J"]
            });

            for (const a of as) {
              fg.emit`var ${a}=this.${a}`;
            }
          }

          fg.emit`var invRight=1/right`;
        }

        for (const a of as) {
          if (op === '/') {
            fg.emit`this.${a}=this.${a}*invRight`;
          } else if (op === '%') {
            fg.emit`this.${a}=${a}-trunc(${a}*invRight)*right`;
          } else {
            fg.emit`this.${a}=this.${a}${op}right`;
          }
        }

        if (false) {}
      },

      preNumber(fg) {
        for (const a of as) {
          fg.emit`this.${a}=left${op}this.${a}`;
        }

        if (false) {}
      }

    });

    if (['+', '-'].includes(op)) {
      aliasProperty(`${name}Vector`, name);

      if (!commutative) {
        aliasProperty(`pre${Name}Vector`, `pre${Name}`);
      }
    }

    if (['*', '/'].includes(op)) {
      aliasProperty(`${name}Number`, name);
    }
  }

  for (const _ref13 of [[_functions__WEBPACK_IMPORTED_MODULE_4__[/* min */ "B"], 1], [_functions__WEBPACK_IMPORTED_MODULE_4__[/* max */ "A"], 1]]) {
    var _ref14 = _slicedToArray(_ref13, 2);

    const fn = _ref14[0];
    const commutative = _ref14[1];
    const name = fn.name,
          Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name);
    defineBinaryOperartion(name, commutative, {
      vector(fg, left, right) {
        fg.ctx[name] = fn;

        for (const a of as) {
          fg.emit`this.${a}=${name}(${left}.${a},${right}.${a})`;
        }

        if (false) {}
      },

      number(fg) {
        fg.ctx[name] = fn;

        for (const a of as) {
          fg.emit`this.${a}=${name}(this.${a},right)`;
        }

        if (false) {}
      },

      preNumber(fg) {
        fg.ctx[name] = fn;

        for (const a of as) {
          fg.emit`this.${a}=${name}(left,this.${a})`;
        }

        if (false) {}
      }

    });

    if ([_functions__WEBPACK_IMPORTED_MODULE_4__[/* min */ "B"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* max */ "A"]].includes(fn)) {
      aliasProperty(`${name}Vector`, name);
    }
  }

  defineMethod(fg => {
    Object.assign(fg.ctx, {
      clamp: _functions__WEBPACK_IMPORTED_MODULE_4__[/* clamp */ "g"]
    });
    fg.name = `clampVectors`;
    fg.params = ['low', 'high'];

    for (const a of as) {
      fg.emit`this.${a}=clamp(this.${a},low.${a},high.${a})`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty('clampVectors', 'clamp');
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      clamp: _functions__WEBPACK_IMPORTED_MODULE_4__[/* clamp */ "g"]
    });
    fg.name = `clampNumbers`;
    fg.params = ['low', 'high'];

    for (const a of as) {
      fg.emit`this.${a}=clamp(this.${a},low,high)`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineGetter(fg => {
    fg.name = 'sqLength';

    for (const a of as) {
      fg.emit`var ${a}=this.${a}`;
    }

    fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;

    if (false) {}
  });
  defineSetter(fg => {
    Object.assign(fg.ctx, {
      sqrt: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"]
    });
    fg.name = 'sqLength';
    fg.params = ['newSqLength'];
    fg.emit`this.multiply(sqrt(newSqLength/this.sqLength))`;
  });
  defineGetter(fg => {
    Object.assign(fg.ctx, {
      sqrt: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"]
    });
    fg.name = 'length';
    fg.emit`return sqrt(this.sqLength)`;

    if (false) {}
  });
  defineSetter(fg => {
    fg.name = 'length';
    fg.params = ['newLength'];
    fg.emit`this.multiply(newLength/this.length)`;
  });
  defineMethod(fg => {
    fg.name = 'sqDistance';
    fg.params = ['that'];

    for (const a of as) {
      fg.emit`var ${a}=this.${a}-that.${a}`;
    }

    fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;

    if (false) {}
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      sqrt: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"]
    });
    fg.name = 'distance';
    fg.params = ['that'];
    fg.emit`return sqrt(this.sqDistance(that))`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'normalize';
    fg.emit`return this.divide(this.length)`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'dot';
    fg.params = ['that'];
    fg.emit`return ${as.map(a => `this.${a}*that.${a}`).join('+')}`;

    if (false) {}
  });

  if (d === 2) {
    defineMethod(fg => {
      fg.name = 'cross';
      fg.params = ['right'];
      fg.emit`return this.x*right.y-this.y*right.x`;

      if (false) {}
    });
  } else {
    function cross(result, left, right) {
      const ax = left.x,
            ay = left.y,
            az = left.z;
      const bx = right.x,
            by = right.y,
            bz = right.z;
      result.x = ay * bz - az * by;
      result.y = az * bx - ax * bz;
      result.z = ax * by - ay * bx;
    }

    defineMethod(fg => {
      Object.assign(fg.ctx, {
        cross
      });
      fg.name = 'cross';
      fg.params = ['right'];
      fg.emit`cross(this,this,right)`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        cross
      });
      fg.name = 'preCross';
      fg.params = ['left'];
      fg.emit`cross(this,left,this)`;
      fg.emit`return this`;

      if (false) {}
    });
  }

  if (d === 2) {
    defineMethod(fg => {
      fg.name = 'orthogonalize';
      fg.emit`var x=this.x`;
      fg.emit`this.x=-this.y`;
      fg.emit`this.y=x`;
      fg.emit`return this`;

      if (false) {}
    });
  } else {
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        abs: _functions__WEBPACK_IMPORTED_MODULE_4__[/* abs */ "a"]
      });
      fg.name = 'orthogonalize';
      fg.emit`var x=this.x,y=this.y,z=this.z`;
      fg.emit`var ax=abs(x),ay=abs(y),az=abs(z)`;
      fg.emit`if(ax<=ay&&ax<=az){`;
      fg.emit`this.x=0`;
      fg.emit`this.y=z`;
      fg.emit`this.z=-y`;
      fg.emit`}else if(ay<=az){`;
      fg.emit`this.x=-z`;
      fg.emit`this.y=0`;
      fg.emit`this.z=x`;
      fg.emit`}else{`;
      fg.emit`this.x=y`;
      fg.emit`this.y=-x`;
      fg.emit`this.z=0`;
      fg.emit`}`;
      fg.emit`return this`;

      if (false) {}
    });
  }

  aliasProperty('add', 'translate');
  aliasProperty(`multiplyVector`, 'scale');
  aliasProperty(`multiply`, 'scaleUniform');
  defineMethod(fg => {
    fg.name = 'shear';
    fg.params = ['shearing'];

    if (d === 2) {
      fg.emit`this.x+=this.y*shearing`;
    } else {
      fg.emit`var y=this.y,z=this.z`;
      fg.emit`this.x+=y*shearing.z+z*shearing.y`;
      fg.emit`this.y=y+z*shearing.x`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    Object.assign(fg.ctx, {
      tmp: new Vector()
    });
    fg.name = 'reflect';
    fg.params = ['normal'];
    fg.emit`tmp.copy(normal).multiply(2*this.dot(normal))`;
    fg.emit`return this.subtract(tmp)`;

    if (false) {}
  });

  if (d === 2) {
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        sin: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sin */ "F"],
        cos: _functions__WEBPACK_IMPORTED_MODULE_4__[/* cos */ "h"]
      });
      fg.name = 'rotate';
      fg.params = ['angle'];
      fg.emit`var x=this.x,y=this.y`;
      fg.emit`var s=sin(angle),c=cos(angle)`;
      fg.emit`this.x=x*c-y*s`;
      fg.emit`this.y=x*s+y*c`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      fg.name = 'rotateBetween';
      fg.params = ['from', 'to'];
      fg.emit`var x=this.x,y=this.y`;
      fg.emit`var s=from.cross(to),c=from.dot(to)`;
      fg.emit`this.x=x*c-y*s`;
      fg.emit`this.y=x*s+y*c`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      fg.name = 'applyComplex';
      fg.params = ['complex'];
      fg.emit`var x=this.x,y=this.y`;
      fg.emit`var re=complex.re,im=complex.im`;
      fg.emit`this.x=x*re-y*im`;
      fg.emit`this.y=x*im+y*re`;
      fg.emit`return this`;

      if (false) {}
    });
  } else {
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        sin: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sin */ "F"],
        cos: _functions__WEBPACK_IMPORTED_MODULE_4__[/* cos */ "h"]
      });
      fg.name = 'rotate';
      fg.params = ['angle', 'axis'];
      fg.emit`var x=this.x,y=this.y,z=this.z`;
      fg.emit`var s=sin(angle),c=cos(angle)`;
      fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;
      fg.emit`var q=(ax*x+ay*y+az*z)*(1-c)`;
      fg.emit`this.x=x*c+(ay*z-az*y)*s+ax*q`;
      fg.emit`this.y=y*c+(az*x-ax*z)*s+ay*q`;
      fg.emit`this.z=z*c+(ax*y-ay*x)*s+az*q`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        axis: new Vector()
      });
      fg.name = 'rotateBetween';
      fg.params = ['from', 'to'];
      fg.emit`axis.copy(from).cross(to)`;
      fg.emit`var axs=axis.x,ays=axis.y,azs=axis.z`;
      fg.emit`axis.normalize()`;
      fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;
      fg.emit`var c=from.dot(to),q=axis.dot(this)*(1-c),`;
      fg.emit`x=this.x,y=this.y,z=this.z`;
      fg.emit`this.x=x*c+(ays*z-azs*y)+axis.x*q`;
      fg.emit`this.y=y*c+(azs*x-axs*z)+axis.y*q`;
      fg.emit`this.z=z*c+(axs*y-ays*x)+axis.z*q`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        sqrt: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"]
      });
      fg.name = 'applyComplex';
      fg.params = ['complex', 'axis'];
      fg.emit`var x=this.x,y=this.y,z=this.z`;
      fg.emit`var re=complex.re,im=complex.im`;
      fg.emit`var f=sqrt(re*re+im*im)`;
      fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;
      fg.emit`var q=(ax*x+ay*y+az*z)*(f-re)`;
      fg.emit`this.x=x*re+(ay*z-az*y)*im+ax*q`;
      fg.emit`this.y=y*re+(az*x-ax*z)*im+ay*q`;
      fg.emit`this.z=z*re+(ax*y-ay*x)*im+az*q`;
      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      fg.name = 'applyQuaternion';
      fg.params = ['quaternion'];
      fg.emit`var x=this.x,y=this.y,z=this.z,`;
      fg.emit`re=quaternion.re,`;
      fg.emit`imX=quaternion.imX,`;
      fg.emit`imY=quaternion.imY,`;
      fg.emit`imZ=quaternion.imZ,`;
      fg.emit`tRe=imX*x+imY*y+imZ*z,`;
      fg.emit`tImX=re*x+imZ*y-imY*z,`;
      fg.emit`tImY=re*y+imX*z-imZ*x,`;
      fg.emit`tImZ=re*z+imY*x-imX*y`;
      fg.emit`this.x=tRe*imX+tImX*re+tImY*imZ-tImZ*imY`;
      fg.emit`this.y=tRe*imY+tImY*re+tImZ*imX-tImX*imZ`;
      fg.emit`this.z=tRe*imZ+tImZ*re+tImX*imY-tImY*imX`;
      fg.emit`return this`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = 'multiplyLinearMatrix';
    fg.params = ['matrix'];

    for (const a of as) {
      fg.emit`var ${a}=this.${a}`;
    }

    for (const _ref15 of as.entries()) {
      var _ref16 = _slicedToArray(_ref15, 2);

      const j = _ref16[0];
      const a = _ref16[1];
      fg.emit`this.${a}=${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty('multiplyLinearMatrix', 'applyLinearMatrix');
  defineMethod(fg => {
    fg.name = 'multiplyAffineMatrix';
    fg.params = ['matrix'];

    for (const a of as) {
      fg.emit`var ${a}=this.${a}`;
    }

    for (const _ref17 of as.entries()) {
      var _ref18 = _slicedToArray(_ref17, 2);

      const j = _ref18[0];
      const a = _ref18[1];
      fg.emit`this.${a}=${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}+matrix._${d}${j}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty('multiplyAffineMatrix', 'applyAffineMatrix');
  defineMethod(fg => {
    fg.name = 'multiplyHomogeneousMatrix';
    fg.params = ['matrix'];

    for (const a of as) {
      fg.emit`var ${a}=this.${a}`;
    }

    fg.emit`var invW=1/(${as.map((a, i) => `${a}*matrix._${i}${d}`).join('+')}+matrix._${d}${d})`;

    for (const _ref19 of as.entries()) {
      var _ref20 = _slicedToArray(_ref19, 2);

      const j = _ref20[0];
      const a = _ref20[1];
      fg.emit`this.${a}=(${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}+matrix._${d}${j})*invW`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty('multiplyHomogeneousMatrix', 'applyHomogeneousMatrix');
  return Vector;
}

const Vector2 = makeClass(2);
const Vector3 = makeClass(3);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Any */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BasicModel; });
/* unused harmony export FunctionModel */
/* unused harmony export MapModel */
/* unused harmony export Model */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ObjectModel; });
/* unused harmony export SetModel */
// ObjectModel v4.2.2 - http://objectmodel.js.org
// MIT License - Sylvain Pollet-Villard
const
	ObjectProto = Object.prototype,
	bettertypeof = x => ObjectProto.toString.call(x).match(/\s([a-zA-Z]+)/)[1],
	getProto = Object.getPrototypeOf,
	setProto = Object.setPrototypeOf,

	has = (o, prop) => ObjectProto.hasOwnProperty.call(o, prop),
	is = (Constructor, obj) => obj instanceof Constructor,
	isFunction = f => typeof f === "function",
	isObject = o => o && typeof o === "object",
	isString = s => typeof s === "string",
	isPlainObject = o => isObject(o) && getProto(o) === ObjectProto,
	isIterable = x => x && isFunction(x[Symbol.iterator]),

	proxify = (val, traps) => new Proxy(val, traps),

	merge = (target, src = {}) => {
		for (let key in src) {
			if (isPlainObject(src[key])) {
				const o = {};
				merge(o, target[key]);
				merge(o, src[key]);
				target[key] = o;
			} else {
				target[key] = src[key];
			}
		}
		return target
	},

	define = (obj, key, value, enumerable = false) => {
		Object.defineProperty(obj, key, { value, enumerable, writable: true, configurable: true });
	},

	extend = (child, parent, props) => {
		child.prototype = Object.assign(Object.create(parent.prototype, {
			constructor: {
				value: child,
				writable: true,
				configurable: true
			}
		}), props);
		setProto(child, parent);
	};

const
	_check = Symbol(),
	_checked = Symbol(), // used to skip validation at instanciation for perf
	_original = Symbol(), // used to bypass proxy

	initModel = (def, constructor, parent, init, getTraps, useNew) => {
		const model = function (val = model.default, mode) {
			if (useNew && !is(model, this)) return new model(val)
			if (init) val = init(val, model, this);

			if (mode === _checked || check(model, val))
				return getTraps ? proxify(val, getTraps(model)) : val
		};

		if (parent) extend(model, parent);
		setProto(model, constructor.prototype);
		model.constructor = constructor;
		model.definition = def;
		model.assertions = [...model.assertions];
		define(model, "errors", []);
		delete model.name;
		return model
	},

	initObjectModel = (obj, model, _this) => {
		if (is(model, obj)) return obj

		if (!isObject(obj) && !isFunction(obj) && obj !== undefined) {
			stackError(model.errors, Object, obj);
		}

		merge(_this, model.default);
		if (model.parentClass) merge(obj, new model.parentClass(obj));
		merge(_this, obj);
		return _this
	},

	extendModel = (child, parent, newProps) => {
		extend(child, parent, newProps);
		child.assertions.push(...parent.assertions);
		return child
	},

	stackError = (errors, expected, received, path, message) => {
		errors.push({ expected, received, path, message });
	},

	unstackErrors = (model, collector = model.errorCollector) => {
		const nbErrors = model.errors.length;
		if (nbErrors > 0) {
			const errors = model.errors.map(err => {
				if (!err.message) {
					err.message = "expecting " + (err.path ? err.path + " to be " : "") + formatDefinition(err.expected)
						+ ", got " + (err.received != null ? bettertypeof(err.received) + " " : "") + format(err.received);
				}
				return err
			});

			model.errors.length = 0;
			collector.call(model, errors); // throw all errors collected
		}
		return nbErrors
	},

	isModelInstance = i => i && getProto(i) && is(Model, getProto(i).constructor),

	parseDefinition = (def) => {
		if (isPlainObject(def)) {
			def = {};
			for (let key in def) { def[key] = parseDefinition(def[key]); }
		}
		else if (!Array.isArray(def)) return [def]
		else if (def.length === 1) return [def[0], undefined, null]

		return def
	},

	formatDefinition = (def, stack) => {
		const parts = parseDefinition(def).map(d => format(d, stack));
		return parts.length > 1 ? parts.join(" or ") : parts[0]
	},

	formatAssertions = fns => fns.length ? `(${fns.map(f => f.name || f.description || f)})` : "",

	extendDefinition = (def, newParts = []) => {
		if (newParts.length > 0) {
			def = [].concat(def, ...[].concat(newParts))// clone to lose ref
				.filter((value, index, self) => self.indexOf(value) === index); // remove duplicates
		}

		return def
	},

	check = (model, obj) => {
		model[_check](obj, null, model.errors, [], true);
		return !unstackErrors(model)
	},

	checkDefinition = (obj, def, path, errors, stack, shouldCast) => {
		const indexFound = stack.indexOf(def);
		if (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)
			return obj // if found twice in call stack, cycle detected, skip validation

		if (Array.isArray(def) && def.length === 1 && obj != null) {
			def = def[0]; // shorten validation path for optionals
		}

		if (is(Model, def)) {
			if (shouldCast) obj = cast(obj, def);
			def[_check](obj, path, errors, stack.concat(def));
		}
		else if (isPlainObject(def)) {
			for (let key in def) {
				const val = obj ? obj[key] : undefined;
				checkDefinition(val, def[key], formatPath(path, key), errors, stack, shouldCast);
			}
		}
		else {
			const pdef = parseDefinition(def);
			if (pdef.some(part => checkDefinitionPart(obj, part, path, stack))) {
				return shouldCast ? cast(obj, def) : obj
			}

			stackError(errors, def, obj, path);
		}

		return obj
	},

	checkDefinitionPart = (obj, def, path, stack, shouldCast) => {
		if (def === Any) return true
		if (obj == null) return obj === def
		if (isPlainObject(def) || is(Model, def)) { // object or model as part of union type
			const errors = [];
			checkDefinition(obj, def, path, errors, stack, shouldCast);
			return !errors.length
		}
		if (is(RegExp, def)) return def.test(obj)
		if (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)
		return obj === def
			|| (isFunction(def) && is(def, obj))
			|| obj.constructor === def
	},

	checkAssertions = (obj, model, path, errors = model.errors) => {
		for (let assertion of model.assertions) {
			let result;
			try {
				result = assertion.call(model, obj);
			} catch (err) {
				result = err;
			}
			if (result !== true) {
				const onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>
					`assertion "${assertion.description}" returned ${format(assertionResult)} `
					+ `for ${path ? path + " =" : "value"} ${format(value)}`;
				stackError(errors, assertion, obj, path, onFail.call(model, result, obj, path));
			}
		}
	},

	format = (obj, stack = []) => {
		if (stack.length > 15 || stack.includes(obj)) return "..."
		if (obj === null || obj === undefined) return String(obj)
		if (isString(obj)) return `"${obj}"`
		if (is(Model, obj)) return obj.toString(stack)

		stack.unshift(obj);

		if (isFunction(obj)) return obj.name || obj.toString()
		if (is(Map, obj) || is(Set, obj)) return format([...obj])
		if (Array.isArray(obj)) return `[${obj.map(item => format(item, stack)).join(", ")}]`
		if (obj.toString && obj.toString !== ObjectProto.toString) return obj.toString()
		if (isObject(obj)) {
			const props = Object.keys(obj),
				indent = "\t".repeat(stack.length);
			return `{${props.map(
				key => `\n${indent + key}: ${format(obj[key], [...stack])}`
			).join(", ")} ${props.length ? `\n${indent.slice(1)}` : ""}}`
		}

		return String(obj)
	},

	formatPath = (path, key) => path ? path + "." + key : key,

	controlMutation = (model, def, path, o, key, privateAccess, applyMutation) => {
		const newPath = formatPath(path, key),
			isPrivate = model.conventionForPrivate(key),
			isConstant = model.conventionForConstant(key),
			isOwnProperty = has(o, key),
			initialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key);

		if (key in def && ((isPrivate && !privateAccess) || (isConstant && o[key] !== undefined)))
			cannot(`modify ${isPrivate ? "private" : "constant"} property ${key}`, model);

		applyMutation();
		if (has(def, key)) checkDefinition(o[key], def[key], newPath, model.errors, []);
		checkAssertions(o, model, newPath);

		const nbErrors = model.errors.length;
		if (nbErrors) {
			if (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor);
			else delete o[key]; // back to the initial property defined in prototype chain

			unstackErrors(model);
		}

		return !nbErrors
	},

	cannot = (msg, model) => {
		model.errors.push({ message: "cannot " + msg });
	},

	cast = (obj, defNode = []) => {
		if (!obj || isPlainObject(defNode) || is(BasicModel, defNode) || isModelInstance(obj))
			return obj // no value or not leaf or already a model instance

		const def = parseDefinition(defNode),
			suitableModels = [];

		for (let part of def) {
			if (is(Model, part) && !is(BasicModel, part) && part.test(obj))
				suitableModels.push(part);
		}

		if (suitableModels.length === 1) {
			// automatically cast to suitable model when explicit (autocasting)
			return new suitableModels[0](obj, _checked)
		}

		if (suitableModels.length > 1)
			console.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(" or ")}`);

		return obj
	},


	getProp = (val, model, def, path, privateAccess) => {
		if (!isPlainObject(def)) return cast(val, def)
		return proxify(val, getTraps(model, def, path, privateAccess))
	},

	getTraps = (model, def, path, privateAccess) => {
		const grantPrivateAccess = f => proxify(f, {
			apply(fn, ctx, args) {
				privateAccess = true;
				const result = Reflect.apply(fn, ctx, args);
				privateAccess = false;
				return result
			}
		});

		return {
			get(o, key) {
				if (key === _original) return o

				if (!isString(key)) return Reflect.get(o, key)

				const newPath = formatPath(path, key);
				const inDef = has(def, key);
				const defPart = def[key];

				if (!privateAccess && inDef && model.conventionForPrivate(key)) {
					cannot(`access to private property ${newPath}`, model);
					unstackErrors(model);
					return
				}

				let value = o[key];

				if (inDef && value && has(o, key) && !isPlainObject(defPart) && !isModelInstance(value)) {
					Reflect.set(o, key, value = cast(value, defPart)); // cast nested models
				}

				if (isFunction(value) && key !== "constructor" && !privateAccess) {
					return grantPrivateAccess(value)
				}

				if (isPlainObject(defPart) && !value) {
					o[key] = value = {}; // null-safe traversal
				}

				return getProp(value, model, defPart, newPath, privateAccess)
			},

			set(o, key, val) {
				return controlMutation(model, def, path, o, key, privateAccess, () => Reflect.set(o, key, cast(val, def[key])))
			},

			deleteProperty(o, key) {
				return controlMutation(model, def, path, o, key, privateAccess, () => Reflect.deleteProperty(o, key))
			},

			defineProperty(o, key, args) {
				return controlMutation(model, def, path, o, key, privateAccess, () => Reflect.defineProperty(o, key, args))
			},

			has(o, key) {
				return Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)
			},

			ownKeys(o) {
				return Reflect.ownKeys(o).filter(key => Reflect.has(def, key) && !model.conventionForPrivate(key))
			},

			getOwnPropertyDescriptor(o, key) {
				let descriptor;
				if (!model.conventionForPrivate(key)) {
					descriptor = Object.getOwnPropertyDescriptor(def, key);
					if (descriptor !== undefined) descriptor.value = o[key];
				}

				return descriptor
			}
		}
	};


function Model(def, params) {
	return isPlainObject(def) ? new ObjectModel(def, params) : new BasicModel(def)
}

Object.assign(Model.prototype, {
	name: "Model",
	assertions: [],

	conventionForConstant: key => key.toUpperCase() === key,
	conventionForPrivate: key => key[0] === "_",

	toString(stack) {
		return has(this, "name") ? this.name : formatDefinition(this.definition, stack) + formatAssertions(this.assertions)
	},

	as(name) {
		define(this, "name", name);
		return this
	},

	defaultTo(val) {
		this.default = val;
		return this
	},

	[_check](obj, path, errors, stack) {
		checkDefinition(obj, this.definition, path, errors, stack);
		checkAssertions(obj, this, path, errors);
	},

	test(obj, errorCollector) {
		let model = this;
		while (!has(model, "errorCollector")) {
			model = getProto(model);
		}

		const initialErrorCollector = model.errorCollector;
		let failed;

		model.errorCollector = errors => {
			failed = true;
			if (errorCollector) errorCollector.call(this, errors);
		};

		new this(obj); // may trigger errorCollector

		model.errorCollector = initialErrorCollector;
		return !failed
	},

	errorCollector(errors) {
		const e = new TypeError(errors.map(e => e.message).join("\n"));
		e.stack = e.stack.replace(/\n.*object-model(.|\n)*object-model.*/, ""); // blackbox objectmodel in stacktrace
		throw e
	},

	assert(assertion, description = format(assertion)) {
		define(assertion, "description", description);
		this.assertions = this.assertions.concat(assertion);
		return this
	}
});


function BasicModel(def) {
	return initModel(def, BasicModel)
}

extend(BasicModel, Model, {
	extend(...newParts) {
		const child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this);
		for (let part of newParts) {
			if (is(BasicModel, part)) child.assertions.push(...part.assertions);
		}

		return child
	}
});

function ObjectModel(def) {
	return initModel(def, ObjectModel, Object, initObjectModel, model => getTraps(model, def), true)
}

extend(ObjectModel, Model, {
	defaultTo(obj) {
		const def = this.definition;
		for (let key in obj) {
			if (has(def, key)) {
				obj[key] = checkDefinition(obj[key], def[key], key, this.errors, [], true);
			}
		}
		unstackErrors(this);
		this.default = obj;
		return this
	},

	toString(stack) {
		return format(this.definition, stack)
	},

	extend(...newParts) {
		const definition = { ...this.definition };
		const proto = { ...this.prototype };
		const defaults = { ...this.default };
		const newAssertions = [];

		for (let part of newParts) {
			if (is(Model, part)) {
				merge(definition, part.definition);
				merge(defaults, part.default);
				newAssertions.push(...part.assertions);
			}
			if (isFunction(part)) merge(proto, part.prototype);
			if (isObject(part)) merge(definition, part);
		}

		const submodel = extendModel(new ObjectModel(definition), this, proto).defaultTo(defaults);
		submodel.assertions = [...this.assertions, ...newAssertions];

		if (getProto(this) !== ObjectModel.prototype) { // extended class
			submodel.parentClass = this;
		}

		return submodel
	},

	[_check](obj, path, errors, stack, shouldCast) {
		if (isObject(obj)) {
			checkDefinition(obj[_original] || obj, this.definition, path, errors, stack, shouldCast);
		}
		else stackError(errors, this, obj, path);

		checkAssertions(obj, this, path, errors);
	}
});

const Any = proxify(BasicModel(), {
	apply(target, ctx, [def]) {
		const anyOf = Object.create(Any);
		anyOf.definition = def;
		return anyOf
	}
});
Any.definition = Any;
Any.toString = () => "Any";

Any.remaining = function (def) { this.definition = def; };
extend(Any.remaining, Any, {
	toString() { return "..." + formatDefinition(this.definition) }
});
Any[Symbol.iterator] = function* () { yield new Any.remaining(this.definition); };

const initListModel = (base, constructor, def, init, clone, mutators, otherTraps) => {

	return initModel(def, constructor, base, init, model => Object.assign({
		getPrototypeOf: () => model.prototype,
		get(l, key) {
			if (key === _original) return l

			const val = l[key];
			return isFunction(val) ? proxify(val, {
				apply(fn, ctx, args) {
					if (has(mutators, key)) {
						// indexes of arguments to check def + cast
						const [begin, end = args.length - 1, getArgDef] = mutators[key];
						for (let i = begin; i <= end; i++) {
							const argDef = getArgDef ? getArgDef(i) : model.definition;
							args[i] = checkDefinition(
								args[i],
								argDef,
								`${base.name}.${key} arguments[${i}]`,
								model.errors,
								[],
								true
							);
						}

						if (model.assertions.length > 0) {
							const testingClone = clone(l);
							fn.apply(testingClone, args);
							checkAssertions(testingClone, model, `after ${key} mutation`);
						}

						unstackErrors(model);
					}

					return fn.apply(l, args)
				}
			}) : val
		}
	}, otherTraps))
};

function ArrayModel(initialDefinition) {
	const model = initListModel(
		Array,
		ArrayModel,
		initialDefinition,
		a => Array.isArray(a) ? a.map(arg => cast(arg, model.definition)) : a,
		a => [...a],
		{
			"copyWithin": [],
			"fill": [0, 0],
			"pop": [],
			"push": [0],
			"reverse": [],
			"shift": [],
			"sort": [],
			"splice": [2],
			"unshift": [0]
		},
		{
			set(arr, key, val) {
				return controlMutation$1(model, arr, key, val, (a, v) => a[key] = v, true)
			},

			deleteProperty(arr, key) {
				return controlMutation$1(model, arr, key, undefined, a => delete a[key])
			}
		}
	);

	return model
}

extend(ArrayModel, Model, {
	toString(stack) {
		return "Array of " + formatDefinition(this.definition, stack)
	},

	[_check](arr, path, errors, stack) {
		if (Array.isArray(arr))
			(arr[_original] || arr).forEach((a, i) => checkDefinition(a, this.definition, `${path || "Array"}[${i}]`, errors, stack));
		else stackError(errors, this, arr, path);

		checkAssertions(arr, this, path, errors);
	},

	extend(...newParts) {
		return extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)
	}
});

const controlMutation$1 = (model, array, key, value, applyMutation, canBeExtended) => {
	const path = `Array[${key}]`;
	const isInDef = (+key >= 0 && (canBeExtended || key in array));
	if (isInDef) value = checkDefinition(value, model.definition, path, model.errors, [], true);

	const testArray = [...array];
	applyMutation(testArray);
	checkAssertions(testArray, model, path);
	const isSuccess = !unstackErrors(model);
	if (isSuccess) applyMutation(array, value);
	return isSuccess
};

function SetModel(initialDefinition) {
	const model = initListModel(
		Set,
		SetModel,
		initialDefinition,
		it => isIterable(it) ? new Set([...it].map(val => cast(val, model.definition))) : it,
		set => new Set(set),
		{
			"add": [0, 0],
			"delete": [],
			"clear": []
		}
	);

	return model
}

extend(SetModel, Model, {
	toString(stack) {
		return "Set of " + formatDefinition(this.definition, stack)
	},

	[_check](set, path, errors, stack) {
		if (is(Set, set)) {
			for (let item of set.values()) {
				checkDefinition(item, this.definition, `${path || "Set"} value`, errors, stack);
			}
		} else stackError(errors, this, set, path);
		checkAssertions(set, this, path, errors);
	},

	extend(...newParts) {
		return extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)
	}
});

function MapModel(initialKeyDefinition, initialValueDefinition) {
	const getDef = i => i === 0 ? model.definition.key : model.definition.value;
	const model = initListModel(
		Map,
		MapModel,
		{ key: initialKeyDefinition, value: initialValueDefinition },
		it => isIterable(it) ? new Map([...it].map(pair => pair.map((x, i) => cast(x, getDef(i))))) : it,
		map => new Map(map),
		{
			"set": [0, 1, getDef],
			"delete": [],
			"clear": []
		}
	);

	return model
}

extend(MapModel, Model, {
	toString(stack) {
		return `Map of ${formatDefinition(this.definition.key, stack)} : ${formatDefinition(this.definition.value, stack)}`
	},

	[_check](map, path, errors, stack) {
		if (is(Map, map)) {
			path = path || "Map";
			for (let [key, value] of map) {
				checkDefinition(key, this.definition.key, `${path} key`, errors, stack);
				checkDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack);
			}
		} else stackError(errors, this, map, path);

		checkAssertions(map, this, path, errors);
	},

	extend(keyParts, valueParts) {
		return extendModel(new MapModel(
			extendDefinition(this.definition.key, keyParts),
			extendDefinition(this.definition.value, valueParts)
		), this)
	}
});

function FunctionModel(...argsDef) {
	return initModel({ arguments: argsDef }, FunctionModel, Function, null, model => ({
		getPrototypeOf: () => model.prototype,

		get(fn, key) {
			return key === _original ? fn : fn[key]
		},

		apply(fn, ctx, args) {
			const def = model.definition;
			const remainingArgDef = def.arguments.find(argDef => is(Any.remaining, argDef));
			const nbArgsToCheck = remainingArgDef ? Math.max(args.length, def.arguments.length - 1) : def.arguments.length;

			for (let i = 0; i < nbArgsToCheck; i++) {
				const argDef = remainingArgDef && i >= def.arguments.length - 1 ? remainingArgDef.definition : def.arguments[i];
				args[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [], true);
			}

			checkAssertions(args, model, "arguments");

			let result;
			if (!model.errors.length) {
				result = Reflect.apply(fn, ctx, args);
				if ("return" in def)
					result = checkDefinition(result, def.return, "return value", model.errors, [], true);
			}
			unstackErrors(model);
			return result
		}
	}))
}

extend(FunctionModel, Model, {
	toString(stack = []) {
		let out = `Function(${this.definition.arguments.map(
			argDef => formatDefinition(argDef, [...stack])
		).join(", ")})`;

		if ("return" in this.definition) {
			out += " => " + formatDefinition(this.definition.return, stack);
		}
		return out
	},

	return(def) {
		this.definition.return = def;
		return this
	},

	extend(newArgs, newReturns) {
		const args = this.definition.arguments,
			  mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i])),
			  mixedReturns = extendDefinition(this.definition.return, newReturns);
		return extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)
	},

	[_check](f, path, errors) {
		if (!isFunction(f)) stackError(errors, "Function", f, path);
	}
});

const styles = {
	list: "list-style-type: none; padding: 0; margin: 0;",
	listItem: "padding: 0 0 0 1em;",
	model: "color: #3e999f;",
	instance: "color: #718c00; font-style: italic",
	function: "color: #4271AE",
	string: "color: #C41A16",
	number: "color: #1C00CF",
	boolean: "color: #AA0D91",
	property: "color: #8959a8",
	private: "color: #C19ED8",
	constant: "color: #8959a8; font-weight: bold",
	privateConstant: "color: #C19ED8; font-weight: bold",
	null: "color: #8e908c",
	undeclared: "color: #C0C0C0;",
	proto: "color: #B871BD; font-style: italic"
};

const getModel = (instance) => {
	if (instance === undefined || instance === null)
		return null

	const proto = getProto(instance);
	if (!proto || !proto.constructor || !is(Model, proto.constructor))
		return null

	return proto.constructor
};

const span = (style, ...children) => ["span", { style }, ...children];

const format$1 = (x, config = {}) => {
	if (x === null || x === undefined)
		return span(styles.null, "" + x);

	if (typeof x === "boolean")
		return span(styles.boolean, x);

	if (typeof x === "number")
		return span(styles.number, x);

	if (typeof x === "string")
		return span(styles.string, `"${x}"`);

	if (Array.isArray(x) && config.isModelDefinition) {
		return span("", ...x.flatMap(part => [format$1(part, config), " or "]).slice(0, -1))
	}

	if (isPlainObject(x))
		return formatObject(x, getModel(x), config)

	if (isFunction(x) && !is(Model, x) && config.isModelDefinition)
		return span(styles.function, x.name || x.toString());

	return ["object", { object: x, config }]
};

const formatObject = (o, model, config) => span("",
	"{",
	["ol", { style: styles.list }, ...Object.keys(o).map(prop =>
		["li", { style: styles.listItem }, span(styles.property, prop), ": ", format$1(o[prop], config)])
	],
	"}"
);

const formatModel = model => {
	const
		cfg = { isModelDefinition: true },
		def = model.definition,
		formatList = (list, map) => list.flatMap(e => [map(e), ", "]).slice(0, -1);
	let parts = [];

	if (is(BasicModel, model)) parts = [format$1(def, cfg)];
	if (is(ArrayModel, model)) parts = ["Array of ", format$1(def, cfg)];
	if (is(SetModel, model)) parts = ["Set of ", format$1(def, cfg)];
	if (is(MapModel, model)) parts = ["Map of ", format$1(def.key, cfg), " : ", format$1(def.value, cfg)];
	if (is(FunctionModel, model)) {
		parts = ["Function(", ...formatList(def.arguments, arg => format$1(arg, cfg)), ")"];
		if ("return" in def) parts.push(" => ", format$1(def.return, cfg));
	}

	if (model.assertions.length > 0) {
		parts.push("\n(assertions: ", ...formatList(model.assertions, f => ["object", { object: f }]), ")");
	}

	return span(styles.model, ...parts)
};

const ModelFormatter = {
	header(x, config = {}) {
		if (x === Any)
			return span(styles.model, "Any")

		if (is(Any.remaining, x))
			return span(styles.model, "...", format$1(x.definition, { isModelDefinition: true }))

		if (is(ObjectModel, x))
			return span(styles.model, x.name)

		if (is(Model, x)) {
			return formatModel(x)
		}

		if (config.isModelDefinition && isPlainObject(x))
			return format$1(x, config)

		return null;
	},
	hasBody(x) {
		return is(ObjectModel, x)
	},
	body(model) {
		return span("",
			"{",
			["ol", { style: styles.list }, ...Object.keys(model.definition).map(prop => {
				const isPrivate = model.conventionForPrivate(prop);
				const isConstant = model.conventionForConstant(prop);
				const hasDefault = model.default && has(model.default, prop);
				let style = styles.property;

				if (isPrivate) {
					style = isConstant ? styles.privateConstant : styles.private;
				} else if (isConstant) {
					style = styles.constant;
				}

				return ["li", { style: styles.listItem },
					span(style, prop), ": ", format$1(model.definition[prop], { isModelDefinition: true }),
					hasDefault ? span(styles.proto, " = ", format$1(model.default[prop])) : ""
				]
			})],
			"}"
		)
	}
};

const ModelInstanceFormatter = {
	header(x, config = {}) {
		if (config.isInstanceProperty && isPlainObject(x)) {
			return format$1(x, config)
		}

		const model = getModel(x);
		if (is(Model, model)) {
			const parts = is(ObjectModel, model) ? [model.name] : [["object", { object: x[_original] }], ` (${model.name})`];
			return span(styles.instance, ...parts)
		}

		return null;
	},
	hasBody(x) {
		return x && is(ObjectModel, getModel(x))
	},
	body(x) {
		const model = getModel(x);
		const o = x[_original] || x;
		return span("",
			"{",
			[
				"ol",
				{ style: styles.list },
				...Object.keys(o).map(prop => {
					const isPrivate = model.conventionForPrivate(prop);
					const isConstant = model.conventionForConstant(prop);
					const isDeclared = prop in model.definition;
					let style = styles.property;

					if (!isDeclared) {
						style = styles.undeclared;
					} else if (isPrivate) {
						style = isConstant ? styles.privateConstant : styles.private;
					} else if (isConstant) {
						style = styles.constant;
					}

					return ["li", { style: styles.listItem },
						span(style, prop), ": ", format$1(o[prop], { isInstanceProperty: true })
					]
				}),
				["li", { style: styles.listItem },
					span(styles.proto, "__proto__", ": ", ["object", { object: getProto(x) }])
				]
			],
			"}"
		)
	}
};

if (typeof window !== "undefined") {
	window.devtoolsFormatters = (window.devtoolsFormatters || [])
		.concat(ModelFormatter, ModelInstanceFormatter);
}


//# sourceMappingURL=object-model.js.map


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isPlainObject */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SealedModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Vector3Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Vector2Model; });
/* harmony import */ var objectmodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* eslint-disable new-cap, no-console */

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types */
 // Fixed example:
// https://github.com/sylvainpolletvillard/ObjectModel/blob/1a1bfb02a26075eafc1ca00cf91dda9af019f389/docs/examples/sealed.js

const isPlainObject = val => {
  return Boolean(val) && typeof val === 'object' && Object.getPrototypeOf(val) === Object.prototype;
};
const SealedModel = options => {
  const model = Object(objectmodel__WEBPACK_IMPORTED_MODULE_0__[/* ObjectModel */ "c"])(options); // @ts-ignore

  model.sealed = true;

  model.extend = () => {
    throw new Error('Sealed models cannot be extended');
  };

  const checkUndeclaredProps = (obj, definition, undeclaredProps, path) => {
    Object.keys(obj).forEach(key => {
      const val = obj[key];
      const subpath = String(path ? path + '.' + key : key);

      if (!Object.prototype.hasOwnProperty.call(definition, key)) {
        undeclaredProps.push(subpath);
      } else if (isPlainObject(val) && isPlainObject(definition[key])) {
        checkUndeclaredProps(val, definition[key], undeclaredProps, subpath);
      }
    });
  };

  function hasNoUndeclaredProps(obj) {
    // @ts-ignore
    if (!model.sealed) {
      return true;
    }

    const undeclaredProps = [];
    checkUndeclaredProps(obj, this.definition, undeclaredProps);
    return !undeclaredProps.length;
  }

  const assertMessage = undeclaredProps => {
    return `Undeclared properties in the sealed model definition: ${undeclaredProps}`;
  };

  return model.assert(hasNoUndeclaredProps, assertMessage);
};
const Vector3Model = SealedModel({
  x: Number,
  y: Number,
  z: Number
});
const Vector2Model = SealedModel({
  x: Number,
  y: Number
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toTitleCase; });
function toTitleCase(s) {
  return (s[0] || '').toUpperCase() + s.slice(1);
}

/***/ }),
/* 12 */,
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Event; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module @wgetemp/event
 */

/**
 * @example
 * const event = new Event();
 *
 * const handler = (...args) => {
 *     console.log(`event happened with args: ${args.join(', ')}`);
 * };
 * event.subscribe(handler)
 *
 * event.emit(1, 2, 3);
 * // => event happened with args: 1, 2, 3
 *
 * event.unsubscribe(handler);
 */
class Event {
  constructor() {
    this._handlers = new Map();
  }
  /**
   * @summary Subscribe handler function to event.
   * @param {function} handler Handler function.
   * @param {object} [opts={}] Options.
   * @param {boolean} [opts.once=false] Automatically unsubscribe after first emission.
   */


  subscribe(handler, {
    once = false
  } = {}) {
    this._handlers.set(handler, once);
  }
  /**
   * @summary Unsubscribe handler function from event.
   * @param {function} handler Handler function.
   */


  unsubscribe(handler) {
    this._handlers.delete(handler);
  }
  /**
   * @summary Unsubscribe all handler functions from event.
   */


  unsubscribeAll() {
    this._handlers.clear();
  }
  /**
   * @summary Emit event with given arguments.
   * @desc Arguments are shared between subscribed handlers. Exceptions
   *     thrown by handlers are caught, logged to console, and discarded.
   * @param {...any} args Arguments.
   * @returns {boolean} Whether the event has been received by some handler.
   */


  emit(...args) {
    const handlers = this._handlers;
    const isReceived = handlers.size > 0;

    for (const _ref of handlers) {
      var _ref2 = _slicedToArray(_ref, 2);

      const handler = _ref2[0];
      const once = _ref2[1];

      if (once) {
        handlers.delete(handler);
      }

      try {
        handler(...args);
      } catch (error) {
        console.error(error);
      }
    }

    return isReceived;
  }

}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BatchMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IndustrialDotScene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return createImageFromBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return IndustrialRenderable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return load; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getReallocationStrategyByBatchSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return UniqueNameGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return adjustInternalFormat; });
/* harmony import */ var _wge_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _wgetemp_containers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(395);
/* harmony import */ var _wgetemp_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




// Make delete do nothing to avoid clearing this map in addInstance method
// Clear this map manually at the end instead
class BatchMap extends _wgetemp_containers__WEBPACK_IMPORTED_MODULE_1__[/* TupleMap */ "a"] {
  delete() {// Do nothing
  }

}
class IndustrialDotScene extends _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* DotScene */ "q"] {
  addInstance(instance, worldMatrix) {
    instance.scene = this;
    super.addInstance(instance, worldMatrix);
  }

  deleteInstance(instance) {
    instance.scene = null;
    super.deleteInstance(instance);
  }

}
async function createImageFromBytes(bytes, mimeType) {
  const blob = new Blob([bytes], {
    type: mimeType
  });
  const url = URL.createObjectURL(blob);

  try {
    return await new _wgetemp_loader__WEBPACK_IMPORTED_MODULE_2__[/* Loader */ "a"]().load(url, {
      type: Image
    });
  } finally {
    URL.revokeObjectURL(url);
  }
}
class IndustrialRenderable extends _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* Renderable */ "V"] {
  constructor(geometry, material, externalId = -1) {
    super(geometry, material);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "externalId", void 0);

    _defineProperty(this, "isSprite", false);

    this.scene = null;
    this.externalId = externalId;
  }

  getScene() {
    if (!this.scene) {
      throw new Error(`Element "${this.externalId}" doesn't included to scene`);
    }

    return this.scene;
  }

  clone() {
    const clone = new IndustrialRenderable(this.geometry, this.material);
    clone.scene = this.scene;
    clone.externalId = this.externalId;
    return clone;
  }

} // Using XMLHttpRequest instead of fetch because of more stable work with big json on mobiles (error "Aw, Snap")

async function load(src, type) {
  // eslint-disable-line @typescript-eslint/ban-types
  return new Promise((response, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.responseType = type;
    xhr.open('GET', src, true);

    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        response(xhr.response);
      } else {
        reject(new Error(`Request "${src}" error, status ${xhr.status}`));
      }
    };

    xhr.onerror = error => reject(error);

    xhr.send(null);
  });
}
async function loadImage(src) {
  return new Promise((resolve, reject) => {
    const image = new Image();

    image.onload = () => {
      resolve(image);
    };

    image.onerror = reject;
    image.src = src;
  });
}
function getReallocationStrategyByBatchSize(batchInstanceCount) {
  return capacity => capacity + batchInstanceCount;
}
class UniqueNameGenerator {
  constructor() {
    _defineProperty(this, "_nameSet", new Set());
  }

  get(name) {
    let it = 0;
    let tempName = name;

    while (this._nameSet.has(tempName)) {
      tempName = name + '.' + it;
      it++;
    }

    this._nameSet.add(tempName);

    return tempName;
  }

  clear() {
    this._nameSet.clear();
  }

}
function adjustInternalFormat(textureProperties) {
  if (textureProperties === null) {
    return;
  }

  const texture = textureProperties.texture;

  switch (texture.format) {
    // eslint-disable-line
    case _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* PixelDataFormat */ "N"].RGB:
      texture.internalFormat = _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* InternalFormat */ "v"].SRGB8;
      break;

    case _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* PixelDataFormat */ "N"].RGBA:
      texture.internalFormat = _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* InternalFormat */ "v"].SRGB8_ALPHA8;
      break;
  }
}

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export normalizeSearch */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return waitPreviousExecution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cleanObject; });
/* unused harmony export deprecated */
/* unused harmony export hidden */
/* unused harmony export enumerable */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return throwDueToModelLoad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getImageFromCanvas; });
/* eslint-disable @typescript-eslint/no-explicit-any */
const normalizeSearch = searchParam => {
  if (typeof searchParam === 'string') {
    return {
      name: searchParam
    };
  }

  return searchParam;
};
function waitPreviousExecution(ctx, functionName, descriptor) {
  let executing = Promise.resolve();
  const originalMethod = descriptor.value;

  descriptor.value = function (...args) {
    executing = executing.catch(() => {
      /* */
    }).then(() => originalMethod.apply(this, args));
    return executing;
  };
}
function cleanObject(object) {
  for (const key in object) {
    if (object[key] === undefined) {
      delete object[key];
    }
  }

  return object;
} // decorator for marking props and methods as deprecated

function deprecated(additionalNotes = '') {
  return function (target, name, descriptor) {
    let targetName = target.name || target.constructor.name;

    if (targetName === 'Object') {
      targetName = '';
    }

    const message = [`[WARN DEPRECATION] Property ${name} of ${targetName} is deprecated and will be deleted within next major version.`, additionalNotes];

    if (!descriptor) {
      return;
    }

    if (descriptor.get) {
      const getter = descriptor.get;

      descriptor.get = function () {
        console.warn(...message);
        return getter();
      };
    }

    if (descriptor.set) {
      const setter = descriptor.set;

      descriptor.set = function (v) {
        console.warn(...message);
        return setter(v);
      };
    }

    if (descriptor.initializer) {
      const initializer = descriptor.initializer;

      descriptor.initializer = function () {
        console.warn(...message);
        return initializer();
      };
    }

    if (typeof descriptor.value === 'function') {
      const valueFunction = descriptor.value;

      descriptor.value = function (...args) {
        console.warn(...message);
        return valueFunction(...args);
      };
    } else if ('value' in descriptor) {
      console.warn(...message);
    }
  };
}
function hidden(target, name, descriptor) {
  if (!descriptor) {
    return;
  }

  descriptor.enumerable = false;
}
function enumerable(target, name, descriptor) {
  if (!descriptor) {
    return;
  }

  descriptor.enumerable = true;
}
const throwDueToModelLoad = () => {
  throw new Error('Cannot call this method until model hasn\'t loaded');
};
const getImageFromCanvas = (() => {
  const canvas2D = document.createElement('canvas');
  const ctx = canvas2D.getContext('2d');
  return (canvas, pixelRatio = 1, options = {}) => {
    if (!ctx) {
      throw new Error('Invalid canvas 3d context');
    } // WARN: clientSize becomes zero if parent DOM is invisible (display: none)
    // const { clientWidth, clientHeight } = canvas; // not correct


    const clientWidth = canvas.width / pixelRatio;
    const clientHeight = canvas.height / pixelRatio;
    const {
      fillColor = 'ffffff'
    } = options;
    let {
      x = 0,
      y = 0,
      width = clientWidth,
      height = clientHeight
    } = options;
    x = Math.max(0, x);
    y = Math.max(0, y);

    if (width + x > clientWidth) {
      width = clientWidth - x;
    }

    if (height + y > clientHeight) {
      height = clientHeight - y;
    }

    canvas2D.width = width;
    canvas2D.height = height;
    ctx.fillStyle = '#' + fillColor;
    ctx.clearRect(0, 0, width, height);
    ctx.fillRect(0, 0, width, height);
    const srcX = x * pixelRatio;
    const srcY = y * pixelRatio;
    const srcWidth = width * pixelRatio;
    const srcHeight = height * pixelRatio;
    ctx.drawImage(canvas, srcX, srcY, srcWidth, srcHeight, 0, 0, width, height);
    return canvas2D.toDataURL();
  };
})();

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return multiplyScalar; });
/* unused harmony export divideScalar */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return normalize; });
/* unused harmony export clone */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return add; });
/* unused harmony export dot */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return distance; });
// TODO Use @webgears-app/math ?
const tempVec2 = {
  x: 0,
  y: 0
};
function length(v) {
  return Math.sqrt(v.x ** 2 + v.y ** 2);
}
function multiplyScalar(v, scalar) {
  v.x *= scalar;
  v.y *= scalar;
  return v;
}
function divideScalar(v, scalar) {
  return multiplyScalar(v, 1 / scalar);
}
function normalize(v) {
  return divideScalar(v, length(v) || 1);
}
function clone(v) {
  return {
    x: v.x,
    y: v.y
  };
}
function sub(v1, v2, dest = {
  x: 0,
  y: 0
}) {
  dest.x = v1.x - v2.x;
  dest.y = v1.y - v2.y;
  return dest;
}
function add(v1, v2, dest = {
  x: 0,
  y: 0
}) {
  dest.x = v1.x + v2.x;
  dest.y = v1.y + v2.y;
  return dest;
}
function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}
function cross(v1, v2) {
  return v1.x * v2.y - v1.y * v2.x;
}
function distance(v1, v2) {
  return length(sub(v1, v2, tempVec2));
}

/***/ }),
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Loader; });
/* harmony import */ var _wgetemp_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/**
 * @module @wgetemp/loader
 */

/**
 * @class module:@wgetemp/loader.Loader.Progress
 * @summary Progress of loading process.
 * @hideconstructor
 */

class Progress {
  constructor() {
    this._current = 0;
    this._total = 0;
    this._inexactCount = 0;
    Object.defineProperties(this, {
      /**
       * @callback module:@wgetemp/loader.Loader.Progress.ChangeEventSignature
       */

      /**
       * @var module:@wgetemp/loader.Loader.Progress#onChange
       * @summary Progress changed.
       * @type {module:@wgetemp/event.Event.<module:@wgetemp/loader.Loader.Progress.ChangeEventSignature>}
       * @readonly
       */
      onChange: {
        value: new _wgetemp_event__WEBPACK_IMPORTED_MODULE_0__[/* Event */ "a"]()
      }
    });
  }
  /**
   * @var module:@wgetemp/loader.Loader.Progress#current
   * @summary This many bytes have been loaded by owner loader, including
   *     child loaders.
   * @type {number}
   * @readonly
   */


  get current() {
    return this._current;
  }
  /**
   * @var module:@wgetemp/loader.Loader.Progress#total
   * @summary At least this many bytes are expected to be loaded by owner
   *     loader (including child loaders) when all initiated loads complete.
   * @type {number}
   * @readonly
   */


  get total() {
    return this._total;
  }
  /**
   * @var module:@wgetemp/loader.Loader.Progress#isExact
   * @summary Whether {@link module:@wgetemp/loader.Loader.Progress#total} is
   *     exact rather than a least-estimate.
   * @desc This can happend when exact total load size is not known (e.g.
   *     there is no Content-Length header in HTTP response).
   * @type {boolean}
   * @readonly
   */


  get isExact() {
    return this._inexactCount === 0;
  }

}
/**
 * @class module:@wgetemp/loader.Loader.Cancelled
 * @summary Thrown when load is cancelled, whether due to calling
 *     {@link module:@wgetemp/loader.Loader#cancel} or other reasions.
 * @extends Error
 * @param {string} url Url that was being loaded.
 */


const Cancelled = (() => {
  class Cancelled extends Error {
    constructor(url) {
      super();
      Object.defineProperties(this, {
        /**
         * @var module:@wgetemp/loader.Loader.Cancelled#url
         * @summary Url that was being loaded.
         * @type {string}
         * @readonly
         */
        url: {
          enumerable: true,
          value: url
        }
      });
    }
    /**
     * @var module:@wgetemp/loader.Loader.Cancelled#message
     * @summary Error message.
     * @type {string}
     * @readonly
     */


    get message() {
      return `cancelled HTTP GET ${this.url}`;
    }

  }

  Object.defineProperties(Cancelled.prototype, {
    /**
     * @var module:@wgetemp/loader.Loader.Cancelled#name
     * @summary Error name.
     * @type {string}
     * @readonly
     */
    name: {
      value: Cancelled.name
    }
  });
  return Cancelled;
})();
/**
 * @class module:@wgetemp/loader.Loader.Failed
 * @summary Thrown when load failed, for reasons other than cancelation.
 * @desc HTTP response codes other outside of [200..299] are considered
 *     failures.
 * @extends Error
 * @param {string} url Url that was being loaded.
 * @param {?number} [status=null] HTTP status code, if any.
 */


const Failed = (() => {
  class Failed extends Error {
    constructor(url, status = null) {
      super();
      Object.defineProperties(this, {
        /**
         * @var module:@wgetemp/loader.Loader.Failed#url
         * @summary Url that was being loaded.
         * @type {string}
         * @readonly
         */
        url: {
          enumerable: true,
          value: url
        },

        /**
         * @var module:@wgetemp/loader.Loader.Failed#status
         * @summary HTTP status code, if any.
         * @type {?number}
         * @readonly
         */
        status: {
          enumerable: true,
          value: status
        }
      });
    }
    /**
     * @var module:@wgetemp/loader.Loader.Failed#message
     * @summary Error message.
     * @type {string}
     * @readonly
     */


    get message() {
      if (this.status === null) {
        return `HTTP GET ${this.url} failed`;
      }

      return `HTTP GET ${this.url} returned status ${this.status}`;
    }

  }

  Object.defineProperties(Failed.prototype, {
    /**
     * @var module:@wgetemp/loader.Loader.Failed#name
     * @summary Error name.
     * @type {string}
     * @readonly
     */
    name: {
      value: Failed.name
    }
  });
  return Failed;
})();

function isTypedArray(type) {
  return Object.getPrototypeOf(type) === Object.getPrototypeOf(Int8Array);
}

function setResponseType(xhr, type) {
  if (type === String) {
    xhr.responseType = 'text';
  } else if (type === ArrayBuffer || isTypedArray(type) || type === DataView) {
    xhr.responseType = 'arraybuffer';
  } else if (type === Blob || type === Image || type === HTMLImageElement) {
    xhr.responseType = 'blob';
  } else if (type === HTMLDocument) {
    xhr.responseType = 'document';
    xhr.overrideMimeType('text/html');
  } else if (type === XMLDocument) {
    xhr.responseType = 'document';
    xhr.overrideMimeType('text/xml');
  } else if (type === Object) {
    xhr.responseType = 'json';
  } else {
    if (false) {}
  }
}

async function castResponse(response, type) {
  if (isTypedArray(type) || type === DataView) {
    return new type(response);
  }

  if (type === Image || type === HTMLImageElement) {
    const url = URL.createObjectURL(response);

    try {
      const image = new Image();
      return await new Promise((resolve, reject) => {
        const onLoad = () => {
          unsubscribe();
          resolve(image);
        };

        image.addEventListener('load', onLoad);

        const onAbort = () => {
          unsubscribe();
          reject(new Cancelled(url));
        };

        image.addEventListener('abort', onAbort);

        const onError = () => {
          unsubscribe();
          reject(new Failed(url));
        };

        image.addEventListener('error', onError);

        const unsubscribe = () => {
          image.removeEventListener('load', onLoad);
          image.removeEventListener('abort', onAbort);
          image.removeEventListener('error', onError);
        };

        image.src = url;
      });
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  return response;
}

const abortedXhrs = new WeakSet();
/**
 * @class module:@wgetemp/loader.Loader
 * @summary Resource loader.
 * @param {object} [opts={}] Options.
 * @param {?module:@wgetemp/loader.Loader} [opts.parent=null] Parent loader. See
 *     {@link module:@wgetemp/loader.Loader#parent}.
 * @param {string} [opts.baseUrl='.'] Base url, against which all relative
 *     resource urls and child loaders' relative base urls are specified. See
 *     {@link module:@wgetemp/loader.Loader#baseUrl}.
 * @param {Function} [opts.type=opts.parent ? opts.parent.type : Uint8Array]
 *     Resource type loaded by default. See
 *     {@link module:@wgetemp/loader.Loader#type}.
 * @example
 * const loader = new Loader({ baseUrl: 'assets/' });
 * const imageLoader = loader.createChild({ baseUrl: 'images/', type: Image });
 * loader.progress.onChange.subscribe(() => {
 *     console.log(`progress: ${loader.progress.current}/${loader.progress.total}`);
 * });
 * const [buffer, image1, image2, image3, image4] = await Promise.all([
 *     loader.load('thing.dat'),
 *     imageLoader.load('image1.png'),
 *     imageLoader.load('image2.png'),
 *     imageLoader.load('image3.png'),
 *     loader.load('../otherAssets/image4.jpeg', { type: Image }),
 * ]);
 * console.log('complete');
 */

const Loader = (() => {
  class Loader {
    constructor({
      parent = null,
      baseUrl = '.',
      type = parent ? parent.type : Uint8Array
    } = {}) {
      Object.defineProperties(this, {
        parent: {
          enumerable: true,
          value: parent
        }
      });
      this.baseUrl = baseUrl;
      this.type = type;
      Object.defineProperties(this, {
        progress: {
          enumerable: true,
          value: new Progress()
        }
      });
      this._xhrs = new Set();
    }
    /**
     * @var module:@wgetemp/loader.Loader#parent
     * @summary Parent loader, if any.
     * @desc When `this.parent` is not null, `this` is a child of
     *     `this.parent`. A loader's progress includes the progress of all
     *     its children. Cancelling a loader also cancel all its children.
     *     This mechanism is useful for loading resources that reference
     *     other resources.
     * @type {?module:@wgetemp/loader.Loader}
     * @readonly
     */

    /**
     * @var module:@wgetemp/loader.Loader#baseUrl
     * @summary Base url, against which all relative resource urls and
     *     child loaders' relative base urls are specified.
     * @desc It is always an absolute url when reading, but a relative
     *     url can be assigned, in which case it is resolved against
     *     `this.parent.baseUrl` if `this.parent` is not null,
     *     and against `window.location.href` otherwise. Url's pathname must
     *     end with '/' if it referes to a directory (see semantics of
     *     {@link URL} contructor).
     * @type {string}
     */


    get baseUrl() {
      return this._baseUrl;
    }

    set baseUrl(baseUrl) {
      const parent = this.parent;
      const baseBaseUrl = parent ? parent.baseUrl : location.href;
      this._baseUrl = new URL(baseUrl, baseBaseUrl).href;
    }
    /**
     * @var module:@wgetemp/loader.Loader#type
     * @summary Resource type loaded by default.
     * @desc Supported values are:
     * - {@link String}
     * - {@link ArrayBuffer}
     * - {@link TypedArray} (any)
     * - {@link DataView}
     * - {@link Blob}
     * - {@link Image}
     * - {@link HTMLImageElement}
     * - {@link HTMLDocument}
     * - {@link XMLDocument}
     * - {@link Object} (denotes parsed JSON)
     * @type {function}
     */

    /**
     * @var module:@wgetemp/loader.Loader#progress
     * @summary Loading progress.
     * @type {module:@wgetemp/loader.Loader.Progress}
     */

    /**
     * @function module:@wgetemp/loader.Loader#createChild
     * @summary Create a child loader (see
     *     {@link module:@wgetemp/loader.Loader#parent}).
     * @param {object} [opts={}] Options. Forwarded to
     *     {@link module:@wgetemp/loader.Loader} constructor, except
     *     `opts.parent` is replaced with `this`.
     * @returns {module:@wgetemp/loader.Loader} Child loader of this loader.
     */


    createChild(opts = {}) {
      opts = Object.assign({}, opts);
      opts.parent = this;
      return new this.constructor(opts);
    }
    /**
     * @function module:@wgetemp/loader.Loader#load
     * @summary Load a resource.
     * @param {string} url Resource url. If relative, resolved against
     *     `opts.baseUrl`.
     * @param {object} [opts={}] Options.
     * @param {string} [opts.baseUrl='.'] Base url to resolve a relative
     *     `url` against. If itself relative, first resolved against
     *     `this.baseUrl`.
     * @param {function} [opts.type=this.type] Resource type (see
     *     {@link module:@wgetemp/loader.Loader#type}).
     * @returns {opts.type} Loaded resource. It will have an injected
     *     property with key {@link module:@wgetemp/loader.Loader.mimeType},
     *     that will have a string value indicationg MIME type supplied by
     *     the server (via Content-Type header) or null.
     * @async
     */


    load(url, {
      baseUrl = '.',
      type = this.type
    } = {}) {
      return new Promise((resolve, reject) => {
        baseUrl = new URL(baseUrl, this.baseUrl).href;
        url = new URL(url, baseUrl).href;
        const xhr = new XMLHttpRequest();
        let currentProgress = 0;
        let totalProgress = 0;
        let progressIsExact = true;

        const onProgress = ({
          loaded: newCurrent,
          total: newTotal,
          lengthComputable: newIsExact
        }) => {
          for (let loader = this; loader; loader = loader.parent) {
            const _loader = loader,
                  progress = _loader.progress;
            progress._current -= currentProgress;

            if (progressIsExact) {
              progress._total -= totalProgress;
            } else {
              progress._total -= currentProgress;
              --progress._inexactCount;
            }

            progress._current += newCurrent;

            if (newIsExact) {
              progress._total += newTotal;
            } else {
              progress._total += newCurrent;
              ++progress._inexactCount;
            }

            progress.onChange.emit();
          }

          currentProgress = newCurrent;
          totalProgress = newTotal;
          progressIsExact = newIsExact;
        };

        xhr.addEventListener('progress', onProgress);

        const onLoad = event => {
          onProgress(event);
          unsubscribe();
          (async () => {
            if (xhr.status < 200 || xhr.status > 299) {
              throw new Failed(url, xhr.status);
            }

            const data = await castResponse(xhr.response, type);

            if (data !== undefined) {
              data[Loader.mimeType] = xhr.getResponseHeader('Content-Type');
            }

            return data;
          })().then(resolve, reject);
        };

        xhr.addEventListener('load', onLoad);

        const onAbort = () => {
          unsubscribe();
          reject(new Cancelled(url));
        };

        xhr.addEventListener('abort', onAbort);

        const onError = () => {
          unsubscribe();
          reject(new Failed(url));
        };

        xhr.addEventListener('error', onError);

        const unsubscribe = () => {
          for (let loader = this; loader; loader = loader.parent) {
            loader._xhrs.delete(xhr);
          }

          xhr.removeEventListener('progress', onProgress);
          xhr.removeEventListener('load', onLoad);
          xhr.removeEventListener('abort', onAbort);
          xhr.removeEventListener('error', onError);
        };

        setResponseType(xhr, type);
        xhr.open('GET', url);
        xhr.send();

        for (let loader = this; loader; loader = loader.parent) {
          loader._xhrs.add(xhr);
        }
      });
    }

    cancel() {
      for (const xhr of this._xhrs) {
        if (abortedXhrs.has(xhr)) {
          continue;
        }

        xhr.abort();
      }
    }

  }

  Object.defineProperties(Loader, {
    Progress: {
      value: Progress
    },
    Cancelled: {
      value: Cancelled
    },
    Failed: {
      value: Failed
    },

    /**
     * @var module:@wgetemp/loader.Loader.mimeType
     * @summary Resource MIME type property key.
     * @desc A property with this key is injected into laoded resources and
     *     indicates setver-supplied MIME type of the resource.
     * @type {Symbol}
     */
    mimeType: {
      enumerable: true,
      value: Symbol('module:@wgetemp/loader.Loader.mimeType')
    }
  });
  return Loader;
})();

/***/ }),
/* 21 */,
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getWorldMatrixByRenderable; });
/* unused harmony export setRenderableMatrix */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getMatrixFromTransforms; });
/* harmony import */ var _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

function getWorldMatrixByRenderable(renderable, manager, matrix) {
  const {
    instanceId,
    instanceIndex
  } = renderable;
  const batchRenderable = manager.getInstanceRenderable(instanceId);

  if (!batchRenderable) {
    return false;
  }

  const {
    batchIdx
  } = batchRenderable;
  const globalIndex = manager.getInstanceGlobalIndex(batchIdx, instanceIndex);
  manager.readWorldTransform(matrix, globalIndex);
  return true;
}
const worldBoundingBox = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Box */ "e"]();
const center = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]();

function createInstance(manager, renderable, matrix) {
  manager.addInstance(renderable);
  manager.setInstanceVisibility(renderable, true, true);
  const batchRenderable = manager.getInstanceRenderable(renderable.instanceId);
  const {
    batchIdx
  } = batchRenderable;
  const globalIndex = manager.getInstanceGlobalIndex(batchIdx, renderable.instanceIndex);
  worldBoundingBox.copy(renderable.geometry.boundingBox).applyAffineMatrix(matrix);
  worldBoundingBox.centerPaste(center);
  manager.storeCenter(center, globalIndex);
}

function setRenderableMatrix(manager, renderable, matrix) {
  let batchRenderable = manager.getInstanceRenderable(renderable.instanceId);

  if (!batchRenderable) {
    createInstance(manager, renderable, matrix);
    batchRenderable = manager.getInstanceRenderable(renderable.instanceId);
  }

  if (!batchRenderable) {
    throw new Error('BatchRenderable not exist');
  }

  const {
    batchIdx
  } = batchRenderable;
  const globalIndex = manager.getInstanceGlobalIndex(batchIdx, renderable.instanceIndex);
  manager.storeWorldTransform(matrix, globalIndex);
}
function getMatrixFromTransforms(position, orientation, scale, matrix = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* AffineMatrix3 */ "b"]()) {
  matrix.set(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0);
  matrix.scale(scale);
  matrix.applyQuaternion(orientation);
  matrix.translationCopy(position);
  return matrix;
}

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ materials_IndustrialPbrMeshMaterial; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ materials_IndustrialUnlitMeshMaterial; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ materials_IndustrialMaterialFactory; });

// NAMESPACE OBJECT: ./src/core/resources/materials/chunks/index.ts
var chunks_namespaceObject = {};
__webpack_require__.r(chunks_namespaceObject);
__webpack_require__.d(chunks_namespaceObject, "worldSpaceParamsVert", function() { return worldSpaceParamsVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "worldSpaceParamsFrag", function() { return worldSpaceParamsFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "worldSpaceVert", function() { return worldSpaceVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "customColorParamsVert", function() { return customColorParamsVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "customColorParamsFrag", function() { return customColorParamsFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "customColorVert", function() { return customColorVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "customColorFrag", function() { return customColorFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "ignoreRaycastParamsVert", function() { return ignoreRaycastParamsVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "ignoreRaycastParamsFrag", function() { return ignoreRaycastParamsFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "ignoreRaycastVert", function() { return ignoreRaycastVert_default.a; });
__webpack_require__.d(chunks_namespaceObject, "ignoreRaycastFrag", function() { return ignoreRaycastFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "sectionBoxFrag", function() { return sectionBoxFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "sectionBoxParamsFrag", function() { return sectionBoxParamsFrag_default.a; });
__webpack_require__.d(chunks_namespaceObject, "normalPackVert", function() { return normalPackVert_default.a; });

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var lib = __webpack_require__(0);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// EXTERNAL MODULE: ./src/global-helpers/index.ts + 13 modules
var global_helpers = __webpack_require__(6);

// EXTERNAL MODULE: ./src/core/resources/materials/shaders/pbr.vert
var pbr = __webpack_require__(234);
var pbr_default = /*#__PURE__*/__webpack_require__.n(pbr);

// EXTERNAL MODULE: ./src/core/resources/materials/shaders/pbr.frag
var shaders_pbr = __webpack_require__(235);
var shaders_pbr_default = /*#__PURE__*/__webpack_require__.n(shaders_pbr);

// EXTERNAL MODULE: ./src/core/resources/materials/shaders/unlit.frag
var unlit = __webpack_require__(236);
var unlit_default = /*#__PURE__*/__webpack_require__.n(unlit);

// EXTERNAL MODULE: ./src/core/resources/materials/shaders/unlit.vert
var shaders_unlit = __webpack_require__(237);
var shaders_unlit_default = /*#__PURE__*/__webpack_require__.n(shaders_unlit);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/worldSpaceParamsVert.glsl
var worldSpaceParamsVert = __webpack_require__(117);
var worldSpaceParamsVert_default = /*#__PURE__*/__webpack_require__.n(worldSpaceParamsVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/worldSpaceParamsFrag.glsl
var worldSpaceParamsFrag = __webpack_require__(118);
var worldSpaceParamsFrag_default = /*#__PURE__*/__webpack_require__.n(worldSpaceParamsFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/worldSpaceVert.glsl
var worldSpaceVert = __webpack_require__(119);
var worldSpaceVert_default = /*#__PURE__*/__webpack_require__.n(worldSpaceVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/customColorParamsVert.glsl
var customColorParamsVert = __webpack_require__(120);
var customColorParamsVert_default = /*#__PURE__*/__webpack_require__.n(customColorParamsVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/customColorParamsFrag.glsl
var customColorParamsFrag = __webpack_require__(121);
var customColorParamsFrag_default = /*#__PURE__*/__webpack_require__.n(customColorParamsFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/customColorVert.glsl
var customColorVert = __webpack_require__(122);
var customColorVert_default = /*#__PURE__*/__webpack_require__.n(customColorVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/customColorFrag.glsl
var customColorFrag = __webpack_require__(123);
var customColorFrag_default = /*#__PURE__*/__webpack_require__.n(customColorFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/ignoreRaycastParamsVert.glsl
var ignoreRaycastParamsVert = __webpack_require__(124);
var ignoreRaycastParamsVert_default = /*#__PURE__*/__webpack_require__.n(ignoreRaycastParamsVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/ignoreRaycastParamsFrag.glsl
var ignoreRaycastParamsFrag = __webpack_require__(125);
var ignoreRaycastParamsFrag_default = /*#__PURE__*/__webpack_require__.n(ignoreRaycastParamsFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/ignoreRaycastVert.glsl
var ignoreRaycastVert = __webpack_require__(126);
var ignoreRaycastVert_default = /*#__PURE__*/__webpack_require__.n(ignoreRaycastVert);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/ignoreRaycastFrag.glsl
var ignoreRaycastFrag = __webpack_require__(127);
var ignoreRaycastFrag_default = /*#__PURE__*/__webpack_require__.n(ignoreRaycastFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/sectionBoxFrag.glsl
var sectionBoxFrag = __webpack_require__(128);
var sectionBoxFrag_default = /*#__PURE__*/__webpack_require__.n(sectionBoxFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/sectionBoxParamsFrag.glsl
var sectionBoxParamsFrag = __webpack_require__(129);
var sectionBoxParamsFrag_default = /*#__PURE__*/__webpack_require__.n(sectionBoxParamsFrag);

// EXTERNAL MODULE: ./src/core/resources/materials/chunks/normalPackVert.glsl
var normalPackVert = __webpack_require__(130);
var normalPackVert_default = /*#__PURE__*/__webpack_require__.n(normalPackVert);

// CONCATENATED MODULE: ./src/core/resources/materials/chunks/index.ts















// CONCATENATED MODULE: ./src/core/resources/materials/index.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









Object.assign(lib["ab" /* ShaderChunks */], chunks_namespaceObject);

const emptyHandler = () => {
  /* */
};

const globalMaterialState = {
  onApplyMaterial: emptyHandler
};
class materials_IndustrialPbrMeshMaterial extends lib["M" /* PbrMeshMaterial */] {
  constructor(properties) {
    super(properties);

    _defineProperty(this, "boxOccluderMin", void 0);

    _defineProperty(this, "boxOccluderMax", void 0);

    this.boxOccluderMin = new math_lib["n" /* Vector3 */]();
    this.boxOccluderMax = new math_lib["n" /* Vector3 */]();
    this.shaders.name = 'INDUSTRIAL_PBR_MESH_SHADER';
    this.shaders.vertexShader = pbr_default.a;
    this.shaders.fragmentShader = shaders_pbr_default.a;
    this.setSelectionEnabled(true);
  }

  get patched() {
    return true;
  }

  setSelectionEnabled(value) {
    if (value) {
      this.shaders.defines.SELECTION_OVERLAY = '';
    } else {
      delete this.shaders.defines.SELECTION_OVERLAY;
    }
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    super.apply(gl, renderable, state, programs, textures, renderPass);
    const technique = this.getTechnique(renderPass.id);

    if (!technique.program) {
      throw new Error('Program is null');
    }

    const {
      uniforms
    } = technique.program.layout;
    const {
      boxOccluderMin,
      boxOccluderMax
    } = this;
    globalMaterialState.onApplyMaterial(state);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMin', boxOccluderMin);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMax', boxOccluderMax);
  }

}
class materials_IndustrialUnlitMeshMaterial extends lib["lb" /* UnlitMeshMaterial */] {
  constructor(properties) {
    super(properties);

    _defineProperty(this, "boxOccluderMin", void 0);

    _defineProperty(this, "boxOccluderMax", void 0);

    this.boxOccluderMin = new math_lib["n" /* Vector3 */]();
    this.boxOccluderMax = new math_lib["n" /* Vector3 */]();
    this.shaders.name = 'INDUSTRIAL_UNLIT_MESH_SHADER';
    this.shaders.vertexShader = shaders_unlit_default.a;
    this.shaders.fragmentShader = unlit_default.a;
    this.setSelectionEnabled(true);
  }

  get patched() {
    return true;
  }

  setSelectionEnabled(value) {
    if (value) {
      this.shaders.defines.SELECTION_OVERLAY = '';
    } else {
      delete this.shaders.defines.SELECTION_OVERLAY;
    }
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    super.apply(gl, renderable, state, programs, textures, renderPass);
    const technique = this.getTechnique(renderPass.id);

    if (!technique.program) {
      throw new Error('Program is null');
    }

    const {
      uniforms
    } = technique.program.layout;
    const {
      boxOccluderMin,
      boxOccluderMax
    } = this;
    globalMaterialState.onApplyMaterial(state);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMin', boxOccluderMin);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMax', boxOccluderMax);
  }

}
class materials_IndustrialMaterialFactory extends lib["E" /* MaterialFactory */] {
  createPbrMeshMaterial(properties) {
    return new materials_IndustrialPbrMeshMaterial(properties);
  }

  createUnlitMeshMaterial(properties) {
    return new materials_IndustrialUnlitMeshMaterial(properties);
  }

}

_defineProperty(materials_IndustrialMaterialFactory, "globalMaterialState", globalMaterialState);

_defineProperty(materials_IndustrialMaterialFactory, "onApplyMaterial", handler => {
  globalMaterialState.onApplyMaterial = handler || emptyHandler;
});

/***/ }),
/* 24 */,
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ APIValidator; });

// CONCATENATED MODULE: ./src/api/validation/symbol-hack.ts
// Needs for testcafe + object-model to work
const NativeSymbol = window.Symbol;
function returnNativeSymbol() {
  window.Symbol = NativeSymbol;
}
function hackSymbol() {
  console.warn('Symbol hacked!'); // @ts-ignore

  window.Symbol = (name = '') => {
    const key = `Symbol(${name}, ${Math.random()})`;
    return {
      toString: () => key
    };
  };
}

if ('__call$' in window) {
  hackSymbol();
}
// EXTERNAL MODULE: ./node_modules/objectmodel/dist/object-model.js
var object_model = __webpack_require__(9);

// EXTERNAL MODULE: ./src/api/validation/utils.ts
var utils = __webpack_require__(10);

// EXTERNAL MODULE: ./src/api/validation/validator.ts
var validator = __webpack_require__(91);

// CONCATENATED MODULE: ./src/api/validation/index.ts
/* eslint-disable new-cap, import/order */




returnNativeSymbol();
const durationModel = Object(object_model["b" /* BasicModel */])(Number).defaultTo(0);
const ColorModel = Object(object_model["b" /* BasicModel */])(String).assert(color => color.length === 6 && !Number.isNaN(parseInt(color, 16)), 'color format is wrong, please use a HEX string with a length of 6');
const ProgressiveRenderingOptions = Object(utils["a" /* SealedModel */])({
  enabled: [Boolean],
  maxDrawcalls: [Number]
});
const ObjectId = Object(object_model["b" /* BasicModel */])(Number).assert(value => value >= 0 && value < 0xffffff, 'ObjectId is out of [0x000000, 0xffffff) range');
const EdgeGeometryOptions = Object(utils["a" /* SealedModel */])({
  enabled: [Boolean],
  color: [ColorModel] // thresholdAngle: [
  //     BasicModel(Number).assert((a => a >= 0 && a <= 90),
  //         'thresholdAngle must be a number from 0 to 90 degrees')
  // ],
  // excludes: [ArrayModel(BasicModel(String))],
  // includes: [ArrayModel(BasicModel(String))]

});
const setSectionBox = [Object(object_model["b" /* BasicModel */])([Object(utils["a" /* SealedModel */])({
  min: utils["c" /* Vector3Model */],
  max: utils["c" /* Vector3Model */]
}), null, undefined])];
const EnvironmentOptions = Object(utils["a" /* SealedModel */])({
  ibl: Object(utils["a" /* SealedModel */])({
    src: String,
    luminance: Number,
    name: [undefined, String]
  })
});
const GhostModeOptions = Object(utils["a" /* SealedModel */])({
  enabled: [Boolean],
  color: [String],
  opacity: [Number]
});
const CameraOptions = Object(utils["a" /* SealedModel */])({
  fov: [Number],
  aperture: [Number],
  ISO: [Number],
  expComp: [Number],
  shutterSpeed: [Number],
  projectionType: [String]
});
const ControlsOptions = Object(utils["a" /* SealedModel */])({
  enabled: [Boolean],
  keyboard: [Boolean],
  zoom: [undefined, Boolean, Object(utils["a" /* SealedModel */])({
    enabled: [Boolean],
    speed: [Number],
    minDistance: [Number],
    maxDistance: [Number]
  })],
  rotation: [undefined, Boolean, Object(utils["a" /* SealedModel */])({
    enabled: [Boolean],
    speed: [Number],
    minPolarAngle: [Number],
    maxPolarAngle: [Number]
  })],
  panning: [undefined, Boolean, Object(utils["a" /* SealedModel */])({
    enabled: [Boolean],
    speed: [Number]
  })],
  damping: [undefined, Boolean, Object(utils["a" /* SealedModel */])({
    enabled: [Boolean],
    factor: [Number]
  })]
});
const GridOptions = Object(object_model["b" /* BasicModel */])([undefined, Boolean, Object(utils["a" /* SealedModel */])({
  enabled: [undefined, Boolean],
  color: [undefined, ColorModel]
})]);
const AxesColorsOptions = Object(object_model["b" /* BasicModel */])([undefined, Object(utils["a" /* SealedModel */])({
  x: ColorModel,
  y: ColorModel,
  z: ColorModel
})]);
const AntialiasingOptions = Object(object_model["b" /* BasicModel */])([undefined, Object(utils["a" /* SealedModel */])({
  mode: Object(object_model["b" /* BasicModel */])(['NONE', 'FXAA', 'SSAA']),
  pixelRatio: Number
})]);
const NavCubeOptions = Object(utils["a" /* SealedModel */])({
  enabled: [Boolean],
  position: [Object(object_model["b" /* BasicModel */])(['TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', 'BOTTOM_RIGHT'])],
  offset: [utils["b" /* Vector2Model */]],
  size: [Number]
});
const StatsOptions = Object(utils["a" /* SealedModel */])({
  enabled: [undefined, Boolean],
  style: [undefined, Object]
});
const ExperimentalOptions = Object(utils["a" /* SealedModel */])({
  stats: [undefined, Boolean, StatsOptions]
});
const setOptions = [Object(utils["a" /* SealedModel */])({
  environment: [undefined, EnvironmentOptions],
  theme: [undefined, Object(utils["a" /* SealedModel */])({
    background: [undefined, String],
    backgroundColor: [undefined, String],
    backgroundImage: [undefined, String]
  })],
  showHiddenObjects: [undefined, Boolean],
  ghostMode: [undefined, Boolean, GhostModeOptions],
  stagingMemorySize: [undefined, Number],
  progressiveRendering: [undefined, Boolean, 'auto', ProgressiveRenderingOptions],
  edgeGeometry: [undefined, Boolean, EdgeGeometryOptions],
  selectionColor: [undefined, ColorModel],
  selectionMode: [undefined, Object(object_model["b" /* BasicModel */])(['none', 'single', 'multi']).defaultTo('single')],
  experimental: [undefined, ExperimentalOptions],
  cameraControls: [undefined, Boolean, ControlsOptions],
  camera: [undefined, CameraOptions],
  navigationCube: [undefined, Boolean, NavCubeOptions],
  axes: GridOptions,
  grid: GridOptions,
  showOrigin: [undefined, Boolean],
  coordinateSystem: [undefined, 'Y_UP', 'Z_UP'],
  axesColors: AxesColorsOptions,
  antialiasing: [undefined, AntialiasingOptions],
  logs: [undefined, Boolean]
}).as('Object')];
const loadModel = [Object(object_model["b" /* BasicModel */])(String), Object(object_model["b" /* BasicModel */])([undefined, Object(utils["a" /* SealedModel */])({
  progressive: [undefined, Boolean]
})])];
const selectObjects = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(ObjectId), null]).defaultTo(null)];
const moveCameraToObjects = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(ObjectId), null]), durationModel];
const moveCameraToPosition = [Object(utils["a" /* SealedModel */])({
  position: utils["c" /* Vector3Model */],
  target: utils["c" /* Vector3Model */]
}).as('Object'), durationModel];
const colorObjects = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(Object(utils["a" /* SealedModel */])({
  color: ColorModel,
  ids: Object(object_model["a" /* ArrayModel */])(ObjectId)
})), null])];
const FilterOptions = Object(utils["a" /* SealedModel */])({
  iterative: [Boolean],
  blacklist: [Boolean]
});
const filterObjects = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(ObjectId), null]), Object(object_model["b" /* BasicModel */])([FilterOptions, undefined])];
const RangeZeroOne = Object(object_model["b" /* BasicModel */])(Number).assert(v => v >= 0 && v <= 1, 'value must be from 0 to 1');
const RangeMinusOneOne = Object(object_model["b" /* BasicModel */])(Number).assert(v => v >= -1 && v <= 1, 'value must be from -1 to 1');
const Origin2DModel = Object(utils["a" /* SealedModel */])({
  x: RangeZeroOne,
  y: RangeZeroOne
});
const Origin3DModel = Object(utils["a" /* SealedModel */])({
  x: RangeMinusOneOne,
  y: RangeMinusOneOne,
  z: RangeMinusOneOne
});
const setPoints = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(Object(utils["a" /* SealedModel */])({
  id: [ObjectId],
  position: utils["c" /* Vector3Model */],
  image: [String],
  color: [ColorModel],
  colorBlendingMethod: [Object(object_model["b" /* BasicModel */])(['add', 'multiply'])],
  size: [Number],
  origin: [Origin2DModel, Origin3DModel, undefined],
  staticSize: [Boolean],
  interactive: [Boolean],
  overlap: [Boolean]
})), null])];
const setExplosion = [Object(object_model["b" /* BasicModel */])([Object(utils["a" /* SealedModel */])({
  progress: [Number],
  force: [Number],
  center: [utils["c" /* Vector3Model */]]
}), null])];
const registerExtension = [Object(object_model["b" /* BasicModel */])(Function)];
const getDistanceBetween = [Object(object_model["b" /* BasicModel */])(ObjectId), Object(object_model["b" /* BasicModel */])(ObjectId)];
const getScreenPosition = [utils["c" /* Vector3Model */]];
const getScreenshot = [Object(object_model["b" /* BasicModel */])([Object(utils["a" /* SealedModel */])({
  x: [Number],
  y: [Number],
  width: [Number],
  height: [Number],
  fillColor: [ColorModel]
})])];
const getDebugInfo = [Object(object_model["b" /* BasicModel */])(undefined)];
const getContextParams = [Object(object_model["b" /* BasicModel */])([Object(utils["a" /* SealedModel */])({
  drawingBufferWidth: [Number],
  drawingBufferHeight: [Number],
  MAX_TEXTURE_SIZE: [Number]
})])];
const raycastObjects = [Object(object_model["b" /* BasicModel */])([utils["b" /* Vector2Model */]])];
const APIValidator = new validator["a" /* Validator */]({
  setOptions,
  loadModel,
  selectObjects,
  moveCameraToObjects,
  moveCameraToPosition,
  colorObjects,
  filterObjects,
  setPoints,
  setSectionBox,
  setExplosion,
  registerExtension,
  getDistanceBetween,
  getScreenPosition,
  getScreenshot,
  getDebugInfo,
  getContextParams,
  raycastObjects
});

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return wrapPreset; });
// EnvironmentOptions required
function wrapPreset(preset, name) {
  if (window.industrialViewer) {
    if (!window.industrialViewer.presets) {
      window.industrialViewer.presets = {};
    }

    window.industrialViewer.presets[name] = preset;
  }
}

/***/ }),
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ createPlaneMesh; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ createBoxMesh; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ createLine; });

// UNUSED EXPORTS: createSphereMesh, createTorusMesh, createCylinderMesh, createConeMesh, createCircleMesh, createCircleLine

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var lib = __webpack_require__(0);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/plane.js
/* eslint-disable new-cap */


function createPlaneMesh({
  name = 'plane',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  width = 1,
  height = 1,
  widthSegments = 1,
  heightSegments = 1
}) {
  const width_half = width / 2;
  const height_half = height / 2;
  const gridX = Math.floor(widthSegments) || 1;
  const gridY = Math.floor(heightSegments) || 1;
  const gridX1 = gridX + 1;
  const gridY1 = gridY + 1;
  const segment_width = width / gridX;
  const segment_height = height / gridY; // Vertex attribute buffers

  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  const verticesCount = gridX1 * gridY1;
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount); // Generate vertices, normals and uvs

  for (let i = 0, iy = 0; iy < gridY1; ++iy) {
    const y = iy * segment_height - height_half;

    for (let ix = 0; ix < gridX1; ++ix, i += elementsPerVertex) {
      const x = ix * segment_width - width_half;
      vertexView.set([x, -y, 0, 0, 0, 1, ix / gridX, 1 - iy / gridY], i);
    }
  } // Index buffer


  const elementsPerFace = 3 * 2; // Two triangles

  const indexElementsCount = gridX * gridY * elementsPerFace;
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);

  for (let i = 0, iy = 0; iy < gridY; ++iy) {
    for (let ix = 0; ix < gridX; ++ix, i += elementsPerFace) {
      const a = ix + gridX1 * iy;
      const b = ix + gridX1 * (iy + 1);
      const c = ix + 1 + gridX1 * (iy + 1);
      const d = ix + 1 + gridX1 * iy;
      indexView.set([a, b, d, d, b, c], i);
    }
  }

  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.boundingBox.min.set(-width_half, -height_half, -0.1e-4);
  geometry.boundingBox.min.set(width_half, height_half, 0.1e-4);
  geometry.needsUpdateBoundingBox = false;
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  if (elementStaging.empty) {
    indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/box.js
/* eslint-disable new-cap */


function createBoxMesh({
  name = 'box',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  width = 1,
  height = 1,
  depth = 1,
  widthSegments = 1,
  heightSegments = 1,
  depthSegments = 1
}) {
  const w = width || 1;
  const h = height || 1;
  const d = depth || 1;
  const wSegments = Math.floor(widthSegments) || 1;
  const hSegments = Math.floor(heightSegments) || 1;
  const dSegments = Math.floor(depthSegments) || 1;
  const planesParams = [// px
  {
    i0: 2,
    i1: 1,
    i2: 0,
    udir: -1,
    vdir: -1,
    width: d,
    height: h,
    depth: w,
    gridX: dSegments,
    gridY: hSegments
  }, // nx
  {
    i0: 2,
    i1: 1,
    i2: 0,
    udir: 1,
    vdir: -1,
    width: d,
    height: h,
    depth: -w,
    gridX: dSegments,
    gridY: hSegments
  }, // py
  {
    i0: 0,
    i1: 2,
    i2: 1,
    udir: 1,
    vdir: 1,
    width: w,
    height: d,
    depth: h,
    gridX: wSegments,
    gridY: dSegments
  }, // ny
  {
    i0: 0,
    i1: 2,
    i2: 1,
    udir: 1,
    vdir: -1,
    width: w,
    height: d,
    depth: -h,
    gridX: wSegments,
    gridY: dSegments
  }, // pz
  {
    i0: 0,
    i1: 1,
    i2: 2,
    udir: 1,
    vdir: -1,
    width: w,
    height: h,
    depth: d,
    gridX: wSegments,
    gridY: hSegments
  }, // nz
  {
    i0: 0,
    i1: 1,
    i2: 2,
    udir: -1,
    vdir: -1,
    width: w,
    height: h,
    depth: -d,
    gridX: wSegments,
    gridY: hSegments
  }];
  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  let verticesCount = 0;
  const elementsPerFace = 3 * 2; // Two triangles

  let indexElementsCount = 0;
  planesParams.forEach(params => {
    const gridX = params.gridX,
          gridY = params.gridY;
    params.indicesStartIndex = indexElementsCount;
    params.verticesStartIndex = verticesCount * elementsPerVertex;
    indexElementsCount += gridX * gridY * elementsPerFace;
    verticesCount += (gridX + 1) * (gridY + 1);
  });
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);
  let numberOfVertices = 0;

  const buildPlane = ({
    i0,
    i1,
    i2,
    udir,
    vdir,
    width,
    height,
    depth,
    gridX,
    gridY,
    indicesStartIndex,
    verticesStartIndex
  }) => {
    const segmentWidth = width / gridX;
    const segmentHeight = height / gridY;
    const widthHalf = width / 2;
    const heightHalf = height / 2;
    const depthHalf = depth / 2;
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    let vertexCounter = 0;
    const vector = [0, 0, 0]; // generate vertices, normals and uvs

    for (let i = verticesStartIndex, iy = 0; iy < gridY1; ++iy) {
      const y = iy * segmentHeight - heightHalf;

      for (let ix = 0; ix < gridX1; ++ix) {
        const x = ix * segmentWidth - widthHalf; // set values to correct vector component

        vector[i0] = x * udir;
        vector[i1] = y * vdir;
        vector[i2] = depthHalf;
        vertexView.set(vector, i);
        i += 3; // set values to correct vector component

        vector[i0] = 0;
        vector[i1] = 0;
        vector[i2] = depth > 0 ? 1 : -1;
        vertexView.set(vector, i);
        i += 3; // uvs

        vertexView.set([ix / gridX, 1 - iy / gridY], i);
        i += 2; // counters

        ++vertexCounter;
      }
    } // indices
    // 1. you need three indices to draw a single face
    // 2. a single segment consists of two faces
    // 3. so we need to generate six (2 * 3) indices per segment


    for (let i = indicesStartIndex, iy = 0; iy < gridY; ++iy) {
      for (let ix = 0; ix < gridX; ++ix, i += elementsPerFace) {
        const a = numberOfVertices + ix + gridX1 * iy;
        const b = numberOfVertices + ix + gridX1 * (iy + 1);
        const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

        indexView.set([a, b, d, d, b, c], i);
      }
    } // update total number of vertices


    numberOfVertices += vertexCounter;
  };

  planesParams.forEach(params => buildPlane(params));
  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.boundingBox.min.set(-width / 2, -height / 2, -depth / 2);
  geometry.boundingBox.max.set(width / 2, height / 2, depth / 2);
  geometry.needsUpdateBoundingBox = false;
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);
  if (vertexStaging.empty) vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  if (elementStaging.empty) indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}


// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/sphere.js
/* eslint-disable new-cap */



function createSphereMesh({
  name = 'sphere',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  radius = 1,
  widthSegments = 8,
  heightSegments = 6,
  phiStart = 0,
  phiLength = Math.PI * 2,
  thetaStart = 0,
  thetaLength = Math.PI
}) {
  const _radius = radius || 1;

  const _widthSegments = Math.max(3, Math.floor(widthSegments) || 8);

  const _heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

  const thetaEnd = thetaStart + thetaLength;
  const grid = [];
  const vertex = new math_lib["n" /* Vector3 */]();
  const normal = new math_lib["n" /* Vector3 */]();
  let index = 0; // Vertex attribute buffers

  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  const verticesCount = (_heightSegments + 1) * (_widthSegments + 1);
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount); // Generate vertices, normals and uvs

  for (let iy = 0, i = 0; iy <= _heightSegments; ++iy) {
    const verticesRow = [];
    const v = iy / _heightSegments;

    for (let ix = 0; ix <= _widthSegments; ++ix, i += elementsPerVertex) {
      const u = ix / _widthSegments;
      vertex.set(-Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), Math.cos(thetaStart + v * thetaLength), Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength));
      vertex.multiplyNumber(_radius);
      normal.copy(vertex).normalize();
      vertexView.set([vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z, u, 1 - v], i);
      verticesRow.push(index++);
    }

    grid.push(verticesRow);
  } // Index buffer


  const elementsPerFace = 3 * 2; // Two triangles

  const indexElementsCount = _widthSegments * _heightSegments * elementsPerFace;
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);

  for (let i = 0, iy = 0; iy < _heightSegments; ++iy) {
    for (let ix = 0; ix < _widthSegments; ++ix) {
      const a = grid[iy][ix + 1];
      const b = grid[iy][ix];
      const c = grid[iy + 1][ix];
      const d = grid[iy + 1][ix + 1];
      const b1 = iy !== 0 || thetaStart > 0;
      const b2 = iy !== _heightSegments - 1 || thetaEnd < Math.PI;

      if (b1) {
        indexView.set([a, b, d], i);
      }

      if (b2) {
        indexView.set([b, c, d], i + b1 * 3);
      }

      i += b1 * 3 + b2 * 3;
    }
  }

  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.boundingBox.min.set(-radius, -radius, -radius);
  geometry.boundingBox.max.set(radius, radius, radius);
  geometry.needsUpdateBoundingBox = false;
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  if (elementStaging.empty) {
    indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/torus.js
/* eslint-disable new-cap */



function createTorusMesh({
  name = 'torus',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  radius = 1,
  tube = 0.4,
  radialSegments = 8,
  tubularSegments = 6,
  arc = Math.PI * 2
}) {
  const _radialSegments = Math.floor(radialSegments) || 8;

  const _tubularSegments = Math.floor(tubularSegments) || 6;

  const center = new math_lib["n" /* Vector3 */]();
  const vertex = new math_lib["n" /* Vector3 */]();
  const normal = new math_lib["n" /* Vector3 */](); // Vertex attribute buffers

  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  const verticesCount = (_radialSegments + 1) * (_tubularSegments + 1);
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount);

  for (let index = 0, j = 0; j <= _radialSegments; ++j) {
    for (let i = 0; i <= _tubularSegments; ++i, index += elementsPerVertex) {
      const u = i / _tubularSegments * arc;
      const v = j / _radialSegments * Math.PI * 2;
      vertex.set((radius + tube * Math.cos(v)) * Math.cos(u), (radius + tube * Math.cos(v)) * Math.sin(u), tube * Math.sin(v));
      center.set(Math.cos(u), Math.sin(u), 0).multiplyNumber(radius);
      normal.copy(vertex);
      normal.subtract(center).normalize();
      vertexView.set([vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z, i / _tubularSegments, j / _radialSegments], index);
    }
  } // Index buffer


  const elementsPerFace = 3 * 2; // Two triangles

  const indexElementsCount = (_radialSegments + 1) * (_tubularSegments + 1) * elementsPerFace;
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);

  for (let index = 0, j = 1; j <= _radialSegments; ++j) {
    for (let i = 1; i <= _tubularSegments; ++i, index += elementsPerFace) {
      const a = (_tubularSegments + 1) * j + i - 1;
      const b = (_tubularSegments + 1) * (j - 1) + i - 1;
      const c = (_tubularSegments + 1) * (j - 1) + i;
      const d = (_tubularSegments + 1) * j + i;
      indexView.set([a, b, d, b, c, d], index);
    }
  }

  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.boundingBox.min.set(-radius, -radius, -tube);
  geometry.boundingBox.max.set(radius, radius, tube);
  geometry.needsUpdateBoundingBox = false;
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  if (elementStaging.empty) {
    indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/cylinder.js
/* eslint-disable new-cap */



function createCylinderMesh({
  name = 'cylinder',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  radiusTop = 1,
  radiusBottom = 1,
  radialSegments = 8,
  heightSegments = 1,
  height = 1,
  openEnded = false,
  thetaStart = 0,
  thetaLength = Math.PI * 2
}) {
  const _height = height || 1;

  const _radialSegments = Math.floor(radialSegments) || 8;

  const _heightSegments = Math.floor(heightSegments) || 1;

  let index = 0;
  const indexArray = [];
  const halfHeight = _height / 2;
  let iv = 0;
  let ii = 0;
  const normal = new math_lib["n" /* Vector3 */]();
  const vertex = new math_lib["n" /* Vector3 */]();
  let capVerticesCount = 0;
  let capIndicesCount = 0;

  if (openEnded === false) {
    capVerticesCount += (2 * _radialSegments + 1) * (radiusTop > 0);
    capVerticesCount += (2 * _radialSegments + 1) * (radiusBottom > 0);
    capIndicesCount += _radialSegments * (radiusTop > 0);
    capIndicesCount += _radialSegments * (radiusBottom > 0);
  } // Vertex attribute buffers


  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  const verticesCount = (_heightSegments + 1) * (_radialSegments + 1) + capVerticesCount;
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount); // Index buffer

  const elementsPerFace = 3 * 2; // Two triangles

  const indexElementsCount = (_radialSegments * _heightSegments + capIndicesCount) * elementsPerFace;
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);

  const generateTorso = (vertexBuffer, indexBuffer) => {
    // this will be used to calculate the normal
    const slope = (radiusBottom - radiusTop) / _height; // generate vertices, normals and uvs

    for (let y = 0; y <= _heightSegments; ++y) {
      const indexRow = [];
      const v = y / _heightSegments; // calculate the radius of the current row

      const radius = v * (radiusBottom - radiusTop) + radiusTop;

      for (let x = 0; x <= _radialSegments; ++x, iv += elementsPerVertex) {
        const u = x / _radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        vertex.set(radius * sinTheta, -v * _height + halfHeight, radius * cosTheta);
        normal.set(sinTheta, slope, cosTheta).normalize();
        vertexBuffer.set([vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z, u, 1 - v], iv); // save index of vertex in respective row

        indexRow.push(index++);
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (let x = 0; x < _radialSegments; ++x) {
      for (let y = 0; y < _heightSegments; ++y, ii += elementsPerFace) {
        // we use the index array to access the correct indices
        const a = indexArray[y][x];
        const b = indexArray[y + 1][x];
        const c = indexArray[y + 1][x + 1];
        const d = indexArray[y][x + 1];
        indexBuffer.set([a, b, d, b, c, d], ii);
      }
    }
  };

  const generateCap = (vertexBuffer, indexBuffer, top) => {
    let centerIndexStart;
    let centerIndexEnd;
    const uv = new math_lib["m" /* Vector2 */]();
    const radius = top === true ? radiusTop : radiusBottom;
    const sign = top === true ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // eslint-disable-line
    // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (let x = 1; x <= _radialSegments; ++x, iv += elementsPerVertex) {
      vertexBuffer.set([0, halfHeight * sign, 0, 0, sign, 0, 0.5, 0.5], iv);
      ++index;
    } // save the index of the last center vertex


    centerIndexEnd = index; // eslint-disable-line
    // now we generate the surrounding vertices, normals and uvs

    for (let x = 0; x <= _radialSegments; ++x, iv += elementsPerVertex) {
      const u = x / _radialSegments;
      const theta = u * thetaLength + thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      vertex.set(radius * sinTheta, halfHeight * sign, radius * cosTheta);
      normal.set(0, sign, 0);
      uv.set(cosTheta * 0.5, sinTheta * 0.5 * sign).addNumber(0.5);
      vertexBuffer.set([vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z, uv.x, uv.y], iv);
      ++index;
    } // generate indices


    for (let x = 0; x < _radialSegments; ++x, ii += elementsPerFace) {
      const c = centerIndexStart + x;
      const i = centerIndexEnd + x;

      if (top === true) {
        indexBuffer.set([i, i + 1, c], ii);
      } else {
        indexBuffer.set([i + 1, i, c], ii);
      }
    }
  };

  generateTorso(vertexView, indexView);

  if (openEnded === false) {
    if (radiusTop > 0) {
      generateCap(vertexView, indexView, true);
    }

    if (radiusBottom > 0) {
      generateCap(vertexView, indexView, false);
    }
  }

  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  {
    const r = Math.max(radiusBottom, radiusTop);
    const h = height / 2;
    geometry.boundingBox.min.set(-r, -h, -r);
    geometry.boundingBox.max.set(r, h, r);
    geometry.needsUpdateBoundingBox = false;
  }
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  if (elementStaging.empty) {
    indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/cone.js
/* eslint-disable new-cap */


function createConeMesh({
  name = 'cone',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  radius = 1,
  radialSegments = 8,
  heightSegments = 1,
  height = 1,
  openEnded = false,
  thetaStart = 0,
  thetaLength = Math.PI * 2
}) {
  return createCylinderMesh({
    name,
    vertexStaging,
    elementStaging,
    vertexHardwareBuffer,
    indexHardwareBuffer,
    material,
    radiusTop: 0,
    radiusBottom: radius,
    radialSegments,
    heightSegments,
    height,
    openEnded,
    thetaStart,
    thetaLength
  });
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/circle.js
/* eslint-disable new-cap */


function createCircleMesh({
  name = 'circle',
  vertexStaging,
  elementStaging,
  vertexHardwareBuffer = null,
  indexHardwareBuffer = null,
  material,
  radius = 10,
  segments = 8,
  thetaStart = 0,
  thetaLength = Math.PI * 2
}) {
  const _radius = radius || 1; // Vertex attribute buffers


  const positionComponentsCount = 3;
  const normalComponentsCount = 3;
  const uvComponentsCount = 2;
  const elementsPerVertex = positionComponentsCount + normalComponentsCount + uvComponentsCount;
  const verticesCount = segments + 2;
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount);
  vertexView.set([0, 0, 0, 0, 0, 1, 0.5, 0.5], 0);

  for (let iv = elementsPerVertex, s = 0, i = 3; s <= segments; ++s, i += 3, iv += elementsPerVertex) {
    const segment = thetaStart + s / segments * thetaLength;

    const x = _radius * Math.cos(segment);

    const y = _radius * Math.sin(segment);

    vertexView.set([x, y, 0, 0, 0, 1, (x / _radius + 1) / 2, (y / _radius + 1) / 2], iv);
  } // Index buffer


  const elementsPerFace = 3;
  const indexElementsCount = segments * elementsPerFace;
  const indexComponentType = indexElementsCount < 256 // eslint-disable-line
  ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = elementStaging.empty ? new indexType(indexElementsCount) : new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount); // indices

  for (let ii = 0, i = 1; i <= segments; ++i, ii += elementsPerFace) {
    indexView.set([i, i + 1, 0], ii);
  }

  const stride = (positionComponentsCount + normalComponentsCount + uvComponentsCount) * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const normalAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: normalComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * positionComponentsCount,
    semantic: lib["d" /* AttributeSemantic */].NORMAL,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const uvAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: uvComponentsCount,
    countElements: verticesCount,
    offset: Float32Array.BYTES_PER_ELEMENT * (positionComponentsCount + normalComponentsCount),
    semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC2,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.boundingBox.min.set(-radius, -radius, -0.1e-4);
  geometry.boundingBox.min.set(radius, radius, 0.1e-4);
  geometry.needsUpdateBoundingBox = false;
  const subMesh = new lib["fb" /* SubMesh */]({
    name: name + '_submesh',
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].NORMAL, normalAttribute);
  geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh);

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  if (elementStaging.empty) {
    indexHardwareBuffer.subdata(indexView, indexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  normalAttribute.release();
  uvAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}
/**
 * @function module:wg-procedural-geometry.createCircleLine
 * @summary Create circle renderable by lines.
 * @param {Object} arguments
 *
 * @param {string} [arguments.name='circle-line'] Name of the lined renderable.
 *
 * @param {module:wg-host-memory-manager.RangeBasedMemoryManager} arguments.vertexStaging Instance of 'RangeBasedMemoryManager' abstract class.
 * @param {module:wg-host-memory-manager.RangeBasedMemoryManager} arguments.elementStaging Instance of 'RangeBasedMemoryManager' abstract class.
 *
 * @param {module:wg-gfx-engine.Material} arguments.material Instance of 'Material' abstract class.
 *
 * @param {number} [arguments.radius=10] Radius of the circle.
 * @param {number} [arguments.segments=8] Number of segments (triangles).
 *
 * @param {number} [arguments.thetaStart=0] Start angle for first segment.
 * @param {number} [arguments.thetaLength=2*PI] The central angle, often called theta, of the circular sector.
 *
 * @returns {module:wg-engine-core.Line} Line.
 */


function createCircleLine({
  name = 'circle-line',
  vertexStaging,
  elementStaging,
  material,
  radius = 1,
  segments = 8,
  thetaStart = 0,
  thetaLength = Math.PI * 2
}) {
  const _radius = radius || 1; // Vertex attribute buffers


  const positionComponentsCount = 3;
  const elementsPerVertex = positionComponentsCount;
  const verticesCount = segments;
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount);

  for (let iv = 0, s = 0; s < segments; ++s, iv += elementsPerVertex) {
    const segment = thetaStart + s / segments * thetaLength;

    const x = _radius * Math.cos(segment);

    const y = _radius * Math.sin(segment);

    vertexView.set([x, y, 0], iv);
  } // Index buffer


  const elementsPerLine = 1;
  const indexElementsCount = segments * elementsPerLine + 1;
  const indexComponentType = indexElementsCount < 256 ? lib["n" /* DataType */].UNSIGNED_BYTE : indexElementsCount < 65536 ? lib["n" /* DataType */].UNSIGNED_SHORT : lib["n" /* DataType */].UNSIGNED_INT;
  const indexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * indexType.BYTES_PER_ELEMENT);
  const indexView = new indexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);
  indexView.set(new Array(indexElementsCount - 1).fill(0).map((el, i) => i).concat([0]));
  const stride = positionComponentsCount * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: indexType
  });
  const geometry = new lib["t" /* Geometry */]({
    primitiveType: lib["O" /* PrimitiveType */].LINE_LOOP
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.indices = indices;
  const line = new lib["y" /* Line */]({
    geometry,
    material,
    name
  });
  return line;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/geometries/line.js

/**
 * @function module:wg-procedural-geometry.createLine
 * @summary Create line renderable.
 * @param {Object} arguments
 *
 * @param {string} [arguments.name='line'] Name of the renderable.
 *
 * @param {module:wg-host-memory-manager.RangeBasedMemoryManager} arguments.vertexStaging Instance of 'RangeBasedMemoryManager' abstract class.
 * @param {module:@wgetemp/webgl-renderer.WebGLBuffer} [arguments.vertexHardwareBuffer=null]
 * Hardware vertex buffer.
 *
 * @param {module:wg-gfx-engine.Material} arguments.material Instance of 'Material' abstract class.
 *
 * @param {number} [arguments.length=1] Length of the line.
 *
 * @returns {module:wg-engine-core.Line} Line.
 */

function createLine({
  name = 'line',
  vertexStaging,
  vertexHardwareBuffer = null,
  material,
  length = 1
}) {
  // Vertex attribute buffers
  const positionComponentsCount = 3;
  const elementsPerVertex = positionComponentsCount;
  const verticesCount = 2;
  const vertexElementsCount = verticesCount * elementsPerVertex;
  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, vertexElementsCount * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = vertexStaging.empty ? new Float32Array(vertexElementsCount) : new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, vertexElementsCount);
  vertexView.set([0, 0, 0], 0);
  vertexView.set([0, 0, length], 3);
  const stride = positionComponentsCount * Float32Array.BYTES_PER_ELEMENT;
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    vertexData: vertexBufferView,
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: positionComponentsCount,
    countElements: verticesCount,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride,
    type: Float32Array
  });
  const geometry = new lib["t" /* Geometry */]({
    primitiveType: lib["O" /* PrimitiveType */].LINES
  });
  geometry.boundingBox.min.set(0, 0, 0);
  geometry.boundingBox.max.set(0.1e-4, 0.1e-4, length);
  geometry.needsUpdateBoundingBox = false;
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  const line = new lib["y" /* Line */]({
    geometry,
    material,
    name
  });

  if (vertexStaging.empty) {
    vertexHardwareBuffer.subdata(vertexView, vertexBufferView.view.byteOffset);
  }

  positionAttribute.release();
  geometry.release();
  vertexBufferView.release();
  return line;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/index.js
/**
 * @module module:@wgetemp/procedural-geometry
 */









/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ line_Line; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ point_Point; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ caption_Caption; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ AlignBox; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ arc_Arc; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ delete_button_DeleteButton; });

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/events/events.js
var events = __webpack_require__(34);

// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/line.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const E = 0.001;
const plugSize = 20;
class line_Line extends events["EventEmitter"] {
  set plugged(value) {
    if (value === this._plugged) {
      return;
    }

    this._plugged = value;

    this._updatePlugs();
  }

  get plugged() {
    return this._plugged;
  }

  set dragging(value) {
    if (value === this._dragging) {
      return;
    }

    this._dragging = value;
    this.draw();
  }

  get dragging() {
    return this._dragging;
  }

  set interactive(value) {
    if (value === this._interactive) {
      return;
    }

    this._interactive = value;
    this.draw();
  }

  get interactive() {
    return this._interactive;
  }

  set color(color) {
    const cssColor = '#' + color;
    this._lineElement.style.stroke = cssColor;
    this._plugElement1.style.stroke = cssColor;
    this._plugElement2.style.stroke = cssColor;
  }

  set opacity(value) {
    const opacity = String(value);
    this._lineElement.style.opacity = opacity;
    this._plugElement1.style.opacity = opacity;
    this._plugElement2.style.opacity = opacity;
  }

  constructor({
    points,
    plugged = false
  }) {
    super();

    _defineProperty(this, "element", void 0);

    _defineProperty(this, "points", void 0);

    _defineProperty(this, "_plugged", void 0);

    _defineProperty(this, "_dragging", void 0);

    _defineProperty(this, "_interactive", void 0);

    _defineProperty(this, "_lineElement", void 0);

    _defineProperty(this, "_selectionElement", void 0);

    _defineProperty(this, "_plugElement1", void 0);

    _defineProperty(this, "_plugElement2", void 0);

    _defineProperty(this, "_handleChangePointDragging", value => {
      this.dragging = value;
    });

    _defineProperty(this, "_handleHover", () => {
      this.emit('hover', {
        target: this
      });
    });

    _defineProperty(this, "_handleUnhover", () => {
      this.emit('unhover', {
        target: this
      });
    });

    _defineProperty(this, "_handleClick", () => {
      this.emit('select', {
        target: this
      });
    });

    _defineProperty(this, "_handleUpdatePoint", event => {
      const pointIndex = this.points.findIndex(point => point === event.target);

      if (pointIndex === -1) {
        return;
      }

      this._updatePointScreenPosition(pointIndex);

      this._updatePlugs();
    });

    _defineProperty(this, "_updatePointScreenPosition", pointIndex => {
      const point = this.points[pointIndex];

      if (!point) {
        return;
      }

      this._lineElement.setAttribute(`x${pointIndex + 1}`, point.containerPosition.x + '');

      this._lineElement.setAttribute(`y${pointIndex + 1}`, point.containerPosition.y + '');

      this._selectionElement.setAttribute(`x${pointIndex + 1}`, point.containerPosition.x + '');

      this._selectionElement.setAttribute(`y${pointIndex + 1}`, point.containerPosition.y + '');
    });

    _defineProperty(this, "_updatePointsScreenPositions", () => {
      this.points.forEach((point, pointIndex) => {
        this._updatePointScreenPosition(pointIndex);
      });

      this._updatePlugs();
    });

    const xmlns = 'http://www.w3.org/2000/svg';
    const element = document.createElementNS(xmlns, 'svg');
    Object.assign(element.style, {
      position: 'absolute',
      width: '100%',
      height: '100%' // filter: 'drop-shadow(0 0 1px rgba(0, 0, 0, .7))'

    });
    element.setAttribute('class', 'bv-measure-line');
    const from = points[0].position;
    const to = points[1].position;
    const x1 = from.x;
    const x2 = to.x;
    const y1 = from.y;
    const y2 = to.y;

    const [x3, y3, x4, y4] = this._getNormalLine(points, points[0], plugSize / 2);

    const [x5, y5, x6, y6] = this._getNormalLine(points, points[1], plugSize / 2);

    element.innerHTML = `
            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" style="stroke:red; stroke-width:2; pointer-events: auto; cursor: pointer;"></line>
            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" style="stroke:red; stroke-width:${plugSize}; pointer-events: auto; cursor: pointer; opacity: 0"></line>
            <line x1="${x4}" y1="${y4}" x2="${x3}" y2="${y3}" style="stroke:red; stroke-width:2; pointer-events: auto; cursor: pointer;"></line>
            <line x1="${x5}" y1="${y5}" x2="${x6}" y2="${y6}" style="stroke:red; stroke-width:2; pointer-events: auto; cursor: pointer;"></line>
        `;
    const lines = element.querySelectorAll('line');
    this.element = element;
    this._interactive = true;
    this._plugged = plugged;
    this._dragging = false;
    this._lineElement = lines[0];
    this._selectionElement = lines[1];
    this._plugElement1 = lines[2];
    this._plugElement2 = lines[3];
    this.points = points;

    this._prepareElements();

    this._addListeners();

    this._updatePointsScreenPositions();

    this.draw();
  }

  _prepareElements() {
    const style = {
      transition: 'stroke 250ms'
    };
    Object.assign(this._lineElement.style, style);
    Object.assign(this._plugElement1.style, style);
    Object.assign(this._plugElement2.style, style);
  }

  _addListeners() {
    this.points.forEach(point => {
      point.on('screen-position-update', this._handleUpdatePoint);
      point.on('dragging-change', this._handleChangePointDragging);
    });
    this.element.addEventListener('click', this._handleClick);
    this.element.addEventListener('mouseenter', this._handleHover);
    this.element.addEventListener('mouseleave', this._handleUnhover);
  }

  _removeListeners() {
    this.points.forEach(point => {
      point.off('screen-position-update', this._handleUpdatePoint);
      point.off('dragging-change', this._handleChangePointDragging);
    });
    this.element.removeEventListener('click', this._handleClick);
    this.element.removeEventListener('mouseenter', this._handleHover);
    this.element.removeEventListener('mouseleave', this._handleUnhover);
  }

  _getNormalLine(points, point, size) {
    const x1 = points[0].containerPosition.x;
    const x2 = points[1].containerPosition.x;
    const y1 = points[0].containerPosition.y;
    const y2 = points[1].containerPosition.y;
    const perX = -(y2 - y1);
    const perY = x2 - x1;

    if (Math.abs(perX) < E && Math.abs(perY) < E) {
      return [x1, y1, x1, y1];
    }

    const perLength = Math.sqrt(perX ** 2 + perY ** 2);
    const nx = perX / perLength;
    const ny = perY / perLength;
    const x3 = point.containerPosition.x + nx * size;
    const y3 = point.containerPosition.y + ny * size;
    const x4 = point.containerPosition.x - nx * size;
    const y4 = point.containerPosition.y - ny * size;
    return [x3, y3, x4, y4];
  }

  _updatePlugs() {
    this._plugElement1.style.visibility = this._plugged ? 'visible' : 'hidden';
    this._plugElement2.style.visibility = this._plugged ? 'visible' : 'hidden';

    if (!this._plugged) {
      return;
    }

    const [x3, y3, x4, y4] = this._getNormalLine(this.points, this.points[0], plugSize / 2);

    this._plugElement1.setAttribute('x1', x3 + '');

    this._plugElement1.setAttribute('y1', y3 + '');

    this._plugElement1.setAttribute('x2', x4 + '');

    this._plugElement1.setAttribute('y2', y4 + '');

    const [x5, y5, x6, y6] = this._getNormalLine(this.points, this.points[1], plugSize / 2);

    this._plugElement2.setAttribute('x1', x5 + '');

    this._plugElement2.setAttribute('y1', y5 + '');

    this._plugElement2.setAttribute('x2', x6 + '');

    this._plugElement2.setAttribute('y2', y6 + '');
  }

  draw() {
    for (let i = 0; i < this.element.children.length; i++) {
      const element = this.element.children[i];

      if (!(element instanceof SVGLineElement)) {
        continue;
      }

      const interactive = !this._dragging && this._interactive;
      Object.assign(element.style, {
        pointerEvents: interactive ? 'auto' : 'none',
        cursor: interactive ? 'pointer' : 'auto'
      });
    }
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/point.ts
function point_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const isTouchDevice = ('ontouchstart' in window);
class point_Point extends events["EventEmitter"] {
  get x() {
    return this.position.x;
  }

  get y() {
    return this.position.y;
  }

  get z() {
    return this.position.z;
  }

  get interactive() {
    return this._interactive;
  }

  set interactive(value) {
    this._interactive = value;
    this.draw();
  }

  get visible() {
    return this._visible;
  }

  set visible(value) {
    this._visible = value;
    this.draw();
  }

  get dragging() {
    return this._dragging;
  }

  set dragging(value) {
    this._dragging = value;

    if (this.parent) {
      this.parent.dragging = value;
    }

    this.emit('dragging-change', value);
    this.draw();
  }

  set color(color) {
    this._pointElement.style.borderColor = '#' + color;
  }

  set touchZoneColor(color) {
    if (!this._touchZoneElement) {
      return;
    }

    this._touchZoneElement.style.background = '#' + color;
  }

  constructor({
    position,
    interactive = true,
    visible = true
  }) {
    super();

    point_defineProperty(this, "index", void 0);

    point_defineProperty(this, "position", void 0);

    point_defineProperty(this, "parent", void 0);

    point_defineProperty(this, "containerPosition", void 0);

    point_defineProperty(this, "element", void 0);

    point_defineProperty(this, "_pointElement", void 0);

    point_defineProperty(this, "_touchZoneElement", void 0);

    point_defineProperty(this, "_interactive", void 0);

    point_defineProperty(this, "_dragging", void 0);

    point_defineProperty(this, "_visible", void 0);

    point_defineProperty(this, "_handleMouseDown", event => {
      this.emit('drag-start', {
        target: this
      });
    });

    point_defineProperty(this, "_handleTouchStart", event => {
      const {
        clientX,
        clientY
      } = event.touches[0];
      const rect = this.element.getBoundingClientRect();
      const offset = {
        x: rect.left - clientX,
        y: rect.top - clientY
      };
      const dragEvent = {
        target: this,
        offset
      };
      this.emit('drag-start', dragEvent);
    });

    const element = document.createElement('div');
    element.className = 'bv-measure-point';
    Object.assign(element.style, {
      position: 'absolute',
      left: '0',
      top: '0',
      pointerEvents: interactive ? 'auto' : 'none'
    });
    const pointElement = document.createElement('div');
    element.appendChild(pointElement);
    const size = 6;
    Object.assign(pointElement.style, {
      position: 'relative',
      width: size + 'px',
      height: size + 'px',
      transform: 'translate(-50%, -50%)',
      borderRadius: '50%',
      transformOrigin: 'center',
      cursor: 'all-scroll',
      background: '#272727',
      border: '2px solid white',
      boxShadow: '0 2px 5px rgba(0, 0, 0, 0.6)'
    });
    let touchZoneElement = null;

    if (isTouchDevice) {
      touchZoneElement = document.createElement('div');
      element.appendChild(touchZoneElement);
      Object.assign(touchZoneElement.style, {
        width: '100px',
        height: '100px',
        position: 'absolute',
        left: '0',
        top: '0',
        background: 'white',
        transform: 'translate(-50%, -50%)',
        opacity: 0.1,
        borderRadius: '50%'
      });
    }

    this.index = 0;
    this.element = element;
    this.parent = null;
    this.position = { ...position
    };
    this.containerPosition = {
      x: 0,
      y: 0
    };
    this._pointElement = pointElement;
    this._touchZoneElement = touchZoneElement;
    this._dragging = false;
    this._visible = visible;
    this._interactive = interactive;

    this._addListeners();

    this.draw();
  }

  _addListeners() {
    this.element.addEventListener('mousedown', this._handleMouseDown);
    this.element.addEventListener('touchstart', this._handleTouchStart);
  }

  _removeListeners() {
    this.element.removeEventListener('mousedown', this._handleMouseDown);
    this.element.removeEventListener('touchstart', this._handleTouchStart);
  }

  setPosition(x, y, z = 0) {
    this.position.x = x;
    this.position.y = y;
    this.position.z = z;
    this.emit('position-change');
  }

  setContainerPosition(x, y) {
    Object.assign(this.element.style, {
      transform: `translate(${x}px, ${y}px)`
    });
    this.containerPosition.x = x;
    this.containerPosition.y = y;
    const event = {
      target: this,
      containerPosition: {
        x,
        y
      }
    };
    this.emit('screen-position-update', event);
  }

  draw() {
    Object.assign(this.element.style, this._interactive ? {
      pointerEvents: 'auto'
    } : {
      pointerEvents: 'none'
    });
    Object.assign(this.element.style, {
      visibility: this._visible && !this._dragging ? 'visible' : 'hidden'
    });
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
    this.parent = null;
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/caption.ts
function caption_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class caption_Caption extends events["EventEmitter"] {
  set selected(value) {
    this._selected = value;
    this.draw();
  }

  get selected() {
    return this._selected;
  }

  set value(value) {
    this._value = value;
    this.draw();
  }

  get value() {
    return this._value;
  }

  set postfix(value) {
    this._postfix = value;
    this.draw();
  }

  get postfix() {
    return this._postfix;
  }

  set interactive(value) {
    if (value === this._interactive) {
      return;
    }

    this._interactive = value;
    this.draw();
  }

  get interactive() {
    return this._interactive;
  }

  set visible(value) {
    this._visible = value;
    this.draw();
  }

  get visible() {
    return this._visible;
  }

  set color(color) {
    this.element.style.backgroundColor = '#' + color;
  }

  set textColor(color) {
    this._textElement.style.color = '#' + color;
  }

  set opacity(value) {
    this.element.style.opacity = String(value);
  }

  constructor({
    value = '',
    postfix = '',
    selected = false,
    children = []
  }) {
    super();

    caption_defineProperty(this, "element", void 0);

    caption_defineProperty(this, "_value", void 0);

    caption_defineProperty(this, "_postfix", void 0);

    caption_defineProperty(this, "_selected", void 0);

    caption_defineProperty(this, "_visible", void 0);

    caption_defineProperty(this, "_interactive", void 0);

    caption_defineProperty(this, "_textElement", void 0);

    caption_defineProperty(this, "_children", void 0);

    caption_defineProperty(this, "_handleHover", () => {
      this.emit('hover', {
        target: this
      });
    });

    caption_defineProperty(this, "_handleUnhover", () => {
      this.emit('unhover', {
        target: this
      });
    });

    caption_defineProperty(this, "_handleClick", event => {
      event.stopPropagation();
      this.emit('select', {
        target: this
      });
    });

    const element = document.createElement('div');
    element.className = 'bv-measure-caption';
    Object.assign(element.style, {
      display: 'flex',
      transition: 'background-color 250ms',
      boxShadow: '0 2px 5px rgba(0, 0, 0, 0.3)',
      background: 'red'
    });
    const textElement = document.createElement('div');
    textElement.className = 'bv-measure-caption-text';
    element.appendChild(textElement);
    children.forEach(child => element.appendChild(child));
    this.element = element;
    this._interactive = true;
    this._selected = selected;
    this._value = value;
    this._postfix = postfix;
    this._textElement = textElement;
    this._visible = true;
    this._children = children;

    this._addEventListener();

    this.draw();
  }

  _addEventListener() {
    this._textElement.addEventListener('click', this._handleClick);

    this.element.addEventListener('mouseenter', this._handleHover);
    this.element.addEventListener('mouseleave', this._handleUnhover);
  }

  _removeListeners() {
    this._textElement.removeEventListener('click', this._handleClick);

    this.element.removeEventListener('mouseenter', this._handleHover);
    this.element.removeEventListener('mouseleave', this._handleUnhover);
  }

  draw() {
    Object.assign(this.element.style, {
      visibility: this._visible ? 'visible' : 'hidden'
    });
    Object.assign(this._textElement.style, {
      height: '24px',
      lineHeight: '24px',
      padding: '0 8px',
      pointerEvents: this._interactive ? 'auto' : 'none',
      cursor: this._interactive ? 'pointer' : 'auto'
    });
    this._textElement.innerHTML = `${this._value}${this._postfix}`;
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/align-box.ts
function align_box_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AlignBox {
  constructor({
    points,
    children
  }) {
    align_box_defineProperty(this, "element", void 0);

    align_box_defineProperty(this, "points", void 0);

    align_box_defineProperty(this, "draw", () => {
      Object.assign(this.element.style, {
        position: 'absolute',
        whiteSpace: 'nowrap',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      });
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      this.points.forEach(point => {
        minX = Math.min(minX, point.containerPosition.x);
        maxX = Math.max(maxX, point.containerPosition.x);
        minY = Math.min(minY, point.containerPosition.y);
        maxY = Math.max(maxY, point.containerPosition.y);
      });
      Object.assign(this.element.style, {
        left: minX + 'px',
        top: minY + 'px',
        width: maxX - minX + 'px',
        height: maxY - minY + 'px'
      });
    });

    const element = document.createElement('div');
    children.forEach(child => element.appendChild(child));
    this.element = element;
    this.points = points;

    this._addListeners();

    this.draw();
  }

  _addListeners() {
    this.points.forEach(point => {
      point.on('screen-position-update', this.draw);
    });
  }

  _removeListeners() {
    this.points.forEach(point => {
      point.off('screen-position-update', this.draw);
    });
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/utils/measures/src/math/vec2.ts
var vec2 = __webpack_require__(16);

// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/arc/utils.ts

const getPathDefineByPoints = (() => {
  const v1 = {
    x: 0,
    y: 0
  };
  const v2 = {
    x: 0,
    y: 0
  };
  const start = {
    x: 0,
    y: 0
  };
  const end = {
    x: 0,
    y: 0
  };
  let radius;
  let sweepFlag;
  return points => {
    vec2["g" /* sub */](points[0].containerPosition, points[1].containerPosition, v1);
    vec2["g" /* sub */](points[2].containerPosition, points[1].containerPosition, v2);
    radius = Math.min(40, Math.min(vec2["d" /* length */](v1), vec2["d" /* length */](v2)) * 0.5);
    vec2["a" /* add */](points[1].containerPosition, vec2["e" /* multiplyScalar */](vec2["f" /* normalize */](v1), radius), start);
    vec2["a" /* add */](points[1].containerPosition, vec2["e" /* multiplyScalar */](vec2["f" /* normalize */](v2), radius), end);
    sweepFlag = vec2["b" /* cross */](v1, v2) < 0 ? 0 : 1;
    return `M ${start.x} ${start.y} A ${radius} ${radius} 0 0 ${sweepFlag} ${end.x} ${end.y}`;
  };
})();
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/arc/index.ts
function arc_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class arc_Arc extends events["EventEmitter"] {
  set color(color) {
    this._pathElement.style.stroke = '#' + color;
  }

  constructor({
    points
  }) {
    super();

    arc_defineProperty(this, "element", void 0);

    arc_defineProperty(this, "points", void 0);

    arc_defineProperty(this, "_pathElement", void 0);

    arc_defineProperty(this, "_updateArc", () => {
      this._pathElement.setAttribute('d', getPathDefineByPoints(this.points));
    });

    const xmlns = 'http://www.w3.org/2000/svg';
    const element = document.createElementNS(xmlns, 'svg');
    Object.assign(element.style, {
      position: 'absolute',
      width: '100%',
      height: '100%' // filter: 'drop-shadow(0 0 1px rgba(0, 0, 0, .7))'

    });
    element.setAttribute('class', 'bv-measure-arc'); // pointer-events: auto; cursor: pointer;

    element.innerHTML = '<path fill="none" stroke="red" stroke-width="2" />';
    const pathElement = element.querySelector('path');

    if (!pathElement) {
      throw new Error('Measure: Can\'t get path element for arc');
    }

    this.element = element;
    this.points = points;
    this._pathElement = pathElement;

    this._addListeners();

    this._updateArc();
  }

  _addListeners() {
    this.points.forEach(point => point.on('screen-position-update', this._updateArc));
  }

  _removeListeners() {
    this.points.forEach(point => point.off('screen-position-update', this._updateArc));
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/delete-button.ts
function delete_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class delete_button_DeleteButton extends events["EventEmitter"] {
  set visible(value) {
    this._visible = value;

    this._updateVisibility();
  }

  get visible() {
    return this._visible;
  }

  constructor() {
    super();

    delete_button_defineProperty(this, "element", void 0);

    delete_button_defineProperty(this, "_visible", void 0);

    delete_button_defineProperty(this, "_handleClick", event => {
      event.stopPropagation();
      this.emit('click');
    });

    const element = document.createElement('div');
    element.className = 'bv-measure-delete-button';
    Object.assign(element.style, {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: '24px',
      height: '24px',
      background: '#272727',
      pointerEvents: 'auto',
      cursor: 'pointer'
    });
    const xmlns = 'http://www.w3.org/2000/svg';
    const svgElement = document.createElementNS(xmlns, 'svg');
    svgElement.setAttribute('width', '16');
    svgElement.setAttribute('height', '16');
    svgElement.setAttribute('viewBox', '0 0 16 16');
    element.appendChild(svgElement);
    svgElement.innerHTML = `
            <path d="M12.818 4.286L12.016 14.5h-8.01L3.203 4.286h-.125a.65.65 0 0 1 0-1.3h3.349V1.5h3.165v1.486h3.328a.65.65 0 1 1 0 1.3h-.103zM8.832 3.05v-.9H7.19v.9h1.642zM4.224 5.305l.637 8.135h6.31l.628-8.135H4.224z" fill="#AAABB0"/>
        `;
    this.element = element;
    this._visible = true;

    this._addListeners();
  }

  _addListeners() {
    this.element.addEventListener('click', this._handleClick);
  }

  _removeListeners() {
    this.element.removeEventListener('click', this._handleClick);
  }

  _updateVisibility() {
    Object.assign(this.element.style, {
      display: this._visible ? 'flex' : 'none'
    });
  }

  dispose() {
    this._removeListeners();

    this.element.remove();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/index.ts







/***/ }),
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),
/* 35 */,
/* 36 */,
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Quaternion; });
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/* harmony import */ var _to_title_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);




const Quaternion = (() => {
  function multiply(result, left, right) {
    const lRe = left.re,
          lImX = left.imX,
          lImY = left.imY,
          lImZ = left.imZ;
    const rRe = right.re,
          rImX = right.imX,
          rImY = right.imY,
          rImZ = right.imZ;
    result.re = lRe * rRe - lImX * rImX - lImY * rImY - lImZ * rImZ;
    result.imX = lRe * rImX + lImX * rRe + lImY * rImZ - lImZ * rImY;
    result.imY = lRe * rImY + lImY * rRe + lImZ * rImX - lImX * rImZ;
    result.imZ = lRe * rImZ + lImZ * rRe + lImX * rImY - lImY * rImX;
    return result;
  }

  const im = new _vectors__WEBPACK_IMPORTED_MODULE_3__[/* Vector3 */ "b"]();
  /**
   * @class module:@wgetemp/math.Quaternion
   * @summary Used for representing 3D rotations and uniform scaling.
   * @desc It is stored in conjugate form, so that multiplication composes transformations from
   * left to right.
   * @param {number} [re=1] Real component.
   * @param {number} [imX=0] Imaginary X component.
   * @param {number} [imY=0] Imaginary Y component.
   * @param {number} [imZ=0] Imaginary Z component.
   */

  class Quaternion {
    constructor(re = 1, imX = 0, imY = 0, imZ = 0) {
      /**
       * @var module:@wgetemp/math.Quaternion#re
       * @summary Real component.
       * @type {number}
       */
      this.re = re;
      /**
       * @var module:@wgetemp/math.Quaternion#imX
       * @summary Imaginary X component.
       * @type {number}
       */

      this.imX = imX;
      /**
       * @var module:@wgetemp/math.Quaternion#imY
       * @summary Imaginary Y component.
       * @type {number}
       */

      this.imY = imY;
      /**
       * @var module:@wgetemp/math.Quaternion#imZ
       * @summary Imaginary Z component.
       * @type {number}
       */

      this.imZ = imZ;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#set
     * @summary Set quaternion components.
     * @param {number} re Real component.
     * @param {number} imX Imaginary X component.
     * @param {number} imY Imaginary Y component.
     * @param {number} imZ Imaginary Z component.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    set(re, imX, imY, imZ) {
      this.re = re;
      this.imX = imX;
      this.imY = imY;
      this.imZ = imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromNumber
     * @summary Set quaternion from real number.
     * @desc ```
     * this.re = re;
     * this.imX = 0;
     * this.imY = 0;
     * this.imZ = 0;
     * ```
     * @param {number} re Real component.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromNumber(re) {
      this.re = re;
      this.imX = 0;
      this.imY = 0;
      this.imZ = 0;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromQuaternion
     * @summary Set quaternion from another quaternion.
     * @param {module:@wgetemp/math.Quaternion} quaternion Source quaternion.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromQuaternion(quaternion) {
      this.re = quaternion.re;
      this.imX = quaternion.imX;
      this.imY = quaternion.imY;
      this.imZ = quaternion.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromArray
     * @summary Set quaternion from array.
     * @desc The array is expected to store the quaternion in more commonly used, non-conjugate
     * form, with imaginary components preceding the real one:
     * ```
     * this.imX = -array[0];
     * this.imY = -array[1];
     * this.imZ = -array[2];
     * this.re  =  array[3];
     * ```
     * @param {ArrayLike} array Source array. Must have at least four elements.
     * First four elements must be numbers.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromArray(array) {
      this.imX = -array[0];
      this.imY = -array[1];
      this.imZ = -array[2];
      this.re = array[3];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromArrayAt
     * @summary Set quaternion from array at given offset.
     * @desc The array is expected to store the quaternion in more commonly used, non-conjugate
     * form, with imaginary components preceding the real one:
     * ```
     * this.imX = -array[offset    ];
     * this.imY = -array[offset + 1];
     * this.imZ = -array[offset + 2];
     * this.re  =  array[offset + 3];
     * ```
     * @param {number} offset Where in the array to take values from.
     * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.
     * Four elements starting at `offset` must be numbers.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromArrayAt(offset, array) {
      this.imX = -array[offset];
      this.imY = -array[offset + 1];
      this.imZ = -array[offset + 2];
      this.re = array[offset + 3];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#toArray
     * @summary Put quaternion elements into array.
     * @desc The array will store the quaternion in more commonly used, non-conjugate
     * form, with imaginary components preceding the real one:
     * ```
     * array[0] = -this.imX;
     * array[1] = -this.imY;
     * array[2] = -this.imZ;
     * array[3] =  this.re;
     * ```
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toArray(array) {
      array[0] = -this.imX;
      array[1] = -this.imY;
      array[2] = -this.imZ;
      array[3] = this.re;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#toArrayAt
     * @summary Put quaternion elements into array at given offset.
     * @desc The array will store the quaternion in more commonly used, non-conjugate
     * form, with imaginary components preceding the real one:
     * ```
     * array[offset    ] = -this.imX;
     * array[offset + 1] = -this.imY;
     * array[offset + 2] = -this.imZ;
     * array[offset + 3] =  this.re;
     * ```
     * @param {number} offset Where in the array to put values to.
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toArrayAt(offset, array) {
      array[offset] = -this.imX;
      array[offset + 1] = -this.imY;
      array[offset + 2] = -this.imZ;
      array[offset + 3] = this.re;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromConjugateArray
     * @summary Set quaternion from array.
     * @desc The array is expected to store the quaternion in conjugate form, with imaginary
     * components preceding the real one:
     * ```
     * this.imX = array[0];
     * this.imY = array[1];
     * this.imZ = array[2];
     * this.re  = array[3];
     * ```
     * @param {ArrayLike} array Source array. Must have at least four elements.
     * First four elements must be numbers.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromConjugateArray(array) {
      this.imX = array[0];
      this.imY = array[1];
      this.imZ = array[2];
      this.re = array[3];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromConjugateArrayAt
     * @summary Set quaternion from array at given offset.
     * @desc The array is expected to store the quaternion in conjugate form, with imaginary
     * components preceding the real one:
     * ```
     * this.imX = array[offset    ];
     * this.imY = array[offset + 1];
     * this.imZ = array[offset + 2];
     * this.re  = array[offset + 3];
     * ```
     * @param {number} offset Where in the array to take values from.
     * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.
     * Four elements starting at `offset` must be numbers.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromConjugateArrayAt(offset, array) {
      this.imX = array[offset];
      this.imY = array[offset + 1];
      this.imZ = array[offset + 2];
      this.re = array[offset + 3];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#toConjugateArray
     * @summary Put quaternion elements into array.
     * @desc The array will store the quaternion in conjugate form, with imaginary components
     * preceding the real one:
     * ```
     * array[0] = this.imX;
     * array[1] = this.imY;
     * array[2] = this.imZ;
     * array[3] = this.re;
     * ```
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toConjugateArray(array) {
      array[0] = this.imX;
      array[1] = this.imY;
      array[2] = this.imZ;
      array[3] = this.re;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#toConjugateArrayAt
     * @summary Put quaternion elements into array at given offset.
     * @desc The array will store the quaternion in conjugate form, with imaginary components
     * preceding the real one:
     * ```
     * array[offset    ] = this.imX;
     * array[offset + 1] = this.imY;
     * array[offset + 2] = this.imZ;
     * array[offset + 3] = this.re;
     * ```
     * @param {number} offset Where in the array to put values to.
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toConjugateArrayAt(offset, array) {
      array[offset] = this.imX;
      array[offset + 1] = this.imY;
      array[offset + 2] = this.imZ;
      array[offset + 3] = this.re;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#clone
     * @returns {module:@wgetemp/math.Quaternion}
     */


    clone() {
      return new Quaternion().copy(this);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#equals
     * @param {module:@wgetemp/math.Quaternion} that Other quaternion.
     * @returns {boolean} Whether `this` components are equal to `that`
     * components.
     */


    equals(that) {
      return this.re === that.re && this.imX === that.imX && this.imY === that.imY && this.imZ === that.imZ;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#negate
     * @desc In place.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    negate() {
      this.re = -this.re;
      this.imX = -this.imX;
      this.imY = -this.imY;
      this.imZ = -this.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#conjugate
     * @desc In place.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    conjugate() {
      this.imX = -this.imX;
      this.imY = -this.imY;
      this.imZ = -this.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#invert
     * @desc In place.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    invert() {
      const invNegSqAbs = -1 / this.sqAbs;
      this.re *= -invNegSqAbs;
      this.imX *= invNegSqAbs;
      this.imY *= invNegSqAbs;
      this.imZ *= invNegSqAbs;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#addQuaternion
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Quaternion} that Other operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    addQuaternion(that) {
      this.re += that.re;
      this.imX += that.imX;
      this.imY += that.imY;
      this.imZ += that.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#addNumber
     * @desc Result is placed into `this`.
     * @param {number} that Other operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    addNumber(that) {
      this.re += that;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#subtractQuaternion
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Quaternion} right Right operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    subtractQuaternion(right) {
      this.re -= right.re;
      this.imX -= right.imX;
      this.imY -= right.imY;
      this.imZ -= right.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#preSubtractQuaternion
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Quaternion} left Left operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preSubtractQuaternion(left) {
      this.re = left.re - this.re;
      this.imX = left.imX - this.imX;
      this.imY = left.imY - this.imY;
      this.imZ = left.imZ - this.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#subtractNumber
     * @desc Result is placed into `this`.
     * @param {number} right Right operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    subtractNumber(right) {
      this.re -= right;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#preSubtractNumber
     * @desc Result is placed into `this`.
     * @param {number} left Left operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preSubtractNumber(left) {
      this.re = left - this.re;
      this.imX = -this.imX;
      this.imY = -this.imY;
      this.imZ = -this.imZ;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#multiplyQuaternion
     * @desc Composes transformations left to right. Result is placed into `this`.
     * @param {module:@wgetemp/math.Quaternion} right Right operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    multiplyQuaternion(right) {
      return multiply(this, this, right);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#preMultiplyQuaternion
     * @desc Composes transformations left to right. Result is placed into `this`.
     * @param {module:@wgetemp/math.Quaternion} left Left operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preMultiplyQuaternion(left) {
      return multiply(this, left, this);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#multiplyNumber
     * @desc Result is placed into `this`.
     * @param {number} that Other operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    multiplyNumber(that) {
      this.re *= that;
      this.imX *= that;
      this.imY *= that;
      this.imZ *= that;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#divideNumber
     * @desc Result is placed into `this`.
     * @param {number} right Right operand.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    divideNumber(right) {
      return this.multiplyNumber(1 / right);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#imPaste
     * @summary Paste imaginary components into a vector.
     * @param {module:@wgetemp/math.Vector3} im Destination vector.
     * @returns {module:@wgetemp/math.Vector3} `im`
     */


    imPaste(im) {
      im.x = this.imX;
      im.y = this.imY;
      im.z = this.imZ;
      return im;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#imPaste
     * @summary Sets imaginary components from vector.
     * @desc Real component is not modified.
     * @param {module:@wgetemp/math.Vector3} im Source vector.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    imCopy(im) {
      this.imX = im.x;
      this.imY = im.y;
      this.imZ = im.z;
      return this;
    }
    /**
     * @var module:@wgetemp/math.Quaternion#sqAbs
     * @summary Squared absolute value (magnitude) of quaternion.
     * @type {number}
     */


    get sqAbs() {
      const re = this.re,
            imX = this.imX,
            imY = this.imY,
            imZ = this.imZ;
      return re * re + imX * imX + imY * imY + imZ * imZ;
    }

    set sqAbs(newSqAbs) {
      this.multiplyNumber(Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(newSqAbs / this.sqAbs));
    }
    /**
     * @var module:@wgetemp/math.Quaternion#abs
     * @summary Absolute value (magnitude aka norm) of quaternion.
     * @type {number}
     */


    get abs() {
      return Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(this.sqAbs);
    }

    set abs(newAbs) {
      this.multiplyNumber(newAbs / this.abs);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#normalize
     * @desc In place.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    normalize() {
      return this.divideNumber(this.abs);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromUniformScaling
     * @summary Initialize `this` with uniform scaling transformation.
     * @param {number} factor Uniform scaling factor.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromUniformScaling(scaling) {
      return this.fromNumber(Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(scaling));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#scaleUniform
     * @summary Apply uniform scaling transformation to `this`.
     * @param {number} factor Uniform scaling factor.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    scaleUniform(scaling) {
      return this.multiplyNumber(Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(scaling));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromRotation
     * @summary Initialize `this` with rotation transformation.
     * @param {number} angle Rotation angle (in radians).
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromRotation(angle, axis) {
      const halfAngle = angle * 0.5;
      const minusSin = -Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sin */ "F"])(halfAngle);
      this.re = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* cos */ "h"])(halfAngle);
      this.imX = minusSin * axis.x;
      this.imY = minusSin * axis.y;
      this.imZ = minusSin * axis.z;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#rotate
     * @summary (Post-)apply rotation transformation to `this`.
     * @param {number} angle Rotation angle (in radians).
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    rotate(angle, axis) {
      return this.multiply(tmp.fromRotation(angle, axis));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#preRotate
     * @summary Pre-apply rotation transformation to `this`.
     * @param {number} angle Rotation angle (in radians).
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preRotate(angle, axis) {
      return this.preMultiply(tmp.fromRotation(angle, axis));
    }
    /**
     * @var module:@wgetemp/math.Quaternion#rotationAngle
     * @summary Rotation angle (in radians).
     * @type {number}
     */


    get rotationAngle() {
      return 2 * Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* acos */ "b"])(this.re / this.abs);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#rotationAxisPaste
     * @summary Paste rotation axis into a vector.
     * @param {module:@wgetemp/math.Vector3} axis Destination vector.
     * @returns {module:@wgetemp/math.Vector3} `axis`
     */


    rotationAxisPaste(axis) {
      return this.imPaste(axis).negate().normalize();
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromRotationBetween
     * @summary Initialize `this` with rotation transformation required to
     * align `from` with `to`.
     * @param {module:@wgetemp/math.Vector3} from Initial direction.
     * Must have unit length.
     * @param {module:@wgetemp/math.Vector3} to Final direction.
     * Must have unit length.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromRotationBetween(from, to) {
      this.re = from.dot(to) + 1;
      this.imCopy(im.copy(to).cross(from));
      this.normalize();

      if (!this.everyIsFinite) {
        this.re = 0;
        this.imCopy(im.copy(from).orthogonalize());
      }

      return this;
    }
    /**
     * @function module:@wgetemp/math.Quaternion#rotateBetween
     * @summary (Post-)apply rotation transformation required to align `from` with `to`.
     * @param {module:@wgetemp/math.Vector3} from Initial direction.
     * Must have unit length.
     * @param {module:@wgetemp/math.Vector3} to Final direction.
     * Must have unit length.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    rotateBetween(from, to) {
      return this.multiply(tmp.fromRotationBetween(from, to));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#preRotateBetween
     * @summary Pre-apply rotation transformation required to align `from` with `to`.
     * @param {module:@wgetemp/math.Vector3} from Initial direction.
     * Must have unit length.
     * @param {module:@wgetemp/math.Vector3} to Final direction.
     * Must have unit length.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preRotateBetween(from, to) {
      return this.preMultiply(tmp.fromRotationBetween(from, to));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#fromComplex
     * @summary Initialize `this` with transformation encoded in
     * {module:@wgetemp/math.Complex} about given axis.
     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    fromComplex(complex, axis) {
      return this.fromRotation(complex.rotationAngle, axis).scaleUniform(complex.uniformScaling);
    }
    /**
     * @function module:@wgetemp/math.Quaternion#applyComplex
     * @summary (Post-)apply transformation encoded in
     * {module:@wgetemp/math.Complex} about given axis.
     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    applyComplex(complex, axis) {
      return this.multiply(tmp.fromComplex(complex, axis));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#applyComplex
     * @summary Pre-apply transformation encoded in
     * {module:@wgetemp/math.Complex} about given axis.
     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.
     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.
     * @returns {module:@wgetemp/math.Quaternion} `this`
     */


    preApplyComplex(complex, axis) {
      return this.preMultiply(tmp.fromComplex(complex, axis));
    }
    /**
     * @function module:@wgetemp/math.Quaternion#complexPaste
     * @summary Paste transformation within the plane othrogonal to rotation axis.
     * @param {module:@wgetemp/math.Complex} axis Destination complex.
     * @returns {module:@wgetemp/math.Complex} `complex`
     */


    complexPaste(complex) {
      const re = this.re,
            imX = this.imX,
            imY = this.imY,
            imZ = this.imZ;
      const sqIm = imX * imX + imY * imY + imZ * imZ;
      complex.re = re * re - sqIm;
      complex.im = 2 * re * Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(sqIm);
      return complex;
    }

  }

  const tmp = new Quaternion();
  const aliasProperty = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__[/* makePropertyAliaser */ "a"](Quaternion.prototype);
  /**
   * @function module:@wgetemp/math.Quaternion#copy
   * @summary Set quaternion from another quaternion.
   * @desc Alias for {@link module:@wgetemp/math.Quaternion#fromQuaternion}.
   * @param {module:@wgetemp/math.Quaternion} quaternion Source quaternion.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('fromQuaternion', 'copy');

  for (const fn of [_functions__WEBPACK_IMPORTED_MODULE_2__[/* isNaN */ "s"], _functions__WEBPACK_IMPORTED_MODULE_2__[/* isFinite */ "q"]]) {
    const Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_1__[/* toTitleCase */ "a"])(fn.name);
    Object.defineProperties(Quaternion.prototype, {
      [`some${Name}`]: {
        configurable: true,

        get() {
          return fn(this.re) || fn(this.imX) || fn(this.imY) || fn(this.imZ);
        }

      },
      [`every${Name}`]: {
        configurable: true,

        get() {
          return fn(this.re) && fn(this.imX) && fn(this.imY) && fn(this.imZ);
        }

      }
    });
  }
  /**
   * @var module:@wgetemp/math.Quaternion#someIsNaN
   * @summary Whether some component {@link module:@wgetemp/math.isNaN}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Quaternion#everyIsNaN
   * @summary Whether every component {@link module:@wgetemp/math.isNaN}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Quaternion#someIsFinite
   * @summary Whether some component {@link module:@wgetemp/math.isFinite}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Quaternion#everyIsFinite
   * @summary Whether every component {@link module:@wgetemp/math.isFinite}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @function module:@wgetemp/math.Quaternion#add
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#addQuaternion}
   * @param {module:@wgetemp/math.Quaternion} that Other operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */


  aliasProperty('addQuaternion', 'add');
  /**
   * @function module:@wgetemp/math.Quaternion#subtract
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#subtractQuaternion}
   * @param {module:@wgetemp/math.Quaternion} right Right operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('subtractQuaternion', 'subtract');
  /**
   * @function module:@wgetemp/math.Quaternion#preSubtract
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#preSubtractQuaternion}
   * @param {module:@wgetemp/math.Quaternion} left Left operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('preSubtractQuaternion', 'preSubtract');
  /**
   * @function module:@wgetemp/math.Quaternion#multiply
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#multiplyQuaternion}
   * @param {module:@wgetemp/math.Quaternion} right Right operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('multiplyQuaternion', 'multiply');
  /**
   * @function module:@wgetemp/math.Quaternion#applyQuaternion
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#multiplyQuaternion}
   * @param {module:@wgetemp/math.Quaternion} right Right operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('multiplyQuaternion', 'applyQuaternion');
  /**
   * @function module:@wgetemp/math.Quaternion#apply
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#multiply}
   * @param {module:@wgetemp/math.Quaternion} right Right operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('multiply', 'apply');
  /**
   * @function module:@wgetemp/math.Quaternion#preMultiply
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiplyQuaternion}
   * @param {module:@wgetemp/math.Quaternion} left Left operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('preMultiplyQuaternion', 'preMultiply');
  /**
   * @function module:@wgetemp/math.Quaternion#preApplyQuaternion
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiplyQuaternion}
   * @param {module:@wgetemp/math.Quaternion} left Left operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('preMultiplyQuaternion', 'preApplyQuaternion');
  /**
   * @function module:@wgetemp/math.Quaternion#preApply
   * @desc Composes transformations left to right. Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiply}
   * @param {module:@wgetemp/math.Quaternion} left Left operand.
   * @returns {module:@wgetemp/math.Quaternion} `this`
   */

  aliasProperty('preMultiply', 'preApply');
  /**
   * @var module:@wgetemp/math.Quaternion#uniformScaling
   * @summary Uniform scaling factor.
   * @desc Alias for {@link module:@wgetemp/math.Quaternion#sqAbs}
   * @type {number}
   */

  aliasProperty('sqAbs', 'uniformScaling');
  return Quaternion;
})();

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Event; });
/* harmony import */ var _wgetemp_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class Event extends _wgetemp_event__WEBPACK_IMPORTED_MODULE_0__[/* Event */ "a"] {
  constructor() {
    super();

    _defineProperty(this, "_targetHandlers", void 0);

    _defineProperty(this, "_handlers", void 0);

    this._handlers = new Map(); // Duplicate from WGEvent

    this._targetHandlers = new Map();
  }

  subscribe(...args) {
    /* eslint-disable-line @typescript-eslint/no-explicit-any */
    if (typeof args[0] === 'function') {
      super.subscribe(args[0], args[1]);
      return;
    }

    if (typeof args[1] === 'function') {
      this.subscribeTarget(args[0], args[1], args[2]);
    }
  }

  subscribeTarget(target, handler, {
    once = false
  } = {}) {
    if (!this._targetHandlers.get(target)) {
      this._targetHandlers.set(target, new Map());
    }

    this._targetHandlers.get(target).set(handler, once);
  }

  unsubscribeAll() {
    super.unsubscribeAll();

    this._targetHandlers.clear();
  }

  unsubscribeTarget(target) {
    this._targetHandlers.delete(target);
  }

  emit(...args) {
    return super.emit(...args);
  }

  async emitAsync(...args) {
    const handlers = this._handlers;
    const isReceived = handlers.size > 0;
    const promises = [];

    for (const [handler, once] of handlers) {
      if (once) {
        handlers.delete(handler);
      }

      promises.push(handler(...args));
    }

    await Promise.all(promises);
    return isReceived;
  }

  emitTarget(target, ...args) {
    const handlers = this._targetHandlers.get(target);

    if (!handlers) {
      return false;
    }

    const isReceived = handlers.size > 0;

    for (const [handler, once] of handlers) {
      if (once) {
        handlers.delete(handler);
      }

      try {
        handler(...args);
      } catch (error) {
        console.error(error);
      }
    }

    return isReceived;
  }

}

/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Complex; });
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/* harmony import */ var _to_title_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);



const Complex = (() => {
  /**
   * @class module:@wgetemp/math.Complex
   * @summary Complex number. Used for representing 2D rotations and uniform
   *     scaling.
   * @param {number} [re=1] Real component.
   * @param {number} [im=0] Imaginary component.
   */
  class Complex {
    constructor(re = 1, im = 0) {
      /**
       * @var module:@wgetemp/math.Complex#re
       * @summary Real component.
       * @type {number}
       */
      this.re = re;
      /**
       * @var module:@wgetemp/math.Complex#im
       * @summary Imaginary component.
       * @type {number}
       */

      this.im = im;
    }
    /**
     * @function module:@wgetemp/math.Complex#set
     * @summary Set complex components.
     * @param {number} re Real component.
     * @param {number} im Imaginary component.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    set(re, im) {
      this.re = re;
      this.im = im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromNumber
     * @summary Set complex from real number.
     * @desc ```
     * this.re = re;
     * this.im = 0;
     * ```
     * @param {number} re Real component.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromNumber(re) {
      this.re = re;
      this.im = 0;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromComplex
     * @summary Set complex from another complex.
     * @param {module:@wgetemp/math.Complex} complex Source complex.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromComplex(complex) {
      this.re = complex.re;
      this.im = complex.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromVector2
     * @summary Set complex from 2D vector.
     * @desc ```
     * this.re = vector.x;
     * this.im = vector.y;
     * ```
     * @param {module:@wgetemp/math.Vector2} complex Source vector.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromVector2(vector) {
      this.re = vector.x;
      this.im = vector.y;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromArray
     * @summary Set complex from array.
     * @desc ```
     * this.re = array[0];
     * this.im = array[1];
     * ```
     * @param {ArrayLike} array Source array. Must have at least two elements.
     * First two elements must be numbers.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromArray(array) {
      this.re = array[0];
      this.im = array[1];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromArrayAt
     * @summary Set complex from array at given offset.
     * @desc ```
     * this.re = array[offset    ];
     * this.im = array[offset + 1];
     * ```
     * @param {number} offset Where in the array to take values from.
     * @param {ArrayLike} array Source array. Must have at least (`offset` + 2) elements.
     * Two elements starting at `offset` must be numbers.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromArrayAt(offset, array) {
      this.re = array[offset];
      this.im = array[offset + 1];
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#toArray
     * @summary Put complex elements into array.
     * @desc ```
     * array[0] = this.re;
     * array[1] = this.im;
     * ```
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toArray(array) {
      array[0] = this.re;
      array[1] = this.im;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Complex#toArrayAt
     * @summary Put complex elements into array at given offset.
     * @desc ```
     * array[offset    ] = this.re;
     * array[offset + 1] = this.im;
     * ```
     * @param {number} offset Where in the array to put values to.
     * @param {ArrayLike} array Destination array.
     * @returns {ArrayLike} `array`
     */


    toArrayAt(offset, array) {
      array[offset] = this.re;
      array[offset + 1] = this.im;
      return array;
    }
    /**
     * @function module:@wgetemp/math.Complex#clone
     * @returns {module:@wgetemp/math.Complex}
     */


    clone() {
      return new Complex().copy(this);
    }
    /**
     * @function module:@wgetemp/math.Complex#equals
     * @param {module:@wgetemp/math.Complex} that Other complex.
     * @returns {boolean} Whether `this` components are equal to `that`
     * components.
     */


    equals(that) {
      return this.re === that.re && this.im === that.im;
    }
    /**
     * @function module:@wgetemp/math.Complex#negate
     * @desc In place.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    negate() {
      this.re = -this.re;
      this.im = -this.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#invert
     * @desc In place.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    invert() {
      const re = this.re,
            im = this.im;
      const invSqAbs = 1 / this.sqAbs;
      this.re *= invSqAbs;
      this.im *= -invSqAbs;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#addComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} that Other operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    addComplex(that) {
      this.re += that.re;
      this.im += that.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#addNumber
     * @desc Result is placed into `this`.
     * @param {number} that Other operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    addNumber(that) {
      this.re += that;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#subtractComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} right Right operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    subtractComplex(right) {
      this.re -= right.re;
      this.im -= right.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#preSubtractComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} left Left operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    preSubtractComplex(left) {
      this.re = left.re - this.re;
      this.im = left.im - this.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#subtractNumber
     * @desc Result is placed into `this`.
     * @param {number} right Right operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    subtractNumber(right) {
      this.re -= right;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#preSubtractNumber
     * @desc Result is placed into `this`.
     * @param {number} left Left operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    preSubtractNumber(left) {
      this.re = left - this.re;
      this.im = -this.im;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#multiplyComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} that Other operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    multiplyComplex(that) {
      const aRe = this.re,
            aIm = this.im;
      const bRe = that.re,
            bIm = that.im;
      this.re = aRe * bRe - aIm * bIm;
      this.im = aRe * bIm + aIm * bRe;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#multiplyNumber
     * @desc Result is placed into `this`.
     * @param {number} that Other operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    multiplyNumber(that) {
      this.re *= that;
      this.im *= that;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#divideComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} right Right operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    divideComplex(right) {
      return this.multiplyComplex(tmp.copy(right).invert());
    }
    /**
     * @function module:@wgetemp/math.Complex#preDivideComplex
     * @desc Result is placed into `this`.
     * @param {module:@wgetemp/math.Complex} left Left operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    preDivideComplex(left) {
      return this.invert().multiplyComplex(left);
    }
    /**
     * @function module:@wgetemp/math.Complex#divideNumber
     * @desc Result is placed into `this`.
     * @param {number} right Right operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    divideNumber(right) {
      return this.multiplyNumber(1 / right);
    }
    /**
     * @function module:@wgetemp/math.Complex#preDivideNumber
     * @desc Result is placed into `this`.
     * @param {number} left Left operand.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    preDivideNumber(left) {
      return this.invert().multiplyNumber(left);
    }
    /**
     * @var module:@wgetemp/math.Complex#sqAbs
     * @summary Squared absolute value (magnitude) of complex number.
     * @type {number}
     */


    get sqAbs() {
      const re = this.re,
            im = this.im;
      return re * re + im * im;
    }

    set sqAbs(newSqAbs) {
      this.multiplyNumber(Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(newSqAbs / this.sqAbs));
    }
    /**
     * @var module:@wgetemp/math.Complex#abs
     * @summary Absolute value (magnitude) of complex number.
     * @type {number}
     */


    get abs() {
      return Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sqrt */ "H"])(this.sqAbs);
    }

    set abs(newAbs) {
      this.multiplyNumber(newAbs / this.abs);
    }
    /**
     * @var module:@wgetemp/math.Complex#arg
     * @summary Argument (rotation angle in radians) of complex number.
     * @type {number}
     */


    get arg() {
      return Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* atan2 */ "c"])(this.im, this.re);
    }

    set arg(newArg) {
      const abs = this.abs;
      this.re = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* cos */ "h"])(newArg) * abs;
      this.im = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sin */ "F"])(newArg) * abs;
    }
    /**
     * @function module:@wgetemp/math.Complex#normalize
     * @desc In place.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    normalize() {
      return this.divideNumber(this.abs);
    }
    /**
     * @function module:@wgetemp/math.Complex#fromRotation
     * @summary Initialize `this` with rotation transformation.
     * @param {number} angle Rotation angle (in radians).
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromRotation(angle) {
      this.re = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* cos */ "h"])(angle);
      this.im = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sin */ "F"])(angle);
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#rotate
     * @summary Apply rotation transformation to `this`.
     * @param {number} angle Rotation angle (in radians).
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    rotate(angle) {
      const re = this.re,
            im = this.im;
      const s = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* sin */ "F"])(angle),
            c = Object(_functions__WEBPACK_IMPORTED_MODULE_2__[/* cos */ "h"])(angle);
      this.re = re * c - im * s;
      this.im = re * s + im * c;
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#fromRotationBetween
     * @summary Initialize `this` with rotation transformation required to
     * align `from` with `to`.
     * @param {module:@wgetemp/math.Vector2} from Initial direction.
     * Must have unit length.
     * @param {module:@wgetemp/math.Vector2} to Final direction.
     * Must have unit length.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    fromRotationBetween(from, to) {
      this.re = from.dot(to);
      this.im = from.cross(to);
      return this;
    }
    /**
     * @function module:@wgetemp/math.Complex#rotateBetween
     * @summary Apply rotation transformation required to align `from` with `to`.
     * @param {module:@wgetemp/math.Vector2} from Initial direction.
     * Must have unit length.
     * @param {module:@wgetemp/math.Vector2} to Final direction.
     * Must have unit length.
     * @returns {module:@wgetemp/math.Complex} `this`
     */


    rotateBetween(from, to) {
      const re = this.re,
            im = this.im;
      const s = from.dot(to),
            c = from.cross(to);
      this.re = re * c - im * s;
      this.im = re * s + im * c;
      return this;
    }

  }

  const tmp = new Complex();
  const aliasProperty = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__[/* makePropertyAliaser */ "a"](Complex.prototype);
  aliasProperty('fromComplex', 'copy');
  aliasProperty('fromVector2', 'fromVector');

  for (const fn of [_functions__WEBPACK_IMPORTED_MODULE_2__[/* isNaN */ "s"], _functions__WEBPACK_IMPORTED_MODULE_2__[/* isFinite */ "q"]]) {
    const Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_1__[/* toTitleCase */ "a"])(fn.name);
    Object.defineProperties(Complex.prototype, {
      [`some${Name}`]: {
        configurable: true,

        get() {
          return fn(this.re) || fn(this.im);
        }

      },
      [`every${Name}`]: {
        configurable: true,

        get() {
          return fn(this.re) && fn(this.im);
        }

      }
    });
  }
  /**
   * @var module:@wgetemp/math.Complex#someIsNaN
   * @summary Whether some component {@link module:@wgetemp/math.isNaN}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Complex#everyIsNaN
   * @summary Whether every component {@link module:@wgetemp/math.isNaN}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Complex#someIsFinite
   * @summary Whether some component {@link module:@wgetemp/math.isFinite}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @var module:@wgetemp/math.Complex#everyIsFinite
   * @summary Whether every component {@link module:@wgetemp/math.isFinite}.
   * @type {boolean}
   * @readonly
   */

  /**
   * @function module:@wgetemp/math.Complex#add
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#addComplex}.
   * @param {module:@wgetemp/math.Complex} that Other operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */


  aliasProperty('addComplex', 'add');
  /**
   * @function module:@wgetemp/math.Complex#subtract
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#subtractComplex}.
   * @param {module:@wgetemp/math.Complex} right Right operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('subtractComplex', 'subtract');
  /**
   * @function module:@wgetemp/math.Complex#preSubtract
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#preSubtractComplex}.
   * @param {module:@wgetemp/math.Complex} left Left operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('preSubtractComplex', 'preSubtract');
  /**
   * @function module:@wgetemp/math.Complex#multiply
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#multiplyComplex}.
   * @param {module:@wgetemp/math.Complex} that Other operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('multiplyComplex', 'multiply');
  /**
   * @function module:@wgetemp/math.Complex#applyComplex
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#multiplyComplex}.
   * @param {module:@wgetemp/math.Complex} that Other operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('multiplyComplex', 'applyComplex');
  /**
   * @function module:@wgetemp/math.Complex#apply
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#multiply}.
   * @param {module:@wgetemp/math.Complex} that Other operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('multiply', 'apply');
  /**
   * @function module:@wgetemp/math.Complex#divide
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#divideComplex}.
   * @param {module:@wgetemp/math.Complex} right Right operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('divideComplex', 'divide');
  /**
   * @function module:@wgetemp/math.Complex#preDivide
   * @desc Result is placed into `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#preDivideComplex}.
   * @param {module:@wgetemp/math.Complex} left Left operand.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('preDivideComplex', 'preDivide');
  /**
   * @function module:@wgetemp/math.Complex#fromUniformScaling
   * @summary Initialize `this` with uniform scaling transformation.
   *
   * Alias for {@link module:@wgetemp/math.Complex#fromNumber}.
   * @param {number} uniformScaling Uniform scaling factor.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('fromNumber', 'fromUniformScaling');
  /**
   * @function module:@wgetemp/math.Complex#scaleUniform
   * @summary Apply uniform scaling transformation to `this`.
   *
   * Alias for {@link module:@wgetemp/math.Complex#multiplyNumber}.
   * @param {number} uniformScaling Uniform scaling factor.
   * @returns {module:@wgetemp/math.Complex} `this`
   */

  aliasProperty('multiplyNumber', 'scaleUniform');
  /**
   * @var module:@wgetemp/math.Complex#uniformScaling
   * @summary Uniform scaling factor.
   * @desc Alias for {@link module:@wgetemp/math.Complex#abs}.
   * @type {number}
   */

  aliasProperty('abs', 'uniformScaling');
  /**
   * @var module:@wgetemp/math.Complex#rotationAngle
   * @summary Rotation angle (in radians).
   * @desc Alias for {@link module:@wgetemp/math.Complex#arg}.
   * @type {number}
   */

  aliasProperty('arg', 'rotationAngle');
  return Complex;
})();

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ utils["b" /* IndustrialDotScene */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ utils["c" /* IndustrialRenderable */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ resources_Resources; });

// UNUSED EXPORTS: EnvironmentMapProperties, EnvironmentMaterialLoader, IBL, IBLLoader, ModelAssets, ModelLoader, TextureLoader, IndustrialPbrMeshMaterial, IndustrialUnlitMeshMaterial, IndustrialMaterialFactory, BatchMap, createImageFromBytes, load, loadImage, getReallocationStrategyByBatchSize, UniqueNameGenerator, adjustInternalFormat

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var lib = __webpack_require__(0);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/loader/index.js
var _wgetemp_loader = __webpack_require__(20);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_image_radiance_hdr/RGBELoader.js
var RGBELoader = __webpack_require__(88);

// CONCATENATED MODULE: ./src/core/resources/loaders/environment-material-loader.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class environment_material_loader_EnvironmentMaterialLoader extends lib["B" /* Loader */] {
  async load(src, options = {}) {
    const {
      luminance = 2048
    } = options;
    const legacyLoader = new _wgetemp_loader["a" /* Loader */]({
      type: Image
    });
    const result = await new RGBELoader["a" /* RGBELoader */]({
      loader: legacyLoader,
      src,
      luminance
    }).assets;
    const {
      customImageData,
      maxEnvLuminance
    } = result;
    const {
      width,
      height,
      depth,
      format,
      internalFormat,
      componentType
    } = customImageData;
    const {
      LINEAR,
      LINEAR_MIPMAP_LINEAR
    } = lib["gb" /* Texture */].Filter;
    const texture = new lib["gb" /* Texture */]({
      name: src.slice(-64) || '',
      width,
      height,
      depth,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
      minFilter: LINEAR_MIPMAP_LINEAR,
      magFilter: LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format,
      internalFormat,
      componentType,
      levelsData: [new lib["hb" /* TextureLevelData */]({
        data: customImageData
      })],
      dynamic: false
    });
    const environmentMap = new lib["D" /* Material */].EnvironmentMapProperties(luminance, maxEnvLuminance, texture);
    const environmentMaterial = new lib["s" /* EnvironmentMaterial */]({
      environmentMap
    });
    return environmentMaterial;
  }

  async parse(id, environmentMaterial) {
    this.core.addResource('environment-material', id, environmentMaterial);
    return Promise.resolve(environmentMaterial);
  }

}

_defineProperty(environment_material_loader_EnvironmentMaterialLoader, "ID", 'environment-material');
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/index.js + 8 modules
var procedural_geometry_src = __webpack_require__(29);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/convolution-routine.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





function _getMipmapsCount(w, h, d, bindingPoint, webgl2Support) {
  if (!(Object(math_lib["u" /* isPow2 */])(w) && Object(math_lib["u" /* isPow2 */])(h) && Object(math_lib["u" /* isPow2 */])(d)) && !webgl2Support) {
    return 1;
  }

  let maxsize = Math.max(w, h);

  if (bindingPoint === lib["gb" /* Texture */].BindingPoint.TEXTURE_3D) {
    maxsize = Math.max(maxsize, d);
  }

  return Math.floor(Math.log2(maxsize)) + 1;
}

const minimalSystemSet = new Set(['draw', 'cubeCamera', 'mesh']);

class convolution_routine_ConvolutionRoutine {
  constructor({
    core,
    vertexStaging,
    elementStaging,
    vertexHardwareBuffer = null,
    indexHardwareBuffer = null,
    environmentMap,
    convolutionMapSize = 32,
    preFilteredEnvMapSize = 512,
    brdfMapSize = 512,
    samplesNumber = 256,
    samplingDelta = Math.PI / 32
  }) {
    this.core = core;
    this.vertexStaging = vertexStaging;
    this.elementStaging = elementStaging;
    this.vertexHardwareBuffer = vertexHardwareBuffer;
    this.indexHardwareBuffer = indexHardwareBuffer;
    this.environmentMap = environmentMap;
    this.samplesNumber = samplesNumber;
    this.samplingDelta = samplingDelta;
    this._iblMaps = [convolutionMapSize > 0 ? this._convoluteRadianceMap(convolutionMapSize) : null, this._preFilterEnvMap(preFilteredEnvMapSize), this._convoluteBRDF(brdfMapSize)];
  }

  get assets() {
    return this._iblMaps;
  }

  _convoluteRadianceMap(size) {
    const width = size;
    const height = size;
    const depth = 1;
    const core = this.core,
          vertexStaging = this.vertexStaging,
          elementStaging = this.elementStaging,
          vertexHardwareBuffer = this.vertexHardwareBuffer,
          indexHardwareBuffer = this.indexHardwareBuffer,
          environmentMap = this.environmentMap;
    const capabilities = core.renderer.capabilities;
    const webgl2Support = capabilities.webgl2Support,
          colorBufferHalfFloatSupport = capabilities.colorBufferHalfFloatSupport;
    const texture = new lib["gb" /* Texture */]({
      name: environmentMap.name + '-radiance-convolution',
      width,
      height,
      depth,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP,
      magFilter: lib["gb" /* Texture */].Filter.LINEAR,
      minFilter: lib["gb" /* Texture */].Filter.LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: lib["N" /* PixelDataFormat */].RGBA,
      internalFormat: webgl2Support && colorBufferHalfFloatSupport ? lib["v" /* InternalFormat */].RGBA16F : lib["v" /* InternalFormat */].RGBA,
      componentType: webgl2Support && colorBufferHalfFloatSupport ? lib["n" /* DataType */].HALF_FLOAT : lib["n" /* DataType */].UNSIGNED_BYTE
      /* HALF_FLOAT */
      ,
      levels: 1
    });
    const renderTarget = new lib["T" /* RenderTargetCube */]({
      width,
      height
    });
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, texture);
    const scene = new lib["Y" /* Scene */]({
      maxSceneNodes: 4,
      config: {
        componentClasses: [...this.core.getComponentClassList()]
      }
    });
    const camera = new lib["k" /* CubeCamera */]({
      name: 'cube-camera-radiance-convolution'
    });
    {
      const node = scene.root.createChild({});
      const transform = new lib["jb" /* Transform */]();
      node.attach(transform);
      node.attach(camera);
    }
    {
      const samplesNumber = this.samplesNumber,
            samplingDelta = this.samplingDelta;
      const material = new lib["i" /* ConvolutionMaterial */]({
        name: 'convolutionMaterial',
        environmentMap,
        defines: {
          RADIANCE_CONVOLUTION: ''
        },
        samplesNumber,
        samplingDelta
      });
      const mesh = Object(procedural_geometry_src["a" /* createBoxMesh */])({
        vertexStaging,
        elementStaging,
        vertexHardwareBuffer,
        indexHardwareBuffer,
        material
      });
      const node = scene.root.createChild({});
      node.attach(mesh);
      const transform = new lib["jb" /* Transform */]();
      node.attach(transform);
      const visibility = new lib["qb" /* Visibility */]({
        enableCulling: false
      });
      node.attach(visibility);
    }
    const rrs = core.renderRequests;
    const look = new lib["C" /* Look */]();
    look.isCamera = false;
    look.isCubeCamera = true;
    core.renderRequests = [new lib["S" /* RenderRequest */]({
      scene,
      look,
      renderTarget,
      autoResize: false,
      systems: minimalSystemSet
    })];
    core.drawFrame(0);
    core.renderRequests = rrs;
    return texture;
  }

  _preFilterEnvMap(size) {
    const core = this.core,
          vertexStaging = this.vertexStaging,
          elementStaging = this.elementStaging,
          vertexHardwareBuffer = this.vertexHardwareBuffer,
          indexHardwareBuffer = this.indexHardwareBuffer,
          environmentMap = this.environmentMap;
    const width = Math.min(environmentMap.width, size);
    const height = width;
    const depth = environmentMap.depth;
    const capabilities = core.renderer.capabilities;
    const webgl2Support = capabilities.webgl2Support,
          colorBufferHalfFloatSupport = capabilities.colorBufferHalfFloatSupport;
    const bindingPoint = lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP;

    const levels = _getMipmapsCount(width, height, depth, bindingPoint, webgl2Support);

    const colorAttachment = new lib["gb" /* Texture */]({
      name: `pre-filtered-envmap-${environmentMap.name}`,
      width,
      height,
      depth,
      bindingPoint,
      magFilter: lib["gb" /* Texture */].Filter.LINEAR,
      minFilter: lib["gb" /* Texture */].Filter.LINEAR_MIPMAP_LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: lib["N" /* PixelDataFormat */].RGBA,
      internalFormat: webgl2Support && colorBufferHalfFloatSupport ? lib["v" /* InternalFormat */].RGBA16F : lib["v" /* InternalFormat */].RGBA,
      componentType: webgl2Support && colorBufferHalfFloatSupport ? lib["n" /* DataType */].HALF_FLOAT : lib["n" /* DataType */].UNSIGNED_BYTE
      /* HALF_FLOAT */

    });
    const roughnesses = Array(...Array(levels)).map((el, i) => i / (levels - 1));
    const scene = new lib["Y" /* Scene */]({
      maxSceneNodes: 4,
      config: {
        componentClasses: [...this.core.getComponentClassList()]
      }
    });
    const camera = new lib["k" /* CubeCamera */]({
      name: 'pre-filtering-cube-camera'
    });
    {
      const transform = new lib["jb" /* Transform */]();
      const node = scene.root.createChild({});
      node.attach(camera);
      node.attach(transform);
    }
    const samplesNumber = this.samplesNumber,
          samplingDelta = this.samplingDelta;
    const material = new lib["i" /* ConvolutionMaterial */]({
      name: 'pre-filtering-envmap',
      environmentMap,
      defines: {
        PRE_FILTERING_ENV_MAP: ''
      },
      samplesNumber,
      samplingDelta
    });
    {
      const transform = new lib["jb" /* Transform */]();
      const mesh = Object(procedural_geometry_src["a" /* createBoxMesh */])({
        vertexStaging,
        elementStaging,
        vertexHardwareBuffer,
        indexHardwareBuffer,
        material
      });
      const node = scene.root.createChild({});
      node.attach(transform);
      node.attach(mesh);
    }
    const renderTarget = new lib["T" /* RenderTargetCube */]({
      width,
      height
    });

    if (webgl2Support) {
      for (const _ref of roughnesses.entries()) {
        var _ref2 = _slicedToArray(_ref, 2);

        const level = _ref2[0];
        const roughness = _ref2[1];
        renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, colorAttachment, level);
        material.roughness = roughness;
        core.renderer.state.viewport = {
          x: 0,
          y: 0,
          width: width >> level,
          height: height >> level
        };
        const rrs = core.renderRequests;
        const look = new lib["C" /* Look */]();
        look.isCamera = false;
        look.isCubeCamera = true;
        core.renderRequests = [new lib["S" /* RenderRequest */]({
          scene,
          look,
          renderTarget,
          autoResize: false,
          systems: minimalSystemSet
        })];
        core.drawFrame(0);
        core.renderRequests = rrs;
      }
    } else {
      for (const _ref3 of roughnesses.entries()) {
        var _ref4 = _slicedToArray(_ref3, 2);

        const level = _ref4[0];
        const roughness = _ref4[1];

        this._auxiliaryRoutine(colorAttachment, level, roughness, width >> level, height >> level);
      }
    }

    return colorAttachment;
  }

  _convoluteBRDF(size) {
    const core = this.core,
          vertexStaging = this.vertexStaging,
          elementStaging = this.elementStaging,
          environmentMap = this.environmentMap,
          vertexHardwareBuffer = this.vertexHardwareBuffer,
          indexHardwareBuffer = this.indexHardwareBuffer;
    const width = size;
    const height = size;
    const capabilities = core.renderer.capabilities;
    const webgl2Support = capabilities.webgl2Support,
          colorBufferHalfFloatSupport = capabilities.colorBufferHalfFloatSupport;
    const brdfLUT = new lib["gb" /* Texture */]({
      name: 'BRDF-convolution-LUT',
      width,
      height,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
      magFilter: lib["gb" /* Texture */].Filter.LINEAR,
      minFilter: lib["gb" /* Texture */].Filter.LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: webgl2Support && colorBufferHalfFloatSupport ? lib["N" /* PixelDataFormat */].RG : lib["N" /* PixelDataFormat */].RGBA,
      internalFormat: webgl2Support && colorBufferHalfFloatSupport ? lib["v" /* InternalFormat */].RG16F : lib["v" /* InternalFormat */].RGBA,
      componentType: webgl2Support && colorBufferHalfFloatSupport ? lib["n" /* DataType */].HALF_FLOAT : lib["n" /* DataType */].UNSIGNED_BYTE
      /* HALF_FLOAT */
      ,
      levels: 1
    });
    const renderTarget = new lib["U" /* RenderTargetFramebuffer */]({
      width,
      height
    });
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, brdfLUT);
    const scene = new lib["Y" /* Scene */]({
      maxSceneNodes: 2,
      config: {
        componentClasses: [...this.core.getComponentClassList()]
      }
    });
    const camera = new lib["f" /* Camera */]({
      name: 'camera-BRDF-convolution'
    });
    {
      const transform = new lib["jb" /* Transform */]();
      const node = scene.root.createChild({});
      node.attach(transform);
      node.attach(camera);
    }
    {
      const transform = new lib["jb" /* Transform */]();
      const node = scene.root.createChild({});
      node.attach(transform);
      const samplesNumber = this.samplesNumber,
            samplingDelta = this.samplingDelta;
      const material = new lib["i" /* ConvolutionMaterial */]({
        name: 'BRDFConvolutionMaterial',
        environmentMap,
        defines: {
          BRDF_CONVOLUTION: ''
        },
        samplesNumber,
        samplingDelta
      });
      const mesh = Object(procedural_geometry_src["c" /* createPlaneMesh */])({
        width: 20,
        height: 20,
        vertexStaging,
        elementStaging,
        vertexHardwareBuffer,
        indexHardwareBuffer,
        material
      });
      node.attach(mesh);
      const visibility = new lib["qb" /* Visibility */]({
        enableCulling: false
      });
      node.attach(visibility);
    }
    const rrs = core.renderRequests;
    core.renderRequests = [new lib["S" /* RenderRequest */]({
      scene,
      look: new lib["C" /* Look */](),
      renderTarget,
      autoResize: false,
      systems: minimalSystemSet
    })];
    core.drawFrame(0);
    core.renderRequests = rrs;
    return brdfLUT;
  }

  _auxiliaryRoutine(dst, level, roughness, width, height) {
    const core = this.core,
          vertexStaging = this.vertexStaging,
          elementStaging = this.elementStaging,
          vertexHardwareBuffer = this.vertexHardwareBuffer,
          indexHardwareBuffer = this.indexHardwareBuffer,
          environmentMap = this.environmentMap;
    const colorAttachment = new lib["gb" /* Texture */]({
      name: environmentMap.name + '-pre-filtered-envmap-' + level,
      width,
      height,
      depth: 1,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP,
      magFilter: lib["gb" /* Texture */].Filter.LINEAR,
      minFilter: lib["gb" /* Texture */].Filter.LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: lib["N" /* PixelDataFormat */].RGBA,
      internalFormat: lib["v" /* InternalFormat */].RGBA,
      componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
      levels: 1
    });
    const internalFormat = colorAttachment.internalFormat;
    const scene = new lib["Y" /* Scene */]({
      maxSceneNodes: 4,
      config: {
        componentClasses: [...this.core.getComponentClassList()]
      }
    });
    const camera = new lib["k" /* CubeCamera */]({
      name: 'cube-camera-hack-' + level
    });
    {
      const transform = new lib["jb" /* Transform */]();
      const node = scene.root.createChild({});
      node.attach(transform);
      node.attach(camera);
    }
    const samplesNumber = this.samplesNumber,
          samplingDelta = this.samplingDelta;
    const material = new lib["i" /* ConvolutionMaterial */]({
      name: 'pre-filtering-envmap-hack-' + level,
      environmentMap,
      defines: {
        PRE_FILTERING_ENV_MAP: ''
      },
      samplesNumber,
      samplingDelta
    });
    material.roughness = roughness;
    {
      const transform = new lib["jb" /* Transform */]();
      const mesh = Object(procedural_geometry_src["a" /* createBoxMesh */])({
        vertexStaging,
        elementStaging,
        vertexHardwareBuffer,
        indexHardwareBuffer,
        material
      });
      const node = scene.root.createChild({});
      node.attach(transform);
      node.attach(mesh);
    }
    const gl = core.renderer.context;

    const _core$renderer$_webGL = core.renderer._webGLTextures.getWebGLTexture(dst),
          webGLTexture = _core$renderer$_webGL.webGLTexture;

    const renderTarget = new lib["T" /* RenderTargetCube */]({
      width,
      height
    });
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, colorAttachment);
    const look = new lib["C" /* Look */]();
    look.isCamera = false;
    look.isCubeCamera = true;
    const renderRequest = new lib["S" /* RenderRequest */]({
      scene,
      look,
      renderTarget,
      autoResize: false,
      systems: minimalSystemSet
    });

    const callback = i => {
      if (renderRequest.look !== look) {
        return;
      }

      gl.bindTexture(lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP, webGLTexture);
      gl.copyTexImage2D(lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, internalFormat, 0, 0, width, height, 0);
    };

    renderRequest.onSubpassEnd.subscribe(callback);
    const rrs = core.renderRequests;
    core.renderRequests = [renderRequest];
    core.drawFrame(0);
    core.renderRequests = rrs;
    renderTarget.release();
  }

}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/panorama-to-cubemap.js



class panorama_to_cubemap_Panorama2Cubemap {
  constructor({
    core,
    vertexStaging,
    elementStaging,
    vertexHardwareBuffer = null,
    indexHardwareBuffer = null
  }) {
    const scene = new lib["Y" /* Scene */]({
      maxSceneNodes: 2,
      config: {
        componentClasses: [...core.getComponentClassList()]
      }
    });
    const camera = new lib["k" /* CubeCamera */]({
      name: 'panorama-to-cubemap-cube-camera'
    });
    {
      const node = scene.root.createChild({});
      const transform = new lib["jb" /* Transform */]();
      node.attach(transform);
      node.attach(camera);
    }
    const material = new lib["s" /* EnvironmentMaterial */]({
      name: 'panorama-to-cubemap',
      environmentMap: null
    });
    {
      const mesh = Object(procedural_geometry_src["a" /* createBoxMesh */])({
        vertexStaging,
        elementStaging,
        vertexHardwareBuffer,
        indexHardwareBuffer,
        material
      });
      const visibility = new lib["qb" /* Visibility */]({
        enableCulling: false
      });
      const transform = new lib["jb" /* Transform */]();
      const node = scene.root.createChild({});
      node.attach(transform);
      node.attach(mesh);
      node.attach(visibility);
    }
    this._scene = scene;

    this._scene.retain();

    this._core = core;
    this._camera = camera;
    this._material = material;
  }

  getCubeMap(environmentMap, size = undefined, mipmaps = true) {
    const _core = this._core,
          scene = this._scene,
          camera = this._camera,
          _material = this._material;
    let width = environmentMap.width,
        height = environmentMap.height;
    const minFilter = environmentMap.minFilter;
    _material.environmentMap = environmentMap;
    const mipmapFiltering = (minFilter === lib["gb" /* Texture */].Filter.NEAREST_MIPMAP_NEAREST || minFilter === lib["gb" /* Texture */].Filter.LINEAR_MIPMAP_NEAREST || minFilter === lib["gb" /* Texture */].Filter.NEAREST_MIPMAP_LINEAR || minFilter === lib["gb" /* Texture */].Filter.LINEAR_MIPMAP_LINEAR) && mipmaps;
    const depth = 1;

    if (typeof size === 'number') {
      width = size;
    } else {
      width = Math.min(width, height);
    }

    const exp = Math.floor(Math.log2(width));
    width = Math.pow(2, exp);
    height = width;
    const bindingPoint = lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP;
    const capabilities = _core.renderer.capabilities;
    const webgl2Support = capabilities.webgl2Support,
          colorBufferFloatSupport = capabilities.colorBufferFloatSupport,
          textureFloatLinearSupport = capabilities.textureFloatLinearSupport;
    const texture = new lib["gb" /* Texture */]({
      name: `cubemap-texture-${environmentMap.name}`,
      width,
      height,
      depth,
      bindingPoint,
      minFilter: mipmapFiltering && textureFloatLinearSupport ? minFilter : lib["gb" /* Texture */].Filter.NEAREST,
      magFilter: mipmapFiltering && textureFloatLinearSupport ? lib["gb" /* Texture */].Filter.LINEAR : lib["gb" /* Texture */].Filter.NEAREST,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: lib["N" /* PixelDataFormat */].RGBA,
      internalFormat: webgl2Support && colorBufferFloatSupport ? lib["v" /* InternalFormat */].RGBA32F : lib["v" /* InternalFormat */].RGBA,
      componentType: webgl2Support && colorBufferFloatSupport ? lib["n" /* DataType */].FLOAT : lib["v" /* InternalFormat */].UNSIGNED_BYTE
    });

    if (!mipmapFiltering) {
      texture.levels = 1;
    }

    const renderTarget = new lib["T" /* RenderTargetCube */]({
      width,
      height
    });
    const semantic = webgl2Support && colorBufferFloatSupport ? lib["L" /* OutputLayoutSemantic */].LINEAR_HDR_COLOR : lib["L" /* OutputLayoutSemantic */].CIE_LUV_COLOR;
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, texture, 0);
    const look = new lib["C" /* Look */]();
    look.isCamera = false;
    look.isCubeCamera = true;
    const renderRequest = new lib["S" /* RenderRequest */]({
      scene,
      look,
      renderTarget,
      autoResize: false,
      systems: new Set(['draw', 'cubeCamera', 'mesh'])
    });
    renderRequest.setOutputLayoutPosition(semantic, 0);
    const rrs = _core.renderRequests;
    _core.renderRequests = [renderRequest];

    _core.drawFrame(0);

    _core.renderRequests = rrs;

    if (mipmapFiltering && colorBufferFloatSupport && textureFloatLinearSupport) {
      _core.renderer.textures.generateMipMaps(texture);
    }

    texture.retain();
    renderTarget.release();
    return texture;
  }
  /**
   * @function module:@wgetemp/environment-routines.Panorama2Cubemap#dispose
   * @summary Disposes Panorama2Cubemap converter.
   */


  dispose() {
    this._scene.release();
  }

}


// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/enum/index.js
var _wgetemp_enum = __webpack_require__(74);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/tuple-map.js
var tuple_map = __webpack_require__(395);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/event/index.js
var _wgetemp_event = __webpack_require__(13);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/baseFlowPass.js


class baseFlowPass_BaseFlowPass {
  constructor(name, renderer) {
    this.name = name;
    this.inputs = [];
    this._output = null;
    this._renderer = renderer;
    this.onPassStart = new _wgetemp_event["a" /* Event */]();
    this.onPassEnd = new _wgetemp_event["a" /* Event */]();
  }

  updateInputs() {}

  get statistics() {
    return null;
  }

  async render(outputs) {}

}

/* harmony default export */ var baseFlowPass = (baseFlowPass_BaseFlowPass);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/clearPass.js



class clearPass_ClearPass extends baseFlowPass {
  constructor(name, renderer, clearMask) {
    super(name, renderer);
    const gl = renderer.context;
    this.clearMask = clearMask || gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;
    this._statistics = new lib["Q" /* RenderPassStatistics */]();
  }

  get statistics() {
    return this._statistics;
  }

  render(outputs) {
    const index = this._output,
          _renderer = this._renderer,
          clearMask = this.clearMask;
    const gl = _renderer.context;
    const display = index === null;
    const output = outputs[index];

    if (!display) {
      const _renderer$frameBuffer = _renderer.frameBuffers.getWebGLFramebuffer(output.back),
            webGLFramebuffer = _renderer$frameBuffer.webGLFramebuffer;

      gl.bindFramebuffer(gl.FRAMEBUFFER, webGLFramebuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    gl.clear(clearMask);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

}

/* harmony default export */ var clearPass = (clearPass_ClearPass);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/scenePass.js



class scenePass_ScenePass extends baseFlowPass {
  constructor({
    name,
    clearMask,
    renderer,
    scene,
    look,
    srgbOutput = false
  }) {
    super(name, renderer);
    this._renderPass = new lib["S" /* RenderRequest */]({
      scene,
      look,
      srgbOutput
    });

    if (clearMask !== undefined) {
      this._renderPass.clearMask = clearMask;
    }
  }

  get renderPass() {
    return this._renderPass;
  }

  get statistics() {
    return this._renderPass.statistics;
  }

  updateInputs(textures) {
    for (const input of this.inputs) {
      const index = input.index;
      input.set(index === undefined ? undefined : textures[index].front);
    }
  }

  render(outputs) {
    const _renderPass = this._renderPass,
          _renderer = this._renderer,
          index = this._output;
    const display = index === null;
    _renderPass.renderTarget = display ? null : outputs[index].back;

    _renderer.render(_renderPass);
  }

}

/* harmony default export */ var scenePass = (scenePass_ScenePass);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/outputPair.js
function outputPair_slicedToArray(arr, i) { return outputPair_arrayWithHoles(arr) || outputPair_iterableToArrayLimit(arr, i) || outputPair_unsupportedIterableToArray(arr, i) || outputPair_nonIterableRest(); }

function outputPair_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function outputPair_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return outputPair_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return outputPair_arrayLikeToArray(o, minLen); }

function outputPair_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function outputPair_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function outputPair_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

class OutputPair {
  constructor(frontTarget, backTarget = null) {
    this._passIndex = 0;
    this._doubleBuffering = backTarget !== null;
    this._outputs = [frontTarget, backTarget];
  }

  get front() {
    const _outputs = this._outputs,
          _passIndex = this._passIndex,
          _doubleBuffering = this._doubleBuffering;
    return _doubleBuffering ? _outputs[_passIndex] : _outputs[0];
  }

  get back() {
    const _outputs = this._outputs,
          _passIndex = this._passIndex,
          _doubleBuffering = this._doubleBuffering;
    return _doubleBuffering ? _outputs[1 - _passIndex] : _outputs[0];
  }

  swap() {
    const _doubleBuffering = this._doubleBuffering,
          _passIndex = this._passIndex;
    this._passIndex = _doubleBuffering ? 1 - _passIndex : 0;
  }

  dispose() {
    const _outputs = this._outputs;

    const _outputs2 = outputPair_slicedToArray(_outputs, 2),
          _outputs2$ = _outputs2[0],
          frontTarget = _outputs2$ === void 0 ? null : _outputs2$,
          _outputs2$2 = _outputs2[1],
          backTarget = _outputs2$2 === void 0 ? null : _outputs2$2;

    if (frontTarget !== null) {
      frontTarget.release();
    }

    if (backTarget !== null) {
      backTarget.release();
    }

    _outputs.length = 0;
  }

}

/* harmony default export */ var outputPair = (OutputPair);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/customPass.js



class customPass_CustomPass extends baseFlowPass {
  constructor(name, renderer, callback, flow) {
    super(name, renderer);
    this._flow = flow;
    this._callback = callback;
    this._statistics = new lib["Q" /* RenderPassStatistics */]();
  }

  render() {
    const _callback = this._callback,
          _flow = this._flow;

    _callback(_flow);
  }

  get statistics() {
    return this._statistics;
  }

}

/* harmony default export */ var customPass = (customPass_CustomPass);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/texturePair.js
class TexturePair {
  constructor(frontTexture, backTexture = null) {
    this._passIndex = 0;
    this._doubleBuffering = backTexture !== null;
    this._textures = [frontTexture, backTexture];
  }

  get front() {
    const _textures = this._textures,
          _passIndex = this._passIndex,
          _doubleBuffering = this._doubleBuffering;
    return _doubleBuffering ? _textures[_passIndex] : _textures[0];
  }

  get back() {
    const _textures = this._textures,
          _passIndex = this._passIndex,
          _doubleBuffering = this._doubleBuffering;
    return _doubleBuffering ? _textures[1 - _passIndex] : _textures[0];
  }

  swap() {
    const _doubleBuffering = this._doubleBuffering,
          _passIndex = this._passIndex;
    this._passIndex = _doubleBuffering ? 1 - _passIndex : 0;
  }

}

/* harmony default export */ var src_texturePair = (TexturePair);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/renderFlow.js
function renderFlow_slicedToArray(arr, i) { return renderFlow_arrayWithHoles(arr) || renderFlow_iterableToArrayLimit(arr, i) || renderFlow_unsupportedIterableToArray(arr, i) || renderFlow_nonIterableRest(); }

function renderFlow_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function renderFlow_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderFlow_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderFlow_arrayLikeToArray(o, minLen); }

function renderFlow_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function renderFlow_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function renderFlow_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }










const _defaultCamera = new lib["f" /* Camera */]({
  name: 'render-flow-default-camera'
});

let _uniqueScopeId = 0;

const _PassType = Object(_wgetemp_enum["a" /* makeEnum */])([['CLEAR', 1], ['STENCIL', 2], ['SCENE', 3], ['QUAD', 4], ['COMPUTE', 5], ['CUSTOM', 6] // TODO:: add copy pass
]);

const _OutputScope = Object(_wgetemp_enum["a" /* makeEnum */])([['LOCAL', 0], ['CHAIN', 1] // TODO:: add global scope
]);

function _getOutputCacheKey(props, doubleBuffering, writeOnly, scope, width, height) {
  const keyValues = [];

  for (const entry of Object.entries(props).sort((lhs, rhs) => {
    return lhs[0].localeCompare(rhs[0]);
  })) {
    keyValues.push(entry);
  }

  const uid = scope === _OutputScope.LOCAL ? 0 : ++_uniqueScopeId;
  return `${JSON.stringify(keyValues)}_w_${width}_h_${height}_double_${doubleBuffering}_wo_${writeOnly}_${uid}`;
}

function _getCacheKeyByRef(cache, inputRef, inputs) {
  if (false) {}

  const _inputs$inputRef = inputs[inputRef],
        sourcePass = _inputs$inputRef.sourcePass,
        sourceLayout = _inputs$inputRef.sourceLayout;
  let cacheKey = null;

  for (const _ref of cache.entries()) {
    var _ref2 = renderFlow_slicedToArray(_ref, 2);

    const key = _ref2[0];
    const items = _ref2[1];

    for (const item of items) {
      const passName = item.passName,
            layoutName = item.layoutName;

      if (passName === sourcePass && layoutName === sourceLayout) {
        cacheKey = key;
        break;
      }
    }

    if (cacheKey !== null) {
      break;
    }
  }

  if (false) {}

  return cacheKey;
}

function _updateInputRanges(cache, inputs, i) {
  if (inputs === undefined) {
    return;
  }

  for (const input of inputs) {
    const sourcePass = input.sourcePass,
          sourceLayout = input.sourceLayout;

    for (const cacheItems of cache.values()) {
      for (const item of cacheItems) {
        const passName = item.passName,
              layoutName = item.layoutName;

        if (passName === sourcePass && layoutName === sourceLayout) {
          item.end = item.end === Infinity || item.end < i ? i : item.end;
        }

        if (false) {}
      }
    }
  }
}

function _parseLayoutName(layoutName) {
  const pattern = /^(DEPTH_ATTACHMENT)|(STENCIL_ATTACHMENT)|(DEPTH_STENCIL_ATTACHMENT)|(COLOR_ATTACHMENT)(\d+)$/;

  const _layoutName$match = layoutName.match(pattern),
        _layoutName$match2 = renderFlow_slicedToArray(_layoutName$match, 6),
        depth = _layoutName$match2[1],
        stencil = _layoutName$match2[2],
        depthStencil = _layoutName$match2[3],
        color = _layoutName$match2[4],
        number = _layoutName$match2[5];

  let layout = null;

  if (depth !== undefined) {
    layout = lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_ATTACHMENT;
  } else if (stencil !== undefined) {
    layout = lib["U" /* RenderTargetFramebuffer */].Attachment.STENCIL_ATTACHMENT;
  } else if (depthStencil !== undefined) {
    layout = lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_STENCIL_ATTACHMENT;
  } else if (color !== undefined) {
    const colorNumber = +number;
    layout = lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0 + colorNumber;
  }

  if (false) {}

  return layout;
}

function _getPassCamera(scene, camera) {
  if (camera.isCamera || camera.isCubeCamera) {
    return camera;
  }

  if (typeof camera === 'string' || camera instanceof String) {
    let camera_ = null;
    scene.root.traverse(o => {
      const _o$getComponents = o.getComponents([lib["f" /* Camera */], lib["k" /* CubeCamera */]]),
            _o$getComponents2 = renderFlow_slicedToArray(_o$getComponents, 2),
            c = _o$getComponents2[0],
            cc = _o$getComponents2[1];

      if (c !== null || cc !== null) {
        const c_ = c || cc;

        if (c_.name === camera) {
          camera_ = c_;
          return false;
        }
      }

      return true;
    });
    return camera_;
  }

  return _defaultCamera;
}

function _setAttachment(flowPass, layout, output, texture, doubleBuffering, semantic) {
  if (layout === lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_ATTACHMENT || layout === lib["U" /* RenderTargetFramebuffer */].Attachment.STENCIL_ATTACHMENT || layout === lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_STENCIL_ATTACHMENT) {
    output.front.setDepthStencilAttachment(layout, texture.front);

    if (doubleBuffering) {
      output.back.setDepthStencilAttachment(layout, texture.back);
    }
  } else {
    output.front.setColorAttachment(layout, texture.front);

    if (doubleBuffering) {
      output.back.setColorAttachment(layout, texture.back);
    }

    if (semantic !== undefined && flowPass instanceof scenePass) {
      const renderPass = flowPass.renderPass;
      renderPass.renderTarget = output.back;
      renderPass.setOutputLayoutPosition(semantic, layout - lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0);
    }
  }
}

function _emptySetter() {}

class renderFlow_RenderFlow {
  static get PassType() {
    return _PassType;
  }

  static get OutputScope() {
    return _OutputScope;
  }

  constructor(core, config = {}) {
    const _config$passChain = config.passChain,
          passChain = _config$passChain === void 0 ? [] : _config$passChain;
    this.statistics = new lib["Q" /* RenderPassStatistics */]();
    this._textures = [];
    this._outputs = [];
    this.core = core;
    this._renderer = core.renderer;
    this._passChain = new Map();
    passChain._outputIndices = new tuple_map["a" /* TupleMap */]();

    this._parsePassChain(passChain);

    this._parseOutputs(passChain);

    this._parseInputs(passChain);
  }

  passChain() {
    return this._passChain.values();
  }

  getPass(name) {
    return this._passChain.get(name);
  }

  getPassOutput(name) {
    const _passChain = this._passChain,
          _outputs = this._outputs;

    const pass = _passChain.get(name);

    if (false) {}

    const index = pass._output;
    return index !== null ? _outputs[index] : null;
  }

  _parseInputs(passChain) {
    const _passChain = this._passChain;
    const _outputIndices = passChain._outputIndices;

    for (const pass of passChain) {
      const name = pass.name,
            inputs = pass.inputs;

      if (inputs === undefined) {
        continue;
      }

      const flowPass = _passChain.get(name);

      for (const input of inputs) {
        const destinationObject = input.destinationObject,
              destinationProperty = input.destinationProperty,
              sourcePass = input.sourcePass,
              sourceLayout = input.sourceLayout,
              setter = input.setter;

        if (destinationObject === undefined && flowPass instanceof customPass) {
          continue;
        }

        const input_ = {
          index: _outputIndices.get([sourcePass, sourceLayout]),
          set: typeof setter === 'function' ? setter : function _set(frontBuffer) {
            destinationObject[destinationProperty] = frontBuffer;
          }
        };

        if (false) {}

        flowPass.inputs.push(input_);
      }
    }
  }

  _parsePassChain(passChain) {
    const renderer = this._renderer,
          _passChain = this._passChain;

    for (const pass of passChain) {
      const name = pass.name,
            clearMask = pass.clearMask,
            _pass$type = pass.type,
            type = _pass$type === void 0 ? _PassType.SCENE : _pass$type;
      let flowPass = null;

      switch (type) {
        case _PassType.CLEAR:
          flowPass = new clearPass(name, renderer, clearMask);
          break;

        case _PassType.SCENE:
          {
            const scene = pass.scene,
                  _pass$srgbOutput = pass.srgbOutput,
                  srgbOutput = _pass$srgbOutput === void 0 ? false : _pass$srgbOutput;

            const camera = _getPassCamera(scene, pass.look);

            flowPass = new scenePass({
              name,
              clearMask,
              renderer,
              scene,
              look: camera,
              srgbOutput
            });
          }
          break;

        case _PassType.QUAD:
          {
            const geometry = renderer.screenTriangle;
            const material = pass.material,
                  _pass$srgbOutput2 = pass.srgbOutput,
                  srgbOutput = _pass$srgbOutput2 === void 0 ? false : _pass$srgbOutput2;

            if (false) {}

            const scene = new lib["Y" /* Scene */]({
              name: `${name}-pass-scene`,
              maxSceneNodes: 4,
              config: {
                componentClasses: [...this.core.getComponentClassList()]
              }
            });
            const visibility = new lib["qb" /* Visibility */]({
              enableCulling: false
            });
            const subMesh = new lib["fb" /* SubMesh */]({
              name: '',
              geometry,
              material
            });
            const mesh = new lib["F" /* Mesh */]({});
            const transform = new lib["jb" /* Transform */]();
            const node = scene.root.createChild({});
            const camera = _defaultCamera;
            mesh.addSubMesh(subMesh);
            node.attach(transform);
            node.attach(camera);
            node.attach(mesh);
            node.attach(visibility);
            flowPass = new scenePass({
              name,
              clearMask,
              renderer,
              scene,
              look: camera,
              srgbOutput
            });
          }
          break;

        case _PassType.CUSTOM:
          {
            const callback = pass.callback;
            flowPass = new customPass(name, renderer, callback, this);
          }
          break;

        case _PassType.STENCIL:
        case _PassType.COMPUTE:
          throw new Error(`pass type ${_PassType.firstNameOf(type)} is not implemented`);

        default:
          throw new Error(`render pass ${name} has unknown type`);
      }

      _passChain.set(name, flowPass);
    }
  }

  _parseOutputs(passChain) {
    const _textures = this._textures,
          _outputs = this._outputs,
          _renderer = this._renderer,
          _passChain = this._passChain;
    const _outputIndices = passChain._outputIndices;
    const cache = new Map();

    for (const _ref3 of passChain.entries()) {
      var _ref4 = renderFlow_slicedToArray(_ref3, 2);

      const i = _ref4[0];
      const pass = _ref4[1];
      const name = pass.name,
            output = pass.output,
            inputs = pass.inputs,
            _pass$doubleBuffering = pass.doubleBuffering,
            doubleBuffering = _pass$doubleBuffering === void 0 ? false : _pass$doubleBuffering;

      _updateInputRanges(cache, inputs, i);

      if (output === undefined || output === null) {
        continue;
      }

      const _output$width = output.width,
            width = _output$width === void 0 ? _renderer.width : _output$width,
            _output$height = output.height,
            height = _output$height === void 0 ? _renderer.height : _output$height,
            layout = output.layout;

      if (false) {}

      for (const _ref5 of Object.entries(layout)) {
        var _ref6 = renderFlow_slicedToArray(_ref5, 2);

        const layoutName = _ref6[0];
        const layoutValue = _ref6[1];
        const properties = layoutValue.properties,
              inputRef = layoutValue.inputRef,
              _layoutValue$writeOnl = layoutValue.writeOnly,
              writeOnly = _layoutValue$writeOnl === void 0 ? false : _layoutValue$writeOnl,
              semantic = layoutValue.semantic,
              _layoutValue$scope = layoutValue.scope,
              scope = _layoutValue$scope === void 0 ? _OutputScope.LOCAL : _layoutValue$scope;

        if (false) {}

        const cacheKey = inputRef !== undefined ? _getCacheKeyByRef(cache, inputRef, inputs) : _getOutputCacheKey(properties, doubleBuffering, writeOnly, scope, width, height);

        if (inputRef !== undefined) {
          const input = inputs[inputRef];
          const setter = input.setter;

          if (typeof setter !== 'function') {
            input.setter = _emptySetter;
          }
        }

        let cacheItems = cache.get(cacheKey);

        if (cacheItems === undefined) {
          cacheItems = [];
          cache.set(cacheKey, cacheItems);
        }

        cacheItems.push({
          passName: name,
          layoutName,
          semantic,
          start: i,
          end: Infinity,
          inputRef,
          properties,
          doubleBuffering,
          writeOnly,
          width,
          height,
          textureIndex: -1
        });
      }
    } // pass chain


    for (const cacheItems of cache.values()) {
      // textureIndexUsage map to exclude same texture usage in the same pass twice (for different layouts)
      const textureIndexUsage = new Map();

      for (const _ref7 of cacheItems.entries()) {
        var _ref8 = renderFlow_slicedToArray(_ref7, 2);

        const i = _ref8[0];
        const item = _ref8[1];
        const start = item.start,
              end = item.end,
              properties = item.properties,
              writeOnly = item.writeOnly,
              inputRef = item.inputRef,
              passName = item.passName;

        if (inputRef !== undefined) {
          continue;
        }

        for (let j = i; j >= 0; j--) {
          if (j === i) {
            continue;
          }

          const prevItem = cacheItems[j];

          if (start > prevItem.end || end < prevItem.start) {
            let usages = textureIndexUsage.get(prevItem.textureIndex);

            if (usages === undefined) {
              usages = [];
              textureIndexUsage.set(prevItem.textureIndex, usages);
            }

            if (!usages.includes(passName)) {
              usages.push(passName);
              item.textureIndex = prevItem.textureIndex;
              break;
            }
          }
        }

        if (item.textureIndex === -1) {
          const width = item.width,
                height = item.height,
                doubleBuffering = item.doubleBuffering;
          properties.width = width;
          properties.height = height;
          const frontTexture = writeOnly ? new lib["P" /* RenderBuffer */](properties) : new lib["gb" /* Texture */](properties);
          const backTexture = doubleBuffering // eslint-disable-line
          ? writeOnly ? new lib["P" /* RenderBuffer */](properties) : new lib["gb" /* Texture */](properties) : null;
          const texturePair = new src_texturePair(frontTexture, backTexture);
          item.textureIndex = _textures.push(texturePair) - 1;
        }

        _outputIndices.set([item.passName, item.layoutName], item.textureIndex);

        {
          const passName = item.passName,
                layoutName = item.layoutName,
                width = item.width,
                height = item.height,
                doubleBuffering = item.doubleBuffering,
                textureIndex = item.textureIndex,
                semantic = item.semantic;

          const flowPass = _passChain.get(passName);

          if (flowPass._output === null) {
            const frontTarget = new lib["U" /* RenderTargetFramebuffer */]({
              width,
              height
            });
            const backTarget = doubleBuffering ? new lib["U" /* RenderTargetFramebuffer */]({
              width,
              height
            }) : null;
            const output = new outputPair(frontTarget, backTarget);
            flowPass._output = _outputs.push(output) - 1;
          }

          {
            const output = _outputs[flowPass._output];

            const layout = _parseLayoutName(layoutName);

            const texture = _textures[textureIndex];

            _setAttachment(flowPass, layout, output, texture, doubleBuffering, semantic);
          }
        }
      } // cache items

    } // cache (no refs)


    for (const _ref9 of passChain.entries()) {
      var _ref10 = renderFlow_slicedToArray(_ref9, 2);

      const pass = _ref10[1];
      const output = pass.output,
            inputs = pass.inputs,
            _pass$doubleBuffering2 = pass.doubleBuffering,
            doubleBuffering = _pass$doubleBuffering2 === void 0 ? false : _pass$doubleBuffering2,
            name = pass.name;

      if (output === undefined || output === null) {
        continue;
      }

      const layout = output.layout;

      for (const _ref11 of Object.entries(layout)) {
        var _ref12 = renderFlow_slicedToArray(_ref11, 2);

        const layoutName = _ref12[0];
        const layoutValue = _ref12[1];
        const inputRef = layoutValue.inputRef,
              semantic = layoutValue.semantic;

        if (inputRef === undefined) {
          continue;
        }

        const _inputs$inputRef2 = inputs[inputRef],
              sourcePass = _inputs$inputRef2.sourcePass,
              sourceLayout = _inputs$inputRef2.sourceLayout;

        const textureIndex = _outputIndices.get([sourcePass, sourceLayout]);

        if (false) {}

        _outputIndices.set([name, layoutName], textureIndex);

        const texturePair = _textures[textureIndex];
        const _texturePair$front = texturePair.front,
              width = _texturePair$front.width,
              height = _texturePair$front.height;

        const flowPass = _passChain.get(name);

        if (flowPass._output === null) {
          const frontTarget = new lib["U" /* RenderTargetFramebuffer */]({
            width,
            height
          });
          const backTarget = doubleBuffering ? new lib["U" /* RenderTargetFramebuffer */]({
            width,
            height
          }) : null;
          const output = new outputPair(frontTarget, backTarget);
          flowPass._output = _outputs.push(output) - 1;
        }

        {
          const output_ = _outputs[flowPass._output];

          const layout_ = _parseLayoutName(layoutName);

          _setAttachment(flowPass, layout_, output_, texturePair, doubleBuffering, semantic);
        }
      }
    } // output refs

  }
  /**
   * @function  module:@wgetemp/render-flow.RenderFlow#render
   * @summary Renders whole pass chain sequentially.
   */


  render() {
    const _passChain = this._passChain,
          _textures = this._textures,
          _outputs = this._outputs,
          statistics = this.statistics;
    statistics.reset();

    for (const pass of _passChain.values()) {
      pass.onPassStart.emit();
      const passStatistics = pass.statistics;
      pass.updateInputs(_textures);
      pass.render(_outputs);
      statistics.add(passStatistics);
      pass.onPassEnd.emit();
    }

    for (const t of _textures) {
      t.swap();
    }

    for (const o of _outputs) {
      o.swap();
    }
  }
  /**
   * @function  module:@wgetemp/render-flow.RenderFlow#dispose
   * @summary Disposes render flow.
   */


  dispose() {
    const _outputs = this._outputs;

    for (const output of _outputs) {
      output.dispose();
    }
  }

}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/render-flow/src/index.js

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/environment-blur/gaussian-blur.js
function _getSigmaBasedOnTapSize(size, threshold) {
  return (size - 1) / (2 * Math.sqrt(-2 * Math.log(threshold * 0.01)));
}

function _gaussianDistribution(x, sigma, EV = 0) {
  return Math.exp(-0.5 * Math.pow((x - EV) / sigma, 2)) / (sigma * Math.sqrt(Math.PI * 2));
}

function _gaussianSimpsonIntegration(a, b, sigma) {
  return (b - a) / 6 * (_gaussianDistribution(a, sigma) + 4 * _gaussianDistribution((a + b) / 2, sigma) + _gaussianDistribution(b, sigma));
}

function _gaussianKernelIntegrals(sigma, taps, halfSize = true, normalize = true) {
  const halfTaps = taps >> 1;
  let weights = new Array(taps).fill(0).map((value, i) => {
    const x = i - halfTaps;
    return _gaussianSimpsonIntegration(x - 0.5, x + 0.5, sigma);
  });

  if (normalize) {
    const total = weights.reduce((accumulator, value) => accumulator + value, 0);
    weights = weights.map(weight => weight / total);
  }

  if (halfSize) {
    weights = weights.slice(halfTaps);
  }

  return weights;
}

function initGaussianFilter(tapSize, bilateral) {
  const useBilateral = !!bilateral;

  const variance = _getSigmaBasedOnTapSize(tapSize, 4);

  let weights = _gaussianKernelIntegrals(variance, tapSize, true, useBilateral);

  const offsets = [];

  if (useBilateral) {
    if (false) {}
  } else {
    const newWeights = [];
    newWeights.push(weights[0]);
    offsets.push(0.0);

    for (let i = 1; i < weights.length; i += 2) {
      const w0 = weights[i];
      const w1 = i + 1 < weights.length ? weights[i + 1] : 0;
      const weight = w0 + w1;
      const a = w0 * i;
      const b = w1 * (i + 1);
      offsets.push((a + b) / weight);
      newWeights.push(weight);
      i = i < weights.length - 1 ? i : i - 1;
    }

    weights = newWeights;
  }

  const weightsFloat32 = new Float32Array(weights.length);
  weights.forEach((weight, i) => weightsFloat32.set([weight], i));
  const offsetsFloat32 = new Float32Array(offsets.length);
  offsets.forEach((offset, i) => offsetsFloat32.set([offset], i));
  return {
    weights,
    offsets
  };
}


// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/environment-blur/shaders/shader.vert
var shader = __webpack_require__(232);
var shader_default = /*#__PURE__*/__webpack_require__.n(shader);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/environment-blur/shaders/shader.frag
var shaders_shader = __webpack_require__(233);
var shaders_shader_default = /*#__PURE__*/__webpack_require__.n(shaders_shader);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/environment-blur/index.js







class environment_blur_EnvironmentBlurMaterial extends lib["sb" /* WebGLBaseMaterial */] {
  constructor(settings = {}) {
    const _settings$name = settings.name,
          name = _settings$name === void 0 ? 'environment-blur-material' : _settings$name,
          _settings$defines = settings.defines,
          defines = _settings$defines === void 0 ? {} : _settings$defines;
    super({
      name,
      alphaMode: lib["D" /* Material */].AlphaMode.OPAQUE
    });
    this.depthTest = false;
    this.depthWrite = false;
    this.colorMap0 = null;
    this.weights = null;
    this.offsets = null;
    this.texelSize = null;
    this._shaders = {
      name,
      extensions: {},
      defines,
      vertexShader: shader_default.a,
      fragmentShader: shaders_shader_default.a
    };
    this._texelSizeVector = new math_lib["m" /* Vector2 */]();
  }

  get shaders() {
    return this._shaders;
  }

  set colorMap0(value) {
    if (this._colorMap0 === value) {
      return;
    }

    this.needsUpdate = lib["sb" /* WebGLBaseMaterial */]._testIfNewTextureRequireUpdate(this._colorMap0, value);

    if (value) {
      const colorMap0 = value;

      if (false) {}

      if (false) {}

      this._colorMap0 = colorMap0;
    } else {
      this._colorMap0 = null;
    }
  }

  apply(gl, renderable, state, programs, textures, renderRequest) {
    const capabilities = programs.capabilities;
    const webgl2Support = capabilities.webgl2Support;
    const renderPassId = renderRequest.id;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderRequest, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderRequest, technique);

    const _colorMap0 = this._colorMap0;
    const program = technique.program;
    const layout = program.layout;
    const uniforms = layout.uniforms;

    if (_colorMap0) {
      const uniform = uniforms.get('colorMap0');

      if (false) {}

      this._setTexture(gl, uniform, _colorMap0, textures);
    }

    if (this.weights) {
      const uniform = uniforms.get('weights');

      if (false) {}

      uniform.setValue(this.weights);
    }

    if (this.offsets) {
      const uniform = uniforms.get('offsets');

      if (false) {}

      uniform.setValue(this.offsets);
    }

    if (this.texelSize) {
      const uniform = uniforms.get('texelSize');

      if (false) {}

      const texelSize = this.texelSize,
            _texelSizeVector = this._texelSizeVector;

      _texelSizeVector.fromArray(texelSize);

      uniform.setValue(_texelSizeVector);
    }

    this._bindTextures(gl);
  }

  _update(renderable, renderRequest, technique) {
    if (!this._needsUpdate(renderable, renderRequest, technique)) {
      return;
    }

    super._update(technique);

    const defines = technique.defines;
    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

}

function createRenderFlow(core, environmentMap, tapSize) {
  const capabilities = core.renderer.capabilities;
  const webgl2Support = capabilities.webgl2Support;
  const colorMap = environmentMap.texture;
  const width = colorMap.width,
        height = colorMap.height,
        wrapS = colorMap.wrapS,
        wrapT = colorMap.wrapT;
  const rgba32f = {
    bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
    magFilter: lib["gb" /* Texture */].Filter.LINEAR,
    minFilter: lib["gb" /* Texture */].Filter.LINEAR,
    wrapS,
    wrapT,
    format: lib["N" /* PixelDataFormat */].RGBA,
    internalFormat: lib["v" /* InternalFormat */].RGBA32F,
    componentType: lib["n" /* DataType */].FLOAT,
    levels: 1,
    dynamic: true
  };
  const rgba8 = {
    bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
    magFilter: lib["gb" /* Texture */].Filter.LINEAR,
    minFilter: lib["gb" /* Texture */].Filter.LINEAR,
    wrapS,
    wrapT,
    format: lib["N" /* PixelDataFormat */].RGBA,
    internalFormat: lib["v" /* InternalFormat */].RGBA,
    componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
    levels: 1,
    dynamic: true
  };

  const _initGaussianFilter = initGaussianFilter(tapSize, false),
        weights = _initGaussianFilter.weights,
        offsets = _initGaussianFilter.offsets;

  const kernelSize = weights.length;
  const nodes = [];

  for (let index = 0; index < 2; ++index) {
    const horizontal = index === 0;
    const name = `environment-blur-${horizontal ? 'horizontal' : 'vertical'}-pass`;
    const defines = {
      KERNEL_SIZE: kernelSize
    };

    if (horizontal) {
      defines.BLUR_HORIZONTAL_PASS = index;
    } else {
      defines.BLUR_VERTICAL_PASS = index;
    }

    const material = new environment_blur_EnvironmentBlurMaterial({
      name,
      defines
    });
    material.texelSize = [1 / width, 1 / height];
    material.weights = weights;
    material.offsets = offsets;
    const layout = {
      COLOR_ATTACHMENT0: {
        properties: webgl2Support ? rgba32f : rgba8
      }
    };
    const inputs = [];

    if (horizontal) {
      inputs.push({
        setter: () => {
          material.colorMap0 = colorMap;
        }
      });
    } else {
      const horizontalNode = nodes[0];
      const sourcePassName = horizontalNode.name;
      inputs.push({
        destinationObject: material,
        destinationProperty: 'colorMap0',
        sourcePass: sourcePassName,
        sourceLayout: 'COLOR_ATTACHMENT0'
      });
    }

    nodes.push({
      name,
      type: renderFlow_RenderFlow.PassType.QUAD,
      srgbOutput: false,
      doubleBuffering: false,
      clearMask: lib["h" /* ClearMask */].COLOR_BUFFER_BIT,
      material,
      inputs,
      output: {
        width,
        height,
        layout
      }
    });
  }

  const nodeNames = nodes.map(node => node.name);
  let enabledSystems = [];
  const config = {
    passChain: [{
      name: 'environment-blur-start-custom-pass',
      type: renderFlow_RenderFlow.PassType.CUSTOM,
      callback: renderFlow => {
        enabledSystems = [...core._systems.values()].filter(system => system.enable);

        for (const system of enabledSystems) {
          system.enable = system instanceof lib["G" /* MeshSystem */];
        }

        const rrs = core.renderRequests;

        for (const nodeName of nodeNames) {
          const _renderFlow$getPass = renderFlow.getPass(nodeName),
                renderPass = _renderFlow$getPass.renderPass;

          core.renderRequests = [renderPass];
          core.drawFrame(0);
        }

        core.renderRequests = rrs;
      }
    }, ...nodes, {
      name: 'environment-blur-end-custom-pass',
      type: renderFlow_RenderFlow.PassType.CUSTOM,
      callback: () => {
        for (const system of enabledSystems) {
          system.enable = true;
        }
      }
    }]
  };
  return new renderFlow_RenderFlow(core, config);
}

function environmentBlur(core, environmentMap, tapSize) {
  if (false) {}

  const renderFlow = createRenderFlow(core, environmentMap, tapSize);
  renderFlow.render();
  const mainRenderTarget = renderFlow.getPassOutput('environment-blur-vertical-pass').front;

  const _mainRenderTarget$get = mainRenderTarget.getColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0),
        texture = _mainRenderTarget$get.attachment;

  texture.retain();
  const luminance = environmentMap.luminance,
        maxEnvLuminance = environmentMap.maxEnvLuminance;
  const result = new lib["D" /* Material */].EnvironmentMapProperties(luminance, maxEnvLuminance, texture);
  renderFlow.dispose();
  return result;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/prepare-ibl/index.js
function prepare_ibl_slicedToArray(arr, i) { return prepare_ibl_arrayWithHoles(arr) || prepare_ibl_iterableToArrayLimit(arr, i) || prepare_ibl_unsupportedIterableToArray(arr, i) || prepare_ibl_nonIterableRest(); }

function prepare_ibl_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function prepare_ibl_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return prepare_ibl_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return prepare_ibl_arrayLikeToArray(o, minLen); }

function prepare_ibl_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function prepare_ibl_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function prepare_ibl_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







function _areaElement(x, y) {
  return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
}

function _texelCoordSolidAngle(x, y, size) {
  const u = 2.0 * (x + 0.5) / size - 1.0;
  const v = 2.0 * (y + 0.5) / size - 1.0;
  const invResolution = 1.0 / size;
  const x0 = u - invResolution;
  const y0 = v - invResolution;
  const x1 = u + invResolution;
  const y1 = v + invResolution;
  return _areaElement(x0, y0) - _areaElement(x0, y1) - _areaElement(x1, y0) + _areaElement(x1, y1);
}

function _computeSH(renderer, cubeMap, nBands) {
  const l = Object(math_lib["p" /* clamp */])(nBands, 1, 3);
  const size = cubeMap.width,
        format = cubeMap.format,
        componentType = cubeMap.componentType;
  const channels = 3;
  const numSH = l * l;
  const iblSH = new Float32Array(numSH * channels);
  iblSH.fill(0);
  const renderTarget = new lib["T" /* RenderTargetCube */]({
    width: size,
    height: size
  });

  if (false) {}

  const elementPerPixel = format === lib["N" /* PixelDataFormat */].RGBA ? 4 : 3;
  const logLuv = componentType === lib["n" /* DataType */].UNSIGNED_BYTE;
  const buffer = logLuv ? new Uint8Array(size * size * elementPerPixel) : new Float32Array(size * size * elementPerPixel);
  const samplerVectors = [];

  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const u = x / (size - 1) * 2 - 1;
      const v = y / (size - 1) * 2 - 1;
      samplerVectors[y * size + x] = new math_lib["n" /* Vector3 */](u, v, 1.0).normalize();
    }
  }

  const tmp = new math_lib["n" /* Vector3 */]();
  const logLUVDecode = new math_lib["h" /* LinearMatrix3 */](6.0013, -2.7, -1.7995, -1.332, 3.1029, -5.772, 0.3007, -1.088, 5.6268);
  const shIndex0 = 0;
  const shIndex1 = 1 * 3;
  const shIndex2 = 2 * 3;
  const shIndex3 = 3 * 3;
  const shIndex4 = 4 * 3;
  const shIndex5 = 5 * 3;
  const shIndex6 = 6 * 3;
  const shIndex7 = 7 * 3;
  const shIndex8 = 8 * 3;
  const nx = 0;
  const px = 1;
  const ny = 2;
  const py = 3;
  const nz = 4;
  const pz = 5;
  let accum = 0;

  for (let face = 0; face < 6; face++) {
    buffer.fill(0);
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, cubeMap, 0);
    renderTarget.target = lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + face;
    renderer.readPixels(renderTarget, 0, 0, size, size, buffer);

    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        const pixelIndex = y * size + x;
        const samplingVector = samplerVectors[pixelIndex];

        const solidAngle = _texelCoordSolidAngle(x, y, size); // https://sourceforge.net/p/gdalgorithms/mailman/message/16999058/
        // [Algorithms] Spherical harmonic lighting


        const shFactor1 = solidAngle * 4 / 17;
        const shFactor2 = solidAngle * 8 / 17;
        const shFactor3 = solidAngle * 15 / 17;
        const shFactor4 = solidAngle * 5 / 68;
        const shFactor5 = solidAngle * 15 / 68;
        let dx = 0;
        let dy = 0;
        let dz = 0;

        if (face === nx) {
          dx = samplingVector.z;
          dy = -samplingVector.y;
          dz = -samplingVector.x;
        } else if (face === px) {
          dx = -samplingVector.z;
          dy = -samplingVector.y;
          dz = samplingVector.x;
        } else if (face === ny) {
          dx = samplingVector.x;
          dy = samplingVector.z;
          dz = samplingVector.y;
        } else if (face === py) {
          dx = samplingVector.x;
          dy = -samplingVector.z;
          dz = -samplingVector.y;
        } else if (face === nz) {
          dx = samplingVector.x;
          dy = -samplingVector.y;
          dz = samplingVector.z;
        } else if (face === pz) {
          dx = -samplingVector.x;
          dy = -samplingVector.y;
          dz = -samplingVector.z;
        } // dx = -dx; //


        if (logLuv) {
          const r = buffer[pixelIndex * elementPerPixel + 0];
          const g = buffer[pixelIndex * elementPerPixel + 1];
          const b = buffer[pixelIndex * elementPerPixel + 2];
          const a = buffer[pixelIndex * elementPerPixel + 3];
          const Le = (b * 255 + a) / 255;
          const y_ = Object(math_lib["q" /* exp2 */])((Le - 127) * 0.5);
          const z_ = y_ / (g / 255);
          const x_ = r / 255 * z_;
          tmp.set(x_, y_, z_);
          tmp.multiplyLinearMatrix(logLUVDecode);
        } else {
          tmp.set(buffer[pixelIndex * elementPerPixel + 0], buffer[pixelIndex * elementPerPixel + 1], buffer[pixelIndex * elementPerPixel + 2]);
        }

        iblSH[shIndex0 + 0] += tmp.x * shFactor1;
        iblSH[shIndex0 + 1] += tmp.y * shFactor1;
        iblSH[shIndex0 + 2] += tmp.z * shFactor1;

        if (l > 1) {
          iblSH[shIndex1 + 0] += tmp.x * shFactor2 * dx;
          iblSH[shIndex1 + 1] += tmp.y * shFactor2 * dx;
          iblSH[shIndex1 + 2] += tmp.z * shFactor2 * dx;
          iblSH[shIndex2 + 0] += tmp.x * shFactor2 * dy;
          iblSH[shIndex2 + 1] += tmp.y * shFactor2 * dy;
          iblSH[shIndex2 + 2] += tmp.z * shFactor2 * dy;
          iblSH[shIndex3 + 0] += tmp.x * shFactor2 * dz;
          iblSH[shIndex3 + 1] += tmp.y * shFactor2 * dz;
          iblSH[shIndex3 + 2] += tmp.z * shFactor2 * dz;
        }

        if (l > 2) {
          iblSH[shIndex4 + 0] += tmp.x * shFactor3 * dx * dz;
          iblSH[shIndex4 + 1] += tmp.y * shFactor3 * dx * dz;
          iblSH[shIndex4 + 2] += tmp.z * shFactor3 * dx * dz;
          iblSH[shIndex5 + 0] += tmp.x * shFactor3 * dz * dy;
          iblSH[shIndex5 + 1] += tmp.y * shFactor3 * dz * dy;
          iblSH[shIndex5 + 2] += tmp.z * shFactor3 * dz * dy;
          iblSH[shIndex6 + 0] += tmp.x * shFactor3 * dy * dx;
          iblSH[shIndex6 + 1] += tmp.y * shFactor3 * dy * dx;
          iblSH[shIndex6 + 2] += tmp.z * shFactor3 * dy * dx;
          iblSH[shIndex7 + 0] += tmp.x * shFactor4 * (3 * dz * dz - 1);
          iblSH[shIndex7 + 1] += tmp.y * shFactor4 * (3 * dz * dz - 1);
          iblSH[shIndex7 + 2] += tmp.z * shFactor4 * (3 * dz * dz - 1);
          iblSH[shIndex8 + 0] += tmp.x * shFactor5 * (dx * dx - dy * dy);
          iblSH[shIndex8 + 1] += tmp.y * shFactor5 * (dx * dx - dy * dy);
          iblSH[shIndex8 + 2] += tmp.z * shFactor5 * (dx * dx - dy * dy);
        }

        accum += solidAngle;
      }
    }
  }

  for (let i = 0, count = iblSH.length; i < count; i++) {
    iblSH[i] *= 4 * Math.PI / accum;
  }

  renderTarget.release();
  return iblSH;
}
/**
 * @namespace module:@wgetemp/environment-routines.IndirectLightAlgorithm
 * @desc Enum to specify indirect light calculation algorithm.
 * @property {number} MONTE_CARLO_CONVOLUTION
 * @property {number} SPHERICAL_HARMONICS_1_BAND
 * @property {number} SPHERICAL_HARMONICS_2_BAND
 * @property {number} SPHERICAL_HARMONICS_3_BAND
 */


class IndirectLightAlgorithm {
  static get MONTE_CARLO_CONVOLUTION() {
    return 0;
  }

  static get SPHERICAL_HARMONICS_1_BAND() {
    return 1;
  }

  static get SPHERICAL_HARMONICS_2_BAND() {
    return 2;
  }

  static get SPHERICAL_HARMONICS_3_BAND() {
    return 3;
  }

}

async function generateIBL(core, vertexStaging, elementStaging, environmentMaterial, parameters = {}) {
  const renderer = core.renderer;
  const vertexHardwareBuffer = renderer.vertexHardwareBuffer,
        indexHardwareBuffer = renderer.indexHardwareBuffer;
  const _parameters$convoluti = parameters.convolutionMapSize,
        convolutionMapSize = _parameters$convoluti === void 0 ? 32 : _parameters$convoluti,
        _parameters$preFilter = parameters.preFilteredEnvMapSize,
        preFilteredEnvMapSize = _parameters$preFilter === void 0 ? 512 : _parameters$preFilter,
        _parameters$brdfMapSi = parameters.brdfMapSize,
        brdfMapSize = _parameters$brdfMapSi === void 0 ? 512 : _parameters$brdfMapSi,
        _parameters$samplesNu = parameters.samplesNumber,
        samplesNumber = _parameters$samplesNu === void 0 ? 256 : _parameters$samplesNu,
        _parameters$samplingD = parameters.samplingDelta,
        samplingDelta = _parameters$samplingD === void 0 ? Math.PI / 32 : _parameters$samplingD,
        _parameters$algorithm = parameters.algorithm,
        algorithm = _parameters$algorithm === void 0 ? IndirectLightAlgorithm.SPHERICAL_HARMONICS_3_BAND : _parameters$algorithm,
        environmentBlurTapSize = parameters.environmentBlurTapSize,
        environmentMipLevel = parameters.environmentMipLevel;
  const capabilities = renderer.capabilities;
  const webgl2Support = capabilities.webgl2Support;
  const converter = new panorama_to_cubemap_Panorama2Cubemap({
    core,
    vertexStaging,
    elementStaging,
    vertexHardwareBuffer,
    indexHardwareBuffer
  });
  let environmentMap = environmentMaterial.environmentMap;

  if (false) {}

  let bluredEnvironmentMap = null;

  if (typeof environmentBlurTapSize === 'number') {
    bluredEnvironmentMap = environmentBlur(core, environmentMap, environmentBlurTapSize);

    if (webgl2Support) {
      const cubeMap = environmentMap.clone();
      cubeMap.texture = converter.getCubeMap(bluredEnvironmentMap);
      bluredEnvironmentMap = cubeMap;
    }
  }

  let iblSH = null;

  if (algorithm !== IndirectLightAlgorithm.MONTE_CARLO_CONVOLUTION) {
    if (environmentMap.bindingPoint !== lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP) {
      const cubeMap128 = converter.getCubeMap(environmentMap, 128, false);
      iblSH = _computeSH(renderer, cubeMap128, algorithm);
      cubeMap128.release();
    } else {
      // TODO:: add down scale if cubemap is too big
      iblSH = _computeSH(renderer, environmentMap.texture, algorithm);
    }
  }

  if (webgl2Support && environmentMap.bindingPoint !== lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP) {
    const cubeMap = environmentMap.clone();
    cubeMap.texture = converter.getCubeMap(environmentMap);
    environmentMap = cubeMap;
  }

  const convolutionRoutine = new convolution_routine_ConvolutionRoutine({
    core,
    vertexStaging,
    elementStaging,
    vertexHardwareBuffer,
    indexHardwareBuffer,
    environmentMap,
    convolutionMapSize: algorithm === IndirectLightAlgorithm.MONTE_CARLO_CONVOLUTION ? convolutionMapSize : 0,
    preFilteredEnvMapSize,
    brdfMapSize,
    samplesNumber,
    samplingDelta
  });

  const _convolutionRoutine$a = prepare_ibl_slicedToArray(convolutionRoutine.assets, 3),
        illuminanceMap = _convolutionRoutine$a[0],
        preFilteredEnvMap = _convolutionRoutine$a[1],
        brdfLUT = _convolutionRoutine$a[2];

  if (typeof environmentMipLevel === 'number') {
    bluredEnvironmentMap = environmentMap.clone();
    bluredEnvironmentMap.texture = preFilteredEnvMap;
    environmentMaterial.mipLevel = environmentMipLevel;
    environmentMaterial.needsUpdate = true;
  }

  converter.dispose();

  if (bluredEnvironmentMap) {
    environmentMaterial.environmentMap = bluredEnvironmentMap;

    if (!webgl2Support) {
      environmentMaterial.useLogLUV = true;
      environmentMaterial.needsUpdate = true;
    }
  } else {
    environmentMaterial.environmentMap = environmentMap;
  }

  return [illuminanceMap, preFilteredEnvMap, brdfLUT, iblSH];
}

async function prepareIBL(core, vertexStaging, elementStaging, assets, parameters = {}) {
  const _core$renderer = core.renderer,
        vertexHardwareBuffer = _core$renderer.vertexHardwareBuffer,
        indexHardwareBuffer = _core$renderer.indexHardwareBuffer;
  const materials = assets.materials,
        scenes = assets.scenes;

  const _scenes = prepare_ibl_slicedToArray(scenes, 1),
        scene = _scenes[0];

  const _materials$filter = materials.filter(material => material instanceof lib["s" /* EnvironmentMaterial */]),
        _materials$filter2 = prepare_ibl_slicedToArray(_materials$filter, 1),
        environmentMaterial = _materials$filter2[0];

  if (environmentMaterial === undefined) {
    return null;
  }

  const environmentMap = environmentMaterial.environmentMap;
  scene.maxEnvLuminance = environmentMap.luminance;

  if (false) {}

  const _await$generateIBL = await generateIBL(core, vertexStaging, elementStaging, environmentMaterial, parameters),
        _await$generateIBL2 = prepare_ibl_slicedToArray(_await$generateIBL, 4),
        illuminanceMap = _await$generateIBL2[0],
        preFilteredEnvMap = _await$generateIBL2[1],
        brdfLUT = _await$generateIBL2[2],
        iblSH = _await$generateIBL2[3];

  const pbrMeshMaterials = materials.filter(material => material instanceof lib["M" /* PbrMeshMaterial */]);

  for (const pbrMaterial of pbrMeshMaterials) {
    pbrMaterial.illuminanceMap = illuminanceMap;
    pbrMaterial.preFilteredEnvMap = await preFilteredEnvMap.load();
    pbrMaterial.brdfLUT = await brdfLUT.load();
    pbrMaterial.sphericalHarmonics = iblSH;
  }

  return [illuminanceMap, preFilteredEnvMap, brdfLUT, iblSH];
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/export-ibl/index.js


function _getComponentPerPixel(format) {
  let byteCount = 0;

  switch (format) {
    case lib["N" /* PixelDataFormat */].ALPHA:
    case lib["N" /* PixelDataFormat */].RED:
    case lib["N" /* PixelDataFormat */].RED_INTEGER:
      byteCount = 1;
      break;

    case lib["N" /* PixelDataFormat */].RG:
    case lib["N" /* PixelDataFormat */].RG_INTEGER:
      byteCount = 2;
      break;

    case lib["N" /* PixelDataFormat */].RGB:
    case lib["N" /* PixelDataFormat */].RGB_INTEGER:
      byteCount = 3;
      break;

    case lib["N" /* PixelDataFormat */].RGBA:
    case lib["N" /* PixelDataFormat */].RGBA_INTEGER:
      byteCount = 4;
      break;

    default:
      break;
  }

  return byteCount;
}

function _getBuffer(dataType, width, height, componentPerPixel) {
  let buffer = null;

  switch (dataType) {
    case lib["n" /* DataType */].BYTE:
      buffer = new Int8Array(width * height * componentPerPixel);
      break;

    case lib["n" /* DataType */].UNSIGNED_BYTE:
      buffer = new Uint8Array(width * height * componentPerPixel);
      break;

    case lib["n" /* DataType */].SHORT:
      buffer = new Int16Array(width * height * componentPerPixel);
      break;

    case lib["n" /* DataType */].UNSIGNED_SHORT:
    case lib["n" /* DataType */].UNSIGNED_SHORT_5_6_5:
    case lib["n" /* DataType */].UNSIGNED_SHORT_4_4_4_4:
    case lib["n" /* DataType */].UNSIGNED_SHORT_5_5_5_1:
    case lib["n" /* DataType */].HALF_FLOAT:
      buffer = new Uint16Array(width * height * componentPerPixel);
      break;

    case lib["n" /* DataType */].INT:
      buffer = new Int32Array(width * height * componentPerPixel);
      break;

    case lib["n" /* DataType */].UNSIGNED_INT_10F_11F_11F_REV: // normalized

    case lib["n" /* DataType */].UNSIGNED_INT_2_10_10_10_REV:
    case lib["n" /* DataType */].UNSIGNED_INT_5_9_9_9_REV:
    case lib["n" /* DataType */].UNSIGNED_INT:
      buffer = new Uint32Array(width * height * componentPerPixel);
      break;

    default:
      break;
  }

  return buffer;
}

function exportIBL(renderer, {
  illuminanceMap = null,
  preFilteredEnvMap = null,
  brdfLUT = null,
  sphericalHarmonics = null
}) {
  const result = {
    illuminanceMap: null,
    brdfLUT: null,
    sphericalHarmonics,
    preFilteredEnvMap: null
  };

  if (illuminanceMap !== null) {
    result.illuminanceMap = new lib["gb" /* Texture */]({
      width: illuminanceMap.width,
      height: illuminanceMap.height,
      depth: 1,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP,
      wrapS: illuminanceMap.wrapS,
      wrapT: illuminanceMap.wrapT,
      magFilter: illuminanceMap.magFilter,
      minFilter: illuminanceMap.minFilter,
      anisotropyDegree: illuminanceMap.anisotropyDegree,
      componentType: illuminanceMap.componentType,
      format: illuminanceMap.format,
      levels: 1,
      internalFormat: illuminanceMap.internalFormat,
      levelsData: [],
      dynamic: true
    });
    const width = illuminanceMap.width,
          height = illuminanceMap.height,
          componentType = illuminanceMap.componentType,
          format = illuminanceMap.format;

    const componentPerPixel = _getComponentPerPixel(format);

    if (false) {}

    const rt = new lib["U" /* RenderTargetFramebuffer */]({
      width,
      height
    });

    for (let face = 0; face < 6; face++) {
      rt.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, illuminanceMap, 0, lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + face);

      const buffer = _getBuffer(componentType, width, height, componentPerPixel);

      if (false) {}

      buffer.fill(0);
      renderer.readPixels(rt, 0, 0, width, height, buffer);
      const faceLevels = [new lib["hb" /* TextureLevelData */]({
        xoffset: 0,
        yoffset: 0,
        zoffset: 0,
        width: illuminanceMap.width,
        height: illuminanceMap.height,
        depth: 1,
        data: buffer
      })];

      result.illuminanceMap._levelsData.push(faceLevels);
    }
  }

  if (brdfLUT !== null) {
    const width = brdfLUT.width,
          height = brdfLUT.height,
          componentType = brdfLUT.componentType,
          format = brdfLUT.format;

    const componentPerPixel = _getComponentPerPixel(format);

    if (false) {}

    const rt = new lib["U" /* RenderTargetFramebuffer */]({
      width,
      height
    });
    rt.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, brdfLUT, 0);
    rt.target = lib["gb" /* Texture */].BindingPoint.TEXTURE_2D;

    const buffer = _getBuffer(componentType, width, height, componentPerPixel);

    if (false) {}

    buffer.fill(0);
    renderer.readPixels(rt, 0, 0, width, height, buffer);
    const outTexture = new lib["gb" /* Texture */]({
      width: brdfLUT.width,
      height: brdfLUT.height,
      depth: 1,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
      wrapS: brdfLUT.wrapS,
      wrapT: brdfLUT.wrapT,
      magFilter: brdfLUT.magFilter,
      minFilter: brdfLUT.minFilter,
      anisotropyDegree: brdfLUT.anisotropyDegree,
      componentType: brdfLUT.componentType,
      format: brdfLUT.format,
      levels: 1,
      internalFormat: brdfLUT.internalFormat,
      levelsData: [],
      dynamic: true
    });

    outTexture._levelsData.push(new lib["hb" /* TextureLevelData */]({
      xoffset: 0,
      yoffset: 0,
      zoffset: 0,
      width: brdfLUT.width,
      height: brdfLUT.height,
      depth: 1,
      data: buffer
    }));

    result.brdfLUT = outTexture;
  }

  if (preFilteredEnvMap !== null) {
    const width = preFilteredEnvMap.width,
          height = preFilteredEnvMap.height,
          componentType = preFilteredEnvMap.componentType,
          format = preFilteredEnvMap.format,
          levels = preFilteredEnvMap.levels;

    const componentPerPixel = _getComponentPerPixel(format);

    if (false) {}

    result.preFilteredEnvMap = new lib["gb" /* Texture */]({
      width: preFilteredEnvMap.width,
      height: preFilteredEnvMap.height,
      depth: 1,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP,
      wrapS: preFilteredEnvMap.wrapS,
      wrapT: preFilteredEnvMap.wrapT,
      magFilter: preFilteredEnvMap.magFilter,
      minFilter: preFilteredEnvMap.minFilter,
      anisotropyDegree: preFilteredEnvMap.anisotropyDegree,
      componentType: preFilteredEnvMap.componentType,
      format: preFilteredEnvMap.format,
      levels,
      internalFormat: preFilteredEnvMap.internalFormat,
      levelsData: [],
      dynamic: true
    });

    for (let face = 0; face < 6; face++) {
      const faceLevels = [];
      const rt = new lib["U" /* RenderTargetFramebuffer */]({
        width,
        height
      });

      for (let level = 0; level < levels; level++) {
        rt.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, preFilteredEnvMap, level, lib["gb" /* Texture */].BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + face);
        const w = Math.floor(width / Math.pow(2, level));
        const h = Math.floor(height / Math.pow(2, level));

        const buffer = _getBuffer(componentType, w, h, componentPerPixel);

        if (false) {}

        buffer.fill(0);
        renderer.readPixels(rt, 0, 0, w, h, buffer);
        faceLevels.push(new lib["hb" /* TextureLevelData */]({
          xoffset: 0,
          yoffset: 0,
          zoffset: 0,
          width: w,
          height: h,
          depth: 1,
          data: buffer
        }));
      }

      result.preFilteredEnvMap._levelsData.push(faceLevels);
    }
  }

  return result;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/environment-routines/src/index.js
/**
 * @module module:@wgetemp/environment-routines
 */





// CONCATENATED MODULE: ./src/core/resources/loaders/ibl-loader.ts
function ibl_loader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class ibl_loader_IBL extends lib["X" /* Resource */] {
  constructor(environmentMaterial, illuminanceMap, preFilteredEnvMap, brdfLUT, iblSH) {
    super();

    ibl_loader_defineProperty(this, "environmentMaterial", void 0);

    ibl_loader_defineProperty(this, "illuminanceMap", void 0);

    ibl_loader_defineProperty(this, "preFilteredEnvMap", void 0);

    ibl_loader_defineProperty(this, "brdfLUT", void 0);

    ibl_loader_defineProperty(this, "iblSH", void 0);

    this.environmentMaterial = environmentMaterial;
    this.illuminanceMap = illuminanceMap;
    this.preFilteredEnvMap = preFilteredEnvMap;
    this.brdfLUT = brdfLUT;
    this.iblSH = iblSH;
  }

}
class ibl_loader_IBLLoader extends lib["B" /* Loader */] {
  constructor(core, gl) {
    super(core);

    ibl_loader_defineProperty(this, "legacyLoader", void 0);

    ibl_loader_defineProperty(this, "_gl", void 0);

    this._gl = gl;
    this.legacyLoader = new _wgetemp_loader["a" /* Loader */]({
      type: Image
    });
  }

  async load(src, options = {}) {
    const environmentMaterial = await this.core.loadResource('environment-material', 'env-material', src, options);
    const {
      renderer
    } = this._gl;
    const {
      elementStaging,
      vertexStaging
    } = renderer;
    const result = await generateIBL(this.core, vertexStaging, elementStaging, environmentMaterial);

    if (!result) {
      throw new Error('No environment material');
    }

    const [illuminanceMap, preFilteredEnvMap, brdfLUT, iblSH] = result;
    return new ibl_loader_IBL(environmentMaterial, illuminanceMap, preFilteredEnvMap, brdfLUT, iblSH);
  }

  async parse(id, ibl) {
    this.core.addResource('ibl', id, ibl);
    return ibl;
  }

}

ibl_loader_defineProperty(ibl_loader_IBLLoader, "ID", 'ibl');
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/path-browserify/index.js
var path_browserify = __webpack_require__(113);
var path_browserify_default = /*#__PURE__*/__webpack_require__.n(path_browserify);

// EXTERNAL MODULE: ./src/core/resources/utils.ts
var utils = __webpack_require__(14);

// EXTERNAL MODULE: ./src/global-helpers/url.ts
var global_helpers_url = __webpack_require__(48);

// CONCATENATED MODULE: ./src/core/resources/loaders/model-loader/wmd-importer.ts
function wmd_importer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function getArrayClass(type) {
  switch (type) {
    case 5120:
      return Int8Array;

    case 5121:
      return Uint8Array;

    case 5122:
      return Int16Array;

    case 5123:
      return Uint16Array;

    case 5124:
      return Int32Array;

    case 5125:
      return Uint32Array;

    case 5126:
      return Float32Array;

    default:
      throw new Error('Unknown type');
  }
}

function getElementStride(type) {
  switch (type) {
    case 5121:
      return 1;

    case 5123:
      return 2;

    case 5125:
      return 4;

    default:
      throw new Error('Unknown type');
  }
}

function getSemantic(location) {
  switch (location) {
    case 0x00:
      return lib["d" /* AttributeSemantic */].POSITION;

    case 0x01:
      return lib["d" /* AttributeSemantic */].NORMAL;

    case 0x02:
      return lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0;

    case 0xFF:
      return lib["d" /* AttributeSemantic */].NONE;

    default:
      throw new Error('Unknown location');
  }
}

var MaterialSide;

(function (MaterialSide) {
  MaterialSide[MaterialSide["DOUBLE"] = 0] = "DOUBLE";
  MaterialSide[MaterialSide["FRONT"] = 1] = "FRONT";
})(MaterialSide || (MaterialSide = {}));

var SectionType;

(function (SectionType) {
  SectionType[SectionType["Renderables"] = 1] = "Renderables";
  SectionType[SectionType["Geometries"] = 2] = "Geometries";
  SectionType[SectionType["Materials"] = 3] = "Materials";
  SectionType[SectionType["Textures"] = 4] = "Textures";
  SectionType[SectionType["Buffers"] = 5] = "Buffers";
})(SectionType || (SectionType = {}));

class wmd_importer_WGeometry extends lib["t" /* Geometry */] {
  constructor(...args) {
    super(...args);

    wmd_importer_defineProperty(this, "_wmdLoadingCount", 0);
  }

  get unloaded() {
    return this._wmdLoadingCount !== 0;
  }

  increaseLoading() {
    this._wmdLoadingCount++;
  }

  decreaseLoading() {
    this._wmdLoadingCount--;

    if (this._wmdLoadingCount === 0) {
      this.onLoad.emit();
    }
  }

}

class wmd_importer_IndustrialWMDImporter {
  constructor(options) {
    wmd_importer_defineProperty(this, "_textDecoder", new TextDecoder());

    wmd_importer_defineProperty(this, "_defaultMaterial", void 0);

    wmd_importer_defineProperty(this, "_materialFactory", void 0);

    wmd_importer_defineProperty(this, "_onCreateInstance", void 0);

    wmd_importer_defineProperty(this, "_updateStaging", void 0);

    wmd_importer_defineProperty(this, "_createScene", void 0);

    wmd_importer_defineProperty(this, "_onLoadChunk", void 0);

    wmd_importer_defineProperty(this, "_batchMap", new utils["a" /* BatchMap */]());

    wmd_importer_defineProperty(this, "_stagings", null);

    wmd_importer_defineProperty(this, "_matrix", new math_lib["b" /* AffineMatrix3 */]());

    wmd_importer_defineProperty(this, "_scene", null);

    wmd_importer_defineProperty(this, "_loader", void 0);

    wmd_importer_defineProperty(this, "_geometryRequest", new Map());

    wmd_importer_defineProperty(this, "_geometries", []);

    wmd_importer_defineProperty(this, "_materials", []);

    wmd_importer_defineProperty(this, "_textures", []);

    wmd_importer_defineProperty(this, "_buffers", []);

    wmd_importer_defineProperty(this, "_subMeshesMap", new Map());

    wmd_importer_defineProperty(this, "_wmpCount", 0);

    wmd_importer_defineProperty(this, "_offset", 0);

    wmd_importer_defineProperty(this, "_f32", null);

    wmd_importer_defineProperty(this, "_u32", null);

    wmd_importer_defineProperty(this, "_u16", null);

    wmd_importer_defineProperty(this, "_u8", null);

    const {
      materialFactory = new lib["E" /* MaterialFactory */](),
      createScene = (maxSceneNodes, batchMap) => new utils["b" /* IndustrialDotScene */]({
        maxSceneNodes,
        batchMap,
        config: {
          componentClasses: []
        }
      }),
      onCreateInstance = () => undefined,
      updateStaging,
      loader = new _wgetemp_loader["a" /* Loader */]()
    } = options; // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#default-material

    this._defaultMaterial = materialFactory.createPbrMeshMaterial({
      albedo: new math_lib["k" /* RGBColor */](1, 1, 1),
      metalness: 1,
      roughness: 1
    });
    this._defaultMaterial.shaders.defines.NORMAL_PACK = 1;
    this._onCreateInstance = onCreateInstance;
    this._materialFactory = materialFactory;
    this._updateStaging = updateStaging;
    this._createScene = createScene;
    this._loader = loader;

    this._onLoadChunk = async () => undefined;
  }

  async import(url, options) {
    const {
      progressive,
      parallelChunks,
      onLoadChunk
    } = options; // Save callBack

    this._onLoadChunk = onLoadChunk; // load wmd file

    const buffer = await this._loader.load(url, {
      type: ArrayBuffer
    });
    this._f32 = new Float32Array(buffer);
    this._u32 = new Uint32Array(buffer);
    this._u16 = new Uint16Array(buffer);
    this._u8 = new Uint8Array(buffer);
    const u32 = this._u32; // Update stagings

    this._stagings = this._updateStaging({
      element: u32[8],
      vertex: u32[7]
    }); // Set element arrays length

    this._geometries.length = u32[3];
    this._materials.length = u32[4];
    this._buffers.length = u32[6]; // WMP settings

    this._wmpCount = u32[10]; // Parse WMD

    this._offset = 11;
    await this._parseSections(url); // Save scene before cleared

    if (this._scene === null) {
      throw new Error('Scene is undefined');
    } // Create scene from WMD file


    const scene = this._scene; // @ts-expect-error No typings for that

    scene._deferredTasks = []; // Save materials before cleared

    const materials = [...this._materials]; // Create all materials from WMD file

    materials.push(this._defaultMaterial); // Clear data if not use wmp files

    if (this._wmpCount === 0) {
      this._release();

      this._clear();
    } // Load and parse WMP


    if (progressive) {
      this._progressiveImportParts(url, parallelChunks);
    } else {
      const allParts = [];

      for (let it = 0; it < this._wmpCount; it++) {
        allParts.push(this._importWMP(url, it));
      }

      await Promise.all(allParts);

      this._release();

      this._clear();
    } // Return


    return {
      materials,
      scenes: [scene]
    };
  }

  async _importWMP(url, part) {
    const extName = path_browserify_default.a.extname(url);
    const wmpUrl = Object(global_helpers_url["a" /* getUrlSibling */])(url, `${path_browserify_default.a.basename(url, extName)}[${part}].wmp`);
    const wmpBuffer = await this._loader.load(wmpUrl, {
      type: ArrayBuffer
    });
    this._f32 = new Float32Array(wmpBuffer);
    this._u32 = new Uint32Array(wmpBuffer);
    this._u16 = new Uint16Array(wmpBuffer);
    this._u8 = new Uint8Array(wmpBuffer);
    this._offset = 2;
    await this._parseSections(url);
  }

  async _progressiveImportParts(url, parallelChunks) {
    let loaded = 1;
    const total = this._wmpCount + 1; // +1 - because wmd file with first chunk has been already loaded

    await this._onLoadChunk(loaded, total);
    const chunkTupleQueue = [];

    for (let it = this._wmpCount - 1; it >= 0; it--) {
      chunkTupleQueue.push([it, url]);
    }

    const loadingChunks = new Set();

    const loadChunk = async (chunkUrl, chunkNumber) => {
      await this._importWMP(chunkUrl, chunkNumber);
      loaded++;
      await this._onLoadChunk(loaded, total);
    };

    const updateLoadingChunks = () => {
      while (loadingChunks.size < parallelChunks) {
        const chunkTuple = chunkTupleQueue.pop();

        if (!chunkTuple) {
          break;
        } // chunkTupleQueue is empty


        const [chunkNumber, chunkUrl] = chunkTuple;
        const loadingChunk = loadChunk(chunkUrl, chunkNumber).then(() => {
          loadingChunks.delete(loadingChunk);
        });
        loadingChunks.add(loadingChunk);
      }
    };

    updateLoadingChunks();

    while (chunkTupleQueue.length > 0 || loadingChunks.size > 0) {
      await Promise.race(loadingChunks); // wait at least one chunk loaded

      updateLoadingChunks();
    }

    this._release();

    this._clear();
  }

  _release() {
    for (const geometry of this._geometries) {
      if (geometry === undefined) {
        continue;
      }

      if (geometry.indices) {
        geometry.indices.release();
      }

      for (const attribute of geometry.attributes.values()) {
        attribute.release();
      }

      geometry.release();
    }

    for (const material of this._materials) {
      if (material === undefined) {
        continue;
      }

      material.release();
    }

    for (const texture of this._textures) {
      if (texture === undefined) {
        continue;
      }

      texture.release();
    }

    for (const buffer of this._buffers) {
      if (buffer === undefined) {
        continue;
      }

      buffer.release();
    }

    this._subMeshesMap.clear();
  }

  _clear() {
    this._batchMap = new utils["a" /* BatchMap */]();
    this._stagings = null;
    this._scene = null;

    this._geometryRequest.clear();

    this._geometries = [];
    this._materials = [];
    this._textures = [];
    this._buffers = [];

    this._subMeshesMap.clear();

    this._wmpCount = 0;
    this._offset = 0;
    this._f32 = null;
    this._u32 = null;
    this._u16 = null;
    this._u8 = null;
  }

  async _parseSections(url) {
    const u32 = this._u32;
    const u8 = this._u8;
    let type = 0;
    let firstElement = 0;
    let elementCount = 0;

    while (this._offset * 4 < u8.length) {
      type = u8[this._offset * 4];
      elementCount = u32[this._offset] >> 8;
      firstElement = u32[this._offset + 1];
      this._offset += 3;

      switch (type) {
        case SectionType.Renderables:
          this._parseRenderables(firstElement, elementCount);

          break;

        case SectionType.Geometries:
          this._parseGeometries(firstElement, elementCount);

          break;

        case SectionType.Materials:
          this._parseMaterials(firstElement, elementCount);

          break;

        case SectionType.Textures:
          await this._parseTextures(firstElement, elementCount, url);
          break;

        case SectionType.Buffers:
          this._parseBuffers(firstElement, elementCount);

          break;

        default:
          console.warn('Undefined section format');
          break;
      }
    }
  }

  _parseRenderables(firstElement, elementCount) {
    const f32 = this._f32;
    const u32 = this._u32;
    const u16 = this._u16;
    const offset = this._offset; // create node, mesh, submesh, setMatrix

    for (let it = 0; it < elementCount; it++) {
      let subMeshes = this._subMeshesMap.get(u32[offset + it * 14]);

      if (!subMeshes) {
        subMeshes = new Set();

        this._subMeshesMap.set(u32[offset + it * 14], subMeshes);
      }

      const materialId = u16[offset * 2 + 3 + it * 28];
      const material = materialId !== 0xFFFF ? this._materials[materialId] : this._defaultMaterial;
      const subMesh = new utils["c" /* IndustrialRenderable */](this._geometries[u16[offset * 2 + 2 + it * 28]], material);
      const k = [subMesh.geometry.id, subMesh.material.id];
      let instanceCount = this._batchMap.get(k) || 0;

      this._batchMap.set(k, ++instanceCount);

      subMeshes.add({
        matrixOffset: offset + it * 14 + 2,
        submesh: subMesh
      });
    }

    this._scene = this._createScene(u32[2] + 1, this._batchMap); // +1 - root node
    // TODO Mb possible to do it in one upper loop without `this._subMeshesMap` creation

    for (const [externalId, subMeshes] of this._subMeshesMap) {
      for (const submeshCell of subMeshes) {
        this._matrix.fromAffineArrayAt(submeshCell.matrixOffset, f32);

        submeshCell.submesh.geometry.needsUpdateBoundingBox = false;

        this._scene.addInstance(submeshCell.submesh, this._matrix);

        this._onCreateInstance(this._scene, this._batchMap, submeshCell.submesh, externalId);
      }
    }

    this._batchMap.clear();

    this._offset = offset + elementCount * 14;
  }

  _parseGeometries(firstElement, elementCount) {
    const u32 = this._u32;
    const u16 = this._u16;
    const u8 = this._u8;
    let offset = this._offset;
    let request;
    let ArrayClass;

    for (let it = firstElement; it < firstElement + elementCount; it++) {
      // Parse header
      this._geometries[it] = new wmd_importer_WGeometry();
      this._geometries[it].primitiveType = u16[offset * 2];
      const elementType = u16[offset * 2 + 1];
      const elementBufferId = u32[offset + 1];
      const attrCount = u16[offset * 2 + 4];
      offset += 3; // Create indexes

      ArrayClass = getArrayClass(elementType);
      request = {
        geometry: this._geometries[it],
        location: 0xFF,
        elementType: lib["nb" /* VertexAttributeType */].SCALAR,
        countComponents: 1,
        componentType: elementType,
        normalized: false,
        semantic: lib["d" /* AttributeSemantic */].NONE,
        stride: getElementStride(elementType),
        offset: 0,
        type: ArrayClass
      };

      if (this._buffers[elementBufferId] !== undefined) {
        // If no index buffer, then id === 0xFFFFFFFF => this._buffers[elementBufferId] === undefined
        this._geometries[it].indices = new lib["mb" /* VertexAttribute */](Object.assign(request, {
          countElements: this._buffers[elementBufferId].view.byteLength / ArrayClass.BYTES_PER_ELEMENT,
          vertexData: this._buffers[elementBufferId]
        }));
      } else {
        if (!this._geometryRequest.has(elementBufferId)) {
          this._geometryRequest.set(elementBufferId, new Set());
        }

        this._geometryRequest.get(elementBufferId).add(request);

        this._geometries[it].increaseLoading();
      } // Create attributes


      for (let jt = 0; jt < attrCount; jt++) {
        const location = u8[offset * 4]; // layout (location = 0) in vec3 position;

        const size = u8[offset * 4 + 1] & 0x7F; // 1, 2, 3, 4

        const normalized = Boolean(u8[offset * 4 + 1] >> 7);
        const attrType = u16[offset * 2 + 1]; // GL_FLOAT

        const stride = u16[offset * 2 + 2];
        const attrOffset = u16[offset * 2 + 3];
        const bufferId = u32[offset + 2];
        ArrayClass = getArrayClass(attrType);
        request = {
          geometry: this._geometries[it],
          location,
          elementType: location === 0 ? lib["nb" /* VertexAttributeType */].VEC3 : lib["nb" /* VertexAttributeType */].VEC2,
          // TODO
          countComponents: size,
          componentType: attrType,
          normalized,
          semantic: getSemantic(location),
          stride,
          offset: attrOffset,
          type: ArrayClass
        };

        if (this._buffers[bufferId] !== undefined) {
          this._geometries[it].attributes.set(request.semantic, new lib["mb" /* VertexAttribute */](Object.assign(request, {
            countElements: this._buffers[bufferId].view.byteLength / ArrayClass.BYTES_PER_ELEMENT / size,
            vertexData: this._buffers[bufferId]
          })));

          if (request.semantic === lib["d" /* AttributeSemantic */].POSITION) {
            this._geometries[it].updateBoundingBox();
          }
        } else {
          if (!this._geometryRequest.has(bufferId)) {
            this._geometryRequest.set(bufferId, new Set());
          }

          this._geometryRequest.get(bufferId).add(request);

          this._geometries[it].increaseLoading();
        }

        offset += 3;
      }
    }

    this._offset = offset;
  }

  _parseMaterials(firstElement, elementCount) {
    // TODO PBR only!
    const f32 = this._f32;
    const u32 = this._u32;
    const u16 = this._u16;
    const u8 = this._u8;
    let offset = this._offset;

    for (let it = firstElement; it < firstElement + elementCount; it++) {
      this._materials[it] = this._materialFactory.createPbrMeshMaterial({
        name: it.toString(),
        albedo: new math_lib["k" /* RGBColor */](),
        opacity: (u32[offset + 1] >>> 24) / 255,
        alphaMode: u8[offset * 4 + 1] & 0x03,
        roughness: f32[offset + 2],
        metalness: f32[offset + 3],
        cullFace: (u8[offset * 4 + 1] >> 2 & 0x03) === MaterialSide.FRONT ? lib["D" /* Material */].CullFace.BACK : lib["D" /* Material */].CullFace.NONE,
        albedoMap: u16[offset * 2 + 10] !== 0xFFFF ? this._textures[u16[offset * 2 + 10]] : undefined,
        normalMap: u16[offset * 2 + 11] !== 0xFFFF ? this._textures[u16[offset * 2 + 11]] : undefined,
        metalnessRoughnessMap: u16[offset * 2 + 12] !== 0xFFFF ? this._textures[u16[offset * 2 + 12]] : undefined,
        ambientOcclusionMap: u16[offset * 2 + 13] !== 0xFFFF ? this._textures[u16[offset * 2 + 13]] : undefined
      });

      this._materials[it].albedo.fromPackedInteger(u32[offset + 1]);

      this._materials[it].shaders.defines.NORMAL_PACK = 1;
      Object(utils["e" /* adjustInternalFormat */])(this._materials[it].albedoMap);
      Object(utils["e" /* adjustInternalFormat */])(this._materials[it].emissiveMap);
      const albedoMap = this._materials[it].albedoMap;

      if (albedoMap !== null) {
        albedoMap.transform.fromAffineArrayAt(offset + 7, f32);
      }

      const normalMap = this._materials[it].normalMap;

      if (normalMap !== null) {
        normalMap.transform.fromAffineArrayAt(offset + 13, f32);
      }

      const metalnessRoughnessMap = this._materials[it].metalnessRoughnessMap;

      if (metalnessRoughnessMap !== null) {
        metalnessRoughnessMap.transform.fromAffineArrayAt(offset + 19, f32);
      }

      const ambientOcclusionMap = this._materials[it].ambientOcclusionMap;

      if (ambientOcclusionMap !== null) {
        ambientOcclusionMap.transform.fromAffineArrayAt(offset + 25, f32);
        ambientOcclusionMap.strength = f32[offset + 4];
      }

      offset += 31;
    }

    this._offset = offset;
  }

  async _parseTextures(firstElement, elementCount, url) {
    const u32 = this._u32;
    const u8 = this._u8;
    let offset = this._offset;

    for (let it = firstElement; it < firstElement + elementCount; it++) {
      offset += 1;
      const levelsData = [];
      const count = u8[offset * 4 - 2];
      let width = 1;
      let height = 1;

      for (let i = 0; i < count; i++) {
        const fileName = this._textDecoder.decode(new Uint8Array(u8.buffer, offset * 4 + 16, u32[offset] - 16));

        const fileUrl = fileName.startsWith('data:') && fileName.includes('base64') ? fileName : Object(global_helpers_url["a" /* getUrlSibling */])(url, fileName);
        const textureLevelData = await this._loadTextureLevelData(fileUrl);
        levelsData.push(textureLevelData);
        width = textureLevelData.width;
        height = textureLevelData.height;
        offset += Math.ceil(u32[offset] / 4);
      }

      this._textures[it] = new lib["gb" /* Texture */]({
        width,
        height,
        bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
        wrapS: lib["gb" /* Texture */].WrappingMode.REPEAT,
        wrapT: lib["gb" /* Texture */].WrappingMode.REPEAT,
        minFilter: lib["gb" /* Texture */].Filter.LINEAR_MIPMAP_LINEAR,
        magFilter: lib["gb" /* Texture */].Filter.LINEAR,
        anisotropyDegree: 4,
        format: lib["N" /* PixelDataFormat */].RGBA,
        levelsData,
        dynamic: true
      });
    }

    this._offset = offset;
  }

  _parseBuffers(firstElement, elementCount) {
    // TODO check geometryRequest when create buffer
    const u32 = this._u32;
    const u8 = this._u8;
    let offset = this._offset;

    for (let it = firstElement; it < firstElement + elementCount; it++) {
      const staging = u32[offset] & 0x80000000 ? this._stagings.elementStaging : this._stagings.vertexStaging;
      const length = u32[offset] & 0x7FFFFFFF;
      this._buffers[it] = new lib["pb" /* VertexBufferView */](staging, length);
      const vertexArray = new Uint8Array(this._buffers[it].view.buffer, this._buffers[it].view.byteOffset, length);
      const dataArray = new Uint8Array(u8.buffer, offset * 4 + 4, length);
      vertexArray.set(dataArray);
      offset += Math.ceil((u32[offset] & 0x7FFFFFFF) / 4) + 1; // geometry requests

      const requestSet = this._geometryRequest.get(it);

      if (requestSet === undefined) {
        continue;
      }

      for (const request of requestSet) {
        const countElements = this._buffers[it].view.byteLength / request.type.BYTES_PER_ELEMENT / request.countComponents;
        const vertexData = this._buffers[it];

        if (request.location === 0xFF) {
          // Indexes
          request.geometry.indices = new lib["mb" /* VertexAttribute */](Object.assign(request, {
            countElements,
            vertexData
          }));
        } else {
          // VertexData
          request.geometry.attributes.set(request.semantic, new lib["mb" /* VertexAttribute */](Object.assign(request, {
            countElements,
            vertexData
          })));
        }

        request.geometry.decreaseLoading();

        if (request.semantic === lib["d" /* AttributeSemantic */].POSITION) {
          request.geometry.updateBoundingBox();
        }
      }
    }

    this._offset = offset;
  } // This method is faster than `_loadTextureLevelData` but without progress


  async _loadTextureLevelDataNoProgress(imageUrl) {
    const data = await Object(utils["i" /* loadImage */])(imageUrl);
    return new lib["hb" /* TextureLevelData */]({
      data,
      width: data.width,
      height: data.height
    });
  }

  async _loadTextureLevelData(url) {
    const bytes = await this._loader.load(url, {
      baseUrl: '',
      type: Uint8Array
    }); // @ts-ignore

    const mimeType = bytes[_wgetemp_loader["a" /* Loader */].mimeType];
    const data = await Object(utils["f" /* createImageFromBytes */])(bytes, mimeType);
    return new lib["hb" /* TextureLevelData */]({
      data,
      width: data.width,
      height: data.height
    });
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/default-map.js
var default_map = __webpack_require__(403);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/index.js + 10 modules
var gltf_extensions_lib = __webpack_require__(66);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/index.js + 5 modules
var gltf_importer_lib = __webpack_require__(65);

// CONCATENATED MODULE: ./src/core/resources/loaders/model-loader/gltf-importer.js
/* eslint-disable generator-star-spacing, no-shadow, yield-star-spacing, no-param-reassign */








async function createImageFromBytes(bytes, mimeType) {
  const blob = new Blob([bytes], {
    type: mimeType
  });
  const url = URL.createObjectURL(blob);

  try {
    return await new _wgetemp_loader["a" /* Loader */]().load(url, {
      type: Image
    });
  } finally {
    URL.revokeObjectURL(url);
  }
}

class Output {
  constructor() {
    this.vertexBufferViews = [];
    this.vertexAttributes = [];
    this.geometries = [];
    this.textureLevelDatas = [];
    this.textures = [];
    this.materials = [];
    this.meshes = [];
    this.nodes = [];
    this.scenes = [];
  }

  dispose() {
    for (const releaseable of function* () {
      yield* this.vertexBufferViews;
      yield* this.vertexAttributes;
      yield* this.geometries;
      yield* this.textures;
      yield* this.materials; // yield* this.meshes;

      yield* this.scenes;
    }.call(this)) {
      releaseable.release();
    }
  }

}
class gltf_importer_IndustrialGLTFImporter {
  constructor({
    loader = new _wgetemp_loader["a" /* Loader */](),
    attributeMemoryManager = null,
    indexMemoryManager = null,
    vertexHardwareBuffer = null,
    indexHardwareBuffer = null,
    materialFactory = null,
    createScene = null,
    extensions = [gltf_extensions_lib["b" /* KHR_texture_transform */]],
    // eslint-disable-line camelcase
    onCreateInstance = () => undefined
  } = {}) {
    this.loader = loader;
    this.attributeMemoryManager = attributeMemoryManager;
    this.indexMemoryManager = indexMemoryManager;
    this.vertexHardwareBuffer = vertexHardwareBuffer;
    this.indexHardwareBuffer = indexHardwareBuffer;
    this.materialFactory = materialFactory;
    this.createScene = createScene;
    this.onCreateInstance = onCreateInstance;
    this._extensions = Object(gltf_extensions_lib["l" /* resolveExtensionDependencies */])(extensions);

    this._reset();
  }

  _reset() {
    this._preImported = false;
    this.url = null;
    this.json = null;
    this.maps = {
      uriToExternalResource: new Map(),
      bufferToBuffer: new Map(),
      bufferViewToBufferView: new Map(),
      bufferViewToVertexBufferView: new Map(),
      accessorToAccessor: new Map(),
      accessorToVertexAttributes: new default_map["a" /* DefaultMap */](() => new Map()),
      primitiveToGeometry: new Map(),
      imageToTextureLevelData: new Map(),
      textureToTexture: new Map(),
      samplerToTextures: new default_map["a" /* DefaultMap */](() => new Set()),
      materialToMaterial: new Map(),
      primitiveToSubMeshes: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      meshToMeshes: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      cameraToCameras: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      nodeToNodes: new default_map["a" /* DefaultMap */](() => new Map()),
      sceneToScene: new Map(),
      batchMap: new utils["a" /* BatchMap */](),
      nodesWithAnimation: new Set()
    };
    this.output = new Output();
    this.estimatedVertexAttributesSize = 0;
    this.estimatedVertexIndicesSize = 0;
  }

  clear() {
    delete this.json;
    delete this.maps;
  }

  getComponentArrayType(componentType) {
    switch (componentType) {
      // eslint-disable-line
      case WebGLRenderingContext.BYTE:
        return Int8Array;

      case WebGLRenderingContext.UNSIGNED_BYTE:
        return Uint8Array;

      case WebGLRenderingContext.SHORT:
        return Int16Array;

      case WebGLRenderingContext.UNSIGNED_SHORT:
        return Uint16Array;

      case WebGLRenderingContext.INT:
        return Int32Array;

      case WebGLRenderingContext.UNSIGNED_INT:
        return Uint32Array;

      case WebGLRenderingContext.FLOAT:
        return Float32Array;
    }

    console.error(`unknown component type: ${componentType}`);
  }

  getComponentSize(componentType) {
    return this.getComponentArrayType(componentType).BYTES_PER_ELEMENT;
  }

  getElementWidth(type) {
    switch (type) {
      // eslint-disable-line
      case 'SCALAR':
        return 1;

      case 'VEC2':
        return 2;

      case 'VEC3':
        return 3;

      case 'VEC4':
        return 4;

      case 'MAT2':
        return 4;

      case 'MAT3':
        return 9;

      case 'MAT4':
        return 16;
    }

    console.error(`unknown type: ${type}`);
  }

  getElementSize({
    type,
    componentType
  }) {
    return this.getElementWidth(type) * this.getComponentSize(componentType);
  }

  translateAttributeSemantic(semantic, morphTargetIndex) {
    const match = /^TEXCOORD_(\d+)$/.exec(semantic);

    if (match) {
      const channel = match[1];
      semantic = `TEX_COORD_CHANNEL_${channel}`;
    } else {
      switch (semantic) {
        // eslint-disable-line
        case 'POSITION':
        case 'NORMAL':
        case 'TANGENT':
          if (morphTargetIndex !== undefined) {
            semantic = `${semantic}_MORPH_${morphTargetIndex}`;
          }

          break;

        case 'COLOR_0':
          semantic = 'COLOR';
          break;

        case 'JOINTS_0':
          semantic = 'BONE_INDICES';
          break;

        case 'WEIGHTS_0':
          semantic = 'BONE_WEIGHTS';
          break;
      }
    }

    semantic = lib["d" /* AttributeSemantic */][semantic];

    if (semantic === undefined) {
      semantic = lib["d" /* AttributeSemantic */].NONE;
    }

    return semantic;
  }

  _normalizeBuffers() {
    const {
      buffers
    } = this.json;

    for (const [i, buffer] of buffers.entries()) {
      buffers[i] = Object.assign({
        extensions: {}
      }, buffer);
    }
  }

  _normalizeBufferViews() {
    const {
      accessors,
      bufferViews,
      meshes
    } = this.json;

    for (const {
      primitives
    } of meshes) {
      for (const {
        indices,
        attributes,
        targets = []
      } of primitives) {
        if (indices !== undefined) {
          const accessor = accessors[indices];

          if (accessor.bufferView !== undefined) {
            const bufferView = bufferViews[accessor.bufferView];
            bufferViews[accessor.bufferView] = Object.assign({
              target: WebGLRenderingContext.ELEMENT_ARRAY_BUFFER
            }, bufferView);
          }
        }

        for (const attribute of function* () {
          yield* Object.values(attributes);

          for (const targetAttributes of targets) {
            yield* Object.values(targetAttributes);
          }
        }.call(this)) {
          const accessor = accessors[attribute];

          if (accessor.bufferView !== undefined) {
            const bufferView = bufferViews[accessor.bufferView];
            bufferViews[accessor.bufferView] = Object.assign({
              target: WebGLRenderingContext.ARRAY_BUFFER,
              byteStride: this.getElementSize(accessor)
            }, bufferView);
          }
        }
      }
    }

    for (const [i, bufferView] of bufferViews.entries()) {
      bufferViews[i] = Object.assign({
        byteOffset: 0,
        extensions: {}
      }, bufferView);
    }
  }

  _normalizeAccessors() {
    const {
      accessors
    } = this.json;

    for (const [i, accessor] of accessors.entries()) {
      accessors[i] = Object.assign({
        byteOffset: 0,
        normalized: false,
        extensions: {}
      }, accessor);
    }
  }

  _normalizeImages() {
    const {
      images
    } = this.json;

    for (const [i, image] of images.entries()) {
      images[i] = Object.assign({
        extensions: {}
      }, image);
    }
  }

  _normalizeSamplers() {
    const {
      samplers
    } = this.json;
    const defaultSampler = {};
    samplers.push(defaultSampler);

    for (const [i, sampler] of samplers.entries()) {
      samplers[i] = Object.assign({
        wrapS: WebGLRenderingContext.REPEAT,
        wrapT: WebGLRenderingContext.REPEAT,
        extensions: {}
      }, sampler);
    }
  }

  _normalizeTextures() {
    let usesDefaultSampler = false;
    const {
      samplers,
      textures
    } = this.json;

    for (const [i, texture] of textures.entries()) {
      if (texture.sampler === undefined) {
        texture.sampler = samplers.length - 1;
        usesDefaultSampler = true;
      }

      textures[i] = Object.assign({
        extensions: {}
      }, texture);
    }

    if (!usesDefaultSampler) {
      samplers.pop();
    }
  }

  _normalizeTextureInfo(textureInfo) {
    return Object.assign({
      texCoord: 0,
      extensions: {}
    }, textureInfo);
  }

  _normalizeMaterials() {
    const {
      materials
    } = this.json; // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#default-material

    const defaultMaterial = {};
    materials.push(defaultMaterial);

    for (let [i, material] of materials.entries()) {
      // eslint-disable-line
      material = Object.assign({
        pbrMetallicRoughness: {},
        emissiveFactor: [0, 0, 0],
        alphaMode: 'OPAQUE',
        alphaCutoff: 0.5,
        doubleSided: false,
        extensions: {}
      }, material);
      materials[i] = material;
      let {
        pbrMetallicRoughness
      } = material;
      pbrMetallicRoughness = Object.assign({
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1,
        extensions: {}
      }, pbrMetallicRoughness);
      Object.assign(material, {
        pbrMetallicRoughness
      });
      let {
        baseColorTexture
      } = pbrMetallicRoughness;

      if (baseColorTexture !== undefined) {
        baseColorTexture = this._normalizeTextureInfo(baseColorTexture);
        Object.assign(pbrMetallicRoughness, {
          baseColorTexture
        });
      }

      let {
        metallicRoughnessTexture
      } = pbrMetallicRoughness;

      if (metallicRoughnessTexture !== undefined) {
        metallicRoughnessTexture = this._normalizeTextureInfo(metallicRoughnessTexture);
        Object.assign(pbrMetallicRoughness, {
          metallicRoughnessTexture
        });
      }

      let {
        normalTexture
      } = material;

      if (normalTexture !== undefined) {
        normalTexture = this._normalizeTextureInfo(normalTexture);
        normalTexture = Object.assign({
          scale: 1
        }, normalTexture);
        Object.assign(material, {
          normalTexture
        });
      }

      let {
        occlusionTexture
      } = material;

      if (occlusionTexture !== undefined) {
        occlusionTexture = this._normalizeTextureInfo(occlusionTexture);
        occlusionTexture = Object.assign({
          strength: 1
        }, occlusionTexture);
        Object.assign(material, {
          occlusionTexture
        });
      }

      let {
        emissiveTexture
      } = material;

      if (emissiveTexture !== undefined) {
        emissiveTexture = this._normalizeTextureInfo(emissiveTexture);
        Object.assign(material, {
          emissiveTexture
        });
      }
    }
  }

  _normalizePrimitives(primitives) {
    let usesDefaultMaterial = false;
    const {
      materials
    } = this.json;

    for (const [i, primitive] of primitives.entries()) {
      if (primitive.material === undefined) {
        primitive.material = materials.length - 1;
        usesDefaultMaterial = true;
      }

      primitives[i] = Object.assign({
        mode: WebGLRenderingContext.TRIANGLES,
        targets: [],
        extensions: {}
      }, primitive);
    }

    return usesDefaultMaterial;
  }

  _normalizeMeshes() {
    let usesDefaultMaterial = false;
    const {
      materials,
      meshes
    } = this.json;

    for (const [i, mesh] of meshes.entries()) {
      if (this._normalizePrimitives(mesh.primitives)) {
        usesDefaultMaterial = true;
      }

      meshes[i] = Object.assign({
        weights: new Array(mesh.primitives[0].targets.length).fill(0),
        extensions: {}
      }, mesh);
    }

    if (!usesDefaultMaterial) {
      materials.pop();
    }
  }

  _normalizeNodes() {
    const matrix = new math_lib["g" /* HomogeneousMatrix3 */]();
    const splitTransform = new math_lib["d" /* AffineSplitTransform3 */]();
    const {
      meshes,
      nodes
    } = this.json;

    for (const [i, node] of nodes.entries()) {
      if (node.mesh !== undefined) {
        node.weights = [...meshes[node.mesh].weights];
      }

      if (node.matrix !== undefined) {
        matrix.fromArray(node.matrix);
        delete node.matrix;
        splitTransform.fromAffineMatrix(matrix);
        const {
          scaling,
          quaternion,
          translation
        } = splitTransform;
        node.scale = scaling.toArray([]);
        node.rotation = quaternion.toArray([]);
        node.translation = translation.toArray([]);
      }

      nodes[i] = Object.assign({
        children: [],
        scale: [1, 1, 1],
        rotation: [0, 0, 0, 1],
        translation: [0, 0, 0],
        extensions: {}
      }, node);
    }
  }

  _normalizeScenes() {
    const {
      scenes
    } = this.json;

    for (const [i, scene] of scenes.entries()) {
      scenes[i] = Object.assign({
        nodes: [],
        extensions: {}
      }, scene);
    }
  }

  _normalize() {
    this.json = Object.assign({
      extensionsUsed: [],
      extensionsRequired: [],
      buffers: [],
      bufferViews: [],
      accessors: [],
      images: [],
      samplers: [],
      textures: [],
      materials: [],
      meshes: [],
      cameras: [],
      scenes: [],
      extensions: {}
    }, this.json);

    this._normalizeBuffers();

    this._normalizeBufferViews();

    this._normalizeAccessors();

    this._normalizeImages();

    this._normalizeSamplers();

    this._normalizeTextures();

    this._normalizeMaterials();

    this._normalizeMeshes();

    this._normalizeNodes();

    this._normalizeScenes();
  }

  async _parse(fileName) {
    this.json = await Object(utils["h" /* load */])(fileName, 'json');
    const {
      version
    } = this.json.asset;

    if (version !== '2.0') {
      console.warn(`unexpected glTF version: ${version},(only 2.0 is explicitly supported)`); // eslint-disable-line
    }

    this._normalize();
  }

  getMemoryManager(target) {
    switch (target) {
      case WebGLRenderingContext.ARRAY_BUFFER:
        return this.attributeMemoryManager;

      case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
        return this.indexMemoryManager;

      case undefined:
      case null:
      default:
        console.warn(false, 'unknown glTF bufferView target');
      // eslint-disable-line
    }
  }

  getHardwareBuffer(target) {
    switch (target) {
      case WebGLRenderingContext.ARRAY_BUFFER:
        return this.vertexHardwareBuffer;

      case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
        return this.indexHardwareBuffer;

      default:
        console.warn(false, 'unknown glTF bufferView target');
      // eslint-disable-line
    }

    return null;
  }

  allocMemory(ArrayType, length, target) {
    const memoryManager = this.getMemoryManager(target);
    return memoryManager.allocMemory(ArrayType, length);
  }

  async _buildBuffers() {
    const {
      maps,
      json
    } = this;
    const baseUrl = new URL(this.url, window.location.href).href;

    for (const jsonBuffer of json.buffers) {
      const url = new URL(jsonBuffer.uri, baseUrl).href;
      const buffer = await this.loader.load(url, {
        type: ArrayBuffer
      });
      maps.bufferToBuffer.set(jsonBuffer, buffer);
    }
  }

  _buildBufferViews() {
    const {
      json,
      maps
    } = this;

    for (const jsonBufferView of json.bufferViews) {
      const jsonBuffer = json.buffers[jsonBufferView.buffer];
      const buffer = maps.bufferToBuffer.get(jsonBuffer);
      const bufferView = {
        buffer,
        offset: jsonBufferView.byteOffset,
        length: jsonBufferView.byteLength,
        stride: jsonBufferView.byteStride,
        target: jsonBufferView.target
      };
      maps.bufferViewToBufferView.set(jsonBufferView, bufferView);
    }
  }

  _buildAccessors() {
    const {
      json,
      maps
    } = this;
    const targets = new Map();

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        for (let jsonAccessor of function* () {
          yield* Object.values(jsonPrimitive.attributes);

          for (const targetAttributes of jsonPrimitive.targets) {
            yield* Object.values(targetAttributes);
          }
        }.call(this)) {
          jsonAccessor = json.accessors[jsonAccessor];

          if (jsonAccessor.bufferView === undefined) {
            targets.set(jsonAccessor, WebGLRenderingContext.ARRAY_BUFFER);
          }
        }

        if (jsonPrimitive.indices !== undefined) {
          const jsonAccessor = json.accessors[jsonPrimitive.indices];

          if (jsonAccessor.bufferView === undefined) {
            targets.set(jsonAccessor, WebGLRenderingContext.ELEMENT_ARRAY_BUFFER);
          }
        }
      }
    }

    for (const jsonAccessor of json.accessors) {
      const ComponentArrayType = this.getComponentArrayType(jsonAccessor.componentType);
      const elementWidth = this.getElementWidth(jsonAccessor.type);
      const componentSize = ComponentArrayType.BYTES_PER_ELEMENT;
      const elementSize = elementWidth * componentSize;
      let bufferView = null;
      const byteOffset = jsonAccessor.byteOffset; // eslint-disable-line

      let length = null;
      let stride = null;
      const accessor = {
        bufferView,
        target: null,
        ComponentArrayType,
        byteOffset,
        elementCount: jsonAccessor.count,
        length,
        stride,
        sparse: null
      };

      if (jsonAccessor.bufferView === undefined) {
        accessor.target = targets.get(jsonAccessor);
        length = accessor.length = accessor.elementCount * elementWidth; // eslint-disable-line

        stride = accessor.stride = elementWidth; // eslint-disable-line
      } else {
        const jsonBufferView = json.bufferViews[jsonAccessor.bufferView];
        bufferView = accessor.bufferView = maps.bufferViewToBufferView.get(jsonBufferView); // eslint-disable-line

        accessor.target = bufferView.target;
        const {
          stride: byteStride = elementSize
        } = bufferView;
        const byteLength = Object(math_lib["v" /* max */])(0, byteStride * (accessor.elementCount - 1) + elementSize);
        stride = accessor.stride = byteStride / componentSize; // eslint-disable-line

        length = accessor.length = byteLength / componentSize; // eslint-disable-line

        if (jsonAccessor.sparse !== undefined) {
          accessor.bufferView = null;
          accessor.byteOffset = 0;
          accessor.length = accessor.elementCount * elementWidth;
          accessor.stride = elementWidth;
        }
      }

      maps.accessorToAccessor.set(jsonAccessor, accessor);
    }
  }

  _buildVertexBufferViewsAndAttributes() {
    const vertexBufferViews = new Map();
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        for (const [accessorIndex, jsonSemantic, morphTargetIndex] of function* () {
          if (jsonPrimitive.indices !== undefined) {
            yield [jsonPrimitive.indices];
          }

          for (const [jsonSemantic, accessorIndex] of Object.entries(jsonPrimitive.attributes)) {
            yield [accessorIndex, jsonSemantic];
          }
        }.call(this)) {
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          let vertexAttribute = maps.accessorToVertexAttributes.get(jsonAccessor).get(semantic);

          if (vertexAttribute !== undefined) {
            continue;
          }

          const accessor = maps.accessorToAccessor.get(jsonAccessor);
          const {
            bufferView
          } = accessor;
          let vertexBufferView;

          if (bufferView !== null) {
            vertexBufferView = vertexBufferViews.get(bufferView);

            if (vertexBufferView === undefined) {
              vertexBufferView = new lib["pb" /* VertexBufferView */]();
              vertexBufferView._loadCount = 0;
              const jsonBufferView = json.bufferViews[jsonAccessor.bufferView];
              maps.bufferViewToVertexBufferView.set(jsonBufferView, vertexBufferView);
              output.vertexBufferViews.push(vertexBufferView);
              vertexBufferViews.set(accessor.bufferView, vertexBufferView);

              switch (bufferView.target) {
                // eslint-disable-line
                case WebGLRenderingContext.ARRAY_BUFFER:
                  this.estimatedVertexAttributesSize += bufferView.length;
                  break;

                case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
                  this.estimatedVertexIndicesSize += bufferView.length;
                  break;
              }
            }
          } else {
            vertexBufferView = new lib["pb" /* VertexBufferView */]();
            vertexBufferView._loadCount = 0;
            output.vertexBufferViews.push(vertexBufferView);

            switch (accessor.target) {
              // eslint-disable-line
              case WebGLRenderingContext.ARRAY_BUFFER:
                this.estimatedVertexAttributesSize += accessor.components.byteLength;
                break;

              case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
                this.estimatedVertexIndicesSize += accessor.components.byteLength;
                break;
            }
          }

          vertexAttribute = new lib["mb" /* VertexAttribute */]({
            vertexData: vertexBufferView,
            offset: accessor.byteOffset,
            stride: accessor.stride * this.getComponentSize(jsonAccessor.componentType),
            semantic,
            normalized: jsonAccessor.normalized,
            countComponents: this.getElementWidth(jsonAccessor.type),
            countElements: accessor.elementCount,
            componentType: jsonAccessor.componentType,
            type: accessor.ComponentArrayType,
            elementType: lib["nb" /* VertexAttributeType */][jsonAccessor.type]
          });
          vertexAttribute._loadCount = 0;
          maps.accessorToVertexAttributes.get(jsonAccessor).set(semantic, vertexAttribute);
          output.vertexAttributes.push(vertexAttribute);
        }
      }
    }
  }

  _loadVertexBufferViewsAndAttributes() {
    const {
      json,
      maps
    } = this;

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        for (const [accessorIndex, jsonSemantic, morphTargetIndex] of function* () {
          if (jsonPrimitive.indices !== undefined) {
            yield [jsonPrimitive.indices];
          }

          for (const [jsonSemantic, accessorIndex] of Object.entries(jsonPrimitive.attributes)) {
            yield [accessorIndex, jsonSemantic];
          }
        }.call(this)) {
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          const vertexAttribute = maps.accessorToVertexAttributes.get(jsonAccessor).get(semantic);
          const accessor = maps.accessorToAccessor.get(jsonAccessor);
          const {
            bufferView
          } = accessor;
          let vertexBufferView;

          if (bufferView !== null) {
            const jsonBufferView = json.bufferViews[jsonAccessor.bufferView];
            vertexBufferView = maps.bufferViewToVertexBufferView.get(jsonBufferView);

            if (vertexBufferView.unloaded) {
              vertexBufferView._loadCount = 1;
              const jsonBuffer = json.buffers[jsonBufferView.buffer];
              const buffer = maps.bufferToBuffer.get(jsonBuffer);
              const memoryManager = this.getMemoryManager(bufferView.target);
              const {
                empty = false
              } = memoryManager;
              vertexBufferView._view = memoryManager.allocMemory(Uint8Array, bufferView.length);
              vertexBufferView._staging = memoryManager;
              vertexBufferView.empty = empty;
              const bytes = new Uint8Array(buffer, bufferView.offset, bufferView.length);

              if (empty) {
                const hwBuffer = this.getHardwareBuffer(bufferView.target);

                if (hwBuffer !== null) {
                  hwBuffer.subdata(bytes, vertexBufferView.view.byteOffset);
                }
              } else {
                vertexBufferView._view.set(bytes);
              }
            }
          } else {
            console.assert(false); // TODO:: ...
            // vertexBufferView = new VertexBufferView();
            // vertexBufferView._loadCount = 0;
          }

          if (vertexAttribute.unloaded) {
            vertexAttribute._loadCount = 1;
            vertexAttribute.view = vertexBufferView.empty ? {
              byteOffset: vertexBufferView.view.byteOffset + accessor.byteOffset
            } : new accessor.ComponentArrayType(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset + accessor.byteOffset, accessor.length);
          }
        }
      }
    }
  }

  _buildGeometries() {
    const geometries = new tuple_map["a" /* TupleMap */]();
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        let vertexIndices;

        if (jsonPrimitive.indices !== undefined) {
          const jsonAccessor = json.accessors[jsonPrimitive.indices];
          vertexIndices = maps.accessorToVertexAttributes.get(jsonAccessor).get(lib["d" /* AttributeSemantic */].NONE);
        }

        const vertexAttributes = Array.from(function* () {
          for (const [jsonSemantic, accessorIndex] of Object.entries(jsonPrimitive.attributes)) {
            yield [accessorIndex, jsonSemantic];
          }

          for (const [morphTargetIndex, jsonMorphTargetAttributes] of jsonPrimitive.targets.entries()) {
            for (const [jsonSemantic, accessorIndex] of Object.entries(jsonMorphTargetAttributes)) {
              yield [accessorIndex, jsonSemantic, morphTargetIndex];
            }
          }
        }.call(this), ([accessorIndex, jsonSemantic, morphTargetIndex]) => {
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          return maps.accessorToVertexAttributes.get(jsonAccessor).get(semantic);
        });
        const key = [jsonPrimitive.mode, vertexIndices !== undefined ? vertexIndices : null, ...vertexAttributes];
        let geometry = geometries.get(key);

        if (geometry === undefined) {
          geometry = new lib["t" /* Geometry */]({
            primitiveType: jsonPrimitive.mode
          });

          if (vertexIndices !== undefined) {
            geometry.indices = vertexIndices;
          }

          for (const vertexAttribute of vertexAttributes) {
            geometry.attributes.set(vertexAttribute.semantic, vertexAttribute);
          }

          geometry._loadCount = 1;

          if (jsonPrimitive.attributes.POSITION !== undefined) {
            const accessor = json.accessors[jsonPrimitive.attributes.POSITION];
            const {
              min: bboxMin = [],
              max: bboxMax = []
            } = accessor;

            if (bboxMin.length >= 3 && bboxMax.length >= 3) {
              geometry.boundingBox.min.fromArray(bboxMin);
              geometry.boundingBox.max.fromArray(bboxMax);
              geometry.needsUpdateBoundingBox = false;
            }
          }

          geometries.set(key, geometry);
        }

        maps.primitiveToGeometry.set(jsonPrimitive, geometry);
      }
    }

    for (const geometry of geometries.values()) {
      output.geometries.push(geometry);
    }
  }

  async _buildTextureLevelDatas() {
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonImage of json.images) {
      const textureLevelData = new lib["hb" /* TextureLevelData */]({
        depth: 1,
        data: null
      });
      textureLevelData._loadCount = 0;
      const {
        WG_image_radiance_hdr: ext
      } = jsonImage.extensions;

      if (ext === undefined) {
        let externalResource = maps.uriToExternalResource.get(jsonImage.uri);

        if (externalResource === undefined) {
          externalResource = new gltf_importer_lib["a" /* ExternalResource */]({
            uri: jsonImage.uri,
            mimeType: jsonImage.mimeType
          });
          externalResource._loadCount = 1;
          externalResource.bytes = await this.loader.load(externalResource.uri, {
            baseUrl: this.url,
            type: Uint8Array
          });

          if (externalResource.mimeType === null) {
            externalResource.mimeType = externalResource.bytes[_wgetemp_loader["a" /* Loader */].mimeType];
          }

          maps.uriToExternalResource.set(jsonImage.uri, externalResource);
        }

        textureLevelData._loadCount = 1;
        const {
          bytes,
          mimeType
        } = externalResource;
        textureLevelData.data = await createImageFromBytes(bytes, mimeType);
        textureLevelData.width = textureLevelData.data.width;
        textureLevelData.height = textureLevelData.data.height;
      }

      maps.imageToTextureLevelData.set(jsonImage, textureLevelData);
      output.textureLevelDatas.push(textureLevelData);
    }
  }

  _buildTextures() {
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonTexture of json.textures) {
      const {
        name,
        source: imageIndex,
        sampler: samplerIndex
      } = jsonTexture;
      const jsonImage = json.images[imageIndex];
      const textureLevelData = maps.imageToTextureLevelData.get(jsonImage);
      const jsonSampler = json.samplers[samplerIndex];
      const texture = new lib["gb" /* Texture */]({
        name,
        bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
        wrapS: jsonSampler.wrapS,
        wrapT: jsonSampler.wrapT,
        minFilter: jsonSampler.minFilter,
        magFilter: jsonSampler.magFilter,
        levelsData: [textureLevelData],
        dynamic: this.dynamicTextures
      });

      if (jsonTexture.extras !== undefined) {
        texture.extras = jsonTexture.extras;
      }

      texture._loadCount = 0;

      if (textureLevelData._loadCount > 0) {
        const image = textureLevelData.data;
        texture.width = image.width;
        texture.height = image.height;

        switch (image[_wgetemp_loader["a" /* Loader */].mimeType]) {
          // eslint-disable-line
          case 'image/jpeg':
            texture.format = lib["N" /* PixelDataFormat */].RGB;
            break;

          case 'image/png':
            texture.format = lib["N" /* PixelDataFormat */].RGBA;
            break;
        }

        texture._needsUpdate = true;
        texture._loadCount = 1;
      }

      maps.textureToTexture.set(jsonTexture, texture);
      maps.samplerToTextures.get(jsonSampler).add(texture);
      output.textures.push(texture);
    }
  }

  _buildMaterials() {
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonMaterial of json.materials) {
      const {
        extensions
      } = jsonMaterial;
      let material;

      if (extensions.KHR_materials_unlit) {
        material = this._createUnlitMeshMaterial(jsonMaterial, maps, json);
      } else {
        material = this._createPbrMeshMaterial(jsonMaterial, maps, json);
      }

      maps.materialToMaterial.set(jsonMaterial, material);
      output.materials.push(material);
    }
  }

  _createPbrMeshMaterial(jsonMaterial, maps, json) {
    const {
      name,
      pbrMetallicRoughness: {
        baseColorTexture: jsonBaseColorTextureInfo,
        baseColorFactor: jsonBaseColorFactor,
        metallicRoughnessTexture: jsonMetallicRoughnessTextureInfo,
        metallicFactor,
        roughnessFactor
      },
      normalTexture: jsonNormalTextureInfo,
      occlusionTexture: jsonOcclusionTextureInfo,
      emissiveTexture: jsonEmissiveTextureInfo,
      emissiveFactor: jsonEmissiveFactor,
      alphaMode: jsonAlphaMode,
      alphaCutoff,
      doubleSided
    } = jsonMaterial;
    const material = this.materialFactory.createPbrMeshMaterial({
      name,
      alphaMode: lib["D" /* Material */].AlphaMode[jsonAlphaMode],
      alphaCutoff,
      opacity: jsonBaseColorFactor[3],
      cullFace: doubleSided ? lib["D" /* Material */].CullFace.NONE : lib["D" /* Material */].CullFace.BACK,
      albedo: new math_lib["k" /* RGBColor */]().fromArray(jsonBaseColorFactor),
      metalness: metallicFactor,
      roughness: roughnessFactor,
      emissive: new math_lib["k" /* RGBColor */]().fromArray(jsonEmissiveFactor)
    });
    material._loadCount = 1;

    if (jsonBaseColorTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex
      } = jsonBaseColorTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.albedoMap = new lib["D" /* Material */].TextureProperties(texture, undefined, texCoordIndex);
    }

    if (jsonMetallicRoughnessTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex
      } = jsonMetallicRoughnessTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.metalnessRoughnessMap = new lib["D" /* Material */].TextureProperties(texture, undefined, texCoordIndex);
    }

    if (jsonNormalTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex,
        scale
      } = jsonNormalTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.normalMap = new lib["D" /* Material */].NormalMapProperties(texture, undefined, texCoordIndex, scale);
    }

    if (jsonOcclusionTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex,
        strength
      } = jsonOcclusionTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.ambientOcclusionMap = new lib["D" /* Material */].AOMapProperties(texture, undefined, texCoordIndex, strength);
    }

    if (jsonEmissiveTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex
      } = jsonEmissiveTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.emissiveMap = new lib["D" /* Material */].EmissiveMapProperties(1, texture, undefined, texCoordIndex);
    }

    if (material.alphaMode === lib["D" /* Material */].AlphaMode.BLEND) {
      material.depthWrite = false;
    }

    if (jsonMaterial.extras !== undefined) {
      material.extras = jsonMaterial.extras;
    }

    Object(utils["e" /* adjustInternalFormat */])(material.albedoMap);
    Object(utils["e" /* adjustInternalFormat */])(material.emissiveMap);
    return material;
  }

  _createUnlitMeshMaterial(jsonMaterial, maps, json) {
    const {
      name,
      pbrMetallicRoughness: {
        baseColorTexture: jsonBaseColorTextureInfo,
        baseColorFactor: jsonBaseColorFactor
      },
      alphaMode: jsonAlphaMode,
      alphaCutoff,
      doubleSided
    } = jsonMaterial;
    const material = this.materialFactory.createUnlitMeshMaterial({
      name,
      alphaMode: lib["D" /* Material */].AlphaMode[jsonAlphaMode],
      alphaCutoff,
      opacity: jsonBaseColorFactor[3],
      cullFace: doubleSided ? lib["D" /* Material */].CullFace.NONE : lib["D" /* Material */].CullFace.BACK,
      color: new math_lib["k" /* RGBColor */]().fromArray(jsonBaseColorFactor)
    });

    if (jsonBaseColorTextureInfo !== undefined) {
      const {
        index: textureIndex,
        texCoord: texCoordIndex
      } = jsonBaseColorTextureInfo;
      const jsonTexture = json.textures[textureIndex];
      const texture = maps.textureToTexture.get(jsonTexture);
      material.colorMap = new lib["D" /* Material */].TextureProperties(texture, undefined, texCoordIndex);
    }

    material._loadCount = 0;

    if (material.alphaMode === lib["D" /* Material */].AlphaMode.BLEND) {
      material.depthWrite = false;
    }

    Object(utils["e" /* adjustInternalFormat */])(material.colorMap);
    return material;
  }

  _buildMeshes() {
    const {
      json,
      maps,
      output
    } = this;

    for (const jsonScene of json.scenes) {
      const walk = nodeIndex => {
        const jsonNode = json.nodes[nodeIndex];

        if (jsonNode.mesh !== undefined) {
          const jsonMesh = json.meshes[jsonNode.mesh];
          const mesh = new lib["F" /* Mesh */]({
            name: jsonMesh.name
          });
          mesh._loadCount = 0;

          for (const jsonPrimitive of jsonMesh.primitives) {
            const geometry = maps.primitiveToGeometry.get(jsonPrimitive);
            const jsonMaterial = json.materials[jsonPrimitive.material];
            const material = maps.materialToMaterial.get(jsonMaterial);
            const subMesh = new utils["c" /* IndustrialRenderable */](geometry, material);

            if (jsonPrimitive.extras !== undefined) {
              subMesh.extras = JSON.parse(JSON.stringify(jsonPrimitive.extras));
            }

            mesh.addSubMesh(subMesh);
            maps.primitiveToSubMeshes.get(jsonPrimitive).set([jsonScene, jsonNode], subMesh);
            const k = [geometry.id, material.id];
            let instanceCount = maps.batchMap.get(k) || 0;
            maps.batchMap.set(k, ++instanceCount);
          }

          if (jsonMesh.extras !== undefined) {
            mesh.extras = JSON.parse(JSON.stringify(jsonMesh.extras));
          }

          maps.meshToMeshes.get(jsonMesh).set([jsonScene, jsonNode], mesh);
          output.meshes.push(mesh);
        }

        jsonNode.children.forEach(walk);
      };

      jsonScene.nodes.forEach(walk);
    }
  }

  _buildNodesAndScenes() {
    // NOTE: since our `SceneNode`s cannot exit without `Scene`s, we cannot
    // sanely expose orphan node trees that are not referenced from some glTF
    // scene.
    const {
      json,
      maps,
      output
    } = this;
    let {
      createScene
    } = this;

    if (createScene === null) {
      // +1 - plus root
      createScene = () => new utils["b" /* IndustrialDotScene */]({
        maxSceneNodes: json.nodes.length + 1,
        batchMap: maps.batchMap,
        config: {
          componentClasses: []
        }
      });
    }

    for (const jsonScene of json.scenes) {
      const scene = createScene(json.nodes.length + 1, maps.batchMap); // +1 - plus root

      scene._deferredTasks = [];
      console.assert(scene.isDotScene, 'dotScene expected');
      scene.name = jsonScene.name;

      if (jsonScene.extras !== undefined) {
        scene.extras = jsonScene.extras; // never shared, no need to clone
      }

      maps.sceneToScene.set(jsonScene, scene);
      output.scenes.push(scene);
    }
  }

  _preEmplaceInstancedData() {
    const {
      json,
      maps
    } = this;
    const splitTransform = new math_lib["d" /* AffineSplitTransform3 */]();
    const worldMatrix = new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0);
    const localMatrix = new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0);

    for (const jsonScene of json.scenes) {
      const scene = maps.sceneToScene.get(jsonScene);

      const walk = (jsonNode, parentWorld) => {
        jsonNode = json.nodes[jsonNode]; // eslint-disable-line

        const externalId = Number(jsonNode.name);

        if (Number.isNaN(externalId) && jsonNode.mesh !== undefined) {
          throw new Error('Gltf node name is not a number. Maybe this file wasn\'t converted right.');
        }

        splitTransform.translation.fromArray(jsonNode.translation);
        splitTransform.scaling.fromArray(jsonNode.scale);
        splitTransform.quaternion.fromArray(jsonNode.rotation);
        localMatrix.fromSplitTransform(splitTransform);
        worldMatrix.copy(localMatrix).multiply(parentWorld);

        if (jsonNode.mesh !== undefined) {
          const jsonMesh = json.meshes[jsonNode.mesh];
          const mesh = maps.meshToMeshes.get(jsonMesh).get([jsonScene, jsonNode]);
          const {
            subMeshCount
          } = mesh;

          for (let i = 0; i < subMeshCount; i++) {
            const subMesh = mesh.getSubMesh(i);
            scene.addInstance(subMesh, worldMatrix);
            this.onCreateInstance(scene, maps.batchMap, subMesh, externalId);
          }
        }

        if (jsonNode.children.length > 0) {
          const parentMatrix = new math_lib["b" /* AffineMatrix3 */]();
          parentMatrix.copy(worldMatrix);

          for (const jsonChild of jsonNode.children) {
            walk(jsonChild, parentMatrix);
          }
        }
      };

      for (const jsonNode of jsonScene.nodes) {
        walk(jsonNode, new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0));
      }
    }

    maps.batchMap.clear();
  }

  async _build() {
    // order is important
    await this._buildBuffers();

    this._buildBufferViews();

    this._buildAccessors();

    this._buildVertexBufferViewsAndAttributes();

    this._buildGeometries();

    await this._buildTextureLevelDatas();

    this._buildTextures();

    this._buildMaterials();

    this._buildMeshes();

    this._buildNodesAndScenes();
  }

  async _preImport(url) {
    this._reset();

    this.url = url;
    await this._parse(this.url);
    await this._build();
    await this._applyExtensions();
  }

  async _applyExtensions() {
    for (const extension of this._extensions) {
      if (extension.preImport !== undefined) {
        await extension.preImport(this);
      }
    }
  }

  async preImport(url) {
    await this._preImport(url);
    this._preImported = true;
  }

  estimateBufferSizes() {
    console.warn('GLTFImporter#estimateBufferSizes is deprecated, use ' + 'GLTFImporter#estimatedVertexAttributesSize and ' + 'GLTFImporter#estimatedVertexIndicesSize instead.');
    return {
      attributeBufferSize: this.estimatedVertexAttributesSize,
      indexBufferSize: this.estimatedVertexIndicesSize
    };
  }

  async import(url) {
    if (!this._preImported) {
      await this._preImport(url);
    }

    this._loadVertexBufferViewsAndAttributes();

    {
      const {
        output
      } = this;
      const {
        meshes
      } = output;
      const [env] = meshes.filter(m => m.name === 'environment');

      if (env !== undefined) {
        await env.load();
      }
    }

    this._preEmplaceInstancedData();

    this.clear();
    this._preImported = false;
    return this.output;
  }

  clearCache() {
    for (const loadable of function* () {
      yield* this.maps.uriToExternalResource.values();
      yield* this.maps.accessorToAccessor.values();
      yield* this.maps.bufferViewToBufferView.values();
      yield* this.maps.bufferToBuffer.values();
    }.call(this)) {
      if (!loadable.unloaded) {
        loadable.unload();
      }
    }
  }

}
// EXTERNAL MODULE: ./src/core/resources/materials/index.ts + 1 modules
var resources_materials = __webpack_require__(23);

// CONCATENATED MODULE: ./src/core/resources/loaders/model-loader/index.ts
function model_loader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








class model_loader_ModelAssets extends lib["X" /* Resource */] {
  constructor(options) {
    super();

    model_loader_defineProperty(this, "extras", void 0);

    model_loader_defineProperty(this, "scenes", void 0);

    model_loader_defineProperty(this, "materials", void 0);

    Object.assign(this, options);
  }

}
class model_loader_ModelLoader extends lib["B" /* Loader */] {
  constructor(core, gl, structure) {
    super(core);

    model_loader_defineProperty(this, "_gl", void 0);

    model_loader_defineProperty(this, "_structure", void 0);

    model_loader_defineProperty(this, "_legacyLoader", void 0);

    model_loader_defineProperty(this, "_wmdImporter", void 0);

    model_loader_defineProperty(this, "_gltfImporter", void 0);

    model_loader_defineProperty(this, "_createScene", (maxSceneNodes, batchMap) => {
      if (!this._gl) {
        throw new Error('Module GL not set');
      }

      const {
        customAttributes
      } = this._gl;
      const config = {
        customAttributes,
        componentClasses: []
      };
      const scene = new utils["b" /* IndustrialDotScene */]({
        name: 'Main',
        maxSceneNodes,
        batchMap,
        config
      });
      return scene;
    });

    model_loader_defineProperty(this, "_handleCreateInstance", (scene, batchMap, instance, id) => {
      this._structure.addElement(id, instance, true); // Need this for fast rebatching
      // https://youtrack.webgears3d.com/issue/3ES-165


      const k = [instance.geometry.id, instance.material.id];
      const batchInstanceCount = batchMap.get(k);

      if (typeof batchInstanceCount !== 'number') {
        throw new Error('Can\'t get batch size');
      }

      instance.reallocStrategy = Object(utils["g" /* getReallocationStrategyByBatchSize */])(batchInstanceCount);
    });

    model_loader_defineProperty(this, "_updateStaging", sizes => {
      if (!this._gl) {
        throw new Error('Module GL not set');
      }

      this._gl.updateStaging(sizes);

      const {
        vertexStaging,
        elementStaging
      } = this._gl.renderer;
      return {
        vertexStaging,
        elementStaging
      };
    });

    this._gl = gl;
    this._structure = structure;
    const loader = new _wgetemp_loader["a" /* Loader */]();
    this._legacyLoader = loader;
    this._wmdImporter = new wmd_importer_IndustrialWMDImporter({
      loader,
      onCreateInstance: this._handleCreateInstance,
      updateStaging: this._updateStaging,
      createScene: this._createScene,
      materialFactory: new resources_materials["a" /* IndustrialMaterialFactory */]()
    });
    this._gltfImporter = new gltf_importer_IndustrialGLTFImporter({
      loader,
      // @ts-expect-error GLTF no typings
      onCreateInstance: this._handleCreateInstance,
      createScene: this._createScene,
      attributeMemoryManager: gl.renderer.vertexStaging,
      indexMemoryManager: gl.renderer.elementStaging,
      materialFactory: new resources_materials["a" /* IndustrialMaterialFactory */]()
    });
  }

  _resetProgress() {
    this._legacyLoader.progress.onChange.unsubscribeAll(); // @ts-ignore modify private property


    this._legacyLoader.progress._current = 0; // @ts-ignore modify private property

    this._legacyLoader.progress._total = 0;
  }

  async _loadModel(url, options) {
    const {
      onProgress,
      ...wmdOptions
    } = options;

    this._resetProgress();

    this._legacyLoader.progress.onChange.subscribe(() => {
      const {
        current,
        total
      } = this._legacyLoader.progress;
      onProgress([current, total]);
    });

    if (url.endsWith('.gltf')) {
      await this._gltfImporter.preImport(url);

      if (this._gltfImporter.estimatedVertexAttributesSize && this._gltfImporter.estimatedVertexIndicesSize) {
        this._updateStaging({
          vertex: this._gltfImporter.estimatedVertexAttributesSize,
          element: this._gltfImporter.estimatedVertexIndicesSize
        });
      }

      const {
        vertexStaging,
        elementStaging
      } = this._gl.renderer;
      this._gltfImporter.indexMemoryManager = elementStaging;
      this._gltfImporter.attributeMemoryManager = vertexStaging;
      const extras = this._gltfImporter.json.extras;
      const {
        materials,
        scenes
      } = await this._gltfImporter.import(url);
      return {
        extras,
        materials,
        scenes
      };
    }

    const assets = await this._wmdImporter.import(url, wmdOptions);
    return assets;
  }

  async load(url, options) {
    const extrasSrc = Object(global_helpers_url["a" /* getUrlSibling */])(url, 'extras.json');
    let externalExtras = {};

    try {
      externalExtras = await Object(utils["h" /* load */])(extrasSrc, 'json');
    } catch (error) {// Ignore
    }

    const modelAssetsRaw = await this._loadModel(url, options);
    return new model_loader_ModelAssets({ ...modelAssetsRaw,
      extras: { ...modelAssetsRaw.extras,
        ...externalExtras
      }
    });
  }

  async parse(id, assets) {
    this.core.addResource(model_loader_ModelLoader.ID, id, assets);
    const uniqueNameGenerator = new utils["d" /* UniqueNameGenerator */]();

    for (const material of assets.materials) {
      material.name = uniqueNameGenerator.get(material.name);
      this.core.addResource('material', material.name, material);
    }

    uniqueNameGenerator.clear();

    for (const [extrasName, extrasValue] of Object.entries(assets.extras)) {
      this.core.addResource('extras', extrasName, extrasValue);
    }

    return assets;
  }

}

model_loader_defineProperty(model_loader_ModelLoader, "ID", 'model');
// CONCATENATED MODULE: ./src/core/resources/loaders/texture-loader.ts
function texture_loader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class texture_loader_TextureLoader extends lib["B" /* Loader */] {
  async load(src, options = {}) {
    const legacyLoader = new _wgetemp_loader["a" /* Loader */]({
      type: Image
    });
    const image = await legacyLoader.load(src);
    const {
      responseType,
      ...textureOptions
    } = options;
    const {
      width,
      height
    } = image;
    const texture = new lib["gb" /* Texture */]({
      name: src.slice(-64),
      width,
      height,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
      magFilter: lib["gb" /* Texture */].Filter.LINEAR,
      minFilter: Object(math_lib["u" /* isPow2 */])(width) && Object(math_lib["u" /* isPow2 */])(height) ? lib["gb" /* Texture */].Filter.LINEAR_MIPMAP_LINEAR : lib["gb" /* Texture */].Filter.LINEAR,
      wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
      format: lib["N" /* PixelDataFormat */].RGBA,
      levelsData: [new lib["hb" /* TextureLevelData */]({
        data: image
      })],
      dynamic: false,
      ...textureOptions
    });
    return texture;
  }

  async parse(id, texture) {
    this.core.addResource(texture_loader_TextureLoader.ID, id, texture);
    return Promise.resolve(texture);
  }

}

texture_loader_defineProperty(texture_loader_TextureLoader, "ID", 'texture');
// CONCATENATED MODULE: ./src/core/resources/assets/point.png
/* harmony default export */ var point = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAACplBMVEX///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////89sGvxAAAA4XRSTlMABAP2/Hff9efvHwfu++HY+QaTRCM8Eo4JDw2gwYWv6CI9m+bsLaHqSxF2Y0UF4grV64uY44o7EAGeYHPIC1EuP0GN9EjOQ4h6Dl/S6d7wZd2JbDJeDFpCrhfPrVftkZRGl5ZUWCF7hMBiuSexkp/UdNB1zIwevXngKUeGmbT+cNydAlN91jeBKMJpK8dy8TosZhzTxJo4vh01979Ag2dbJrIkOZxrNjMg2RVS5Fkqysbbyz7RxWoY5VVK8yW8cVb9137ylaulbrtcE23Nh4AUZNr6UKJv+Gh4Ycl8TAiCf6Mu8iaqAAAKC0lEQVR4Xu3d5X9UZxYH8N9YZiaTEFckKoSECCSBAsEiQHD3QnHX4hRoi5RCsS5V2bp7t93q7tZW3V1+/8m+mc9SgZBH7r3PM5nv+/Mi93Mz995zznMOXJWUlDS8dHHPfYOPLhm0c86MtDBJhtNmzNk5aMnRwff11B9qRMLyfzz+wI5HBwTZuxnvDjww/mM/EsroQ5tHjgtTQHjcyM2HRiMRxMpC2yoppXJbqCwGq10auyVMJeEtY6tgJ3/9qhRqkfJFvR+W8U9aU0ONakZO8sMeD2dHqF0k+3lYoWjebjpk97wimK6tOkAHBarLYDDfur103N51Ppip+PhBuuLg8WKYZ9TjUbom+vgomKX4ZJSuin5WDHO0h5rpuuZQO8zg31xBT1TU+WCAnCZ6pqkeXtu3hJ5akgov+YYF6LHAMB88M/+XNEDXfHijsDWdRkhvLYQHLr5FY7x1EW7znUmnQdLP+OCq0ndpmPOlcNGCCzTOhQVwS+wqjVQegyse+jsN9cY+uGBxDY1VsxiOGxukwYJj4ayschru2Sw4qPZRGu/RWjjmoZ20wM6H4JBzr9IKr56DI+Y30xLN8+GAtlm0xqw2aNfdQYt0dEOzDx+hVR75EFp1ZtIymZ3QaHGY1gl0Q5vTYVoofBqaVK2klVZWQYsrLbRUyxVoUDSd1ppeBGVZ+2mx/VlQdSetdgsU7aHl9kDJ4SAtFzwMBblptF70aUhrXMYEsKzRox9A+38If0YnzHywumDDE69MvJS7NL8dANrzl+ZemvjKExsKqn/6aYAOWAAppReoWaRgUqoPvVvaVhChZh9thQT/m9Tq2NU89FHe0WPUqisL4n5NnTLqIKQugzpNgbBngtRn1QQIm7Cd+gTzIKjwBHVJCxVDSnEojbqcKISYVmqS0gMFPSnUpBVC5qdTi5QPoOiDFGqRPh8CfF3UoWUdNFjXQh26fOi7EDUoWQRNFpVQgxD6bH2YyjJ/4Yc2d83LpLLAevTVECobsR5avdhKZUPQR6upKuMwtFudQVWr0Sf++6loMBwxmIru96MvZlNNxVA4ZOj7VHMZfdAYoZKzv4Fjfn6WSiLtuLlhVLI8BgfFllPJMNzUtEqquBMOu5MqKqfhZv5BFWvguDVUcRI3URulglvhglupIFqL3j1OBZPhislUsBG9mhalvFa4pJXyogsdq4RNgWumUN5P0IusCkq7HS4aQWkDfLixBZb8/cDtlPZD3FgXZa2Cy1ZR1tu4oTyF6pPrbqGsPNzIjylpCDwwhJKqcQMvZ1LOdwrhgcLvUE5gFK5vF+W8mg9P5LdQznO4vibKGQqPDKWc7+G6HnAy/2NWjuhhXM92SnkJHsqglGxcx10RSsmBh3IoJXIXvm0SpcyFp+ZSyiRtiYb0VHgqNZ0ybsO3+GdQxnvw2L2UUePX9N8UgecilJGjKdH0XXhukabkXQYlNMAADVoe3rmUsQIGWEEZufi69yghBUZI0fE9cAclrIUR1lLCHfiaWIfcDWDvLRCO4asuUsIiGOJvlNCmXBEtgTFWKtdJt1HcD2CMAxT3FL5idDPFxWCMIoprHo1rtlJcNgySTXH34Jo6insdBplAcXW45jYKa4JRMihsJK4ZJ/MZZJTfUtg4/J8/TFGZMMyPKCrgRxyelEmpGOYqhW1FHP5AYWUwTB6FjUccpqpngmzMDG1AHAZSVAGMU6BQJB1EURNhnIkUNQhxGEBRqTBOKkUNQNzwIEX5YBwfRQWHx0NLKWomDDSTokrjkd0UtR8GepCiFscjx1DUQBhoIEWNiUeOleuJtf85eF888ghFTYWBplLUkXhkOUXNhoFmU1R5PHI5Rd0NA91NUcvjkZso6jEY6DGK2hSPnE5RE2CgKoq6X8+bsP3vwiUU9X0YaClFzYhHzqKoUTDQKIqaFY/soKiFMFAjRQXikRQGI1FYIl2A5AVIXoBiivpI8UfQ/qeA4mPQ/vcAxRch+7OiifUqvJ6iUhLrY2gCRU3X8Tlsf2UkmRBJpsR+RVEHEikpmkyLJwsjORT1SYKUxpLF0WR5PNkgkWyRSZgmqY0UVZ1YbXItCm1y4xOgUfIZlUbJrQnQKntUpVXWH6CoPydAs7Qvkdrl6yhsXPLARAIdmalSPDJzD8Vtt/7QVD8/Nlc5Gl/xVD8/OJk8OttGCa/BEGPUh+rFAv3t+Hwglhyg8DXPWTxCYyYlzEsOUfmGl6wdozOAEn6naZDSosQZpJRDGRXwXAVl1OOb/DWUca+dw9TShuNbbrNznN7vKWNHfx+oOLSfj9RsHq5xqGoGPPQppazp72N1n8d1nerng5Wxi3IavBqt3UA585LD1fv3eP0/4kbK+vuCBXRRVrYFifC4vcklK86s2RmRCGt2MCzxFy39Cb0pitpwBaY4t2oLG6lghPH3P7nR0XV7k41fNjerFjdxkipWGfv8izvp9MrNZ+GwcqpYOc3xveNfOrt09Uvn94+3l1DJoHw4Jn8QlZS0ow8uU02Dc4uXG6jmcj9fvb3T79ry9XpoV69h+bqL6/fnpkKrfXNdXL+P9QEqy7wXGv0lk8oeWY8+C1GDktegyWsl1OCv6DtfF3VoWAENVjRQh2U+CJifTi1S1kLR2hRqEXwBQlqpSUoPFPSkUJMREFN4grqkhYohpTiURl1OFELQxSD1yZ4AYRO2U59gGYSdoU4ZdRBSl0Gd5kKc701qdexqHvoo7+gxatWVBQmln1OzSMHEVB96t/SZggg167gHUhbQCXM+GTh56uzx75zLfTl/OID2/PzS3HPvjJ89dfLALacCdMAYpeqT/W6BrMZlTAC7GyHt6SitF30aCjqDtFywE0r20HLDoGgHrTYQqrL202L7s6CsaDqtNb0IGlxpoaVarkCLqjRaKa0KmpwO00Lh09CmO0DrBHKgUWcmLZPZCa3+mUmrZA6FZp0BWiTQCe26O2iNjhw44IGVtETaA3DEpfdphYoqOCT1FC1wKhWOqd1E422qhYOydtBwO7LgrF1BGiy4B47rrqGxarrhgn1v0FBv74MrYuU00rP/glsWXKBxPu+Bi3LP0zDnc+Eq35l0GiT4bx/c1jaHxpjTBg8UjkinEdJHNMIbLyyjAZa9AM/4QgF6LBDywUsvLqGnlrwIr61uomeaDsMAvssV9ETFEz6YYWGokq6rDC2EOaZ9FqWrov+ZBrPUbozSNdGNtTBP8fGDdMXB48Uwk2/dXjpu7zofDJZXHaCDAtVlMF3RvN10yO55RbDCw9kRahfJfh728E9aU0ONakZO8sMy/vpVKdTi4Bf1ftipateWMJWEt+yqgtViZaFtlZRSuS1UFkMiGH1o88hxYQoIjxu5+dBoJBT/k+M3VA8aEGTvZpz/74ZXnvQjYQ3PzRkz9kj5kLNNc5rT0kmG09Jmzmk6O6T8yNgxh19vhJuSkpL+B7rgk4s7RkykAAAAAElFTkSuQmCC");
// EXTERNAL MODULE: ./src/global-helpers/index.ts + 13 modules
var global_helpers = __webpack_require__(6);

// CONCATENATED MODULE: ./src/core/resources/index.ts
function resources_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














class resources_Resources {
  constructor({
    core,
    gl,
    store,
    structure
  }) {
    resources_defineProperty(this, "_core", void 0);

    resources_defineProperty(this, "_store", void 0);

    resources_defineProperty(this, "_defaultPointLoading", void 0);

    resources_defineProperty(this, "onLoadChunk", new global_helpers["b" /* Event */]());

    this._core = core;
    this._store = store;
    core.regResource('environment-material', lib["s" /* EnvironmentMaterial */]);
    core.regResource('vertexBuffer', lib["ob" /* VertexBuffer */]);
    core.regResource('model', model_loader_ModelAssets); // Material is abstruct class

    core.regResource('material', lib["D" /* Material */]); // eslint-disable-line @typescript-eslint/no-explicit-any

    core.regResource('texture', lib["gb" /* Texture */]);
    core.regResource('extras', Object); // eslint-disable-line @typescript-eslint/no-explicit-any

    core.regResource('ibl', ibl_loader_IBL);
    core.addResource('vertexBuffer', 'mainVertex', gl.renderer.vertexStaging);
    core.addResource('vertexBuffer', 'mainElement', gl.renderer.elementStaging);
    core.regLoader(new ibl_loader_IBLLoader(core, gl));
    core.regLoader(new texture_loader_TextureLoader(core));
    core.regLoader(new environment_material_loader_EnvironmentMaterialLoader(core));
    core.regLoader(new model_loader_ModelLoader(core, gl, structure));
    this._defaultPointLoading = core.loadResource('texture', 'default_point', point);
  }

  _clearResource(resourceType) {
    // TODO probably not the best solution and better use delResource
    this._core.getResourceMap(resourceType).clear();
  }

  _clear() {
    this._clearResource('environment-material');

    this._clearResource('material'); // this._clearResource('texture'); // only default_point now


    this._clearResource('extras');

    this._clearResource('model');

    this._clearResource('ibl');
  }

  async loadModel(modelPath, options) {
    this._clear();

    await this._defaultPointLoading;
    const modelId = 'model';
    const assets = await this._core.loadResource('model', modelId, modelPath, { ...options,
      onProgress: ([loaded, total]) => {
        this._store.load.setProgress({
          loaded,
          total
        });
      },
      onLoadChunk: async (chunksLoaded, chunksTotal) => {
        this._store.load.setProgress({
          chunksLoaded,
          chunksTotal
        });

        await this.onLoadChunk.emitAsync();
      }
    }); // No need to store model assets object itself

    this._core.delResource('model', modelId);

    const [scene] = assets.scenes;
    return scene;
  }

}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 47 */,
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getUrlSibling; });
function getUrlSibling(url, sibling) {
  const fullModelUrl = new URL(url, window.location.href).href;
  const siblingFullUrl = new URL(sibling, fullModelUrl).href;
  return siblingFullUrl;
}

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ angle_Angle; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ distance_Distance; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ sample_Sample; });

// UNUSED EXPORTS: CSSColor

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/events/events.js
var events = __webpack_require__(34);

// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/math/color.ts
function fromNumber(color) {
  if (color > 0xffffff && color < 0) {
    throw new Error(`Invalid color value "${color}"`);
  }

  return {
    r: (color >> 16 & 0xff) / 0xff,
    g: (color >> 8 & 0xff) / 0xff,
    b: (color & 0xff) / 0xff
  };
}
function fromString(color) {
  return fromNumber(parseInt(color, 16));
}
function create() {
  return {
    r: 0,
    g: 0,
    b: 0
  };
}
function toNumber(color) {
  const {
    r,
    g,
    b
  } = color;
  return Math.round(r * 0xff) << 16 | Math.round(g * 0xff) << 8 | Math.round(b * 0xff);
}

const toInteger = component => Math.round(component * 0xff);

const beautifyNumber = value => {
  const num = Number(toInteger(value)).toString(16);
  return new Array(3 - num.length).join('0') + num;
};

function color_toString(color) {
  const {
    r,
    g,
    b
  } = color;
  return beautifyNumber(r) + beautifyNumber(g) + beautifyNumber(b);
}
function add(color, value, out = color) {
  out.r = Math.min(color.r + value, 1);
  out.g = Math.min(color.g + value, 1);
  out.b = Math.min(color.b + value, 1);
  return out;
}
function toGrayScale(color) {
  const {
    r,
    g,
    b
  } = color;
  return 0.299 * r + 0.587 * g + 0.114 * b;
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/sample/sample.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const getSampleId = (() => {
  let id = 0;
  return () => 'sample_' + id++;
})();

let CSSColor;

(function (CSSColor) {
  CSSColor["LIGHT"] = "FFFFFF";
  CSSColor["DARK"] = "272727";
})(CSSColor || (CSSColor = {}));

class sample_Sample extends events["EventEmitter"] {
  set dynamic(value) {
    if (value === this._dynamic) {
      return;
    }

    this._dynamic = value;
    this.draw();
  }

  get dynamic() {
    return this._dynamic;
  }

  set selected(value) {
    if (value === this._selected) {
      return;
    }

    this._selected = value;
    this.applyColors(value ? 'active' : 'normal');
    this.draw();
  }

  get selected() {
    return this._selected;
  }

  set interactive(value) {
    if (value === this._interactive) {
      return;
    }

    this._interactive = value;
    this.draw();
  }

  get interactive() {
    return this._interactive;
  }

  set dragging(value) {
    if (value === this._dragging) {
      return;
    }

    this._dragging = value;
    this.draw();
  }

  get dragging() {
    return this._dragging;
  }

  get value() {
    return 0;
  }

  get unit() {
    return '';
  }

  set visible(value) {
    this._visible = value;

    this._updateVisibility();
  }

  get visible() {
    return this._visible;
  }

  set opacity(value) {
    this._opacity = value;
    this.draw();
  }

  set color(color) {
    this._colors = this._prepareColors(color);
  }

  get color() {
    return this._colors.normal;
  }

  set outOfView(value) {
    this._outOfView = value;

    this._updateVisibility();
  }

  constructor(options) {
    super();

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "element", void 0);

    _defineProperty(this, "points", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "_selected", void 0);

    _defineProperty(this, "_interactive", void 0);

    _defineProperty(this, "_dynamic", void 0);

    _defineProperty(this, "_dragging", void 0);

    _defineProperty(this, "_visible", void 0);

    _defineProperty(this, "_colors", void 0);

    _defineProperty(this, "_opacity", void 0);

    _defineProperty(this, "_outOfView", void 0);

    _defineProperty(this, "opacityMode", 'caption');

    _defineProperty(this, "_handlePointStart", event => {
      event.stopPropagation();
    });

    const {
      id = getSampleId(),
      dynamic = true,
      selected = false,
      interactive = false,
      visible = true,
      color = sample_Sample.DEFAULT_COLOR,
      points,
      className
    } = options;
    const element = document.createElement('div');
    element.className = className || '';
    element.id = 'measure-sample-' + id;
    element.addEventListener('mousedown', this._handlePointStart);
    element.addEventListener('touchstart', this._handlePointStart);
    points.forEach(point => {
      element.appendChild(point.element);
      point.parent = this;
    });
    this._visible = visible;
    this._outOfView = false;
    this._dragging = false;
    this._selected = selected;
    this._interactive = interactive;
    this._dynamic = dynamic;
    this._colors = this._prepareColors(color);
    this._opacity = 1;
    this.element = element;
    this.points = points;
    this.id = id;

    this._updateVisibility();
  }

  _prepareColors(baseColor) {
    const normal = fromString(baseColor);
    const hover = create();
    const grayScale = toGrayScale(normal);
    add(normal, grayScale * 0.15, hover);
    return {
      normal: color_toString(normal),
      hover: color_toString(hover),
      active: CSSColor.LIGHT,
      textNormal: grayScale > 0.5 ? CSSColor.DARK : CSSColor.LIGHT,
      textActive: CSSColor.DARK
    };
  }

  _updateVisibility() {
    this.element.style.display = this._visible && !this._outOfView ? 'block' : 'none';
  }

  dispose() {
    this.points.forEach(point => point.dispose());
    this.element.removeEventListener('mousedown', this._handlePointStart);
    this.element.removeEventListener('touchstart', this._handlePointStart);
    this.element.remove();
  }

}

_defineProperty(sample_Sample, "DEFAULT_COLOR", '027AFF');

_defineProperty(sample_Sample, "DEFAULT_FONT", 'Arial');
// EXTERNAL MODULE: /home/kirill/projects/industrial/utils/measures/src/primitive/index.ts + 7 modules
var primitive = __webpack_require__(31);

// EXTERNAL MODULE: /home/kirill/projects/industrial/utils/measures/src/math/vec2.ts
var vec2 = __webpack_require__(16);

// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/math/vec3.ts
const tempVec3 = {
  x: 0,
  y: 0,
  z: 0
};
function vec3_length(v) {
  return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);
}
function multiplyScalar(v, scalar) {
  v.x *= scalar;
  v.y *= scalar;
  v.z *= scalar;
  return v;
}
function divideScalar(v, scalar) {
  return multiplyScalar(v, 1 / scalar);
}
function sub(v1, v2, dest = {
  x: 0,
  y: 0,
  z: 0
}) {
  dest.x = v1.x - v2.x;
  dest.y = v1.y - v2.y;
  dest.z = v1.z - v2.z;
  return dest;
}
function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}
function normalize(v) {
  return divideScalar(v, vec3_length(v) || 1);
}
function vec3_distance(v1, v2) {
  return vec3_length(sub(v1, v2, tempVec3));
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/sample/angle.ts
function angle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class angle_Angle extends sample_Sample {
  get value() {
    return this._value;
  }

  get unit() {
    return this._unit;
  }

  constructor(options) {
    super({ ...options,
      className: 'bv-measure-angle'
    });

    angle_defineProperty(this, "type", 'angle');

    angle_defineProperty(this, "_lines", void 0);

    angle_defineProperty(this, "_arc", void 0);

    angle_defineProperty(this, "_caption", void 0);

    angle_defineProperty(this, "_deleteButton", void 0);

    angle_defineProperty(this, "_hoveredPrimitives", void 0);

    angle_defineProperty(this, "_value", 0);

    angle_defineProperty(this, "_unit", '');

    angle_defineProperty(this, "_handleChangePointDragging", value => {
      this._lines.forEach(line => {
        line.dragging = value;
      });
    });

    angle_defineProperty(this, "_handleClickDelete", () => {
      this.emit('delete', {
        target: this
      });
    });

    angle_defineProperty(this, "_handlSelect", () => {
      this.applyColors(this._selected ? 'active' : 'normal');
      this.emit('select', {
        target: this
      });
    });

    angle_defineProperty(this, "_handleHover", ({
      target
    }) => {
      const wasUnhovered = this._hoveredPrimitives.size === 0;

      this._hoveredPrimitives.add(target);

      if (!this._selected) {
        this.applyColors('hover');
      }

      if (wasUnhovered && this._hoveredPrimitives.size) {
        this.emit('hover', {
          target: this
        });
      }
    });

    angle_defineProperty(this, "_handleUnhover", ({
      target
    }) => {
      const wasHovered = this._hoveredPrimitives.size > 0;

      this._hoveredPrimitives.delete(target);

      if (!this._selected) {
        this.applyColors('normal');
      }

      if (wasHovered && !this._hoveredPrimitives.size) {
        this.emit('unhover', {
          target: this
        });
      }
    });

    angle_defineProperty(this, "_handleChangePointPosition", pointIndex => {
      this._updateAngleCaption();

      this.emit('update-position', {
        target: this,
        pointIndex
      });
    });

    angle_defineProperty(this, "_updateAngleCaption", () => {
      const {
        points
      } = this;
      const v1 = sub(points[1].position, points[0].position);
      const v2 = sub(points[1].position, points[2].position);
      normalize(v1);
      normalize(v2);
      const angle = Math.acos(dot(v1, v2));
      this._value = angle / Math.PI * 180;
      this._caption.value = `${Math.round(this._value)}`;
      this.emit('update-value', {
        target: this
      });
    });

    angle_defineProperty(this, "_updateScreenPosition", () => {
      const {
        points
      } = this;
      const v1 = vec2["g" /* sub */](points[0].containerPosition, points[1].containerPosition);
      const v2 = vec2["g" /* sub */](points[2].containerPosition, points[1].containerPosition);
      const radius = Math.max(Math.min(40, Math.min(vec2["d" /* length */](v1), vec2["d" /* length */](v2)) * 0.5), 20);
      vec2["f" /* normalize */](v1);
      vec2["f" /* normalize */](v2);
      const v3 = vec2["f" /* normalize */](vec2["a" /* add */](v1, v2));
      const bv = vec2["a" /* add */](points[1].containerPosition, vec2["e" /* multiplyScalar */](vec2["f" /* normalize */](v3), radius));
      Object.assign(this._caption.element.style, {
        position: 'absolute',
        left: bv.x + 'px',
        top: bv.y + 'px',
        transform: 'translate(-50%, -50%)'
      });
    });

    const {
      points: _points
    } = options;
    const lines = [new primitive["e" /* Line */]({
      points: [_points[0], _points[1]]
    }), new primitive["e" /* Line */]({
      points: [_points[1], _points[2]]
    })];
    lines.forEach(line => {
      this.element.prepend(line.element);
    });
    const arc = new primitive["b" /* Arc */]({
      points: _points
    });
    this.element.appendChild(arc.element);
    const deleteButton = new primitive["d" /* DeleteButton */]();
    const caption = new primitive["c" /* Caption */]({
      postfix: this._unit,
      children: [deleteButton.element]
    });
    this.element.appendChild(caption.element);
    this._arc = arc;
    this._lines = lines;
    this._caption = caption;
    this._deleteButton = deleteButton;
    this._hoveredPrimitives = new Set();

    this._addListeners();

    this.draw();

    this._updateScreenPosition();

    this._updateAngleCaption();
  }

  applyColors(state) {
    const {
      normal,
      hover,
      active,
      textNormal,
      textActive
    } = this._colors;
    let captionColor = '';
    let pointColor = '';
    let lineColor = '';
    let textColor = '';

    if (state === 'normal') {
      captionColor = normal;
      pointColor = normal;
      lineColor = normal;
      textColor = textNormal;
    } else if (state === 'hover') {
      captionColor = hover;
      pointColor = hover;
      lineColor = hover;
      textColor = textNormal;
    } else if (state === 'active') {
      captionColor = active;
      pointColor = active;
      lineColor = normal;
      textColor = textActive;
    }

    if (this._dragging && state === 'active') {
      captionColor = normal;
      textColor = textNormal;
    }

    this._arc.color = lineColor;
    this._caption.color = captionColor;
    this._caption.textColor = textColor;

    this._lines.forEach(line => {
      line.color = lineColor;
    });

    this.points.forEach(point => {
      point.color = pointColor;
      point.touchZoneColor = normal;
    });
  }

  applyOpacity() {
    if (this._opacity === 1) {
      this.element.style.opacity = String(this._opacity);
      this._caption.opacity = this._opacity;
      return;
    }

    if (this.opacityMode === 'full') {
      this.element.style.opacity = String(this._opacity);
    } else if (this.opacityMode === 'caption') {
      this._caption.opacity = this._opacity;
    }
  }

  _addListeners() {
    this.points.forEach((point, index) => {
      point.index = index;
      point.on('screen-position-update', this._updateScreenPosition);
      point.on('dragging-change', this._handleChangePointDragging);
      point.on('position-change', () => this._handleChangePointPosition(index));
    });

    this._caption.on('select', this._handlSelect);

    this._caption.on('hover', this._handleHover);

    this._caption.on('unhover', this._handleUnhover);

    this._lines.forEach(line => {
      line.on('select', this._handlSelect);
      line.on('hover', this._handleHover);
      line.on('unhover', this._handleUnhover);
    });

    this._deleteButton.on('click', this._handleClickDelete);
  }

  _removeListeners() {
    this.points.forEach(point => {
      point.off('screen-position-update', this._updateScreenPosition);
      point.off('dragging-change', this._handleChangePointDragging);
      point.off('position-change', this._handleChangePointPosition);
    });

    this._caption.off('select', this._handlSelect);

    this._caption.off('hover', this._handleHover);

    this._caption.off('unhover', this._handleUnhover);

    this._lines.forEach(line => {
      line.off('select', this._handlSelect);
      line.off('hover', this._handleHover);
      line.off('unhover', this._handleUnhover);
    });

    this._deleteButton.off('click', this._handleClickDelete);
  }

  draw() {
    this.applyColors(this._selected ? 'active' : 'normal');
    this.applyOpacity();
    this._caption.selected = this._selected;
    this._caption.interactive = this._interactive;

    this._lines.forEach(line => {
      line.interactive = this._interactive;
    });

    this._deleteButton.visible = !this._dragging && this._selected;
    this.points.forEach(point => {
      point.interactive = this._interactive && this._dynamic;
      point.visible = this._selected && this._dynamic;
    });
  }

  dispose() {
    super.dispose();

    this._removeListeners();

    this._lines.forEach(line => line.dispose());

    this._arc.dispose();

    this._caption.dispose();

    this._deleteButton.dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/sample/distance.ts
function distance_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function distance_beautifyNumber(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
}

const M_2_MM = 1000;
const MIN_SCREEN_DISTANCE = 24;
class distance_Distance extends sample_Sample {
  set scale(value) {
    this._scale = value;

    this._updateCaption();
  }

  get scale() {
    return this._scale;
  }

  get value() {
    return this._value;
  }

  get unit() {
    return this._unit;
  }

  constructor(options) {
    super({ ...options,
      className: 'bv-measure-distance'
    });

    distance_defineProperty(this, "type", 'distance');

    distance_defineProperty(this, "points", void 0);

    distance_defineProperty(this, "_caption", void 0);

    distance_defineProperty(this, "_line", void 0);

    distance_defineProperty(this, "_deleteButton", void 0);

    distance_defineProperty(this, "_alignBox", void 0);

    distance_defineProperty(this, "_scale", void 0);

    distance_defineProperty(this, "_hoveredPrimitives", void 0);

    distance_defineProperty(this, "_value", 0);

    distance_defineProperty(this, "_unit", 'mm');

    distance_defineProperty(this, "_handleClickDelete", () => {
      this.emit('delete', {
        target: this
      });
    });

    distance_defineProperty(this, "_handleSelect", () => {
      this.applyColors(this._selected ? 'active' : 'normal');
      this.emit('select', {
        target: this
      });
    });

    distance_defineProperty(this, "_handleHover", ({
      target
    }) => {
      const wasUnhovered = this._hoveredPrimitives.size === 0;

      this._hoveredPrimitives.add(target);

      if (!this._selected) {
        this.applyColors('hover');
      }

      if (wasUnhovered && this._hoveredPrimitives.size) {
        this.emit('hover', {
          target: this
        });
      }
    });

    distance_defineProperty(this, "_handleUnhover", ({
      target
    }) => {
      const wasHovered = this._hoveredPrimitives.size > 0;

      this._hoveredPrimitives.delete(target);

      if (!this._selected) {
        this.applyColors('normal');
      }

      if (wasHovered && !this._hoveredPrimitives.size) {
        this.emit('unhover', {
          target: this
        });
      }
    });

    distance_defineProperty(this, "_handleChangePointPosition", pointIndex => {
      this.emit('update-position', {
        target: this,
        pointIndex
      });
    });

    distance_defineProperty(this, "_updateCaption", () => {
      const distanceScreen = vec2["c" /* distance */](this.points[0].containerPosition, this.points[1].containerPosition);
      const distance = vec3_distance(this.points[0].position, this.points[1].position);
      this._value = distance * this._scale * M_2_MM;
      this.emit('update-value', {
        target: this
      });
      this._caption.value = distance_beautifyNumber(Math.round(this._value));
      this._caption.visible = distanceScreen > MIN_SCREEN_DISTANCE;
    });

    const {
      points,
      scale
    } = options;
    const line = new primitive["e" /* Line */]({
      points,
      plugged: true
    });
    this.element.prepend(line.element);
    const deleteButton = new primitive["d" /* DeleteButton */]();
    const caption = new primitive["c" /* Caption */]({
      postfix: ` ${this._unit}`,
      children: [deleteButton.element]
    });
    caption.element.appendChild(deleteButton.element);
    const alignBox = new primitive["a" /* AlignBox */]({
      points,
      children: [caption.element]
    });
    this.element.appendChild(alignBox.element);
    this.points = points;
    this._line = line;
    this._alignBox = alignBox;
    this._deleteButton = deleteButton;
    this._caption = caption;
    this._scale = scale;
    this._hoveredPrimitives = new Set();

    this._addListeners();

    this.draw();

    this._updateCaption();
  }

  applyColors(state) {
    const {
      normal,
      hover,
      active,
      textNormal,
      textActive
    } = this._colors;
    let captionColor = '';
    let pointColor = '';
    let lineColor = '';
    let textColor = '';

    if (state === 'normal') {
      captionColor = normal;
      pointColor = normal;
      lineColor = normal;
      textColor = textNormal;
    } else if (state === 'hover') {
      captionColor = hover;
      pointColor = hover;
      lineColor = hover;
      textColor = textNormal;
    } else if (state === 'active') {
      captionColor = active;
      pointColor = active;
      lineColor = normal;
      textColor = textActive;
    }

    if (this._dragging && state === 'active') {
      captionColor = normal;
      textColor = textNormal;
    }

    this._line.color = lineColor;
    this._caption.color = captionColor;
    this._caption.textColor = textColor;
    this.points.forEach(point => {
      point.color = pointColor;
      point.touchZoneColor = normal;
    });
  }

  applyOpacity() {
    if (this._opacity === 1) {
      this.element.style.opacity = '1';
      this._caption.opacity = 1;
      return;
    }

    if (this.opacityMode === 'full') {
      this.element.style.opacity = String(this._opacity);
    } else if (this.opacityMode === 'caption') {
      this._caption.opacity = this._opacity;
    }
  }

  _addListeners() {
    this.points.forEach((point, index) => {
      point.index = index;
      point.on('screen-position-update', this._updateCaption);
      point.on('position-change', () => this._handleChangePointPosition(index));
    });

    this._line.on('select', this._handleSelect);

    this._caption.on('select', this._handleSelect);

    this._deleteButton.on('click', this._handleClickDelete);

    this._line.on('hover', this._handleHover);

    this._line.on('unhover', this._handleUnhover);

    this._caption.on('hover', this._handleHover);

    this._caption.on('unhover', this._handleUnhover);
  }

  _removeListeners() {
    this.points.forEach(point => {
      point.off('screen-position-update', this._updateCaption);
      point.off('position-change', this._handleChangePointPosition);
    });

    this._line.off('select', this._handleSelect);

    this._caption.off('select', this._handleSelect);

    this._deleteButton.off('click', this._handleClickDelete);
  }

  draw() {
    this.applyColors(this._selected ? 'active' : 'normal');
    this.applyOpacity();
    this._caption.selected = this._selected;
    this._caption.interactive = this._interactive;
    this._line.plugged = !this._selected || !this._dynamic;
    this._line.interactive = this._interactive;
    this._deleteButton.visible = !this._dragging && this._selected;
    this.points.forEach(point => {
      point.interactive = this._interactive && this._dynamic;
      point.visible = this._selected && this._dynamic;
    });
  }

  dispose() {
    super.dispose();

    this._removeListeners();

    this._caption.dispose();

    this._line.dispose();

    this._deleteButton.dispose();

    this._alignBox.dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/utils/measures/src/sample/index.ts




/***/ }),
/* 50 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 51 */,
/* 52 */,
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function compileSearch(funcName, predicate, reversed, extraArgs, earlyOut) {
  var code = [
    "function ", funcName, "(a,l,h,", extraArgs.join(","),  "){",
    earlyOut ? "" : "var i=", (reversed ? "l-1" : "h+1"),
    ";while(l<=h){var m=(l+h)>>>1,x=a[m]"]
  if(earlyOut) {
    if(predicate.indexOf("c") < 0) {
      code.push(";if(x===y){return m}else if(x<=y){")
    } else {
      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){")
    }
  } else {
    code.push(";if(", predicate, "){i=m;")
  }
  if(reversed) {
    code.push("l=m+1}else{h=m-1}")
  } else {
    code.push("h=m-1}else{l=m+1}")
  }
  code.push("}")
  if(earlyOut) {
    code.push("return -1};")
  } else {
    code.push("return i};")
  }
  return code.join("")
}

function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
  var result = new Function([
  compileSearch("A", "x" + predicate + "y", reversed, ["y"], earlyOut),
  compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], earlyOut),
"function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(typeof(c)==='function'){\
return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\
}}\
return dispatchBsearch", suffix].join(""))
  return result()
}

module.exports = {
  ge: compileBoundsSearch(">=", false,  "GE"),
  gt: compileBoundsSearch(">",  false,  "GT"),
  lt: compileBoundsSearch("<",  true,   "LT"),
  le: compileBoundsSearch("<=", true,   "LE"),
  eq: compileBoundsSearch("-",  true,   "EQ", true)
}


/***/ }),
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IndustrialViewer; });
/* harmony import */ var _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(250);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85);
/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(243);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25);
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87);
/* harmony import */ var _global_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);
/* harmony import */ var _core_resources__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45);
/* harmony import */ var _iframe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(244);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Measure", function() { return _measure__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(131);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_10__) if(["default","Measure"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_10__[key]; }) }(__WEBPACK_IMPORT_KEY__));
var _class, _class2, _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }














/**
 * Renderer statistics.
 *
 * @public
 */

/**
 * Main class.
 *
 * @public
 */
let IndustrialViewer = (_class = (_temp = _class2 = class IndustrialViewer {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * {@link Measure | Measure API}
   */

  /**
   * Allows to extend application functionality.
   *
   * @example
   * ```js
   * import IndustrialViewer from '@wg/industrial-viewer';
   * import extension from '@wg/industrial-viewer/extensions/[extentionName]';
   *
   * IndustrialViewer.registerExtension(extention);
   * ```
   */
  static registerExtension(ExtensionClass) {
    // eslint-disable-line @typescript-eslint/ban-types
    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('registerExtension', ExtensionClass);

    IndustrialViewer._extensionClasses.add(ExtensionClass);
  }
  /**
   * Viewer initialization.
   *
   * @param container - DOM element where viewer will be placed to
   * @param options - viewer's options
   */


  constructor(container, options) {
    _defineProperty(this, "_app", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_eventEmmiter", void 0);

    _defineProperty(this, "measure", void 0);

    const eventEmmiter = new _event_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]();
    this._eventEmmiter = eventEmmiter;
    const app = new _app__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](container, eventEmmiter);
    this._app = app;
    this._options = new _options__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](app.store);
    this.measure = new _measure__WEBPACK_IMPORTED_MODULE_6__[/* default */ "b"](app); // Extensions

    IndustrialViewer._extensionClasses.forEach(ExtensionClass => new ExtensionClass(this, app));

    this._app.logger.decoratePublicMethodCalls('viewer', this);

    this._app.logger.decoratePublicMethodCalls('viewer.measure', this.measure);

    Object(_iframe__WEBPACK_IMPORTED_MODULE_9__[/* decorateWithIframeAPI */ "a"])(this, eventEmmiter);
    this.setOptions({ ...options
    });
  }
  /**
   * Add listener for event.
   *
   * @param event - Event type
   * @param callback - Callback function
   *
   * @example
   * ```js
   * widget3d.addEventListener('select', (event) => {
   *     console.log(event);
   * });
   * ```
   */


  addEventListener(event, callback) {
    // eslint-disable-line @typescript-eslint/ban-types
    this._eventEmmiter.addEventListener(event, callback);
  }
  /**
   * Remove listener for event.
   *
   * @param event - Event type
   * @param callback - Callback function
   *
   * @example
   * ```js
   * function callbackFunction(event) { console.log(event); }
   *
   * // Add listener
   * widget3d.addEventListener('select', callbackFunction);
   *
   * // Remove listener
   * widget3d.removeEventListener('select', callbackFunction);
   * ```
   */


  removeEventListener(event, callback) {
    // eslint-disable-line @typescript-eslint/ban-types
    this._eventEmmiter.removeEventListener(event, callback);
  }
  /**
   * Set up viewer settings.
   *
   * @param options - viewer's options
   *
   * @remarks
   * There are several presets with predefined options.
   * Presets available from `'@wg/industrial-viewer/presets/[presetName]'`;
   * Available presets: `'default'` `'horizon'` `'sky'` `'street'` `'parking'`.
   *
   * @example
   * ```js
   * await widget3d.setOptions({
   *     stagingMemorySize: 256,
   *     progressiveRendering: {
   *         enabled: true
   *         maxDrawcalls: 1024
   *     },
   *     edgeGeometry: {
   *         enabled: true,
   *         color: '00ff00'
   *     }
   * });
   * ```
   *
   * @example
   * Use preset
   * ```js
   * import horizonPreset from '@wg/industrial-viewer/presets/horizon';
   *
   * await widget3d.setOptions(horizonPreset);
   * ```
   */


  async setOptions(options) {
    const [vOptions] = _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('setOptions', options);

    if (!this._app.gl.validateAntialiasing(options.antialiasing)) {
      throw new Error('Can not set this antialiasing. Try to decrease pixelRatio.');
    }

    this._options.setOptions(vOptions);

    await Promise.all([this._app.waitStoreReady(this._app.store.environment), this._app.waitStoreReady(this._app.store.edges)]);
  }
  /**
   * Get all viewer settings.
   *
   * @example
   * ```js
   * const options = widget3d.getOptions();
   * // options = { camera: {}, environment: {}, theme: {}, cameraControls: {}, edgeGeometry: {},  }
   * ```
   */


  getOptions() {
    return this._options.getOptions();
  }
  /**
   * Get object ids from the current model.
   *
   * @example
   * ```js
   * const objectIds = widget3d.getObjects();
   * ```
   */


  getObjects() {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    return this._app.structure.getAllIds();
  }
  /**
   * Loads a 3D model by url.
   *
   * @param url - 3D model url
   * @param options - Optional loading options (Default: `{ progressive: true }`)
   *
   * @remarks
   * If there is a 3D model in the scene it will be replaced by the new one.
   * By default loading is progressive, which means that it will start rendering as soon as possible.
   * Available model formats: wmd (prefered), gltf (converted and optimized with WGT convertion service).
   *
   * @example
   * ```js
   * await widget3d.loadModel('assets/scenes/metro/model.gltf');
   * ```
   */


  async loadModel(url, options = {}) {
    if (!(this._app.store.load.isLoaded || this._app.store.load.isNone)) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('loadModel', url);
    const {
      progressive = true,
      parallelChunks = 6
    } = options;
    await this._app.loadModel(url, {
      progressive,
      parallelChunks
    });
  }
  /**
   * Create box section.
   *
   * @example
   * ```js
   * // Box based model size
   * widget3d.setSectionBox();
   *
   * // Specify box boundaries
   * widget3d.setSectionBox({
   *     min: { x: -10, y: -10, z: -10 },
   *     max: { x: 10,  y: 10,  z: 10 }
   * });
   *
   * // Hide section box
   * widget3d.setSectionBox(null);
   * ```
   */


  setSectionBox(sectionBox) {
    const scene = this._app.layers.layer3dMain.scene;

    if (!this._app.store.load.isLoaded || !scene) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('setSectionBox', sectionBox);

    if (sectionBox === null) {
      this._app.store.sectionBox.setEnabled(false);

      return;
    }

    const sectoring = this._app.structure.getGroup('sectoring');

    const filter = this._app.structure.getGroup('filter');

    const filterNodeSectionBox = rederable => {
      if (!(rederable instanceof _core_resources__WEBPACK_IMPORTED_MODULE_8__[/* IndustrialRenderable */ "b"])) {
        return true;
      }

      if (sectoring && sectoring.has(rederable)) {
        return false;
      }

      if (filter && filter.has(rederable)) {
        return false;
      }

      return true;
    };

    let min;
    let max;

    if (sectionBox === undefined) {
      const bbox = Object(_global_helpers__WEBPACK_IMPORTED_MODULE_7__[/* computeBBox */ "e"])(this._app.structure.getAllElements(), filterNodeSectionBox);
      min = bbox.min.subtractNumber(0.1);
      max = bbox.max.addNumber(0.1);
    } else {
      min = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]().copy(this._app.store.axes.getInternalPosition(sectionBox.min));
      max = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]().copy(this._app.store.axes.getInternalPosition(sectionBox.max));
    }

    this._app.store.sectionBox.set({
      min,
      max
    });
  }
  /**
   * Get box section dimentsions.
   *
   * @remarks
   * Get null if section box is not set.
   *
   * @example
   * ```js
   * const box = widget3d.getSectionBox();
   * ```
   */


  getSectionBox() {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    if (!this._app.store.sectionBox.enabled || !this._app.store.sectionBox.min || !this._app.store.sectionBox.max) {
      return null;
    }

    return {
      min: this._app.store.axes.getExternalPosition(this._app.store.sectionBox.min),
      max: this._app.store.axes.getExternalPosition(this._app.store.sectionBox.max)
    };
  }
  /**
   * Select objects on the 3D scene.
   *
   * @example
   * ```js
   * // Selection:
   * await widget3d.selectObjects([1, 2]);
   *
   * // Deselection:
   * await widget3d.selectObjects([]);
   * await widget3d.selectObjects(null);
   * ```
   */


  async selectObjects(ids) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('selectObjects', ids);
    const {
      select
    } = this._app.store;

    for (const id of ids || []) {
      if (id !== null && !this._app.structure.has(id)) {
        throw new Error(`Node with name "${id}" not found`);
      }
    }

    select.selectObjects(ids);
    await this._app.waitStoreReady(select);
  }
  /**
   * Move camera to see the target objects.
   *
   * @param ids - Object identifiers
   * @param animationDuration - Animation duration (in milliseconds)
   *
   * @example
   * ```js
   * // Move to see current objects
   * await widget3d.moveCameraToObjects([1, 2], 1000);
   *
   * // Move to see whole object
   * await widget3d.moveCameraToObjects(null, 1000);
   * ```
   */


  async moveCameraToObjects(ids, animationDuration = 0) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    const [vIds, vAnimationDuration] = _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('moveCameraToObjects', ids, animationDuration);

    if (!vIds || vIds.length === 0) {
      await this._app.moveCamera.fitCameraToNodes(null, vAnimationDuration);
      return;
    }

    await this._app.moveCamera.fitCameraToNodes(vIds, vAnimationDuration);
  }
  /**
   * Get current camera position and target.
   *
   * @remarks
   * Combination with {@link IndustrialViewer.moveCameraToPosition} method makes it possible to move the camera to the specified position.
   *
   * @example
   * ```js
   * widget3d.getCameraPosition();
   * ```
   */


  getCameraPosition() {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    return this._app.moveCamera.getCameraPosition();
  }
  /**
   * Move the camera to the specified place.
   *
   * @param options - Camera options
   * @param animationDuration - Animation duration (in milliseconds)
   *
   * @remarks
   * Use method {@link IndustrialViewer.getCameraPosition} to get current camera position options.
   *
   * @example
   * ```js
   * await widget3d.moveCameraToPosition({ position: { x: 20, y: 10, z: 2.5 }, target: { x: 0.5, y: 5, z: 12 } }, 1000);
   * ```
   */


  async moveCameraToPosition(options, animationDuration = 0) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    const [vSettings, vAnimationDuration] = _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('moveCameraToPosition', options, animationDuration);
    await this._app.moveCamera.moveCameraToPosition(vSettings, vAnimationDuration, true);
  }
  /**
   * Color an array of objects with the specified color.
   *
   * @remarks
   * Once called this method resets all the previous color settings. Once called with null parameter this method reset all the previous color settings to default values.
   *
   * @example
   * ```js
   * // Color objects:
   * await widget3d.colorObjects([
   *     {
   *         color: '0000ff',
   *         ids: [386, 383]
   *     },
   *     {
   *         color: 'ffff00',
   *         ids: [704, 614, 524]
   *     }
   * ]);
   *
   * // Reset colors:
   * await widget3d.colorObjects(null);
   * ```
   */


  async colorObjects(options) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('colorObjects', options);

    this._app.store.color.colorObjects(options);

    await this._app.waitStoreReady(this._app.store.color);
  }
  /**
   * Set objects visibility.
   *
   * @remarks
   * Default behavior is that objects which ids were passed become visible.
   * All the rest objects (not listed in the method) will be hidden.
   * Once used this method resets previous visibility settings.
   * Once called with null parameter this method resets all visibility settings to true, i.e. all objects become visible.
   *
   * @example
   * ```js
   * // Show only object 1 and 2 (all other objects are invisible)
   * await widget3d.filterObjects([1, 2]);
   * // or
   * await widget3d.filterObjects([1, 2], { blacklist: false });
   *
   * // Hide all objects
   * await widget3d.filterObjects([]);
   * // or
   * await widget3d.filterObjects([], { blacklist: false });
   *
   * // Show all objects
   * await widget3d.filterObjects(null);
   * // or
   * await widget3d.filterObjects(null, { blacklist: false });
   *
   * // Hide only object 1 and 2 (all other objects are visible)
   * await widget3d.filterObjects([1, 2], { blacklist: true });
   *
   * // Show all objects
   * await widget3d.filterObjects([], { blacklist: true });
   *
   * // Hide all objects
   * await widget3d.filterObjects(null, { blacklist: true });
   *
   * // Show objects 1 and 2. Then hide object 1. Object 2 is visible only.
   * await widget3d.filterObjects([1, 2], { blacklist: false });
   * await widget3d.filterObjects([1], { blacklist: true, iterative: true });
   *
   * // Show object 1. Then show object 3. Objects 1 and 3 are visible.
   * await widget3d.filterObjects([1], { blacklist: false });
   * await widget3d.filterObjects([3], { blacklist: false, iterative: true });
   * ```
   */


  async filterObjects(ids, options = {}) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('filterObjects', ids, options);
    const {
      filter
    } = this._app.store;
    const idsSet = ids ? new Set(ids) : null;
    filter.filterObjects(idsSet, options);
    await this._app.waitStoreReady(filter);
  }
  /**
   * Append points of interest to the model.
   *
   * @returns Ids of created points (could be useful if you haven't set them manually).
   *
   * @example
   * ```js
   * // Set points
   * await widget3d.setPoints([{
   *     position: { x: 0, y: 2, z: 0 }
   * }]);
   *
   * // Remove points
   * await widget3d.setPoints(null);
   * ```
   */


  async setPoints(pointsList) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('setPoints', pointsList);
    await this._app.points.setPoints(pointsList);
    return this._app.points.ids;
  }
  /**
   * Set parameters to explode objects.
   *
   * @example
   * ```js
   * widget3d.setExplosion({
   *     progress: 0.5,
   *     force: 5,
   *     center: { x: 0, y: 0, z: 0 }
   * });
   * ```
   */


  setExplosion(config) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('setExplosion', config);

    this._app.store.explode.setConfig(config);
  }
  /**
   * Get minimal distance between two objects.
   *
   * @remarks
   * This method could need time to resolve. Time duration depends on complexity of objects.
   *
   * @example
   * ```js
   * const distancePoints = await widget3d.getDistanceBetween(1, 2);
   * ```
   */


  async getDistanceBetween(id0, id1) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('getDistanceBetween', id0, id1);
    const result = await this._app.distanceCalculator.calculate(id0, id1);
    return {
      distance: result.distance,
      start: this._app.store.axes.getExternalPosition(result.start),
      end: this._app.store.axes.getExternalPosition(result.end)
    };
  }
  /**
   * Get position of 3d point in screen space
   *
   * @remarks
   * Returns `null` when point locates behind near plane of camera frustum (behind camera). Zero point locates on top left corner of screen
   *
   * @example
   * ```js
   * const { x, y } = await widget3d.getScreenPosition({ x: 0, y: 0, z: 0 });
   * ```
   */


  getScreenPosition(coords) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('getScreenPosition', coords);
    const {
      look
    } = this._app.layers.layer3dMain;

    const internalPosition = this._app.store.axes.getInternalPosition(coords);

    if (Object(_global_helpers__WEBPACK_IMPORTED_MODULE_7__[/* isBehindCamera */ "v"])(internalPosition, look)) {
      return null;
    }

    const screenCoords = Object(_global_helpers__WEBPACK_IMPORTED_MODULE_7__[/* getScreenPositionFrom3d */ "o"])(internalPosition, this._app.gl.renderer, look);
    return Object(_global_helpers__WEBPACK_IMPORTED_MODULE_7__[/* getVector2Like */ "p"])(screenCoords);
  }
  /**
   * Raycast objects by 2d screen coordinates
   *
   * @remarks
   * Screen coordinates are absolute.
   * Returns an array of ids of all objects intersected with the ray and sorted from the closest object to the farthest.
   *
   * @example
   * ```js
   * const ids = await widget3d.raycastObjects({ x: 250, y: 500 });
   * ```
   */


  raycastObjects(coords) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('raycastObjects', coords);
    const layer3d = this._app.layers.layer3dMain;
    const ndc = Object(_global_helpers__WEBPACK_IMPORTED_MODULE_7__[/* getPositionNdcFrom2d */ "n"])(coords, layer3d.renderer);
    const hits = layer3d.raycastLayer(ndc);
    return hits.map(hit => hit.id);
  }
  /**
   * Get screenshot of canvas area
   *
   * @remarks
   * Returns base64 string.
   * Makes screenshot of full canvas surface when argument is empty
   *
   * @example
   * ```js
   * const screenshot = widget3d.getScreenshot();
   * const image = new Image();
   * image.src = screenshot;
   * ```
   */


  getScreenshot(options) {
    if (!this._app.store.load.isLoaded) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throwDueToModelLoad */ "c"])();
    }

    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('getScreenshot', options);
    return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* getImageFromCanvas */ "b"])(this._app.gl.canvas, this._app.gl.renderer.pixelRatio, options);
  }
  /**
   * Return back debug information.
   *
   * @remarks
   * In addition if {@link Options.logs} option is enabled this method returns public method calls logs.
   *
   * @example
   * ```js
   * const info = widget3d.getDebugInfo();
   * ```
   */


  getDebugInfo() {
    // @ts-ignore arguments
    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('getDebugInfo', ...arguments); // eslint-disable-line prefer-rest-params

    return this._app.logger.getInfo();
  }
  /**
   * Return 3D context information.
   *
   * @example
   * ```js
   * const { MAX_TEXTURE_SIZE } = widget3d.getContextParams();
   * ```
   */


  getContextParams() {
    // @ts-ignore arguments
    _validation__WEBPACK_IMPORTED_MODULE_5__[/* APIValidator */ "a"].run('getContextParams', ...arguments); // eslint-disable-line prefer-rest-params

    const ctx = this._app.gl.renderer.context;
    return {
      drawingBufferWidth: ctx.drawingBufferWidth,
      drawingBufferHeight: ctx.drawingBufferHeight,
      MAX_TEXTURE_SIZE: ctx.getParameter(ctx.MAX_TEXTURE_SIZE)
    };
  }
  /**
   * Send report to the `sentry` server.
   *
   * @remarks
   * This feature demands to include extention `SentryExtension` before using.
   * In the fail case it returns rejected promise.
   *
   * @example
   * ```js
   * import IndustrialViewer from '@wg/industrial-viewer';
   * import SentryExtension from '@wg/industrial-viewer/extensions/sentry';
   *
   * IndustrialViewer.registerExtension(SentryExtension);
   * const widget3d = new IndustrialViewer();
   *
   * try {
   *     await widget3d.sendReport({ message: 'Something is wrong!' });
   * } catch (e) {
   *     // exception code...
   * }
   * ```
   */


  async sendReport(options) {
    throw new Error('Add Sentry extension this method to work');
  }
  /**
   * Extended stats for draw calls, objects, vertices etc.
   *
   * @example
   * ```js
   * widget3d.getRenderStats();
   * ```
   */


  getRenderStats() {
    return { ...this._app.layers.layer3dMain.statistics
    };
  }

}, _defineProperty(_class2, "_extensionClasses", new Set()), _temp), (_applyDecoratedDescriptor(_class.prototype, "setPoints", [_utils__WEBPACK_IMPORTED_MODULE_4__[/* waitPreviousExecution */ "d"]], Object.getOwnPropertyDescriptor(_class.prototype, "setPoints"), _class.prototype)), _class);


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getInstanceGlobalIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getInstanceWorldBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return updateInstanceCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInstanceCenter; });
/* harmony import */ var _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

const centerElementsPerInstance = 3;
const tempMatrix = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* AffineMatrix3 */ "b"]();
const tempCenter = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]();
const tempBox = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Box */ "e"]();
function getInstanceGlobalIndex(instanceDataManager, instance) {
  const {
    instanceId,
    instanceIndex
  } = instance;
  const {
    batchIdx
  } = instanceDataManager.getInstanceRenderable(instanceId);
  const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
  return globalIndex;
}
function getInstanceWorldBBox(instanceDataManager, instance, box = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Box */ "e"]()) {
  const globalIndex = getInstanceGlobalIndex(instanceDataManager, instance);
  instanceDataManager.readWorldTransform(tempMatrix, globalIndex);
  box.copy(instance.geometry.boundingBox);
  box.applyAffineMatrix(tempMatrix);
  return box;
}
function updateInstanceCenter(instanceDataManager, instance) {
  const globalIndex = getInstanceGlobalIndex(instanceDataManager, instance);
  getInstanceWorldBBox(instanceDataManager, instance, tempBox);
  tempBox.centerPaste(tempCenter);
  instanceDataManager.storeCenter(tempCenter, globalIndex);
}
function getInstanceCenter(instanceDataManager, instance, center = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]()) {
  const globalIndex = getInstanceGlobalIndex(instanceDataManager, instance); // @ts-expect-error private _centers

  const centers = instanceDataManager._centers;
  center.fromArrayAt(globalIndex * centerElementsPerInstance, centers);
  return center;
}

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ external_resource_ExternalResource; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ lib_GLTFImporter; });

// UNUSED EXPORTS: Buffer, BufferView, Accessor, Output

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/loader/index.js
var _wgetemp_loader = __webpack_require__(20);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/default-map.js
var default_map = __webpack_require__(403);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/endianness/index.js
/**
 * @module @wgetemp/endianness
 */

/**
 * @function module:@wgetemp/endianness.native
 * @summary Does nothing.
 * @param {TypedArray} array
 * @returns `array`
 * @readonly
 */

function endianness_native(array) {
  return array;
}
/**
 * @function module:@wgetemp/endianness.foreign
 * @summary Reverse array element endianness in-place.
 * @param {TypedArray} array
 * @returns `array`
 * @readonly
 */

function foreign(array) {
  const elementByteLength = array.constructor.BYTES_PER_ELEMENT;

  if (elementByteLength !== 1) {
    const bytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    const byteLength = bytes.byteLength;
    let t;

    switch (elementByteLength) {
      case 2:
        for (let i0 = 0; i0 < byteLength; i0 += 2) {
          const i1 = i0 + 1;
          t = bytes[i0];
          bytes[i0] = bytes[i1];
          bytes[i1] = t;
        }

        break;

      case 4:
        for (let i0 = 0; i0 < byteLength; i0 += 4) {
          const i1 = i0 + 1;
          const i2 = i0 + 2;
          const i3 = i0 + 3;
          t = bytes[i0];
          bytes[i0] = bytes[i3];
          bytes[i3] = t;
          t = bytes[i1];
          bytes[i1] = bytes[i2];
          bytes[i2] = t;
        }

        break;

      case 8:
        for (let i0 = 0; i0 < byteLength; i0 += 8) {
          const i1 = i0 + 1;
          const i2 = i0 + 2;
          const i3 = i0 + 3;
          const i4 = i0 + 4;
          const i5 = i0 + 5;
          const i6 = i0 + 6;
          const i7 = i0 + 7;
          t = bytes[i0];
          bytes[i0] = bytes[i7];
          bytes[i7] = t;
          t = bytes[i1];
          bytes[i1] = bytes[i6];
          bytes[i6] = t;
          t = bytes[i2];
          bytes[i2] = bytes[i5];
          bytes[i5] = t;
          t = bytes[i3];
          bytes[i3] = bytes[i4];
          bytes[i4] = t;
        }

        break;

      default:
        if (false) {}

      //  'unexpected element size');
    }
  }

  return array;
}
/**
 * @const module:@wgetemp/endianness.isLittle
 * @summary Whether host is little-endian.
 * @type {boolean}
 */

const isLittle = (() => {
  const u16 = Uint16Array.of(1);
  const u8x2 = new Uint8Array(u16.buffer);
  return !!u8x2[0];
})();
/**
 * @function module:@wgetemp/endianness.little
 * @summary Transform array elements between host and little endianness.
 * @desc Aliases either {@link module:@wgetemp/endianness.native} or
 * {@link module:@wgetemp/endianness.foreign}, depending on
 * {@link module:@wgetemp/endianness.isLittle}.
 * @param {TypedArray} array
 * @returns `array`
 */

const little = isLittle ? endianness_native : foreign;
/**
 * @constant module:@wgetemp/endianness.isBig
 * @summary Whether host is big-endian.
 * @type {boolean}
 * @readonly
 */

const isBig = !isLittle;
/**
 * @function module:@wgetemp/endianness.big
 * @summary Transform array elements between host and big endianness.
 * @desc Aliases either {@link module:@wgetemp/endianness.native} or
 * {@link module:@wgetemp/endianness.foreign}, depending on
 * {@link module:@wgetemp/endianness.isBig}.
 * @param {TypedArray} array
 * @returns `array`
 */

const big = isBig ? endianness_native : foreign;
/**
 * @callback module:@wgetemp/endianness.AdjustmentFunction
 * @param {TypedArray} array
 * @returns `array`
 */

/**
 * @class module:@wgetemp/endianness.MultiAdjuster
 * @summary Adjust endianness of shared data.
 * @desc Remembers if a value at a particular offset in an ArrayBuffer has had
 * it's endiannes adjusted, so that calling
 * {@link module:@wgetemp/endianness.MultiAdjuster#adjust} on the same data
 * multiple times (possibly via different views) is idempotent.
 * @param {module:@wgetemp/endianness.AdjustmentFunction} [adjust={@link module:@wgetemp/endianness.foreign}]
 * Endianness adjustment function. Usually {@link module:@wgetemp/endianness.little},
 * {@link module:@wgetemp/endianness.big}, {@link module:@wgetemp/endianness.native},
 * or {@link module:@wgetemp/endianness.foreign}.
 */

class endianness_MultiAdjuster {
  constructor(adjust = foreign) {
    this._adjust = adjust;
    this._maps = new default_map["a" /* DefaultMap */](() => new Map(), [], WeakMap);
  }
  /**
   * @function module:@wgetemp/endianness.MultiAdjuster#adjust
   * @summary Adjust endianness of the array idempotently, according to the
   * adjustment function.
   * @param {TypedArray} array
   * @returns `array`
   */


  adjust(array) {
    if (this._adjust === reverse) {
      const map = this._maps.get(array.buffer);

      const start = array.byteOffset;
      const end = start + array.byteLength;
      const step = array.constructor.BYTES_PER_ELEMENT;

      for (let offset = start; offset < end; offset += step) {
        const size = map.get(offset);

        if (size !== undefined && size !== step) {
          throw new Error('partial element overlap');
        }
      }

      for (let offset = start; offset < end; offset += step) {
        map.set(offset, step);
      }

      this._adjust(array);
    }

    return array;
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/tuple-map.js
var tuple_map = __webpack_require__(395);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/index.js + 10 modules
var lib = __webpack_require__(66);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var core_lib = __webpack_require__(0);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/external-resource.js

class external_resource_ExternalResource extends core_lib["p" /* DisposableUsageCounter */] {
  constructor({
    uri,
    mimeType = null
  }) {
    super();
    this.uri = uri;
    this.bytes = null;
    this.mimeType = mimeType;
  }

  _actuallyUnload() {
    this.bytes = null;

    super._actuallyUnload();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/buffer.js

class buffer_Buffer extends core_lib["p" /* DisposableUsageCounter */] {
  constructor({
    uri = null,
    length
  }) {
    super();
    this.uri = uri;
    this.length = length;
    this.bytes = null;
  }

  _actuallyUnload() {
    this.bytes = null;

    super._actuallyUnload();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/buffer-view.js

class buffer_view_BufferView extends core_lib["p" /* DisposableUsageCounter */] {
  constructor({
    buffer,
    offset,
    length,
    stride,
    target = null
  }) {
    super();
    this.buffer = buffer;
    this.offset = offset;
    this.length = length;
    this.stride = stride;
    this.target = target;
    this.bytes = null;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), this.buffer.load()]);
  }

  _actuallyUnload() {
    this.buffer.unload();
    this.bytes = null;

    super._actuallyUnload();
  }

  _dispose() {
    this.buffer.release();

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/accessor.js

class accessor_Accessor extends core_lib["p" /* DisposableUsageCounter */] {
  constructor({
    bufferView = null,
    target = null,
    ComponentArrayType,
    byteOffset,
    elementCount,
    length,
    stride
  }) {
    super();
    this.bufferView = bufferView;
    this.target = target;
    this.ComponentArrayType = ComponentArrayType;
    this.byteOffset = byteOffset;
    this.elementCount = elementCount;
    this.length = length;
    this.stride = stride;
    this.components = null;
  }

  async _loadDependencies() {
    await Promise.all([super._loadDependencies(), ...function* () {
      if (this.bufferView) {
        yield this.bufferView.load();
      }
    }.call(this)]);
  }

  _actuallyUnload() {
    this.components = null;

    if (this.bufferView) {
      this.bufferView.unload();
    }

    super._actuallyUnload();
  }

  _dispose() {
    if (this.bufferView) {
      this.bufferView.release();
    }

    super._dispose();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/index.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable generator-star-spacing */

/* eslint-disable yield-star-spacing */

/* eslint-disable no-param-reassign */












function cast(from, ToType) {
  const length = from.byteLength / ToType.BYTES_PER_ELEMENT;

  if (false) {}

  return new ToType(from.buffer, from.byteOffset, length);
}

async function createImageFromBytes(bytes, mimeType) {
  const blob = new Blob([bytes], {
    type: mimeType
  });
  const url = URL.createObjectURL(blob);

  try {
    return await new _wgetemp_loader["a" /* Loader */]().load(url, {
      type: Image
    });
  } finally {
    URL.revokeObjectURL(url);
  }
}

const fakeMemoryManager = {
  allocMemory(ArrayType, length) {
    return new ArrayType(length);
  },

  releaseMemory() {}

};
const maxGPUMorphTargets = 3;
/**
 * @class module:@wgetemp/gltf-importer.Output
 * @summary Importer output. Contains parsed contents of glTF file.
 */

class Output {
  constructor() {
    /**
     * @var module:@wgetemp/gltf-importer.Output#vertexBufferViews
     * @type {module:@wgetemp/engine-core.VertexBufferView[]}
     */
    this.vertexBufferViews = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#vertexAttributes
     * @type {module:@wgetemp/engine-core.VertexAttribute[]}
     */

    this.vertexAttributes = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#morphTargets
     * @type {module:@wgetemp/engine-core.MorphTargetData[]}
     */

    this.morphTargets = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#geometries
     * @type {module:@wgetemp/engine-core.Geometry[]}
     */

    this.geometries = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#textureLevelDatas
     * @type {module:@wgetemp/engine-core.TextureLevelData[]}
     */

    this.textureLevelDatas = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#textures
     * @type {module:@wgetemp/engine-core.Texture[]}
     */

    this.textures = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#materials
     * @type {module:@wgetemp/engine-core.Material[]}
     */

    this.materials = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#meshes
     * @type {module:@wgetemp/engine-core.Mesh[]}
     */

    this.meshes = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#cameras
     * @type {module:@wgetemp/engine-core.Camera[]}
     */

    this.cameras = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#nodes
     * @type {module:@wgetemp/engine-core.SceneNode[]}
     */

    this.nodes = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#scenes
     * @type {module:@wgetemp/engine-core.Scene[]}
     */

    this.scenes = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#animations
     * @type {module:@wgetemp/engine-core.Animation[]}
     */

    this.animations = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#bones
     * @type {module:@wgetemp/engine-core.Bone[]}
     */

    this.bones = [];
    /**
     * @var module:@wgetemp/gltf-importer.Output#skeletons
     * @type {module:@wgetemp/engine-core.Skeleton[]}
     */

    this.skeletons = [];
  }
  /**
   * @func module:@wgetemp/gltf-importer.Output#dispose
   * @summary Release all resources.
   */


  dispose() {
    for (const releaseable of function* () {
      yield* this.vertexBufferViews;
      yield* this.vertexAttributes;
      yield* this.morphTargets;
      yield* this.geometries;
      yield* this.textureLevelDatas;
      yield* this.textures;
      yield* this.materials;
      yield* this.meshes;
      yield* this.cameras;
      yield* this.scenes;
      yield* this.animations;
      yield* this.bones;
      yield* this.skeletons;
    }.call(this)) {
      releaseable.release();
    }
  }

}
/**
 * @callback module:@wgetemp/gltf-importer.CreateSceneSignature
 * @returns {module:@wgetemp/engine-core.Scene}
 */

/**
 * @typedef module:@wgetemp/gltf-importer.Maps
 * @desc Object-type map keys are glTF objects.
 * @property {Map<string, module:@wgetemp/gltf-importer.ExternalResource>} uriToExternalResource
 * @property {Map<object, module:@wgetemp/gltf-importer.Buffer>} bufferToBuffer
 * @property {Map<object, module:@wgetemp/gltf-importer.BufferView>} bufferViewToBufferView
 * @property {Map<object, module:@wgetemp/engine-core.VertexBufferView>} bufferViewToVertexBufferView
 * @property {Map<object, module:@wgetemp/gltf-importer.Accessor>} accessorToAccessor
 * @property {Map<object, Map<string, module:@wgetemp/engine-core.VertexAttribute>>} accessorToVertexAttributes
 * The string is glTF attribute semantic name.
 * @property {Map<object, module:@wgetemp/engine-core.Geometry>} primitiveToGeometry
 * @property {Map<object, module:@wgetemp/engine-core.TextureLevelData>} imageToTextureLevelData
 * @property {Map<object, module:@wgetemp/engine-core.Texture>} textureToTexture
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.Texture>>} samplerToTextures
 * The second object-type map key is glTF texture.
 * @property {Map<object, module:@wgetemp/engine-core.Material>} materialToMaterial
 * @property {Map<object, TupleMap<Array, module:@wgetemp/engine-core.SubMesh>>} primitiveToSubMeshes
 * Array-type map key is [glTF scene, glTF node] tuple.
 * @property {Map<object, TupleMap<Array, module:@wgetemp/engine-core.SubMesh>>} meshToMeshes
 * Array-type map key is [glTF scene, glTF node] tuple.
 * @property {Map<object, TupleMap<Array, module:@wgetemp/engine-core.Camera>>} cameraToCameras
 * Array-type map key is [glTF scene, glTF node] tuple.
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.SceneNode>>} nodeToNodes
 * Second object-type map key is glTF scene.
 * @property {Map<object, module:@wgetemp/engine-core.Scene>} sceneToScene
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.Animation>>} animationToAnimations
 * Second object-type map key is glTF scene.
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.Animation>>} animationSamplerToAnimationSamplers
 * Second object-type map key is glTF scene.
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.Animation>>} animationChannelToNodeAnimationChannels
 * Second object-type map key is glTF scene.
 * @property {Map<object, Map<object, module:@wgetemp/engine-core.Animation>>} skinToSkeletons
 * Second object-type map key is glTF scene.
 */

/**
 * @class module:@wgetemp/gltf-importer.GLTFImporter
 * @summary Import assets from glTF files.
 * @param {object} [args={}]
 * @param {module:@wgetemp/loader.Loader} [args.loader=new Loader()] Loader to use.
 * @param {?module:@wgetemp/host-memory-manager.RangeBasedMemoryManager} [args.attributeMemoryManager=null]
 * Memory manager for vertex attributes.
 * @param {?module:@wgetemp/host-memory-manager.RangeBasedMemoryManager} [args.indexMemoryManager=null]
 * Memory manager for vertex indices.
 * @param {?module:module:@wgetemp/webgl-renderer.WebGLBuffer} [args.vertexHardwareBuffer=null]
 * Vertex hardware buffer.
 * @param {?module:module:@wgetemp/webgl-renderer.WebGLBuffer} [args.indexHardwareBuffer=null]
 * Index hardware buffer.
 * @param {?module:@wgetemp/webgl-renderer.MaterialFactory} [args.materialFactory=null]
 * @param {?module:@wgetemp/gltf-importer.CreateSceneSignature} [args.createScene=null]
 * Importer uses this function to create new scenes. This can be used to pass non-default parameters to
 * scene's constructor.
 * @param {boolean} [args.dynamicTextures=false]
 * Passed to constructor of {@link module:@wgetemp/engine-core.Texture} as
 * `dynamic`.
 * @param {boolean} [args.keepResources=false]
 * Whether to keep loaded resources (for later export).
 * @param {boolean} [args.unmovableMeshes=false]
 * Defines if importer prevents transform creation on node with a mesh.
 * It makes no any effects if keepResouces parameter is true.
 * @param {object.<module:@wgetemp/gltf-extensions.Extension>}
 * [args.extensions={@link module:@wgetemp/gltf-extensions.defaultExtensions}]
 * glTF extenions.
 *@example
 * import { RangeBasedMemoryManager } from '@wgetemp/host-memory-manager';
 * import { MaterialFactory } from '@wgetemp/webgl-renderer';
 * import { GLTFImporter } from '@wgetemp/gltf-importer';
 *
 * const importer = new GLTFImporter({
 *     attributeMemoryManager: new RangeBaseMemoryManager({ byteLength: 400 * 1024 * 1024 }),
 *     indexMemoryManager: new RangeBaseMemoryManager({ byteLength: 200 * 1024 * 1024 }),
 *     materialFactory: new MaterialFactory(),
 * });
 *
 * const output = await importer.import('https://example.com/path/to/scene.gltf');
 * const [scene] = output.scenes;
 * scene.retain();
 * output.dispose();
 * // Go on to use `scene`.
 */

class lib_GLTFImporter {
  constructor({
    loader = new _wgetemp_loader["a" /* Loader */](),
    attributeMemoryManager = null,
    indexMemoryManager = null,
    vertexHardwareBuffer = null,
    indexHardwareBuffer = null,
    materialFactory = null,
    createScene = null,
    dynamicTextures = false,
    keepResources = false,
    unmovableMeshes = false,
    extensions = lib["k" /* defaultExtensions */]
  } = {}) {
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#loader
     * @type {module:@wgetemp/loader.Loader}
     * @summary Loader used to load everything.
     */
    this.loader = loader;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#attributeMemoryManager
     * @type {?module:@wgetemp/host-memory-manager.RangeBasedMemoryManager}
     * @summary Memory manager for vertex attributes.
     */

    this.attributeMemoryManager = attributeMemoryManager;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#indexMemoryManager
     * @type {?module:@wgetemp/host-memory-manager.RangeBasedMemoryManager}
     * @summary Memory manager for vertex indices.
     */

    this.indexMemoryManager = indexMemoryManager;
    /**
     * @var module:@wgetemp/.GLTFImporter#vertexHardwareBuffer
     * @type {?module:module:@wgetemp/webgl-renderer.WebGLBuffer}
     * @summary Vertex hardware buffer.
     */

    this.vertexHardwareBuffer = vertexHardwareBuffer;
    /**
     * @var module:@wgetemp/.GLTFImporter#indexHardwareBuffer
     * @type {?module:module:@wgetemp/webgl-renderer.WebGLBuffer}
     * @summary Index hardware buffer.
     */

    this.indexHardwareBuffer = indexHardwareBuffer;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#materialFactory
     * @type {?module:@wgetemp/webgl-renderer.MaterialFactory}
     */

    this.materialFactory = materialFactory;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#createScene
     * @type {?module:@wgetemp/gltf-importer.CreateSceneSignature}
     * @summary Importer uses this function to create new scenes.
     * @desc This can be used to pass non-default parameters to
     * scene's constructor.
     */

    this.createScene = createScene;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#dynamicTextures
     * @type {boolean}
     * @summary Passed to constructor of
     * {@link module:@wgetemp/engine-core.Texture} as `dynamic`.
     */

    this.dynamicTextures = dynamicTextures;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#keepResources
     * @type {boolean}
     * @summary Whether to keep loaded resources (for later export).
     * @param {object.<module:@wgetemp/gltf-extensions.Extension>}
     * [args.extensions={@link module:@wgetemp/gltf-extensions.defaultExtensions}]
     * glTF extenions.
     */

    this.keepResources = keepResources;
    /**
     *  @var module:@wgetemp/gltf-importer.GLTFImporter#unmoveableMeshes
     *  @type {boolean}
     *  @summary Defines if importer prevents transform creation on node with a mesh
     */

    this.unmovableMeshes = unmovableMeshes;
    this._extensions = Object(lib["l" /* resolveExtensionDependencies */])(extensions);

    this._reset();
  }

  _reset() {
    this._preImported = false;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#url
     * @type {?string}
     * @summary URL most recently passed to
     * {@link module:@wgetemp/gltf-importer.GLTFImporter#import}.
     */

    this.url = null;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#binaryChunks
     * @type {Array}
     * @summary When loading binary glTF, some buffers are stored directly
     * within it. They end up in this array.
     */

    this.binaryChunks = [];
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#json
     * @type {?object}
     * @summary Parsed and normalized json content of glTF.
     */

    this.json = null;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#maps
     * @type {module:@wgetemp/gltf-importer.Maps}
     * @summary Various mappings between corresponding glTF and engine objects.
     */

    this.maps = {
      uriToExternalResource: new Map(),
      bufferToBuffer: new Map(),
      bufferViewToBufferView: new Map(),
      bufferViewToVertexBufferView: new Map(),
      accessorToAccessor: new Map(),
      accessorToVertexAttributes: new default_map["a" /* DefaultMap */](() => new Map()),
      accessorToMorphTargetData: new default_map["a" /* DefaultMap */](() => new Map()),
      primitiveToGeometry: new Map(),
      imageToTextureLevelData: new Map(),
      textureToTexture: new Map(),
      samplerToTextures: new default_map["a" /* DefaultMap */](() => new Set()),
      materialToMaterial: new Map(),
      primitiveToSubMeshes: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      meshToMeshes: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      cameraToCameras: new default_map["a" /* DefaultMap */](() => new tuple_map["a" /* TupleMap */]()),
      nodeToNodes: new default_map["a" /* DefaultMap */](() => new Map()),
      sceneToScene: new Map(),
      animationToAnimations: new default_map["a" /* DefaultMap */](() => new Map()),
      animationSamplerToAnimationSamplers: new default_map["a" /* DefaultMap */](() => new Map()),
      animationChannelToNodeAnimationChannels: new default_map["a" /* DefaultMap */](() => new Map()),
      skinToSkeletons: new default_map["a" /* DefaultMap */](() => new Map()),
      batchMap: new tuple_map["a" /* TupleMap */](),
      nodesWithAnimation: new Set()
    };
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#output
     * @type {module:@wgetemp/gltf-importer.Output}
     * @summary Imported assets.
     * @desc {@link module:@wgetemp/gltf-importer.Output#dispose} must be called
     * when you retained what you need from it, typically only a scene.
     */

    this.output = new Output();
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#estimatedVertexAttributesSize
     * @type {number}
     * @summary {@link module:@wgetemp/gltf-importer.GLTFImporter#attributeMemoryManager}
     * should have at least this much bytes available.
     * @desc Only meaningful after {@link module:@wgetemp/gltf-importer.GLTFImporter#preImport}.
     */

    this.estimatedVertexAttributesSize = 0;
    /**
     * @var module:@wgetemp/gltf-importer.GLTFImporter#estimatedVertexIndicesSize
     * @type {number}
     * @summary {@link module:@wgetemp/gltf-importer.GLTFImporter#indexMemoryManager}
     * should have at least this much bytes available.
     * @desc Only meaningful after {@link module:@wgetemp/gltf-importer.GLTFImporter#preImport}.
     */

    this.estimatedVertexIndicesSize = 0;
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getComponentArrayType
   * @param {number} componentType GL scalar component type.
   * @returns {function} Typed array constructor.
   * @summary Translate GL component type to js typed array constructor.
   */


  getComponentArrayType(componentType) {
    switch (componentType) {
      // eslint-disable-line
      case WebGLRenderingContext.BYTE:
        return Int8Array;

      case WebGLRenderingContext.UNSIGNED_BYTE:
        return Uint8Array;

      case WebGLRenderingContext.SHORT:
        return Int16Array;

      case WebGLRenderingContext.UNSIGNED_SHORT:
        return Uint16Array;

      case WebGLRenderingContext.INT:
        return Int32Array;

      case WebGLRenderingContext.UNSIGNED_INT:
        return Uint32Array;

      case WebGLRenderingContext.FLOAT:
        return Float32Array;
    }

    console.error(`unknown component type: ${componentType}`);
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getComponentSize
   * @param {number} componentType GL scalar component type.
   * @returns {number} Size in bytes.
   * @summary Get the size of a GL scalar component type.
   */


  getComponentSize(componentType) {
    return this.getComponentArrayType(componentType).BYTES_PER_ELEMENT;
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getElementWidth
   * @param {string} type glTF accessor element type.
   * @returns {number} How many scalar components there are in an element.
   * @summary Get how many scalar components are there in glTF accessor element.
   */


  getElementWidth(type) {
    switch (type) {
      // eslint-disable-line
      case 'SCALAR':
        return 1;

      case 'VEC2':
        return 2;

      case 'VEC3':
        return 3;

      case 'VEC4':
        return 4;

      case 'MAT2':
        return 4;

      case 'MAT3':
        return 9;

      case 'MAT4':
        return 16;
    }

    console.error(`unknown type: ${type}`);
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getElementSize
   * @param {object} args
   * @param {string} args.type glTF accessor element type.
   * @param {number} args.componentType GL scalar component type.
   * @returns {number} Size in bytes.
   * @summary Get the size of a GL element in bytes.
   */


  getElementSize({
    type,
    componentType
  }) {
    return this.getElementWidth(type) * this.getComponentSize(componentType);
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#translateAttributeSemantic
   * @param {string} semantic glTF attribute semantic name.
   * @param {number} [morphTargetIndex] Morph target index, if any.
   * @returns {module:@wgetemp/engine-core.AttributeSemantic}
   * @summary Translate vertex attribute semantic from glTF to engine.
   */


  translateAttributeSemantic(semantic, morphTargetIndex) {
    let match;

    if (match = /^TEXCOORD_(\d+)$/.exec(semantic)) {
      const channel = match[1];
      semantic = `TEX_COORD_CHANNEL_${channel}`;
    } else {
      switch (semantic) {
        // eslint-disable-line
        case 'POSITION':
        case 'NORMAL':
        case 'TANGENT':
          if (morphTargetIndex !== undefined) {
            semantic = `${semantic}_MORPH_${morphTargetIndex}`;
          }

          break;

        case 'COLOR_0':
          semantic = 'COLOR';
          break;

        case 'JOINTS_0':
          semantic = 'BONE_INDICES';
          break;

        case 'WEIGHTS_0':
          semantic = 'BONE_WEIGHTS';
          break;
      }
    }

    semantic = core_lib["d" /* AttributeSemantic */][semantic];

    if (semantic === undefined) {
      semantic = core_lib["d" /* AttributeSemantic */].NONE;
    }

    return semantic;
  }

  _normalizeBuffers() {
    const buffers = this.json.buffers;

    for (const _ref of buffers.entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const i = _ref2[0];
      const buffer = _ref2[1];
      buffers[i] = Object.assign({
        extensions: {}
      }, buffer);
    }
  }

  _normalizeBufferViews() {
    const _this$json = this.json,
          accessors = _this$json.accessors,
          bufferViews = _this$json.bufferViews,
          meshes = _this$json.meshes;

    for (const _ref3 of meshes) {
      const primitives = _ref3.primitives;

      for (const _ref4 of primitives) {
        const indices = _ref4.indices;
        const attributes = _ref4.attributes;
        var _ref4$targets = _ref4.targets;
        const targets = _ref4$targets === void 0 ? [] : _ref4$targets;

        if (indices !== undefined) {
          const accessor = accessors[indices];

          if (accessor.bufferView !== undefined) {
            const bufferView = bufferViews[accessor.bufferView];
            bufferViews[accessor.bufferView] = Object.assign({
              target: WebGLRenderingContext.ELEMENT_ARRAY_BUFFER
            }, bufferView);
          }
        }

        for (const attribute of function* () {
          yield* Object.values(attributes);

          for (const targetAttributes of targets) {
            yield* Object.values(targetAttributes);
          }
        }.call(this)) {
          const accessor = accessors[attribute];

          if (accessor.bufferView !== undefined) {
            const bufferView = bufferViews[accessor.bufferView];
            bufferViews[accessor.bufferView] = Object.assign({
              target: WebGLRenderingContext.ARRAY_BUFFER,
              byteStride: this.getElementSize(accessor)
            }, bufferView);
          }
        }
      }
    }

    for (const _ref5 of bufferViews.entries()) {
      var _ref6 = _slicedToArray(_ref5, 2);

      const i = _ref6[0];
      const bufferView = _ref6[1];
      bufferViews[i] = Object.assign({
        byteOffset: 0,
        extensions: {}
      }, bufferView);
    }
  }

  _normalizeAccessors() {
    const accessors = this.json.accessors;

    for (const _ref7 of accessors.entries()) {
      var _ref8 = _slicedToArray(_ref7, 2);

      const i = _ref8[0];
      const accessor = _ref8[1];
      accessors[i] = Object.assign({
        byteOffset: 0,
        normalized: false,
        extensions: {}
      }, accessor);
    }
  }

  _normalizeImages() {
    const images = this.json.images;

    for (const _ref9 of images.entries()) {
      var _ref10 = _slicedToArray(_ref9, 2);

      const i = _ref10[0];
      const image = _ref10[1];
      images[i] = Object.assign({
        extensions: {}
      }, image);
    }
  }

  _normalizeSamplers() {
    const samplers = this.json.samplers;
    const defaultSampler = {};
    samplers.push(defaultSampler);

    for (const _ref11 of samplers.entries()) {
      var _ref12 = _slicedToArray(_ref11, 2);

      const i = _ref12[0];
      const sampler = _ref12[1];
      samplers[i] = Object.assign({
        wrapS: WebGLRenderingContext.REPEAT,
        wrapT: WebGLRenderingContext.REPEAT,
        extensions: {}
      }, sampler);
    }
  }

  _normalizeTextures() {
    let usesDefaultSampler = false;
    const _this$json2 = this.json,
          samplers = _this$json2.samplers,
          textures = _this$json2.textures;

    for (const _ref13 of textures.entries()) {
      var _ref14 = _slicedToArray(_ref13, 2);

      const i = _ref14[0];
      const texture = _ref14[1];

      if (texture.sampler === undefined) {
        texture.sampler = samplers.length - 1;
        usesDefaultSampler = true;
      }

      textures[i] = Object.assign({
        extensions: {}
      }, texture);
    }

    if (!usesDefaultSampler) {
      samplers.pop();
    }
  }

  _normalizeTextureInfo(textureInfo) {
    return Object.assign({
      texCoord: 0,
      extensions: {}
    }, textureInfo);
  }

  _normalizeMaterials() {
    const materials = this.json.materials;
    const defaultMaterial = {};
    materials.push(defaultMaterial);

    for (let _ref15 of materials.entries()) {
      var _ref16 = _slicedToArray(_ref15, 2);

      let i = _ref16[0];
      let material = _ref16[1];
      // eslint-disable-line
      material = Object.assign({
        pbrMetallicRoughness: {},
        emissiveFactor: [0, 0, 0],
        alphaMode: 'OPAQUE',
        alphaCutoff: 0.5,
        doubleSided: false,
        extensions: {}
      }, material);
      materials[i] = material;
      let _material = material,
          pbrMetallicRoughness = _material.pbrMetallicRoughness;
      pbrMetallicRoughness = Object.assign({
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1,
        extensions: {}
      }, pbrMetallicRoughness);
      Object.assign(material, {
        pbrMetallicRoughness
      });
      let _pbrMetallicRoughness = pbrMetallicRoughness,
          baseColorTexture = _pbrMetallicRoughness.baseColorTexture;

      if (baseColorTexture !== undefined) {
        baseColorTexture = this._normalizeTextureInfo(baseColorTexture);
        Object.assign(pbrMetallicRoughness, {
          baseColorTexture
        });
      }

      let _pbrMetallicRoughness2 = pbrMetallicRoughness,
          metallicRoughnessTexture = _pbrMetallicRoughness2.metallicRoughnessTexture;

      if (metallicRoughnessTexture !== undefined) {
        metallicRoughnessTexture = this._normalizeTextureInfo(metallicRoughnessTexture);
        Object.assign(pbrMetallicRoughness, {
          metallicRoughnessTexture
        });
      }

      let _material2 = material,
          normalTexture = _material2.normalTexture;

      if (normalTexture !== undefined) {
        normalTexture = this._normalizeTextureInfo(normalTexture);
        normalTexture = Object.assign({
          scale: 1
        }, normalTexture);
        Object.assign(material, {
          normalTexture
        });
      }

      let _material3 = material,
          occlusionTexture = _material3.occlusionTexture;

      if (occlusionTexture !== undefined) {
        occlusionTexture = this._normalizeTextureInfo(occlusionTexture);
        occlusionTexture = Object.assign({
          strength: 1
        }, occlusionTexture);
        Object.assign(material, {
          occlusionTexture
        });
      }

      let _material4 = material,
          emissiveTexture = _material4.emissiveTexture;

      if (emissiveTexture !== undefined) {
        emissiveTexture = this._normalizeTextureInfo(emissiveTexture);
        Object.assign(material, {
          emissiveTexture
        });
      }
    }
  }

  _normalizePrimitives(primitives) {
    let usesDefaultMaterial = false;
    const materials = this.json.materials;

    for (const _ref17 of primitives.entries()) {
      var _ref18 = _slicedToArray(_ref17, 2);

      const i = _ref18[0];
      const primitive = _ref18[1];

      if (primitive.material === undefined) {
        primitive.material = materials.length - 1;
        usesDefaultMaterial = true;
      }

      primitives[i] = Object.assign({
        mode: WebGLRenderingContext.TRIANGLES,
        targets: [],
        extensions: {}
      }, primitive);
    }

    return usesDefaultMaterial;
  }

  _normalizeMeshes() {
    let usesDefaultMaterial = false;
    const _this$json3 = this.json,
          materials = _this$json3.materials,
          meshes = _this$json3.meshes;

    for (const _ref19 of meshes.entries()) {
      var _ref20 = _slicedToArray(_ref19, 2);

      const i = _ref20[0];
      const mesh = _ref20[1];

      if (this._normalizePrimitives(mesh.primitives)) {
        usesDefaultMaterial = true;
      }

      meshes[i] = Object.assign({
        weights: new Array(mesh.primitives[0].targets.length).fill(0),
        extensions: {}
      }, mesh);
    }

    if (!usesDefaultMaterial) {
      materials.pop();
    }
  }

  _normalizeCameras() {
    const cameras = this.json.cameras;

    for (const _ref21 of cameras.entries()) {
      var _ref22 = _slicedToArray(_ref21, 2);

      const i = _ref22[0];
      const camera = _ref22[1];
      camera[camera.type] = Object.assign({
        extensions: {}
      }, camera[camera.type]);
      cameras[i] = Object.assign({
        extensions: {}
      }, camera);
    }
  }

  _normalizeNodes() {
    const matrix = new math_lib["g" /* HomogeneousMatrix3 */]();
    const splitTransform = new math_lib["d" /* AffineSplitTransform3 */]();
    const _this$json4 = this.json,
          meshes = _this$json4.meshes,
          nodes = _this$json4.nodes;

    for (const _ref23 of nodes.entries()) {
      var _ref24 = _slicedToArray(_ref23, 2);

      const i = _ref24[0];
      const node = _ref24[1];

      if (node.mesh !== undefined) {
        node.weights = [...meshes[node.mesh].weights];
      }

      if (node.matrix !== undefined) {
        matrix.fromArray(node.matrix);
        delete node.matrix;
        splitTransform.fromAffineMatrix(matrix);
        const scaling = splitTransform.scaling,
              quaternion = splitTransform.quaternion,
              translation = splitTransform.translation;
        node.scale = scaling.toArray([]);
        node.rotation = quaternion.toArray([]);
        node.translation = translation.toArray([]);
      }

      nodes[i] = Object.assign({
        children: [],
        scale: [1, 1, 1],
        rotation: [0, 0, 0, 1],
        translation: [0, 0, 0],
        extensions: {}
      }, node);
    }
  }

  _normalizeScenes() {
    const scenes = this.json.scenes;

    for (const _ref25 of scenes.entries()) {
      var _ref26 = _slicedToArray(_ref25, 2);

      const i = _ref26[0];
      const scene = _ref26[1];
      scenes[i] = Object.assign({
        nodes: [],
        extensions: {}
      }, scene);
    }
  }

  _normalizeAnimationSamplers(samplers) {
    for (const _ref27 of samplers.entries()) {
      var _ref28 = _slicedToArray(_ref27, 2);

      const i = _ref28[0];
      const sampler = _ref28[1];
      samplers[i] = Object.assign({
        interpolation: 'LINEAR',
        extensions: {}
      }, sampler);
    }
  }

  _normalizeAnimationChannels(channels) {
    for (const _ref29 of channels.entries()) {
      var _ref30 = _slicedToArray(_ref29, 2);

      const i = _ref30[0];
      const channel = _ref30[1];
      channel.target = Object.assign({
        extensions: {}
      }, channel.target);
      channels[i] = Object.assign({
        extensions: {}
      }, channel);
    }
  }

  _normalizeAnimations() {
    const animations = this.json.animations;

    for (const _ref31 of animations.entries()) {
      var _ref32 = _slicedToArray(_ref31, 2);

      const i = _ref32[0];
      const animation = _ref32[1];

      this._normalizeAnimationSamplers(animation.samplers);

      this._normalizeAnimationChannels(animation.channels);

      animations[i] = Object.assign({
        extensions: {}
      }, animation);
    }
  }

  _normalizeSkins() {
    const _this$json5 = this.json,
          nodes = _this$json5.nodes,
          skins = _this$json5.skins;
    const parents = new Map();

    for (const _ref33 of nodes.entries()) {
      var _ref34 = _slicedToArray(_ref33, 2);

      const parent = _ref34[0];
      var _ref34$1$children = _ref34[1].children;
      const children = _ref34$1$children === void 0 ? [] : _ref34$1$children;

      for (const child of children) {
        parents.set(child, parent);
      }
    }

    for (const _ref35 of skins.entries()) {
      var _ref36 = _slicedToArray(_ref35, 2);

      const i = _ref36[0];
      const skin = _ref36[1];

      if (skin.skeleton === undefined) {
        const joints = skin.joints; // find lowest common ancestor

        let path = [];

        for (let _ref37 of joints.entries()) {
          var _ref38 = _slicedToArray(_ref37, 2);

          let j = _ref38[0];
          let node = _ref38[1];

          // eslint-disable-line
          do {
            if (j === 0) {
              path.push(node);
            } else {
              const index = path.indexOf(node);

              if (index !== -1) {
                path = path.slice(index);
                break;
              }
            }
          } while ((node = parents.get(node)) !== undefined);
        }

        skin.skeleton = path[0]; // eslint-disable-line
      }

      skins[i] = Object.assign({
        extensions: {}
      }, skin);
    }
  }

  _normalize() {
    this.json = Object.assign({
      extensionsUsed: [],
      extensionsRequired: [],
      buffers: [],
      bufferViews: [],
      accessors: [],
      images: [],
      samplers: [],
      textures: [],
      materials: [],
      meshes: [],
      cameras: [],
      nodes: [],
      scenes: [],
      animations: [],
      skins: [],
      extensions: {}
    }, this.json);

    this._normalizeBuffers();

    this._normalizeBufferViews();

    this._normalizeAccessors();

    this._normalizeImages();

    this._normalizeSamplers();

    this._normalizeTextures();

    this._normalizeMaterials();

    this._normalizeMeshes();

    this._normalizeCameras();

    this._normalizeNodes();

    this._normalizeScenes();

    this._normalizeAnimations();

    this._normalizeSkins();
  }

  _parse(bytes) {
    this.json = JSON.parse(new TextDecoder().decode(bytes));
    const version = this.json.asset.version;

    if (version !== '2.0') {
      console.warn(`unexpected glTF version: ${version},(only 2.0 is explicitly supported)`); // eslint-disable-line
    }

    this._normalize();
  }

  _parseBinary(bytes) {
    if (bytes.length < 12) {
      throw new Error('too small to contain a GLB header');
    }

    const _endianness$little = little(bytes.slice(4, 8)),
          _endianness$little2 = _slicedToArray(_endianness$little, 1),
          version = _endianness$little2[0];

    if (version !== 2) {
      console.warn(`unexpected GLB version: ${version}, (only version 2 is explicitly supported)`); // eslint-disable-line
    }

    bytes = bytes.subarray(12);

    const _endianness$little3 = little(cast(bytes.slice(0, 4), Uint32Array)),
          _endianness$little4 = _slicedToArray(_endianness$little3, 1),
          jsonLength = _endianness$little4[0];

    this._parse(bytes.subarray(8, 8 + jsonLength));

    bytes = bytes.subarray(8 + jsonLength);

    while (bytes.length > 0) {
      const _endianness$little5 = little(cast(bytes.slice(0, 8), Uint32Array)),
            _endianness$little6 = _slicedToArray(_endianness$little5, 2),
            length = _endianness$little6[0],
            type = _endianness$little6[1];

      this.binaryChunks.push({
        type,
        bytes: bytes.subarray(8, 8 + length)
      });
      bytes = bytes.subarray(8 + length);
    }
  }

  _isBinary(bytes) {
    if (bytes.length < 4) {
      return false;
    }

    const _endianness$little7 = little(cast(bytes.slice(0, 4), Uint32Array)),
          _endianness$little8 = _slicedToArray(_endianness$little7, 1),
          magic = _endianness$little8[0];

    return magic === 0x46546C67;
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getMemoryManager
   * @param {number} [target] GL buffer enum, if any.
   * @returns {module:@wgetemp/host-memory-manager.RangeBasedMemoryManager}
   * @summary Get manager for a specific kind of memory.
   */


  getMemoryManager(target) {
    switch (target) {
      case WebGLRenderingContext.ARRAY_BUFFER:
        return this.attributeMemoryManager;

      case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
        return this.indexMemoryManager;

      case undefined:
      case null:
        return fakeMemoryManager;

      default:
        console.warn(false, 'unknown glTF bufferView target');
      // eslint-disable-line
    }
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#getHardwareBuffer
   * @param {number} [target] GL buffer enum, if any.
   * @returns {?module:module:@wgetemp/webgl-renderer.WebGLBuffer}
   * @summary Hardware buffer for a specific target.
   */


  getHardwareBuffer(target) {
    switch (target) {
      case WebGLRenderingContext.ARRAY_BUFFER:
        return this.vertexHardwareBuffer;

      case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
        return this.indexHardwareBuffer;

      default:
        console.warn(false, 'unknown glTF bufferView target');
      // eslint-disable-line
    }

    return null;
  }
  /**
   * @func module:@wgetemp/gltf-importer.GLTFImporter#allocMemory
   * @param {function} ArrayType Typed array constructor.
   * @param {number} length Length of the array to allocate.
   * @param {number} [target] GL buffer enum, if any.
   * @returns {ArrayType} Allocated array.
   * @summary Allocate specific kind of memory.
   */


  allocMemory(ArrayType, length, target) {
    const memoryManager = this.getMemoryManager(target);
    return memoryManager.allocMemory(ArrayType, length);
  }

  _buildBuffers() {
    const maps = this.maps,
          json = this.json;

    for (const jsonBuffer of json.buffers) {
      const buffer = new buffer_Buffer({
        uri: jsonBuffer.uri,
        length: jsonBuffer.byteLength
      });
      buffer._loadCount = 0;

      buffer._actuallyLoad = async () => {
        if (buffer.uri === null) {
          var _this$binaryChunks = _slicedToArray(this.binaryChunks, 1);

          buffer.bytes = _this$binaryChunks[0].bytes;
        } else {
          buffer.bytes = await this.loader.load(buffer.uri, {
            baseUrl: this.url,
            type: Uint8Array
          });
        }
      };

      maps.bufferToBuffer.set(jsonBuffer, buffer);
    }
  }

  _buildBufferViews() {
    const json = this.json,
          maps = this.maps;

    for (const jsonBufferView of json.bufferViews) {
      const jsonBuffer = json.buffers[jsonBufferView.buffer];
      const bufferView = new buffer_view_BufferView({
        buffer: maps.bufferToBuffer.get(jsonBuffer),
        offset: jsonBufferView.byteOffset,
        length: jsonBufferView.byteLength,
        stride: jsonBufferView.byteStride,
        target: jsonBufferView.target,
        memoryManager: this.getMemoryManager(jsonBufferView.target)
      });
      bufferView._loadCount = 0;

      bufferView._actuallyLoad = () => {
        const buffer = bufferView.buffer,
              offset = bufferView.offset,
              length = bufferView.length;
        bufferView.bytes = new Uint8Array(buffer.bytes.buffer, buffer.bytes.byteOffset + offset, length);
      };

      maps.bufferViewToBufferView.set(jsonBufferView, bufferView);
    }
  }

  _buildAccessors() {
    const endiannessAdjuster = new endianness_MultiAdjuster();

    const adjustEndianness = (array, componentCount = 1, stride = componentCount) => {
      if (isLittle) {
        return;
      }

      for (let offset = 0; offset < array.length; offset += stride) {
        endiannessAdjuster.adjust(array.subarray(offset, offset + componentCount));
      }
    };

    const json = this.json,
          maps = this.maps;
    const targets = new Map();

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        for (let jsonAccessor of function* () {
          yield* Object.values(jsonPrimitive.attributes);

          for (const targetAttributes of jsonPrimitive.targets) {
            yield* Object.values(targetAttributes);
          }
        }.call(this)) {
          jsonAccessor = json.accessors[jsonAccessor];

          if (jsonAccessor.bufferView === undefined) {
            targets.set(jsonAccessor, WebGLRenderingContext.ARRAY_BUFFER);
          }
        }

        if (jsonPrimitive.indices !== undefined) {
          const jsonAccessor = json.accessors[jsonPrimitive.indices];

          if (jsonAccessor.bufferView === undefined) {
            targets.set(jsonAccessor, WebGLRenderingContext.ELEMENT_ARRAY_BUFFER);
          }
        }
      }
    }

    for (const jsonAccessor of json.accessors) {
      const ComponentArrayType = this.getComponentArrayType(jsonAccessor.componentType);
      const elementWidth = this.getElementWidth(jsonAccessor.type);
      const componentSize = ComponentArrayType.BYTES_PER_ELEMENT;
      const elementSize = elementWidth * componentSize;
      let bufferView = null;
      const byteOffset = jsonAccessor.byteOffset; // eslint-disable-line

      let length = null;
      let stride = null;
      let sparse = null;
      const accessor = new accessor_Accessor({
        bufferView,
        target: null,
        ComponentArrayType,
        byteOffset,
        elementCount: jsonAccessor.count,
        length,
        stride,
        sparse: null
      });

      if (jsonAccessor.bufferView === undefined) {
        accessor.target = targets.get(jsonAccessor);
        length = accessor.length = accessor.elementCount * elementWidth; // eslint-disable-line

        stride = accessor.stride = elementWidth; // eslint-disable-line
      } else {
        const jsonBufferView = json.bufferViews[jsonAccessor.bufferView];
        bufferView = accessor.bufferView = maps.bufferViewToBufferView.get(jsonBufferView); // eslint-disable-line

        accessor.target = bufferView.target;
        const _bufferView = bufferView,
              _bufferView$stride = _bufferView.stride,
              byteStride = _bufferView$stride === void 0 ? elementSize : _bufferView$stride;
        const byteLength = Object(math_lib["v" /* max */])(0, byteStride * (accessor.elementCount - 1) + elementSize);
        stride = accessor.stride = byteStride / componentSize; // eslint-disable-line

        length = accessor.length = byteLength / componentSize; // eslint-disable-line

        if (jsonAccessor.sparse !== undefined) {
          accessor.bufferView = null;
          accessor.byteOffset = 0;
          accessor.length = accessor.elementCount * elementWidth;
          accessor.stride = elementWidth;
        }
      }

      if (jsonAccessor.sparse !== undefined) {
        sparse = {};
        const _jsonAccessor$sparse = jsonAccessor.sparse,
              indices = _jsonAccessor$sparse.indices,
              values = _jsonAccessor$sparse.values,
              count = _jsonAccessor$sparse.count;
        sparse.count = count;
        {
          sparse.IndicesArrayType = this.getComponentArrayType(indices.componentType);
          const jsonBufferView = json.bufferViews[indices.bufferView];
          const bufferView = maps.bufferViewToBufferView.get(jsonBufferView);
          sparse.indicesBufferView = bufferView;
          sparse.indicesByteOffset = indices.byteOffset;
        }
        {
          const jsonBufferView = json.bufferViews[values.bufferView];
          const bufferView = maps.bufferViewToBufferView.get(jsonBufferView);
          sparse.valuesBufferView = bufferView;
          sparse.valuesByteOffset = values.byteOffset;
        }
      }

      accessor._loadCount = 0;

      accessor._actuallyLoad = async () => {
        await Promise.all(Array.from(function* () {
          if (bufferView !== null) {
            yield bufferView;
          }

          if (sparse !== null) {
            yield sparse.indicesBufferView;
            yield sparse.valuesBufferView;
          }
        }.call(this), async loadable => {
          if (loadable.unloaded) {
            const loading = loadable.loading;
            await loadable.load();

            if (loading) {
              loadable.unload();
            }
          }
        }));
        let components = null;

        if (bufferView !== undefined) {
          components = new ComponentArrayType(bufferView.bytes.buffer, bufferView.bytes.byteOffset + byteOffset, length);
        }

        if (components !== null && jsonAccessor.sparse === undefined) {
          accessor.components = components;
        } else {
          accessor.components = new ComponentArrayType(accessor.length);

          if (components !== null) {
            if (accessor.stride === stride) {
              accessor.components.set(components);
            } else {
              for (let i = 0; i < accessor.elementCount; ++i) {
                const offset = i * stride;
                const accessorOffset = i * accessor.stride;
                accessor.components.set(components.subarray(offset, offset + elementWidth), accessorOffset);
              }
            }
          }
        }

        adjustEndianness(accessor.components, elementWidth, accessor.stride);

        if (sparse !== null) {
          const _sparse = sparse,
                count = _sparse.count,
                IndicesArrayType = _sparse.IndicesArrayType,
                indicesBytes = _sparse.indicesBufferView.bytes,
                indicesByteOffset = _sparse.indicesByteOffset,
                valuesBytes = _sparse.valuesBufferView.bytes,
                valuesByteOffset = _sparse.valuesByteOffset;
          const indices = new IndicesArrayType(indicesBytes.buffer, indicesBytes.byteOffset + indicesByteOffset, count);
          const values = new ComponentArrayType(valuesBytes.buffer, valuesBytes.byteOffset + valuesByteOffset, count * elementWidth);
          adjustEndianness(indices);
          adjustEndianness(values, elementWidth);

          for (const _ref39 of indices.entries()) {
            var _ref40 = _slicedToArray(_ref39, 2);

            const i = _ref40[0];
            const index = _ref40[1];
            const offset = index * accessor.stride;
            const valueOffset = i * elementWidth;
            accessor.components.set(values.subarray(valueOffset, valueOffset + elementWidth), offset);
          }
        }
      };

      maps.accessorToAccessor.set(jsonAccessor, accessor);
    }
  }

  _buildVertexBufferViewsAndAttributes() {
    const vertexBufferViews = new Map();
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        for (const _ref41 of function* () {
          if (jsonPrimitive.indices !== undefined) {
            yield [jsonPrimitive.indices];
          }

          for (const _ref43 of Object.entries(jsonPrimitive.attributes)) {
            var _ref44 = _slicedToArray(_ref43, 2);

            const jsonSemantic = _ref44[0];
            const accessorIndex = _ref44[1];
            yield [accessorIndex, jsonSemantic];
          }

          for (const _ref45 of jsonPrimitive.targets.entries()) {
            var _ref46 = _slicedToArray(_ref45, 2);

            const morphTargetIndex = _ref46[0];
            const jsonMorphTargetAttributes = _ref46[1];

            for (const _ref47 of Object.entries(jsonMorphTargetAttributes)) {
              var _ref48 = _slicedToArray(_ref47, 2);

              const jsonSemantic = _ref48[0];
              const accessorIndex = _ref48[1];
              yield [accessorIndex, jsonSemantic, morphTargetIndex];
            }
          }
        }.call(this)) {
          var _ref42 = _slicedToArray(_ref41, 3);

          const accessorIndex = _ref42[0];
          const jsonSemantic = _ref42[1];
          const morphTargetIndex = _ref42[2];
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          let vertexAttribute = maps.accessorToVertexAttributes.get(jsonAccessor).get(semantic);

          if (vertexAttribute !== undefined) {
            continue;
          }

          const accessor = maps.accessorToAccessor.get(jsonAccessor);
          const bufferView = accessor.bufferView;
          let vertexBufferView;

          if (bufferView !== null) {
            vertexBufferView = vertexBufferViews.get(bufferView);

            if (vertexBufferView === undefined) {
              vertexBufferView = new core_lib["pb" /* VertexBufferView */]();
              vertexBufferView._loadCount = 0;

              vertexBufferView._actuallyLoad = async () => {
                if (bufferView.unloaded) {
                  const loading = bufferView.loading;
                  await bufferView.load();

                  if (loading) {
                    bufferView.unload();
                  }
                }

                const memoryManager = this.getMemoryManager(bufferView.target);
                const _memoryManager$empty = memoryManager.empty,
                      empty = _memoryManager$empty === void 0 ? false : _memoryManager$empty;
                vertexBufferView._staging = memoryManager;
                vertexBufferView._view = memoryManager.allocMemory(Uint8Array, bufferView.length);
                vertexBufferView.empty = empty;

                if (empty) {
                  const hwBuffer = this.getHardwareBuffer(bufferView.target);

                  if (hwBuffer !== null) {
                    hwBuffer.subdata(bufferView.bytes, vertexBufferView.view.byteOffset);
                  }
                } else {
                  vertexBufferView._view.set(bufferView.bytes);
                }
              };

              const jsonBufferView = json.bufferViews[jsonAccessor.bufferView];
              maps.bufferViewToVertexBufferView.set(jsonBufferView, vertexBufferView);
              output.vertexBufferViews.push(vertexBufferView);
              vertexBufferViews.set(accessor.bufferView, vertexBufferView);

              switch (bufferView.target) {
                // eslint-disable-line
                case WebGLRenderingContext.ARRAY_BUFFER:
                  this.estimatedVertexAttributesSize += bufferView.length;
                  break;

                case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
                  this.estimatedVertexIndicesSize += bufferView.length;
                  break;
              }
            }
          } else {
            vertexBufferView = new core_lib["pb" /* VertexBufferView */]();
            vertexBufferView._loadCount = 0;

            vertexBufferView._actuallyLoad = async () => {
              if (accessor.unloaded) {
                const loading = accessor.loading;
                await accessor.load();

                if (loading) {
                  accessor.unload();
                }
              }

              const memoryManager = this.getMemoryManager(accessor.target);
              const _memoryManager$empty2 = memoryManager.empty,
                    empty = _memoryManager$empty2 === void 0 ? false : _memoryManager$empty2;
              vertexBufferView._staging = memoryManager;
              vertexBufferView._view = memoryManager.allocMemory(Uint8Array, accessor.components.byteLength);
              vertexBufferView.empty = empty;

              if (empty) {
                const hwBuffer = this.getHardwareBuffer(accessor.target);

                if (hwBuffer !== null) {
                  hwBuffer.subdata(cast(accessor.components, Uint8Array), vertexBufferView.view.byteOffset);
                }
              } else {
                vertexBufferView._view.set(cast(accessor.components, Uint8Array));
              }
            };

            output.vertexBufferViews.push(vertexBufferView);

            switch (accessor.target) {
              // eslint-disable-line
              case WebGLRenderingContext.ARRAY_BUFFER:
                this.estimatedVertexAttributesSize += accessor.components.byteLength;
                break;

              case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
                this.estimatedVertexIndicesSize += accessor.components.byteLength;
                break;
            }
          }

          if (morphTargetIndex !== undefined) {
            const componentCount = this.getElementWidth(jsonAccessor.type);
            const morphTargetData = new core_lib["I" /* MorphTargetData */]({
              elementCount: accessor.elementCount,
              componentCount,
              semantic,
              type: accessor.ComponentArrayType
            });
            const stride = accessor.stride,
                  ComponentArrayType = accessor.ComponentArrayType,
                  elementCount = accessor.elementCount;
            const bytesPerMorphElement = componentCount * ComponentArrayType.BYTES_PER_ELEMENT;
            morphTargetData._loadCount = 0;

            morphTargetData._actuallyLoad = async () => {
              if (accessor.unloaded) {
                const loading = accessor.loading;
                await accessor.load();

                if (loading) {
                  accessor.unload();
                }
              }

              const components = accessor.components;

              if (stride * ComponentArrayType.BYTES_PER_ELEMENT === bytesPerMorphElement) {
                morphTargetData.view.set(components);
              } else {
                for (let elementIdx = 0; elementIdx < elementCount; elementIdx++) {
                  let dstArrayIdx = elementIdx * stride / ComponentArrayType.BYTES_PER_ELEMENT;
                  let srcArrayIdx = elementIdx * componentCount;

                  for (let componentIdx = 0; componentIdx < componentCount; componentIdx++) {
                    morphTargetData.view[dstArrayIdx + componentIdx] = components[srcArrayIdx + componentIdx];
                  }
                }
              }
            };

            maps.accessorToMorphTargetData.get(jsonAccessor).set(semantic, morphTargetData);
            output.morphTargets.push(morphTargetData);
          }

          if (morphTargetIndex === undefined || morphTargetIndex < maxGPUMorphTargets) {
            vertexAttribute = new core_lib["mb" /* VertexAttribute */]({
              vertexData: vertexBufferView,
              offset: accessor.byteOffset,
              stride: accessor.stride * this.getComponentSize(jsonAccessor.componentType),
              semantic,
              normalized: jsonAccessor.normalized,
              countComponents: this.getElementWidth(jsonAccessor.type),
              countElements: accessor.elementCount,
              componentType: jsonAccessor.componentType,
              type: accessor.ComponentArrayType,
              elementType: core_lib["nb" /* VertexAttributeType */][jsonAccessor.type]
            });
            vertexAttribute._loadCount = 0;

            vertexAttribute._actuallyLoad = () => {
              vertexAttribute.view = vertexBufferView.empty ? {
                byteOffset: vertexBufferView.view.byteOffset + accessor.byteOffset
              } : new accessor.ComponentArrayType(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset + accessor.byteOffset, accessor.length);
            };

            maps.accessorToVertexAttributes.get(jsonAccessor).set(semantic, vertexAttribute);
            output.vertexAttributes.push(vertexAttribute);
          }
        }
      }
    }
  }

  _buildGeometries() {
    const geometries = new tuple_map["a" /* TupleMap */]();
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonMesh of json.meshes) {
      for (const jsonPrimitive of jsonMesh.primitives) {
        let maxMorphTargetIndex = 0;
        let vertexIndices;

        if (jsonPrimitive.indices !== undefined) {
          const jsonAccessor = json.accessors[jsonPrimitive.indices];
          vertexIndices = maps.accessorToVertexAttributes.get(jsonAccessor).get(core_lib["d" /* AttributeSemantic */].NONE);
        }

        const vertexAttributes = Array.from(function* () {
          for (const _ref49 of Object.entries(jsonPrimitive.attributes)) {
            var _ref50 = _slicedToArray(_ref49, 2);

            const jsonSemantic = _ref50[0];
            const accessorIndex = _ref50[1];
            yield [accessorIndex, jsonSemantic];
          }

          for (const _ref51 of jsonPrimitive.targets.entries()) {
            var _ref52 = _slicedToArray(_ref51, 2);

            const morphTargetIndex = _ref52[0];
            const jsonMorphTargetAttributes = _ref52[1];
            if (morphTargetIndex >= maxGPUMorphTargets) continue;

            for (const _ref53 of Object.entries(jsonMorphTargetAttributes)) {
              var _ref54 = _slicedToArray(_ref53, 2);

              const jsonSemantic = _ref54[0];
              const accessorIndex = _ref54[1];
              yield [accessorIndex, jsonSemantic, morphTargetIndex];
            }
          }
        }.call(this), ([accessorIndex, jsonSemantic, morphTargetIndex]) => {
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          return maps.accessorToVertexAttributes.get(jsonAccessor).get(semantic);
        });
        const morphTargets = Array.from(function* () {
          for (const _ref55 of jsonPrimitive.targets.entries()) {
            var _ref56 = _slicedToArray(_ref55, 2);

            const morphTargetIndex = _ref56[0];
            const jsonMorphTargetAttributes = _ref56[1];

            for (const _ref57 of Object.entries(jsonMorphTargetAttributes)) {
              var _ref58 = _slicedToArray(_ref57, 2);

              const jsonSemantic = _ref58[0];
              const accessorIndex = _ref58[1];
              yield [accessorIndex, jsonSemantic, morphTargetIndex];
            }
          }
        }.call(this), ([accessorIndex, jsonSemantic, morphTargetIndex]) => {
          const jsonAccessor = json.accessors[accessorIndex];
          const semantic = this.translateAttributeSemantic(jsonSemantic, morphTargetIndex);
          return maps.accessorToMorphTargetData.get(jsonAccessor).get(semantic);
        });
        const key = [jsonPrimitive.mode, vertexIndices !== undefined ? vertexIndices : null, ...vertexAttributes, ...morphTargets];
        let geometry = geometries.get(key);

        if (geometry === undefined) {
          geometry = new core_lib["t" /* Geometry */]({
            primitiveType: jsonPrimitive.mode
          });

          if (vertexIndices !== undefined) {
            geometry.indices = vertexIndices;
          }

          for (const vertexAttribute of vertexAttributes) {
            geometry.attributes.set(vertexAttribute.semantic, vertexAttribute);
          }

          for (const morphTarget of morphTargets) {
            geometry.morphTargets.set(morphTarget.semantic, morphTarget);
          }

          geometry._loadCount = 0;

          if (jsonPrimitive.attributes.POSITION !== undefined) {
            const accessor = json.accessors[jsonPrimitive.attributes.POSITION];
            const _accessor$min = accessor.min,
                  bboxMin = _accessor$min === void 0 ? [] : _accessor$min,
                  _accessor$max = accessor.max,
                  bboxMax = _accessor$max === void 0 ? [] : _accessor$max;

            if (bboxMin.length >= 3 && bboxMax.length >= 3) {
              geometry.boundingBox.min.fromArray(bboxMin);
              geometry.boundingBox.max.fromArray(bboxMax);
              geometry.needsUpdateBoundingBox = false;
            }
          }

          geometries.set(key, geometry);
        }

        maps.primitiveToGeometry.set(jsonPrimitive, geometry);
      }
    }

    for (const geometry of geometries.values()) {
      output.geometries.push(geometry);
    }
  }

  _buildTextureLevelDatas() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonImage of json.images) {
      const textureLevelData = new core_lib["hb" /* TextureLevelData */]({
        depth: 1,
        data: null
      });

      if (jsonImage.uri === undefined) {
        const jsonBufferView = json.bufferViews[jsonImage.bufferView];
        const bufferView = maps.bufferViewToBufferView.get(jsonBufferView);
        textureLevelData._loadCount = 0;

        textureLevelData._actuallyLoad = async () => {
          if (bufferView.unloaded) {
            const loading = bufferView.loading;
            await bufferView.load();

            if (loading) {
              bufferView.unload();
            }
          }

          textureLevelData.data = await createImageFromBytes(bufferView.bytes, jsonImage.mimeType);
          textureLevelData.width = textureLevelData.data.width;
          textureLevelData.height = textureLevelData.data.height;

          if (this.keepResources) {
            textureLevelData.data.resource = {
              name: jsonImage.name,
              mimeType: jsonImage.mimeType,
              bytes: bufferView.bytes
            };
          }
        };
      } else {
        let externalResource = maps.uriToExternalResource.get(jsonImage.uri);

        if (externalResource === undefined) {
          externalResource = new external_resource_ExternalResource({
            uri: jsonImage.uri,
            mimeType: jsonImage.mimeType
          });
          externalResource._loadCount = 0;

          externalResource._actuallyLoad = async () => {
            externalResource.bytes = await this.loader.load(externalResource.uri, {
              baseUrl: this.url,
              type: Uint8Array
            });

            if (externalResource.mimeType === null) {
              externalResource.mimeType = externalResource.bytes[_wgetemp_loader["a" /* Loader */].mimeType];
            }
          };

          maps.uriToExternalResource.set(jsonImage.uri, externalResource);
        }

        textureLevelData._loadCount = 0;

        textureLevelData._actuallyLoad = async () => {
          if (externalResource.unloaded) {
            const _externalResource = externalResource,
                  loading = _externalResource.loading;
            await externalResource.load();

            if (loading) {
              externalResource.unload();
            }
          }

          const _externalResource2 = externalResource,
                bytes = _externalResource2.bytes,
                mimeType = _externalResource2.mimeType;
          textureLevelData.data = await createImageFromBytes(bytes, mimeType);
          textureLevelData.width = textureLevelData.data.width;
          textureLevelData.height = textureLevelData.data.height;

          if (this.keepResources) {
            textureLevelData.data.resource = {
              name: jsonImage.name,
              mimeType,
              bytes
            };

            if (!jsonImage.uri.startsWith('data:')) {
              textureLevelData.data.resource.path = jsonImage.uri;
            }
          }
        };
      }

      maps.imageToTextureLevelData.set(jsonImage, textureLevelData);
      output.textureLevelDatas.push(textureLevelData);
    }
  }

  _buildTextures() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonTexture of json.textures) {
      const name = jsonTexture.name,
            imageIndex = jsonTexture.source,
            samplerIndex = jsonTexture.sampler;
      const jsonImage = json.images[imageIndex];
      const textureLevelData = maps.imageToTextureLevelData.get(jsonImage);
      const jsonSampler = json.samplers[samplerIndex];
      const texture = new core_lib["gb" /* Texture */]({
        name,
        bindingPoint: core_lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
        wrapS: jsonSampler.wrapS,
        wrapT: jsonSampler.wrapT,
        minFilter: jsonSampler.minFilter,
        magFilter: jsonSampler.magFilter,
        levelsData: [textureLevelData],
        dynamic: this.dynamicTextures
      });

      if (jsonTexture.extras !== undefined) {
        texture.extras = jsonTexture.extras;
      }

      texture._loadCount = 0;

      texture._actuallyLoad = () => {
        const image = textureLevelData.data;
        texture.width = image.width;
        texture.height = image.height;

        switch (image[_wgetemp_loader["a" /* Loader */].mimeType]) {
          // eslint-disable-line
          case 'image/jpeg':
            texture.format = core_lib["N" /* PixelDataFormat */].RGB;
            break;

          case 'image/png':
            texture.format = core_lib["N" /* PixelDataFormat */].RGBA;
            break;
        }

        texture._needsUpdate = true;
      };

      maps.textureToTexture.set(jsonTexture, texture);
      maps.samplerToTextures.get(jsonSampler).add(texture);
      output.textures.push(texture);
    }
  }

  _buildMaterials() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonMaterial of json.materials) {
      const name = jsonMaterial.name,
            _jsonMaterial$pbrMeta = jsonMaterial.pbrMetallicRoughness,
            jsonBaseColorTextureInfo = _jsonMaterial$pbrMeta.baseColorTexture,
            jsonBaseColorFactor = _jsonMaterial$pbrMeta.baseColorFactor,
            jsonMetallicRoughnessTextureInfo = _jsonMaterial$pbrMeta.metallicRoughnessTexture,
            metallicFactor = _jsonMaterial$pbrMeta.metallicFactor,
            roughnessFactor = _jsonMaterial$pbrMeta.roughnessFactor,
            jsonNormalTextureInfo = jsonMaterial.normalTexture,
            jsonOcclusionTextureInfo = jsonMaterial.occlusionTexture,
            jsonEmissiveTextureInfo = jsonMaterial.emissiveTexture,
            jsonEmissiveFactor = jsonMaterial.emissiveFactor,
            jsonAlphaMode = jsonMaterial.alphaMode,
            alphaCutoff = jsonMaterial.alphaCutoff,
            doubleSided = jsonMaterial.doubleSided;
      const material = this.materialFactory.createPbrMeshMaterial({
        name,
        alphaMode: core_lib["D" /* Material */].AlphaMode[jsonAlphaMode],
        alphaCutoff,
        opacity: jsonBaseColorFactor[3],
        cullFace: doubleSided ? core_lib["D" /* Material */].CullFace.NONE : core_lib["D" /* Material */].CullFace.BACK,
        albedo: new math_lib["k" /* RGBColor */]().fromArray(jsonBaseColorFactor),
        metalness: metallicFactor,
        roughness: roughnessFactor,
        emissive: new math_lib["k" /* RGBColor */]().fromArray(jsonEmissiveFactor)
      });
      material._loadCount = 0;

      if (jsonBaseColorTextureInfo !== undefined) {
        const textureIndex = jsonBaseColorTextureInfo.index,
              texCoordIndex = jsonBaseColorTextureInfo.texCoord;
        const jsonTexture = json.textures[textureIndex];
        const texture = maps.textureToTexture.get(jsonTexture);
        material.albedoMap = new core_lib["D" /* Material */].TextureProperties(texture, undefined, texCoordIndex);
      }

      if (jsonMetallicRoughnessTextureInfo !== undefined) {
        const textureIndex = jsonMetallicRoughnessTextureInfo.index,
              texCoordIndex = jsonMetallicRoughnessTextureInfo.texCoord;
        const jsonTexture = json.textures[textureIndex];
        const texture = maps.textureToTexture.get(jsonTexture);
        material.metalnessRoughnessMap = new core_lib["D" /* Material */].TextureProperties(texture, undefined, texCoordIndex);
      }

      if (jsonNormalTextureInfo !== undefined) {
        const textureIndex = jsonNormalTextureInfo.index,
              texCoordIndex = jsonNormalTextureInfo.texCoord,
              scale = jsonNormalTextureInfo.scale;
        const jsonTexture = json.textures[textureIndex];
        const texture = maps.textureToTexture.get(jsonTexture);
        material.normalMap = new core_lib["D" /* Material */].NormalMapProperties(texture, undefined, texCoordIndex, scale);
      }

      if (jsonOcclusionTextureInfo !== undefined) {
        const textureIndex = jsonOcclusionTextureInfo.index,
              texCoordIndex = jsonOcclusionTextureInfo.texCoord,
              strength = jsonOcclusionTextureInfo.strength;
        const jsonTexture = json.textures[textureIndex];
        const texture = maps.textureToTexture.get(jsonTexture);
        material.ambientOcclusionMap = new core_lib["D" /* Material */].AOMapProperties(texture, undefined, texCoordIndex, strength);
      }

      if (jsonEmissiveTextureInfo !== undefined) {
        const textureIndex = jsonEmissiveTextureInfo.index,
              texCoordIndex = jsonEmissiveTextureInfo.texCoord;
        const jsonTexture = json.textures[textureIndex];
        const texture = maps.textureToTexture.get(jsonTexture);
        material.emissiveMap = new core_lib["D" /* Material */].EmissiveMapProperties(1, texture, undefined, texCoordIndex);
      }

      if (material.alphaMode === core_lib["D" /* Material */].AlphaMode.BLEND) {
        material.depthWrite = false;
      }

      if (jsonMaterial.extras !== undefined) {
        material.extras = jsonMaterial.extras;
      }

      material._actuallyLoad = () => {
        for (const map of [material.albedoMap, material.emissiveMap]) {
          if (!map) {
            continue;
          }

          const texture = map.texture;

          switch (texture.format) {
            // eslint-disable-line
            case core_lib["N" /* PixelDataFormat */].RGB:
              texture.internalFormat = core_lib["v" /* InternalFormat */].SRGB8;
              break;

            case core_lib["N" /* PixelDataFormat */].RGBA:
              texture.internalFormat = core_lib["v" /* InternalFormat */].SRGB8_ALPHA8;
              break;
          }
        }
      };

      maps.materialToMaterial.set(jsonMaterial, material);
      output.materials.push(material);
    }
  }

  _buildMeshes() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonScene of json.scenes) {
      const walk = nodeIndex => {
        const jsonNode = json.nodes[nodeIndex];

        if (jsonNode.mesh !== undefined) {
          const jsonMesh = json.meshes[jsonNode.mesh];
          const mesh = new core_lib["F" /* Mesh */]({
            name: jsonMesh.name
          });
          mesh._loadCount = 0;

          for (const jsonPrimitive of jsonMesh.primitives) {
            const geometry = maps.primitiveToGeometry.get(jsonPrimitive);
            const jsonMaterial = json.materials[jsonPrimitive.material];
            const material = maps.materialToMaterial.get(jsonMaterial);
            const subMesh = new core_lib["fb" /* SubMesh */]({
              name: jsonPrimitive.name,
              geometry: null,
              material: null
            });
            subMesh._loaded = false;
            subMesh.geometry = geometry;
            subMesh.material = material;

            if (jsonPrimitive.extras !== undefined) {
              subMesh.extras = JSON.parse(JSON.stringify(jsonPrimitive.extras));
            }

            mesh.addSubMesh(subMesh);
            maps.primitiveToSubMeshes.get(jsonPrimitive).set([jsonScene, jsonNode], subMesh);
            const k = [geometry.id, material.id];
            let instanceCount = maps.batchMap.get(k) || 0;
            maps.batchMap.set(k, ++instanceCount);
          }

          if (jsonMesh.extras !== undefined) {
            mesh.extras = JSON.parse(JSON.stringify(jsonMesh.extras));
          }

          maps.meshToMeshes.get(jsonMesh).set([jsonScene, jsonNode], mesh);
          output.meshes.push(mesh);
        }

        jsonNode.children.forEach(walk);
      };

      jsonScene.nodes.forEach(walk);
    }
  }

  _buildCameras() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonScene of json.scenes) {
      const walk = jsonNode => {
        jsonNode = json.nodes[jsonNode]; // eslint-disable-line

        if (jsonNode.camera !== undefined) {
          const jsonCamera = json.cameras[jsonNode.camera];
          const camera = new core_lib["f" /* Camera */]({
            name: jsonCamera.name
          });

          switch (jsonCamera.type) {
            case 'orthographic':
              camera.projectionType = core_lib["f" /* Camera */].ProjectionTypes.ORTHOGRAPHIC;
              camera.xmag = jsonCamera.orthographic.xmag;
              camera.ymag = jsonCamera.orthographic.ymag;
              camera.znear = jsonCamera.orthographic.znear;
              camera.zfar = jsonCamera.orthographic.zfar;
              break;

            case 'perspective':
              camera.projectionType = core_lib["f" /* Camera */].ProjectionTypes.PERSPECTIVE;

              if (jsonCamera.perspective.aspect !== undefined) {
                camera.aspect = jsonCamera.perspective.aspect;
              }

              camera.yfov = jsonCamera.perspective.yfov;
              camera.znear = jsonCamera.perspective.znear;

              if (jsonCamera.perspective.zfar !== undefined) {
                camera.zfar = jsonCamera.perspective.zfar;
              }

              break;

            default:
              console.warn('unknown glTF camera type');
          }

          if (jsonCamera.extras !== undefined) {
            camera.extras = JSON.parse(JSON.stringify(jsonCamera.extras));
          }

          maps.cameraToCameras.get(jsonCamera).set([jsonScene, jsonNode], camera);
          output.cameras.push(camera);
        }

        jsonNode.children.forEach(walk);
      };

      jsonScene.nodes.forEach(walk);
    }
  }

  _buildNodesAndScenes() {
    // NOTE: since our `SceneNode`s cannot exit without `Scene`s, we cannot
    // sanely expose orphan node trees that are not referenced from some glTF
    // scene.
    const json = this.json,
          maps = this.maps,
          keepResources = this.keepResources,
          unmovableMeshes = this.unmovableMeshes,
          output = this.output;
    let createScene = this.createScene;

    if (createScene === null) {
      // +1 - plus root
      createScene = () => new core_lib["Y" /* Scene */]({
        maxSceneNodes: json.nodes.length + 1,
        batchMap: maps.batchMap
      });
    }

    for (const jsonScene of json.scenes) {
      const scene = createScene(json.nodes.length + 1, maps.batchMap); // +1 - plus root

      scene.name = jsonScene.name;

      const walk = (parent, jsonNode) => {
        let transformRequired = keepResources;
        jsonNode = json.nodes[jsonNode]; // eslint-disable-line

        const node = parent.createChild({
          name: jsonNode.name
        });

        if (jsonNode.mesh !== undefined) {
          const jsonMesh = json.meshes[jsonNode.mesh];
          const mesh = maps.meshToMeshes.get(jsonMesh).get([jsonScene, jsonNode]);
          node.attach(mesh);
          let morphWeights = jsonNode.weights || jsonMesh.weights || jsonMesh.primitives[0].targets.length;
          morphWeights = new Float32Array(morphWeights);

          if (morphWeights.length !== 0) {
            const morph = new core_lib["H" /* Morph */](morphWeights);
            node.attach(morph);
          }

          if (!unmovableMeshes) transformRequired = true;
        }

        if (jsonNode.camera !== undefined) {
          const jsonCamera = json.cameras[jsonNode.camera];
          const camera = maps.cameraToCameras.get(jsonCamera).get([jsonScene, jsonNode]);
          node.attach(camera);
          transformRequired = true;
        }

        if (jsonNode.extras !== undefined) {
          node.extras = JSON.parse(JSON.stringify(jsonNode.extras));
        }

        if (transformRequired) {
          node.attach(new core_lib["jb" /* Transform */]());
        }

        maps.nodeToNodes.get(jsonNode).set(jsonScene, node);
        output.nodes.push(node);

        for (const jsonChild of jsonNode.children) {
          walk(node, jsonChild);
        }
      };

      for (const jsonNode of jsonScene.nodes) {
        walk(scene.root, jsonNode);
      }

      if (jsonScene.extras !== undefined) {
        scene.extras = jsonScene.extras; // never shared, no need to clone
      }

      maps.sceneToScene.set(jsonScene, scene);
      output.scenes.push(scene);
    }
  }

  _buildAnimations() {
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonScene of json.scenes) {
      const scene = maps.sceneToScene.get(jsonScene);

      for (const jsonAnimation of json.animations) {
        const inputs = [];
        const outputs = [];
        const animation = new core_lib["b" /* Animation */]({
          name: jsonAnimation.name,
          inputs,
          outputs
        });
        animation.stop();
        const animationIndex = scene.addAnimation(animation);

        for (const jsonSampler of jsonAnimation.samplers) {
          const sampler = new core_lib["b" /* Animation */].Sampler();

          switch (jsonSampler.interpolation) {
            case 'STEP':
              sampler.interpolation = core_lib["b" /* Animation */].Sampler.Interpolation.STEP;
              break;

            default:
              console.warn(`unknown glTL animation interpolation type: ${jsonSampler.interpolation},` + 'using LINEAR instead');

            case 'LINEAR':
              sampler.interpolation = core_lib["b" /* Animation */].Sampler.Interpolation.LINEAR;
              break;

            case 'CUBICSPLINE':
              sampler.interpolation = core_lib["b" /* Animation */].Sampler.Interpolation.CUBIC;
              break;
          }

          {
            const jsonAccessor = json.accessors[jsonSampler.input];
            const accessor = maps.accessorToAccessor.get(jsonAccessor);
            animation.duration = Object(math_lib["v" /* max */])(jsonAccessor.max[0], animation.duration);
            sampler.input = inputs.push({
              view: null,
              min: jsonAccessor.min[0],
              max: jsonAccessor.max[0]
            }) - 1;
          }
          {
            const jsonAccessor = json.accessors[jsonSampler.output];
            const accessor = maps.accessorToAccessor.get(jsonAccessor);
            sampler.output = outputs.push({
              view: null,
              countComponents: this.getElementWidth(jsonAccessor.type)
            }) - 1;
          }
          maps.animationSamplerToAnimationSamplers.get(jsonSampler).set(jsonScene, sampler);
          animation.samplers.push(sampler);
        }

        for (const jsonChannel of jsonAnimation.channels) {
          if (jsonChannel.target.node === undefined) {
            continue;
          }

          const jsonNode = json.nodes[jsonChannel.target.node];
          const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);
          const jsonSampler = jsonAnimation.samplers[jsonChannel.sampler];
          const sampler = maps.animationSamplerToAnimationSamplers.get(jsonSampler).get(jsonScene);

          if (jsonChannel.target.path === 'rotation') {
            sampler._isQuat = true;
          }

          let target = null;

          if (jsonChannel.target.path === 'weights') {
            var _node$getComponents = node.getComponents([core_lib["H" /* Morph */]]);

            var _node$getComponents2 = _slicedToArray(_node$getComponents, 1);

            target = _node$getComponents2[0];
          } else {
            var _node$getComponents3 = node.getComponents([core_lib["jb" /* Transform */]]);

            var _node$getComponents4 = _slicedToArray(_node$getComponents3, 1);

            target = _node$getComponents4[0];

            if (target === null) {
              target = new core_lib["jb" /* Transform */]();
              node.attach(target);
            }

            maps.nodesWithAnimation.add(jsonNode);
          }

          if (false) {}

          const channel = new core_lib["J" /* NodeAnimation */].Channel(target, jsonChannel.sampler, animationIndex);

          switch (jsonChannel.target.path) {
            case 'scale':
              channel.update = core_lib["J" /* NodeAnimation */].Channel.scaleUpdate;
              break;

            case 'rotation':
              channel.update = core_lib["J" /* NodeAnimation */].Channel.orientationUpdate;
              break;

            case 'translation':
              channel.update = core_lib["J" /* NodeAnimation */].Channel.translationUpdate;
              break;

            case 'weights':
              animation._outputs[sampler.output].countComponents *= target.weights.length;
              channel.update = core_lib["J" /* NodeAnimation */].Channel.morphUpdate;
              break;

            default:
              console.warn(`unknown glTF animation target path: ${jsonSampler.target.path}`);
              continue;
          }

          let _node$getComponents5 = node.getComponents([core_lib["J" /* NodeAnimation */]]),
              _node$getComponents6 = _slicedToArray(_node$getComponents5, 1),
              nodeAnimation = _node$getComponents6[0];

          if (nodeAnimation === null) {
            nodeAnimation = new core_lib["J" /* NodeAnimation */]();
            node.attach(nodeAnimation);
          }

          maps.animationChannelToNodeAnimationChannels.get(jsonChannel).set(jsonScene, channel);
          nodeAnimation.channels.push(channel);
          animation.retain();
        }

        if (jsonAnimation.extras !== undefined) {
          animation.extras = JSON.parse(JSON.stringify(jsonAnimation.extras));
        }

        animation._loadCount = 0;

        animation._actuallyLoad = async () => {
          await Promise.all(function* () {
            for (const _ref59 of jsonAnimation.samplers.entries()) {
              var _ref60 = _slicedToArray(_ref59, 2);

              const i = _ref60[0];
              const jsonSampler = _ref60[1];
              const sampler = maps.animationSamplerToAnimationSamplers.get(jsonSampler).get(jsonScene);
              yield Promise.all([(async () => {
                const jsonAccessor = json.accessors[jsonSampler.input];
                const accessor = maps.accessorToAccessor.get(jsonAccessor);
                const track = inputs[i];

                if (accessor.unloaded) {
                  const loading = accessor.loading;
                  await accessor.load();

                  if (loading) {
                    accessor.unload();
                  }
                }

                track.view = accessor.components.slice();
              })(), (async () => {
                const jsonAccessor = json.accessors[jsonSampler.output];
                const accessor = maps.accessorToAccessor.get(jsonAccessor);
                const track = outputs[i];

                if (accessor.unloaded) {
                  const loading = accessor.loading;
                  await accessor.load();

                  if (loading) {
                    accessor.unload();
                  }
                }

                const elementWidth = this.getElementWidth(jsonAccessor.type);
                let denormalizedComponents;

                if (jsonAccessor.normalized) {
                  // XXX: untested
                  denormalizedComponents = new Float32Array(jsonAccessor.count * elementWidth);
                  const signed = !accessor.ComponentArrayType.name.startsWith('U');
                  const recMax = 1 / (2 ** (accessor.ComponentArrayType.BYTES_PER_ELEMENT * 8 - signed) - 1);

                  for (let i = 0; i < jsonAccessor.count; ++i) {
                    for (let j = 0; j < elementWidth; ++j) {
                      let value = accessor.components[i * accessor.stride + j];
                      value = Object(math_lib["v" /* max */])(-1, value * recMax);
                      denormalizedComponents[i * elementWidth + j] = value;
                    }
                  }

                  if (this.keepResources) {
                    denormalizedComponents.resource = {
                      normalizedType: accessor.ComponentArrayType
                    };
                  }
                } else {
                  denormalizedComponents = accessor.components.slice();

                  if (this.keepResources) {
                    denormalizedComponents.resource = {};
                  }
                }

                track.view = denormalizedComponents;
              })()]);
            }
          }.call(this));
          animation.needsUpdate = true;
        };

        maps.animationToAnimations.get(jsonAnimation).set(jsonScene, animation);
        output.animations.push(animation);
      }
    }
  }

  _buildSkeletonsAndBones() {
    const invBindMatTmp = new math_lib["g" /* HomogeneousMatrix3 */]();
    const json = this.json,
          maps = this.maps,
          output = this.output;

    for (const jsonScene of json.scenes) {
      const scene = maps.sceneToScene.get(jsonScene);

      for (const jsonSkin of json.skins) {
        const rootGltfNode = json.nodes[jsonSkin.skeleton];
        const rootNode = maps.nodeToNodes.get(rootGltfNode).get(jsonScene);

        const _rootNode$getComponen = rootNode.getComponents([core_lib["jb" /* Transform */]]),
              _rootNode$getComponen2 = _slicedToArray(_rootNode$getComponen, 1),
              rootTransform = _rootNode$getComponen2[0];

        const skeleton = new core_lib["bb" /* Skeleton */](jsonSkin.name, rootTransform, jsonSkin.joints.length);
        const skeletonIndex = scene.addSkeleton(skeleton);

        for (const _ref61 of jsonSkin.joints.entries()) {
          var _ref62 = _slicedToArray(_ref61, 2);

          const i = _ref62[0];
          const nodeIndex = _ref62[1];
          const jsonNode = json.nodes[nodeIndex];
          const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);
          const bone = new core_lib["e" /* Bone */](skeletonIndex, i);
          node.attach(bone);

          const _node$getComponents7 = node.getComponents([core_lib["jb" /* Transform */]]),
                _node$getComponents8 = _slicedToArray(_node$getComponents7, 1),
                transform = _node$getComponents8[0];

          if (transform === null) {
            node.attach(new core_lib["jb" /* Transform */]());
          }

          output.bones.push(bone);
        }

        const jsonInvBindMatsAccessor = json.accessors[jsonSkin.inverseBindMatrices];
        const invBindMatsAccessor = maps.accessorToAccessor.get(jsonInvBindMatsAccessor);
        skeleton._loadCount = 0;

        skeleton._actuallyLoad = async () => {
          if (invBindMatsAccessor.unloaded) {
            const loading = invBindMatsAccessor.loading;
            await invBindMatsAccessor.load();

            if (loading) {
              invBindMatsAccessor.unload();
            }
          }

          for (const _ref63 of jsonSkin.joints.entries()) {
            var _ref64 = _slicedToArray(_ref63, 2);

            const i = _ref64[0];
            const nodeIndex = _ref64[1];
            const jsonNode = json.nodes[nodeIndex];
            const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);

            const _node$getComponents9 = node.getComponents([core_lib["e" /* Bone */]]),
                  _node$getComponents10 = _slicedToArray(_node$getComponents9, 1),
                  bone = _node$getComponents10[0];

            invBindMatTmp.fromArrayAt(invBindMatsAccessor.stride * i, invBindMatsAccessor.components);
            bone.inverseBindMatrix.fromAffine(invBindMatTmp);
          }
        };

        maps.skinToSkeletons.get(jsonSkin).set(jsonScene, skeleton);
        output.skeletons.push(skeleton);
      }

      const walk = jsonNode => {
        jsonNode = json.nodes[jsonNode];
        const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);

        if (jsonNode.skin !== undefined) {
          const jsonSkin = json.skins[jsonNode.skin];
          const skeleton = maps.skinToSkeletons.get(jsonSkin).get(jsonScene);

          const _node$getComponents11 = node.getComponents([core_lib["F" /* Mesh */]]),
                _node$getComponents12 = _slicedToArray(_node$getComponents11, 1),
                mesh = _node$getComponents12[0];

          if (mesh !== null) {
            mesh.skeleton = skeleton;
          }
        }

        jsonNode.children.forEach(walk);
      };

      jsonScene.nodes.forEach(walk);
    }
  }

  _buildTransforms() {
    const json = this.json,
          maps = this.maps;
    const components = [core_lib["jb" /* Transform */]];
    const result = [null];

    for (const jsonScene of json.scenes) {
      const walk = (jsonNode, parentAnimated) => {
        jsonNode = json.nodes[jsonNode]; // eslint-disable-line

        const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);

        let _node$getComponents13 = node.getComponents(components, result),
            _node$getComponents14 = _slicedToArray(_node$getComponents13, 1),
            transform = _node$getComponents14[0];

        if (maps.nodesWithAnimation.has(jsonNode)) parentAnimated = true; // eslint-disable-line

        if (transform !== null) {
          transform.position.fromArray(jsonNode.translation);
          transform.scale.fromArray(jsonNode.scale);
          transform.orientation.fromArray(jsonNode.rotation);
          transform.state = core_lib["jb" /* Transform */].StateMask.UPDATE_LOCAL;
        } else if (parentAnimated) {
          transform = new core_lib["jb" /* Transform */]({
            position: new math_lib["n" /* Vector3 */]().fromArray(jsonNode.translation),
            scale: new math_lib["n" /* Vector3 */]().fromArray(jsonNode.scale),
            orientation: new math_lib["i" /* Quaternion */]().fromArray(jsonNode.rotation)
          });
          transform.state = core_lib["jb" /* Transform */].StateMask.UPDATE_LOCAL;
          node.attach(transform);
        }

        for (const jsonChild of jsonNode.children) {
          walk(jsonChild, parentAnimated);
        }
      };

      for (const jsonNode of jsonScene.nodes) {
        walk(jsonNode, maps.nodesWithAnimation.has(jsonNode));
      }
    }
  }

  _preEmplaceInstancedData() {
    const json = this.json,
          maps = this.maps;
    const center = new math_lib["n" /* Vector3 */]();
    const worldBoundingBox = new math_lib["e" /* Box */]();
    const splitTransform = new math_lib["d" /* AffineSplitTransform3 */]();
    const worldMatrix = new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0);
    const localMatrix = new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0);
    const components = [core_lib["jb" /* Transform */], core_lib["F" /* Mesh */]];
    const result = [null, null];

    for (const jsonScene of json.scenes) {
      const scene = maps.sceneToScene.get(jsonScene);
      const instanceDataManager = scene.instanceDataManager,
            _instanceKeys = scene._instanceKeys,
            spatialIndex = scene.spatialIndex;

      const walk = (jsonNode, parentWorld) => {
        jsonNode = json.nodes[jsonNode]; // eslint-disable-line

        splitTransform.translation.fromArray(jsonNode.translation);
        splitTransform.scaling.fromArray(jsonNode.scale);
        splitTransform.quaternion.fromArray(jsonNode.rotation);
        localMatrix.fromSplitTransform(splitTransform);
        worldMatrix.copy(localMatrix).multiply(parentWorld);
        const node = maps.nodeToNodes.get(jsonNode).get(jsonScene);

        const _node$getComponents15 = node.getComponents(components, result),
              _node$getComponents16 = _slicedToArray(_node$getComponents15, 2),
              transform = _node$getComponents16[0],
              mesh = _node$getComponents16[1];

        if (mesh !== null && transform === null) {
          const subMeshCount = mesh.subMeshCount;

          for (let i = 0; i < subMeshCount; i++) {
            const subMesh = mesh.getSubMesh(i);

            if (false) {}

            instanceDataManager.addInstance(subMesh);
            instanceDataManager.setInstanceVisibility(subMesh, true, true);

            if (false) {}

            const instanceId = subMesh.instanceId,
                  instanceIndex = subMesh.instanceIndex,
                  geometry = subMesh.geometry,
                  id = subMesh.id;
            const boundingBox = geometry.boundingBox;

            const _instanceDataManager$ = instanceDataManager.getInstanceRenderable(instanceId),
                  batchIdx = _instanceDataManager$.batchIdx;

            const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

            if (false) {}

            const instanceKey = {
              node,
              renderable: subMesh,
              batchSetIdx: 0,
              globalIndex
            };

            _instanceKeys.set(subMesh, instanceKey);

            worldBoundingBox.copy(boundingBox).applyAffineMatrix(worldMatrix);
            spatialIndex.insert(instanceKey, worldBoundingBox);
            worldBoundingBox.centerPaste(center);
            instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
            instanceDataManager.storeRenderableIdentifier(globalIndex, id);
            instanceDataManager.storeCenter(center, globalIndex);

            if (subMesh.unloaded) {
              const _instancedBatches = instanceDataManager._instancedBatches;

              _instancedBatches.disableBatch(batchIdx);
            }
          }
        }

        if (jsonNode.children.length > 0) {
          const parentMatrix = new math_lib["b" /* AffineMatrix3 */]();
          parentMatrix.copy(worldMatrix);

          for (const jsonChild of jsonNode.children) {
            walk(jsonChild, parentMatrix);
          }
        }
      };

      for (const jsonNode of jsonScene.nodes) {
        walk(jsonNode, new math_lib["b" /* AffineMatrix3 */]().fromNumber(1.0));
      }
    }
  }

  _enableBatches() {
    const json = this.json,
          maps = this.maps,
          unmovableMeshes = this.unmovableMeshes;
    if (!unmovableMeshes) return;

    for (const jsonScene of json.scenes) {
      const scene = maps.sceneToScene.get(jsonScene);
      const instanceDataManager = scene.instanceDataManager;
      const _instancedBatches = instanceDataManager._instancedBatches;

      _instancedBatches.enableAll();
    }
  }

  _build() {
    // order is important
    this._buildBuffers();

    this._buildBufferViews();

    this._buildAccessors();

    this._buildVertexBufferViewsAndAttributes();

    this._buildGeometries();

    this._buildTextureLevelDatas();

    this._buildTextures();

    this._buildMaterials();

    this._buildMeshes();

    this._buildCameras();

    this._buildNodesAndScenes();

    this._buildAnimations();

    this._buildSkeletonsAndBones();

    this._buildTransforms();

    this._preEmplaceInstancedData();
  }

  async _applyExtensions() {
    for (const extension of this._extensions) {
      if (extension.preImport !== undefined) {
        await extension.preImport(this);
      }
    }
  }

  async _preImport(url) {
    this._reset();

    this.url = url;
    const bytes = await this.loader.load(this.url, {
      type: Uint8Array
    });

    if (this._isBinary(bytes)) {
      this._parseBinary(bytes);
    } else {
      this._parse(bytes);
    }

    this._build();

    await this._applyExtensions();
  }
  /**
   * @function module:@wgetemp/gltf-importer.GLTFImporter#preImport
   * @summary Import glTF or GLB file only loading bare essentials, skipping
   * heavy resources like meshes and textures.
   * @desc This is useful if you want to intelligently stream such resources using
   * {@link module:@wgetemp/engine-core.DisposableUsageCounter#load} and
   * {@link module:@wgetemp/engine-core.DisposableUsageCounter#unload} or
   * simply to observe
   * {@link module:@wgetemp/gltf-importer.GLTFImporter#estimatedVertexAttributesSize}
   * and {@link module:@wgetemp/gltf-importer.GLTFImporter#estimatedVertexIndicesSize}
   * to decide how much memory to allocate, followed by a call to
   * {@link module:@wgetemp/gltf-importer.GLTFImporter#import} with the
   * same url to load everything at once.
   *
   * Result can be found in
   * {@link module:@wgetemp/gltf-importer.GLTFImporter#output}.
   * @param {string} url Url to import from. As long as the asset contains
   * no external references, it can be an object or data url.
   * @async
   */


  async preImport(url) {
    await this._preImport(url);
    await Promise.all(Array.from(function* () {
      yield* this.output.skeletons;
    }.call(this), loadable => {
      return loadable.load();
    }));
    this._preImported = true;
  }

  estimateBufferSizes() {
    console.warn('GLTFImporter#estimateBufferSizes is deprecated, use ' + 'GLTFImporter#estimatedVertexAttributesSize and ' + 'GLTFImporter#estimatedVertexIndicesSize instead.');
    return {
      attributeBufferSize: this.estimatedVertexAttributesSize,
      indexBufferSize: this.estimatedVertexIndicesSize
    };
  }
  /**
   * @function module:@wgetemp/gltf-importer.GLTFImporter#import
   * @summary Import glTF or GLB file.
   * @param {string} url Url to import from. As long as the asset contains
   * no external references, it can be an object or data url.
   * @returns {module:@wgetemp/gltf-importer.GLTFImporter.Output}
   * {@link module:@wgetemp/gltf-importer.GLTFImporter#output}
   * @async
   */


  async import(url) {
    if (!this._preImported) {
      await this._preImport(url);
    }

    await Promise.all(Array.from(function* () {
      yield* this.output.meshes;
      yield* this.output.animations;

      if (!this._preImported) {
        yield* this.output.skeletons;
      }
    }.call(this), loadable => {
      return loadable.load();
    }));

    this._enableBatches();

    if (!this._preImported) {
      this.clearCache();
    }

    this._preImported = false;
    return this.output;
  }
  /**
   * @function module:@wgetemp/gltf-importer.GLTFImporter#clearCache
   * @summary Clear external resource cache.
   * @desc GLTFImporter caches all external resources, so that multiple
   * calls to {@link module:@wgetemp/engine-core.DisposableUsageCounter#load}
   * on multiple objects untimately referring to same resource do no incur
   * redundant network/disk transfers.
   *
   * This function allows you to clear this cache. You  probably want to call
   * it once you have loaded everything you want at a given moment.
   */


  clearCache() {
    for (const loadable of function* () {
      yield* this.maps.uriToExternalResource.values();
      yield* this.maps.accessorToAccessor.values();
      yield* this.maps.bufferViewToBufferView.values();
      yield* this.maps.bufferToBuffer.values();
    }.call(this)) {
      if (!loadable.unloaded) {
        loadable.unload();
      }
    }
  }

}

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ KHR_materials_unlit; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ KHR_texture_transform; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ WG_dielectric_specular; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ WG_material_depth_properties; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ WG_emissive_map_luminance; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ WG_image_radiance_hdr; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ WG_sampler_projection; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ WG_scene_environment; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ WG_material_shadow_properties; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ WG_clear_coat; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ defaultExtensions; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ resolveExtensionDependencies; });

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var lib = __webpack_require__(1);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var core_lib = __webpack_require__(0);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/KHR_materials_unlit.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



/**
 * @const module:@wgetemp/gltf-extensions.KHR_materials_unlit
 * @summary Implemetation of [KHR_materials_unlit]{@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit}
 * glTF extension.
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */

const KHR_materials_unlit = {
  preImport(importer) {
    const json = importer.json,
          output = importer.output,
          maps = importer.maps,
          materialFactory = importer.materialFactory;
    const updates = new Map();

    for (const jsonMaterial of json.materials) {
      const ext = jsonMaterial.extensions.KHR_materials_unlit;

      if (ext === undefined) {
        continue;
      }

      const pbrMaterial = maps.materialToMaterial.get(jsonMaterial);
      const unlitMaterial = materialFactory.createUnlitMeshMaterial({
        name: pbrMaterial.name,
        alphaMode: pbrMaterial.alphaMode,
        alphaCutoff: pbrMaterial.alphaCutoff,
        opacity: pbrMaterial.opacity,
        cullFace: pbrMaterial.cullFace,
        color: pbrMaterial.albedo.clone()
      });
      unlitMaterial._loadCount = 0;
      unlitMaterial.depthWrite = pbrMaterial.depthWrite;
      unlitMaterial.depthTest = pbrMaterial.depthTest;

      unlitMaterial.colorMap = (({
        albedoMap
      }) => {
        if (albedoMap !== null) {
          return albedoMap.clone();
        }

        return null;
      })(pbrMaterial);

      unlitMaterial._actuallyLoad = () => {
        if (unlitMaterial.colorMap !== null) {
          const texture = unlitMaterial.colorMap.texture;

          switch (texture.format) {
            case core_lib["N" /* PixelDataFormat */].RGB:
              texture.internalFormat = core_lib["v" /* InternalFormat */].SRGB8;
              break;

            case core_lib["N" /* PixelDataFormat */].RGBA:
              texture.internalFormat = core_lib["v" /* InternalFormat */].SRGB8_ALPHA8;
              break;
          }
        }
      };

      if (pbrMaterial.extras !== undefined) {
        unlitMaterial.extras = pbrMaterial.extras;
      }

      updates.set(pbrMaterial, unlitMaterial);
      maps.materialToMaterial.set(jsonMaterial, unlitMaterial);
    }

    for (const _ref of output.materials.entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const i = _ref2[0];
      const material = _ref2[1];
      const newMaterial = updates.get(material);

      if (newMaterial === undefined) {
        continue;
      }

      output.materials[i].release();
      output.materials[i] = newMaterial;
      break;
    }

    for (const mesh of output.meshes) {
      for (const subMesh of mesh.subMeshes()) {
        const newMaterial = updates.get(subMesh.material);

        if (newMaterial === undefined) {
          continue;
        }

        subMesh.material = newMaterial;
      }
    }
  },

  export(exporter) {
    for (const _ref3 of exporter.maps.materialToMaterial) {
      var _ref4 = _slicedToArray(_ref3, 2);

      const material = _ref4[0];
      const gltfMaterial = _ref4[1];

      if (!material.isUnlitMeshMaterial) {
        continue;
      }

      let value;
      const _gltfMaterial$pbrMeta = gltfMaterial.pbrMetallicRoughness,
            mr = _gltfMaterial$pbrMeta === void 0 ? {} : _gltfMaterial$pbrMeta;

      if ((value = material.color) !== undefined) {
        if (!value.equals(new lib["k" /* RGBColor */](1, 1, 1)) || material.opacity !== 1) {
          mr.baseColorFactor = [...value.toArray([]), material.opacity];
        }
      }

      if ((value = material.colorMap) != null) {
        mr.baseColorTexture = exporter.exportTextureProperties(value);
      }

      if (Object.values(mr).filter(x => x !== undefined).length > 0) {
        gltfMaterial.pbrMetallicRoughness = mr;
      }

      exporter.useExtensions(gltfMaterial, {
        KHR_materials_unlit: {}
      });
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/KHR_texture_transform.js
function KHR_texture_transform_slicedToArray(arr, i) { return KHR_texture_transform_arrayWithHoles(arr) || KHR_texture_transform_iterableToArrayLimit(arr, i) || KHR_texture_transform_unsupportedIterableToArray(arr, i) || KHR_texture_transform_nonIterableRest(); }

function KHR_texture_transform_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function KHR_texture_transform_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return KHR_texture_transform_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return KHR_texture_transform_arrayLikeToArray(o, minLen); }

function KHR_texture_transform_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function KHR_texture_transform_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function KHR_texture_transform_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * @const module:@wgetemp/gltf-extensions.KHR_texture_transform
 * @summary Implemetation of [KHR_texture_transform]{@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform}
 * glTF extension.
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */

const KHR_texture_transform = {
  preImport(importer) {
    const json = importer.json,
          output = importer.output,
          maps = importer.maps;

    for (const jsonMaterial of json.materials) {
      const material = maps.materialToMaterial.get(jsonMaterial);

      for (const _ref of [// TODO: replace with material.getTextures()
      [jsonMaterial.pbrMetallicRoughness.baseColorTexture, material.albedoMap || material.colorMap], [jsonMaterial.pbrMetallicRoughness.metallicRoughnessTexture, material.metalnessRoughnessMap], [jsonMaterial.normalTexture, material.normalMap], [jsonMaterial.occlusionTexture, material.ambientOcclusionMap], [jsonMaterial.emissiveTexture, material.emissiveMap]]) {
        var _ref2 = KHR_texture_transform_slicedToArray(_ref, 2);

        const jsonTextureInfo = _ref2[0];
        const textureProperties = _ref2[1];

        if (jsonTextureInfo === undefined || textureProperties == null) {
          continue;
        }

        const ext = jsonTextureInfo.extensions.KHR_texture_transform;

        if (ext === undefined) {
          continue;
        }

        const texCoord = ext.texCoord,
              _ext$scale = ext.scale,
              scale = _ext$scale === void 0 ? [1, 1] : _ext$scale,
              _ext$rotation = ext.rotation,
              rotation = _ext$rotation === void 0 ? 0 : _ext$rotation,
              _ext$offset = ext.offset,
              offset = _ext$offset === void 0 ? [0, 0] : _ext$offset;

        if (texCoord !== undefined) {
          textureProperties.channel = texCoord;
        }

        textureProperties.transform.fromScaling(new lib["m" /* Vector2 */]().fromArray(scale)).rotate(
        /* NO, there should be NO minus here */
        rotation).translate(new lib["m" /* Vector2 */]().fromArray(offset));
      }
    }
  },

  export(exporter) {
    const splitTransform = new lib["c" /* AffineSplitTransform2 */]();

    for (const _ref3 of exporter.maps.materialToMaterial) {
      var _ref4 = KHR_texture_transform_slicedToArray(_ref3, 2);

      const material = _ref4[0];
      const gltfMaterial = _ref4[1];
      const _gltfMaterial$pbrMeta = gltfMaterial.pbrMetallicRoughness,
            mr = _gltfMaterial$pbrMeta === void 0 ? {} : _gltfMaterial$pbrMeta;

      for (const _ref5 of [[material.albedoMap || material.colorMap, mr.baseColorTexture], [material.metalnessRoughnessMap, mr.metallicRoughnessTexture], [material.normalMap, gltfMaterial.normalTexture], [material.ambientOcclusionMap, gltfMaterial.occlusionTexture], [material.emissiveMap, gltfMaterial.emissiveTexture]]) {
        var _ref6 = KHR_texture_transform_slicedToArray(_ref5, 2);

        const textureProperties = _ref6[0];
        const gltfTextureInfo = _ref6[1];

        if (textureProperties == null || gltfTextureInfo === undefined) {
          continue;
        }

        const _splitTransform$fromM = splitTransform.fromMatrix(textureProperties.transform),
              scaling = _splitTransform$fromM.scaling,
              rotationAngle = _splitTransform$fromM.complex.rotationAngle,
              translation = _splitTransform$fromM.translation;

        const ext = {};

        if (!scaling.equals(new lib["m" /* Vector2 */](1, 1))) {
          ext.scale = scaling.toArray([]);
        }

        if (rotationAngle !== 0) {
          ext.rotation =
          /* NO, there should be NO minus here */
          rotationAngle;
        }

        if (!translation.equals(new lib["m" /* Vector2 */](0, 0))) {
          ext.offset = translation.toArray([]);
        }

        if (Object.values(ext).filter(x => x !== undefined).length > 0) {
          exporter.useExtensions(gltfTextureInfo, {
            KHR_texture_transform: ext
          });
        }
      }
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_dielectric_specular.js
function WG_dielectric_specular_slicedToArray(arr, i) { return WG_dielectric_specular_arrayWithHoles(arr) || WG_dielectric_specular_iterableToArrayLimit(arr, i) || WG_dielectric_specular_unsupportedIterableToArray(arr, i) || WG_dielectric_specular_nonIterableRest(); }

function WG_dielectric_specular_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_dielectric_specular_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_dielectric_specular_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_dielectric_specular_arrayLikeToArray(o, minLen); }

function WG_dielectric_specular_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_dielectric_specular_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_dielectric_specular_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @const module:@wgetemp/gltf-extensions.WG_dielectric_specular
 * @summary Provides serialization for {@link module:@wgetemp/webgl-renderer.PbrMeshMaterial#normalIncidenceFresnel}.
 * @desc Extends glTF [pbrMetallicRoughness]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-pbrmetallicroughness}
 * with the following:
 *
 *     "WG_dielectric_specular": {
 *         "factor": 0.42, // default is 0.05
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */
const WG_dielectric_specular = {
  // XXX: untested
  preImport(importer) {
    const json = importer.json,
          output = importer.output,
          maps = importer.maps,
          materialFactory = importer.materialFactory;

    for (const jsonMaterial of json.materials) {
      const ext = jsonMaterial.pbrMetallicRoughness.extensions.WG_dielectric_specular;

      if (ext === undefined) {
        continue;
      }

      const factor = ext.factor;

      if (factor === undefined) {
        continue;
      }

      const material = maps.materialToMaterial.get(jsonMaterial);

      if (material.normalIncidenceFresnel === undefined) {
        continue;
      }

      material.normalIncidenceFresnel = factor;
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.materialToMaterial) {
      var _ref2 = WG_dielectric_specular_slicedToArray(_ref, 2);

      const material = _ref2[0];
      const gltfMaterial = _ref2[1];
      const factor = material.normalIncidenceFresnel;

      if (factor === undefined || factor === 0.05) {
        continue;
      }

      let mr = gltfMaterial.pbrMetallicRoughness;

      if (mr === undefined) {
        gltfMaterial.pbrMetallicRoughness = mr = {};
      }

      exporter.useExtensions(mr, {
        WG_dielectric_specular: {
          factor
        }
      });
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_material_depth_properties.js
function WG_material_depth_properties_slicedToArray(arr, i) { return WG_material_depth_properties_arrayWithHoles(arr) || WG_material_depth_properties_iterableToArrayLimit(arr, i) || WG_material_depth_properties_unsupportedIterableToArray(arr, i) || WG_material_depth_properties_nonIterableRest(); }

function WG_material_depth_properties_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_material_depth_properties_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_material_depth_properties_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_material_depth_properties_arrayLikeToArray(o, minLen); }

function WG_material_depth_properties_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_material_depth_properties_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_material_depth_properties_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @const module:@wgetemp/gltf-extensions.WG_material_depth_properties
 * @summary Provides serialization for {@link module:@wgetemp/engine-core.Material#depthTest}
 * and {@link module:@wgetemp/engine-core.Material#depthWrite}.
 * @desc Extends glTF [material]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-material}
 * with the following:
 *
 *     "WG_material_depth_properties": {
 *         "test": false, // default is true
 *         "write": false, // default is true
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */
const WG_material_depth_properties = {
  // XXX: untested
  preImport(importer) {
    const json = importer.json,
          maps = importer.maps,
          materialFactory = importer.materialFactory;

    for (const jsonMaterial of json.materials) {
      const ext = jsonMaterial.extensions.WG_material_depth_properties;

      if (ext === undefined) {
        continue;
      }

      const test = ext.test,
            write = ext.write;
      const material = maps.materialToMaterial.get(jsonMaterial);

      if (test !== undefined) {
        material.depthTest = test;
      }

      if (write !== undefined) {
        material.depthWrite = write;
      }
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.materialToMaterial) {
      var _ref2 = WG_material_depth_properties_slicedToArray(_ref, 2);

      const material = _ref2[0];
      const gltfMaterial = _ref2[1];
      const depthTest = material.depthTest,
            depthWrite = material.depthWrite;

      if (depthTest && depthWrite) {
        continue;
      }

      exporter.useExtensions(gltfMaterial, {
        WG_material_depth_properties: {
          test: depthTest ? undefined : false,
          write: depthWrite ? undefined : false
        }
      });
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_emissive_map_luminance.js
function WG_emissive_map_luminance_slicedToArray(arr, i) { return WG_emissive_map_luminance_arrayWithHoles(arr) || WG_emissive_map_luminance_iterableToArrayLimit(arr, i) || WG_emissive_map_luminance_unsupportedIterableToArray(arr, i) || WG_emissive_map_luminance_nonIterableRest(); }

function WG_emissive_map_luminance_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_emissive_map_luminance_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_emissive_map_luminance_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_emissive_map_luminance_arrayLikeToArray(o, minLen); }

function WG_emissive_map_luminance_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_emissive_map_luminance_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_emissive_map_luminance_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * @const module:@wgetemp/gltf-extensions.WG_emissive_map_luminance
 * @summary Provides serialization for {@link module:@wgetemp/engine-core.Material.EmissiveMapProperties#luminance}.
 * @desc Extends glTF [textureInfo]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-textureinfo}
 * with the following:
 *
 *     "WG_emissive_map_luminance": {
 *         "luminance": 42,
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */

const WG_emissive_map_luminance = {
  preImport(importer) {
    const json = importer.json,
          maps = importer.maps;

    for (const jsonMaterial of json.materials) {
      const emissiveTexture = jsonMaterial.emissiveTexture;

      if (emissiveTexture === undefined) {
        continue;
      }

      const ext = emissiveTexture.extensions.WG_emissive_map_luminance;

      if (ext === undefined) {
        continue;
      }

      const luminance = ext.luminance;
      const material = maps.materialToMaterial.get(jsonMaterial);
      const emissiveMap = material.emissiveMap;

      if (!(emissiveMap instanceof core_lib["D" /* Material */].EmissiveMapProperties)) {
        continue;
      }

      emissiveMap.luminance = luminance;
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.materialToMaterial) {
      var _ref2 = WG_emissive_map_luminance_slicedToArray(_ref, 2);

      const emissiveMap = _ref2[0].emissiveMap;
      const gltfEmissiveTextureInfo = _ref2[1].emissiveTexture;

      if (!(emissiveMap instanceof core_lib["D" /* Material */].EmissiveMapProperties)) {
        continue;
      }

      exporter.useExtensions(gltfEmissiveTextureInfo, {
        WG_emissive_map_luminance: {
          luminance: emissiveMap.luminance
        }
      });
    }
  }

};
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_image_radiance_hdr/RGBELoader.js
var RGBELoader = __webpack_require__(88);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_image_radiance_hdr/index.js
function WG_image_radiance_hdr_slicedToArray(arr, i) { return WG_image_radiance_hdr_arrayWithHoles(arr) || WG_image_radiance_hdr_iterableToArrayLimit(arr, i) || WG_image_radiance_hdr_unsupportedIterableToArray(arr, i) || WG_image_radiance_hdr_nonIterableRest(); }

function WG_image_radiance_hdr_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_image_radiance_hdr_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_image_radiance_hdr_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_image_radiance_hdr_arrayLikeToArray(o, minLen); }

function WG_image_radiance_hdr_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_image_radiance_hdr_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_image_radiance_hdr_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * @const module:@wgetemp/gltf-extensions.WG_image_radiance_hdr
 * @summary Provides serialization for [RGBE]{@link https://en.wikipedia.org/wiki/RGBE_image_format} HDR images
 * and {@link module:@wgetemp/engine-core.Material.EnvironmentMapProperties#luminance}.
 * @desc Extends glTF [image]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-image}
 * with the following:
 *
 *     "WG_image_radiance_hdr": {
 *         "name": "my-rgbe-image", // optional
 *         "uri": "path/to/image.hdr", // optional
 *         "mimeType": "image/vnd.radiance", // optional,
 *         "bufferView": 42, // optional,
 *         "luminance": 42.0,
 *     },
 *
 * As with glTF [image]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-image},
 * either uri or bufferView+mimeType must be specified.
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */

const WG_image_radiance_hdr = {
  luminance: Symbol('WG_image_radiance_hdr.luminance'),
  maxEnvLuminance: Symbol('WG_image_radiance_hdr.maxEnvLuminance'),
  resource: Symbol('WG_image_radiance_hdr.resource'),

  preImport(importer) {
    const updatedLevelDatas = new Set();
    const json = importer.json,
          maps = importer.maps,
          output = importer.output;

    for (const jsonImage of json.images) {
      const ext = jsonImage.extensions.WG_image_radiance_hdr;

      if (ext === undefined) {
        continue;
      }

      const textureLevelData = maps.imageToTextureLevelData.get(jsonImage);
      const actuallyLoadOriginal = textureLevelData._actuallyLoad;

      textureLevelData._actuallyLoad = async () => {
        if (importer.keepResources) {
          await actuallyLoadOriginal();
        }

        let bytes;

        if (ext.uri !== undefined) {
          bytes = await importer.loader.load(ext.uri, {
            baseUrl: importer.url,
            type: Uint8Array
          });
        } else {
          const jsonBufferView = json.bufferViews[ext.bufferView];
          const bufferView = maps.bufferViewToBufferView.get(jsonBufferView);

          if (bufferView.unloaded) {
            await bufferView.load();
          }

          bytes = bufferView.bytes;
        }

        const _await$RGBELoader$ass = await new RGBELoader["a" /* RGBELoader */]({
          name: ext.name || jsonImage.name,
          src: bytes,
          luminance: ext.luminance
        }).assets,
              customImageData = _await$RGBELoader$ass.customImageData,
              maxEnvLuminance = _await$RGBELoader$ass.maxEnvLuminance;

        customImageData[this.luminance] = ext.luminance;
        customImageData[this.maxEnvLuminance] = maxEnvLuminance;

        if (importer.keepResources) {
          customImageData.resource = Object.assign(textureLevelData.data.resource, {
            [this.resource]: {
              name: ext.name || textureLevelData.data.resource.name,
              bytes,
              mimeType: 'image/vnd.radiance'
            }
          });

          if (ext.uri && !ext.uri.startsWith('data:')) {
            customImageData.resource[this.resource].path = ext.uri;
          }
        }

        textureLevelData.data = customImageData;
        textureLevelData.width = customImageData.width;
        textureLevelData.height = customImageData.height;
      };

      updatedLevelDatas.add(textureLevelData);
    }

    for (const texture of output.textures) {
      const _texture$_levelsData = WG_image_radiance_hdr_slicedToArray(texture._levelsData, 1),
            textureLevelData = _texture$_levelsData[0];

      if (!updatedLevelDatas.has(textureLevelData)) {
        continue;
      }

      texture._actuallyLoad = () => {
        const customImageData = textureLevelData.data;
        texture.width = customImageData.width;
        texture.height = customImageData.height;
        texture.depth = customImageData.depth;
        texture.componentType = customImageData.componentType;
        texture.format = customImageData.format;
        texture.internalFormat = customImageData.internalFormat;
        texture._needsUpdate = true;
      };
    }
  },

  export(exporter) {
    for (const mesh of exporter.maps.meshToMesh.keys()) {
      for (const _ref of mesh.subMeshes()) {
        const environmentMap = _ref.material.environmentMap;

        if (environmentMap == null) {
          continue;
        }

        const _exporter$exportTextu = exporter.exportTextureProperties(environmentMap),
              gltfImage = _exporter$exportTextu.index.source;

        const _environmentMap$textu = WG_image_radiance_hdr_slicedToArray(environmentMap.texture._levelsData, 1),
              image = _environmentMap$textu[0].data;

        const resource = image.resource[this.resource];

        if (resource === undefined) {
          continue;
        }

        const ext = {
          name: resource.name,
          uri: resource.path,
          bufferView: exporter.makeBufferView({
            [exporter.bytes]: resource.bytes
          }),
          mimeType: resource.mimeType,
          luminance: environmentMap.luminance
        };
        exporter.fixNameAndUri(ext, 'images/unnamed', '.hdr');
        exporter.resources.add(ext);
        exporter.useExtensions(gltfImage, {
          WG_image_radiance_hdr: ext
        });
      }
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_sampler_projection.js
function WG_sampler_projection_slicedToArray(arr, i) { return WG_sampler_projection_arrayWithHoles(arr) || WG_sampler_projection_iterableToArrayLimit(arr, i) || WG_sampler_projection_unsupportedIterableToArray(arr, i) || WG_sampler_projection_nonIterableRest(); }

function WG_sampler_projection_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_sampler_projection_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_sampler_projection_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_sampler_projection_arrayLikeToArray(o, minLen); }

function WG_sampler_projection_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_sampler_projection_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_sampler_projection_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @const module:@wgetemp/gltf-extensions.WG_sampler_projection
 * @summary Provides the ability to specify [sampler]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler}'s
 * projection type. Currently only equirectangular projection is defined.
 * @desc Extends glTF [sampler]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler}
 * with the following:
 *
 *     "WG_sampler_projection": {
 *         "type": "equirectangular",
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */
const WG_sampler_projection = {
  type: Symbol('WG_sampler_projection.type'),

  preImport(importer) {
    const json = importer.json,
          maps = importer.maps,
          output = importer.output;

    for (const jsonSampler of json.samplers) {
      const ext = jsonSampler.extensions.WG_sampler_projection;

      if (ext === undefined) {
        continue;
      }

      switch (ext.type) {
        case 'equirectangular':
          break;

        default:
          console.warn(`unknown WG_sampler_projection.type: ${ext.type},` + ' sampler extension ignored');
          continue;
      }

      for (const texture of maps.samplerToTextures.get(jsonSampler)) {
        texture[this.type] = ext.type;
      }
    }
  },

  export(exporter) {
    for (const mesh of exporter.maps.meshToMesh.keys()) {
      for (const _ref of mesh.subMeshes()) {
        const environmentMap = _ref.material.environmentMap;

        if (environmentMap == null) {
          continue;
        }

        exporter.exportTextureProperties(environmentMap);
      }
    }

    for (const _ref2 of exporter.maps.textureToTexture) {
      var _ref3 = WG_sampler_projection_slicedToArray(_ref2, 2);

      const texture = _ref3[0];
      const gltfTexture = _ref3[1];
      const projectionType = texture[this.type];

      if (projectionType === undefined) {
        continue;
      }

      let gltfSampler = gltfTexture.sampler;

      if (gltfSampler === undefined) {
        gltfTexture.sampler = gltfSampler = {
          [exporter.destination]: [exporter.gltf, 'samplers']
        };
      }

      exporter.useExtensions(gltfSampler, {
        WG_sampler_projection: {
          type: projectionType
        }
      });
    }
  }

};
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/index.js + 8 modules
var src = __webpack_require__(29);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_scene_environment.js
function WG_scene_environment_slicedToArray(arr, i) { return WG_scene_environment_arrayWithHoles(arr) || WG_scene_environment_iterableToArrayLimit(arr, i) || WG_scene_environment_unsupportedIterableToArray(arr, i) || WG_scene_environment_nonIterableRest(); }

function WG_scene_environment_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_scene_environment_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_scene_environment_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_scene_environment_arrayLikeToArray(o, minLen); }

function WG_scene_environment_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_scene_environment_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_scene_environment_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



 // eslint-disable-line

 // eslint-disable-line

function createSkyBoxGeometry({
  attributeMemoryManager,
  indexMemoryManager,
  vertexHardwareBuffer,
  indexHardwareBuffer
}) {
  const mesh = Object(src["a" /* createBoxMesh */])({
    name: 'environment',
    vertexStaging: attributeMemoryManager,
    elementStaging: indexMemoryManager,
    vertexHardwareBuffer,
    indexHardwareBuffer,
    material: null
  });
  return mesh.getSubMesh(0).geometry;
}
/**
 * @const module:@wgetemp/gltf-extensions.WG_scene_environment
 * @summary Allows to specify scene environment map. Depends on {@link module:@wgetemp/gltf-extensions.WG_sampler_projection}.
 * @desc Extends glTF [scene]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene}
 * with the following:
 *
 *     "WG_scene_environment": {
 *         "texture": {
 *             "index": 42,
 *         },
 *     },
 *
 * `texture` is essentialy a [textureInfo]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-textureinfo} object,
 * Which must refer to a texture with equirectangular sampler, as specified via {@link module:@wgetemp/gltf-extensions.WG_sampler_projection} extension.
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */


const WG_scene_environment = {
  //eslint-disable-line
  requires: ['WG_sampler_projection'],
  after: ['WG_image_radiance_hdr'],

  preImport(importer) {
    const json = importer.json,
          maps = importer.maps,
          output = importer.output;

    for (const jsonScene of json.scenes) {
      const ext = jsonScene.extensions.WG_scene_environment;

      if (ext === undefined) {
        continue;
      }

      const scene = maps.sceneToScene.get(jsonScene);
      const jsonTexture = json.textures[ext.texture.index];
      const texture = maps.textureToTexture.get(jsonTexture);

      switch (texture[WG_sampler_projection.type]) {
        case 'equirectangular':
          break;

        default:
          console.warn('texture targeted by WG_scene_environment.texture.index' + ` has unknown projection type: ${texture.projectionType}, extension ignored`);
          continue;
      }

      const mapProperties = new core_lib["D" /* Material */].EnvironmentMapProperties(1, 1, texture);
      const material = importer.materialFactory.createEnvironmentMaterial({
        name: 'environment'
      });
      material._loadCount = 0;
      material.environmentMap = mapProperties;

      material._actuallyLoad = () => {
        const _texture$_levelsData$ = texture._levelsData[0].data,
              _texture$_levelsData$2 = _texture$_levelsData$ === void 0 ? {} : _texture$_levelsData$,
              luminance = _texture$_levelsData$2[WG_image_radiance_hdr.luminance],
              maxEnvLuminance = _texture$_levelsData$2[WG_image_radiance_hdr.maxEnvLuminance];

        if (luminance === undefined) {
          console.warn('texture targeted by WG_scene_environment.texture.index' + ' targets an image that has no .luminance property, extension ignored');
          return;
        }

        if (maxEnvLuminance === undefined) {
          console.warn('texture targeted by WG_scene_environment.texture.index' + ' targets an image that has no .maxEnvLuminance property, extension ignored');
          return;
        }

        mapProperties.luminance = luminance;
        mapProperties.maxEnvLuminance = maxEnvLuminance;
      };

      output.materials.push(material);
      const subMesh = new core_lib["fb" /* SubMesh */]({
        name: 'environment',
        geometry: null,
        material
      });
      subMesh.renderQueueGroup = core_lib["R" /* RenderQueueGroup */].ENV_EARLY;
      subMesh._loaded = false;
      importer.estimatedVertexAttributesSize += 6 * // face count
      4 * ( // vertices per face
      3 + // floats per position
      3 + // floats per normal
      2 // floats per texcoord
      ) * 4; // bytes per float

      importer.estimatedVertexIndicesSize += 6 * // face count
      2 * // triangles per face
      3 * // indices per triangle
      1; // bytes per index

      const mesh = new core_lib["F" /* Mesh */]({
        name: 'environment'
      });
      mesh.addSubMesh(subMesh);
      mesh._loadCount = 0;

      mesh._actuallyLoad = () => {
        if (subMesh.geometry) {
          subMesh.geometry.release();
        }

        subMesh.geometry = createSkyBoxGeometry({
          attributeMemoryManager: importer.attributeMemoryManager,
          indexMemoryManager: importer.indexMemoryManager,
          vertexHardwareBuffer: importer.vertexHardwareBuffer,
          indexHardwareBuffer: importer.indexHardwareBuffer
        });
      };

      output.meshes.push(mesh);
      const visibility = new core_lib["qb" /* Visibility */]({
        enableCulling: false
      });
      const transform = new core_lib["jb" /* Transform */]();
      const node = scene.root.createChild({
        name: 'environment'
      });
      node.attach(transform);
      node.attach(mesh);
      node.attach(visibility);
      output.nodes.push(node);
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.nodeToNode) {
      var _ref2 = WG_scene_environment_slicedToArray(_ref, 2);

      const node = _ref2[0];
      const gltfNode = _ref2[1];

      const _node$getComponents = node.getComponents([core_lib["F" /* Mesh */]]),
            _node$getComponents2 = WG_scene_environment_slicedToArray(_node$getComponents, 1),
            mesh = _node$getComponents2[0];

      if (mesh === null) {
        continue;
      }

      for (const _ref3 of mesh.subMeshes()) {
        const environmentMap = _ref3.material.environmentMap;

        if (environmentMap != null) {
          const gltfScene = exporter.maps.sceneToScene.get(node.scene);
          exporter.useExtensions(gltfScene, {
            WG_scene_environment: {
              texture: exporter.exportTextureProperties(environmentMap)
            }
          });

          if (node.parent === node.scene.root) {
            gltfScene.nodes = gltfScene.nodes.filter(gltfChild => {
              return gltfChild !== gltfNode;
            });
          } else {
            const gltfParent = exporter.maps.nodeToNode.get(node.parent);
            gltfParent.children = gltfParent.children.filter(gltfChild => {
              return gltfChild !== gltfNode;
            });
          }

          return;
        }
      }
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_material_shadow_properties.js
function WG_material_shadow_properties_slicedToArray(arr, i) { return WG_material_shadow_properties_arrayWithHoles(arr) || WG_material_shadow_properties_iterableToArrayLimit(arr, i) || WG_material_shadow_properties_unsupportedIterableToArray(arr, i) || WG_material_shadow_properties_nonIterableRest(); }

function WG_material_shadow_properties_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_material_shadow_properties_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_material_shadow_properties_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_material_shadow_properties_arrayLikeToArray(o, minLen); }

function WG_material_shadow_properties_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_material_shadow_properties_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_material_shadow_properties_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @const module:@wgetemp/gltf-extensions.WG_material_shadow_properties
 * @summary Provides serialization for {@link module:@wgetemp/engine-core.Material#castShadow}
 * and {@link module:@wgetemp/engine-core.Material#receiveShadow}.
 * @desc Extends glTF [material]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-material}
 * with the following:
 *
 *     "WG_material_shadow_properties": {
 *         "cast": true, // default is false
 *         "receive": true, // default is false
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */
const WG_material_shadow_properties = {
  preImport(importer) {
    const json = importer.json,
          output = importer.output,
          maps = importer.maps,
          materialFactory = importer.materialFactory;

    for (const jsonMaterial of json.materials) {
      const ext = jsonMaterial.extensions.WG_material_shadow_properties;

      if (ext === undefined) {
        continue;
      }

      const cast = ext.cast,
            receive = ext.receive;
      const material = maps.materialToMaterial.get(jsonMaterial);

      if (cast !== undefined) {
        material.castShadow = cast;
      }

      if (receive !== undefined) {
        material.receiveShadow = receive;
      }
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.materialToMaterial) {
      var _ref2 = WG_material_shadow_properties_slicedToArray(_ref, 2);

      const material = _ref2[0];
      const gltfMaterial = _ref2[1];
      const castShadow = material.castShadow,
            receiveShadow = material.receiveShadow;

      if (!castShadow && !receiveShadow) {
        continue;
      }

      exporter.useExtensions(gltfMaterial, {
        WG_material_shadow_properties: {
          cast: castShadow ? true : undefined,
          receive: receiveShadow ? true : undefined
        }
      });
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/WG_clear_coat.js
function WG_clear_coat_slicedToArray(arr, i) { return WG_clear_coat_arrayWithHoles(arr) || WG_clear_coat_iterableToArrayLimit(arr, i) || WG_clear_coat_unsupportedIterableToArray(arr, i) || WG_clear_coat_nonIterableRest(); }

function WG_clear_coat_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function WG_clear_coat_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return WG_clear_coat_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WG_clear_coat_arrayLikeToArray(o, minLen); }

function WG_clear_coat_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function WG_clear_coat_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function WG_clear_coat_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @const module:@wgetemp/gltf-extensions.WG_clear_coat
 * @summary Provides serialization for {@link module:@wgetemp/webgl-renderer.PbrMeshMaterial#clearCoatStrength}
 * and {@link module:@wgetemp/webgl-renderer.PbrMeshMaterial#clearCoatRoughness}.
 * @desc Extends glTF [pbrMetallicRoughness]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-pbrmetallicroughness}
 * with the following:
 *
 *     "WG_clear_coat": {
 *         "strength": 1, // default is 0
 *         "roughness": 1, // default is 0
 *     },
 *
 * @type {module:@wgetemp/gltf-extensions.Extension}
 */
const WG_clear_coat = {
  preImport(importer) {
    const json = importer.json,
          output = importer.output,
          maps = importer.maps,
          materialFactory = importer.materialFactory;

    for (const jsonMaterial of json.materials) {
      const ext = jsonMaterial.pbrMetallicRoughness.extensions.WG_clear_coat;
      if (ext === undefined) continue;
      const strength = ext.strength,
            roughness = ext.roughness;
      const material = maps.materialToMaterial.get(jsonMaterial);
      if (strength !== undefined) material.clearCoatStrength = strength;
      if (roughness !== undefined) material.clearCoatRoughness = roughness;
    }
  },

  export(exporter) {
    for (const _ref of exporter.maps.materialToMaterial) {
      var _ref2 = WG_clear_coat_slicedToArray(_ref, 2);

      const material = _ref2[0];
      const gltfMaterial = _ref2[1];
      const strength = material.clearCoatStrength,
            roughness = material.clearCoatRoughness;

      if (strength !== 0 || roughness !== 0) {
        let mr = gltfMaterial.pbrMetallicRoughness;

        if (mr === undefined) {
          gltfMaterial.pbrMetallicRoughness = mr = {};
        }

        exporter.useExtensions(mr, {
          WG_clear_coat: {
            strength: strength !== 0 ? strength : undefined,
            roughness: roughness !== 0 ? roughness : undefined
          }
        });
      }
    }
  }

};
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-extensions/lib/index.js
/**
 * @module @wgetemp/gltf-extensions
 */











/**
 * @callback module:@wgetemp/gltf-extensions.ExtensionImport
 * @summary Import extension function signature.
 * @param {module:@wgetemp/gltf-importer.GLTFImporter.ExtensionContext} context
 * Import context.
 * @async
 */

/**
 * @callback module:@wgetemp/gltf-extensions.ExtensionExport
 * @summary Export extension function signature.
 * @param {module:@wgetemp/gltf-exporter.GLTFExporter} exporter glTF exporter.
 * @async
 */

/**
 * @typedef module:@wgetemp/gltf-extensions.Extension
 * @summary Allows customization of {@link module:@wgetemp/gltf-importer.GLTFImporter} and
 * {@link module:@wgetemp/gltf-exporter.GLTFExporter}, often maps directly to glTF extensions.
 * @property {string[]} [requires=[]] Same as `after`, but logs an error if specified extension
 * is not present.
 * @property {string[]} [after=[]] Names of extensions after which this extension will be applied.
 * @property {string[]} [before=[]] Names of extensions before which this extension will be applied.
 * Prefer to use `after`.
 * @property {module:@wgetemp/gltf-extensions.ExtensionImport} [import]
 * Function called to apply the extension on import.
 * @property {module:@wgetemp/gltf-extensions.ExtensionExport} [export]
 * Function called to apply the extension on export.
 */

/**
 * @const module:@wgetemp/gltf-extensions.defaultExtensions
 * @type {object}
 * @property {module:@wgetemp/gltf-extensions.Extension} KHR_materials_unlit {@link module:@wgetemp/gltf-extensions.KHR_materials_unlit}
 * @property {module:@wgetemp/gltf-extensions.Extension} KHR_texture_transform {@link module:@wgetemp/gltf-extensions.KHR_texture_transform}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_dielectric_specular {@link module:@wgetemp/gltf-extensions.WG_dielectric_specular}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_material_depth_properties {@link module:@wgetemp/gltf-extensions.WG_material_depth_properties}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_emissive_map_luminance {@link module:@wgetemp/gltf-extensions.WG_emissive_map_luminance}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_image_radiance_hdr {@link module:@wgetemp/gltf-extensions.WG_image_radiance_hdr}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_sampler_projection {@link module:@wgetemp/gltf-extensions.WG_sampler_projection}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_scene_environment {@link module:@wgetemp/gltf-extensions.WG_scene_environment}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_material_shadow_properties {@link module:@wgetemp/gltf-extensions.WG_material_shadow_properties}
 * @property {module:@wgetemp/gltf-extensions.Extension} WG_clear_coat {@link module:@wgetemp/gltf-extensions.WG_clear_coat}
 */

const defaultExtensions = {
  KHR_materials_unlit: KHR_materials_unlit,
  KHR_texture_transform: KHR_texture_transform,
  WG_dielectric_specular: WG_dielectric_specular,
  WG_material_depth_properties: WG_material_depth_properties,
  WG_emissive_map_luminance: WG_emissive_map_luminance,
  WG_image_radiance_hdr: WG_image_radiance_hdr,
  WG_sampler_projection: WG_sampler_projection,
  WG_scene_environment: WG_scene_environment,
  WG_material_shadow_properties: WG_material_shadow_properties,
  WG_clear_coat: WG_clear_coat
};
function resolveExtensionDependencies(extensions) {
  extensions = Object.entries(extensions);
  extensions = new Map(extensions.map(([name, extension]) => {
    return [name, {
      name,
      extension,
      requires: (extension.requires || []).slice(),
      after: (extension.after || []).slice(),
      before: (extension.before || []).slice()
    }];
  }));

  for (const extension of extensions.values()) {
    for (const dependency of extension.requires) {
      if (!extensions.has(dependency)) {
        console.error(`no ${dependency} glTF extension supplied required by` + ` extension ${extension.name}`);
      }

      extension.after.push(dependency);
    }
  }

  for (const extension of extensions.values()) {
    extension.after = new Set(extension.after.map(name => extensions.get(name)).filter(extension => extension !== undefined));
    extension.before = new Set(extension.before.map(name => extensions.get(name)).filter(extension => extension !== undefined));
  }

  extensions = [...extensions.values()];

  for (const extension of extensions) {
    for (const dependency of extension.before) {
      dependency.after.add(extension);
    }
  }

  for (const extension of extensions) {
    extension.after = [...extension.after];
  } // DFS toposort


  const processed = new Set();
  const pending = new Set();
  const sorted = [];
  const path = [];
  extensions.forEach(function walk(extension) {
    if (processed.has(extension)) {
      return;
    }

    if (pending.has(extension)) {
      const cycle = path.slice(path.indexOf(extension.name));
      console.error(`there is a cycle in extension dependency graph: ${[...cycle, cycle[0]].join(' -> ')}`);
      return;
    }

    path.push(extension.name);
    pending.add(extension);
    extension.after.forEach(walk, this);
    pending.delete(extension);
    path.pop();
    processed.add(extension);
    sorted.push(extension);
  }, this);
  extensions = sorted;
  extensions = extensions.map(extension => extension.extension);
  return extensions;
}

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return makeMethodDefiner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return makeGetterDefiner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return makeSetterDefiner; });
/* harmony import */ var _generate_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);


function makeFunctionPropertyDefiner(type, name, object) {
  return {
    [name](generate) {
      const fn = Object(_generate_function__WEBPACK_IMPORTED_MODULE_0__[/* generateFunction */ "a"])(generate);
      let descriptor = Object.getOwnPropertyDescriptor(object, fn.name);

      if (descriptor === undefined) {
        descriptor = {
          configurable: true
        };
      }

      if (type === 'value') {
        descriptor.writable = true;
      }

      descriptor[type] = fn;
      Object.defineProperty(object, fn.name, descriptor);
    }

  }[name];
}

function makeMethodDefiner(object) {
  return makeFunctionPropertyDefiner('value', 'defineMethod', object);
}
function makeGetterDefiner(object) {
  return makeFunctionPropertyDefiner('get', 'defineGetter', object);
}
function makeSetterDefiner(object) {
  return makeFunctionPropertyDefiner('set', 'defineSetter', object);
}

/***/ }),
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return degToRad; });
/* unused harmony export radToDeg */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clamp; });
/* unused harmony export interpolation */
/* unused harmony export smoothstep */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getScreenPositionFrom3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getPositionNdcFrom2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isBehindCamera; });
/* harmony import */ var _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

const degToRad = Math.PI / 180;
const radToDeg = 180 / Math.PI;
function clamp(val, min, max) {
  return Math.max(min, Math.min(val, max));
}
function interpolation(val, min, max) {
  return clamp((val - min) / (max - min), 0, 1);
}
function smoothstep(val, min, max) {
  const t = clamp((val - min) / (max - min), 0, 1);
  return t * t * (3 - 2 * t);
}
const getScreenPositionFrom3d = (() => {
  const screenPosition = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "m"]();
  const clipPosition = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]();
  return (worldPosition, renderer, look) => {
    clipPosition.copy(worldPosition).applyHomogeneousMatrix(look.viewProjectionMatrix);
    screenPosition.set((1 + clipPosition.x) * (renderer.width / renderer.pixelRatio) * 0.5, (1 - clipPosition.y) * (renderer.height / renderer.pixelRatio) * 0.5);
    return screenPosition;
  };
})();
const getPositionNdcFrom2d = (() => {
  const ndcPosition = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "m"]();
  let width;
  let height;
  return (screenPosition, renderer) => {
    width = renderer.width / renderer.pixelRatio;
    height = renderer.height / renderer.pixelRatio;
    ndcPosition.set(screenPosition.x / width * 2 - 1, (height - screenPosition.y) / height * 2 - 1);
    return ndcPosition;
  };
})();
const isBehindCamera = (() => {
  const viewPosition = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "n"]();
  return (point, look) => {
    viewPosition.copy(point).applyAffineMatrix(look.viewMatrix);
    return -viewPosition.z < look.znear;
  };
})();

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return makeEnum; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module module:@wgetemp/enum
 */

/**
 * @interface module:@wgetemp/enum.Enum
 * @summary Enum with iteration and lookup convenience utilities.
 * @example
 * const Fruit = makeEnum([
 *     'APPLE'
 *     'ORANGE'
 *     'BANANA',
 *     'KIWI',
 * ]);
 *
 * // Access element value.
 * Fruit.ORANGE
 * // => 1
 *
 * // Is iterable.
 * [...Fruit] // same as Fruit.values()
 * // => [0, 1, 2, 3]
 *
 * // Get iterator over names.
 * [...Fruit.names()] // same as Fruit.keys()
 * // => ['APPLE', 'ORANGE', 'BANANA', 'KIWI']
 *
 * // Get iterator over entries.
 * [...Fruit.entries()]
 * // => [['APPLE', 0], ['ORANGE', 1], ['BANANA', 2], ['KIWI', 3]]
 *
 * // Get first name for a given value or undefined if none exists.
 * Fruit.firstNameOf(2)
 * // => 'BANANA'
 *
 * // It is also possible to specify some or all values explicitly:
 * [...makeEnum([
 *     'APPLE',
 *     ['ORANGE', 'foo'],
 *     ['BANANA'],
 *     ['KIWI', 42],
 * ])]
 * // => [0, 'foo', 1, 42]
 */

/**
 * @function module:@wgetemp/enum.Enum#firstNameOf
 * @summary Get name of first entry with given value.
 * @param {any} value Entry value.
 * @returns {(string|undefined)} Name of first entry with given value or
 *     undefined if none such.
 */

/**
 * @function module:@wgetemp/enum.Enum#names
 * @summary Get iterator over entry names.
 * @returns {Iterator.<string>} Names.
 */

/**
 * @function module:@wgetemp/enum.Enum#keys
 * @desc Alias for {@link module:@wgetemp/enum.Enum#names}.
 * @summary Get iterator over entry names.
 * @returns {Iterator.<any>} Names.
 */

/**
 * @function module:@wgetemp/enum.Enum#values
 * @summary Get iterator over entry value.
 * @returns {Iterator.<any>} Values.
 */

/**
 * @typedef {Array} module:@wgetemp/enum.Enum.Entry
 * @summary Tuple of name and value.
 * @property {string} 0 Name.
 * @property {any} 1 Value.
 */

/**
 * @function module:@wgetemp/enum.Enum#entries
 * @summary Get iterator over entries.
 * @desc Also accessible as [Symbol.iterator].
 * @returns {Iterator.<module:@wgetemp/enum.Enum.Entry>} Entries.
 */
function parseEntry(entry) {
  if (typeof entry === 'string' || entry instanceof String) {
    entry = [entry];
  }

  entry = Array.from(entry);

  if (false) {}

  if (false) {}

  if (false) {}

  if (entry.length === 1) {
    entry.push(undefined);
  }

  return entry;
}

function fillEntryValues(entries) {
  let nextValue = 0;

  for (const entry of entries) {
    if (entry[1] === undefined) {
      entry[1] = nextValue++;
    } else if (typeof entry[1] === 'number' || entry[1] instanceof Number) {
      nextValue = entry[1] + 1;
    }
  }
}
/**
 * @typedef {(string|Array)} module:@wgetemp/enum.Enum.EntryDescriptor
 * @summary Either entry name string or 1-tuple of name, or 2-tuple of name and value.
 * @property {string} 0 Name.
 * @property {any} [1] Value.
 */

/**
 * @summary Create new enum with given entries.
 * @desc Any value that can be a key in a Map is allowed as entry value. When
 *     value is not specified for an entry, it defaults to value of the nearest
 *     preceding entry with a number value plus one; or zero for the first entry,
 *     same as C enums.
 * @param {Iterable.<module:@wgetemp/enum.Enum.EntryDescriptor>} entries Entry descriptors.
 * @returns {module:@wgetemp/enum.Enum}
 */


function makeEnum(entries) {
  entries = Array.from(entries, parseEntry);
  fillEntryValues(entries);
  const Enum = {};
  const names = [];
  const values = [];
  const firstNames = new Map();

  for (const _ref of entries) {
    var _ref2 = _slicedToArray(_ref, 2);

    const name = _ref2[0];
    const value = _ref2[1];
    Enum[name] = value;
    names.push(name);
    values.push(value);

    if (!firstNames.has(name)) {
      firstNames.set(value, name);
    }
  }

  const entryCount = entries;
  const props = Object.getOwnPropertyDescriptors({
    firstNameOf(value) {
      return firstNames.get(value);
    },

    names() {
      return names.values();
    },

    keys() {
      return names.values();
    },

    values() {
      return values.values();
    },

    [Symbol.iterator]() {
      return values.values();
    },

    *entries() {
      for (let i = 0; i < entryCount; ++i) {
        yield [names[i], values[i]];
      }
    }

  });

  for (const key of Reflect.ownKeys(props)) {
    props[key].enumerable = false;
  }

  Object.defineProperties(Enum, props); // XXX: angular.js polyfills Object.defineProperties with a broken version
  // that ignores symbols. The following is a workaround for this.

  if (!Enum.hasOwnProperty(Symbol.iterator)) {
    Enum[Symbol.iterator] = props[Symbol.iterator].value;
  }

  return Enum;
}

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Measure; });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sample__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sample", function() { return _sample__WEBPACK_IMPORTED_MODULE_1__["c"]; });

/* harmony import */ var _primitive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _math_vec2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(231);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(115);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(116);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_events__WEBPACK_IMPORTED_MODULE_6__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const defaultTranspileToScreenCoordinates = ({
  x,
  y
}) => ({
  x,
  y
});

const defaultRaycastScreenCoordinates = ({
  x,
  y
}) => ({
  position: {
    x,
    y,
    z: 0
  }
});

function isPositionOverElement(position, element) {
  const rect = element.getBoundingClientRect();
  return position.x >= rect.left && position.x <= rect.right && position.y >= rect.top && position.y <= rect.bottom;
}

class Measure extends events__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"] {
  constructor(options) {
    super();

    _defineProperty(this, "_container", void 0);

    _defineProperty(this, "_element", void 0);

    _defineProperty(this, "_samples", void 0);

    _defineProperty(this, "_mode", void 0);

    _defineProperty(this, "_selectionMode", void 0);

    _defineProperty(this, "_defaultColor", void 0);

    _defineProperty(this, "_points", void 0);

    _defineProperty(this, "_tempPoints", void 0);

    _defineProperty(this, "_tempSample", void 0);

    _defineProperty(this, "_hoveredSample", void 0);

    _defineProperty(this, "_tempLine", void 0);

    _defineProperty(this, "_pointerDown", void 0);

    _defineProperty(this, "_pointerDownElement", void 0);

    _defineProperty(this, "_pointerMovement", void 0);

    _defineProperty(this, "_draggingPoint", void 0);

    _defineProperty(this, "_draggingOffset", void 0);

    _defineProperty(this, "_draggingPointHit", void 0);

    _defineProperty(this, "_state", void 0);

    _defineProperty(this, "_scale", 1);

    _defineProperty(this, "transpileToScreenCoordinates", defaultTranspileToScreenCoordinates);

    _defineProperty(this, "raycastScreenCoordinates", defaultRaycastScreenCoordinates);

    _defineProperty(this, "_handleDragStartPoint", event => {
      const draggingPoint = event.target;

      if (this._state !== 'idle') {
        return;
      }

      const {
        parent
      } = draggingPoint;

      if (parent !== null) {
        this.emit('sample.move-start', {
          type: 'sample.move-start',
          emitter: 'internal',
          sample: parent,
          pointIndex: draggingPoint.index
        });
      }

      this._dragPoint(draggingPoint, event.offset);

      this._setState('dragging-point');
    });

    _defineProperty(this, "_handleDragEndPoint", () => {
      if (this._draggingPoint === null) {
        return;
      }

      if (this._state !== 'dragging-point') {
        return;
      }

      const {
        parent
      } = this._draggingPoint;

      if (parent !== null) {
        this.emit('sample.move-end', {
          type: 'sample.move-end',
          emitter: 'internal',
          sample: parent,
          pointIndex: this._draggingPoint.index
        });
      }

      this._dragPoint(null);

      this._setState('idle');
    });

    _defineProperty(this, "_handleSelectSample", ({
      target
    }) => {
      if (this._mode === 'view') {
        return;
      }

      if (this._selectionMode === 'none') {
        return;
      }

      if (this._state === 'adding-point') {
        return;
      }

      if (this._selectionMode === 'single') {
        this._samples.forEach(sample => {
          sample.selected = false;
        }); // Move on top


        this._element.appendChild(target.element);

        if (!target.selected) {
          target.selected = true;

          this._emitSelectSamples([target], 'internal');
        }

        return;
      }

      if (this._selectionMode === 'multi') {
        if (target.selected) {
          target.selected = false;
        } else {
          this._element.appendChild(target.element);

          target.selected = true;
        }

        this._emitSelectSamples(this.selectedSamples, 'internal');
      }
    });

    _defineProperty(this, "_handleHoverSample", ({
      target
    }) => {
      if (this._mode === 'view') {
        return;
      }

      this._hoveredSample = target;
      this.emit('sample.hover', {
        type: 'sample.hover',
        emitter: 'internal',
        sample: target
      });
    });

    _defineProperty(this, "_handleUnhoverSample", async ({
      target
    }) => {
      this._hoveredSample = null; // Wait some time to make sure no items were hovered instead

      await new Promise(resolve => setTimeout(resolve, 0));

      if (this._hoveredSample) {
        return;
      }

      this.emit('sample.unhover', {
        type: 'sample.unhover',
        emitter: 'internal',
        sample: target
      });
    });

    _defineProperty(this, "_handleDeleteSample", ({
      target
    }) => {
      this._deleteSample(target, 'internal');
    });

    _defineProperty(this, "_handleUpdateSampleValue", ({
      target
    }) => {
      this.emit('sample.update-value', {
        type: 'sample.update-value',
        emitter: 'internal',
        sample: target,
        value: target.value
      });
    });

    _defineProperty(this, "_handleUpdateSamplePosition", ({
      target,
      pointIndex
    }) => {
      if (this._state !== 'dragging-point') {
        return;
      }

      const {
        x,
        y,
        z
      } = target.points[pointIndex].position;
      this.emit('sample.move', {
        type: 'sample.move',
        emitter: 'internal',
        sample: target,
        pointIndex,
        position: {
          x,
          y,
          z
        }
      });
    });

    _defineProperty(this, "_throttledUpdatePointByScreenPosition", void 0);

    _defineProperty(this, "_updatePointScreenPosition", point => {
      const {
        x,
        y
      } = this.transpileToScreenCoordinates(point.position, point);
      point.setContainerPosition(x, y);
    });

    _defineProperty(this, "updateScreenPosition", () => {
      this._points.forEach(this._updatePointScreenPosition);
    });

    const {
      container,
      throttle: throttleOption = 200
    } = options;
    const element = document.createElement('div');
    container.appendChild(element);
    Object.assign(element.style, {
      userSelect: 'none',
      position: 'absolute',
      left: '0',
      top: '0',
      width: '100%',
      height: '100%',
      pointerEvents: 'none',
      overflow: 'hidden',
      transformOrigin: 'center',
      fontFamily: _sample__WEBPACK_IMPORTED_MODULE_1__[/* Sample */ "c"].DEFAULT_FONT
    });
    element.className = 'bv-measure';
    this._mode = 'view';
    this._state = 'idle';
    this._selectionMode = 'single';
    this._defaultColor = _sample__WEBPACK_IMPORTED_MODULE_1__[/* Sample */ "c"].DEFAULT_COLOR;
    this._container = container;
    this._element = element;
    this._points = new Set();
    this._samples = new Map();
    this._tempPoints = [];
    this._tempSample = null;
    this._hoveredSample = null;
    this._tempLine = null;
    this._pointerDown = false;
    this._pointerDownElement = null;
    this._pointerMovement = 0;
    this._draggingPoint = null;
    this._draggingPointHit = false;
    this._draggingOffset = {
      x: 0,
      y: 0
    };
    this._throttledUpdatePointByScreenPosition = throttleOption > 0 ? Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* throttle */ "a"])(this._updatePointByScreenPosition, throttleOption) : this._updatePointByScreenPosition;

    this._addListeners();
  }

  get selectedSamples() {
    return [...this._samples.values()].filter(sample => sample.selected);
  }

  _addListeners() {
    this._container.addEventListener('mousemove', event => {
      if (this._draggingPoint === null) {
        return;
      }

      this._handleDragPoint({
        x: event.clientX,
        y: event.clientY
      });
    });

    this._container.addEventListener('touchmove', event => {
      if (this._draggingPoint === null) {
        return;
      }

      if (this._state !== 'dragging-point') {
        return;
      }

      const screenPosition = {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };

      if (!isPositionOverElement(screenPosition, this._container)) {
        return;
      }

      this._handleDragPoint(screenPosition);
    });

    document.addEventListener('mouseup', this._handleDragEndPoint);
    document.addEventListener('touchend', this._handleDragEndPoint);
    document.addEventListener('keydown', event => {
      // stop dragging point and creation sample
      if (event.key === 'Escape') {
        this._handleDragEndPoint();

        this._cancelCreation();
      }
    });
    document.addEventListener('pointerdown', e => {
      this._pointerDown = true;
      this._pointerDownElement = e.target;
    });
    document.addEventListener('pointerup', e => {
      this._pointerDown = false;

      if (this._pointerMovement) {
        this._pointerMovement = 0;
        return;
      }

      if (this._pointerDownElement !== e.target) {
        return;
      }

      if (this._mode === 'view') {
        return;
      }

      if (this._selectionMode === 'none' || this._selectionMode === 'multi') {
        return;
      }

      if (this._element.contains(e.target)) {
        return;
      }

      let deselected = 0;

      this._samples.forEach(sample => {
        if (sample.selected) {
          sample.selected = false;
          deselected++;
        }
      });

      if (deselected) {
        this._emitSelectSamples([], 'internal');
      }
    });
    document.addEventListener('pointermove', ({
      movementX,
      movementY
    }) => {
      if (this._pointerDown) {
        this._pointerMovement += Math.hypot(movementX, movementY);
      }
    });
  }

  _handleDragPoint(screenPosition) {
    if (this._draggingPoint === null) {
      return;
    }

    if (this._state === 'idle') {
      return;
    }

    if (this._draggingPointHit) {
      const containerPosition = this._getContainerPositionFromEvent(screenPosition, this._draggingOffset);

      this._draggingPoint.setContainerPosition(containerPosition.x, containerPosition.y);
    }

    this._throttledUpdatePointByScreenPosition(this._draggingPoint, screenPosition, this._draggingOffset);
  }

  _getContainerPositionFromEvent(screenPosition, offset) {
    const rect = this._container.getBoundingClientRect();

    const containerPosition = {
      x: screenPosition.x - rect.left,
      y: screenPosition.y - rect.top
    };
    return _math_vec2__WEBPACK_IMPORTED_MODULE_3__[/* add */ "a"](containerPosition, offset, containerPosition);
  }

  _setState(state) {
    this._state = state;
  }

  _updatePointByScreenPosition(point, screenPosition, offset) {
    const containerPosition = this._getContainerPositionFromEvent(screenPosition, offset);

    const raycastResult = this.raycastScreenCoordinates(containerPosition);

    if (!raycastResult) {
      this._draggingPointHit = false;

      this._updatePointScreenPosition(point); // return back last hit position


      return;
    }

    this._draggingPointHit = true;
    const position = raycastResult.position;
    point.setPosition(position.x, position.y, position.z);
    point.setContainerPosition(containerPosition.x, containerPosition.y);
  }

  _dragPoint(point, offset = {
    x: 0,
    y: 0
  }) {
    if (point !== null) {
      const {
        parent
      } = point;

      if (parent) {
        parent.opacityMode = 'caption';
        parent.opacity = 0.5;
      }

      this._samples.forEach(sample => {
        if (parent === sample) {
          return;
        }

        sample.opacityMode = 'full';
        sample.opacity = 0.5;
        sample.interactive = false;
      });
    } else {
      if (this._draggingPoint && this._draggingPoint.parent) {
        this._draggingPoint.parent.opacity = 1;
      }

      this._samples.forEach(sample => {
        sample.opacity = 1;
        sample.interactive = true;
      });
    }

    if (this._draggingPoint) {
      this._draggingPoint.dragging = false;
    }

    this._draggingPoint = point;
    this._draggingPointHit = false;
    this._draggingOffset = offset;

    if (this._draggingPoint) {
      this._draggingPoint.dragging = true;
    }
  }

  _drawPoint(position) {
    const point = new _primitive__WEBPACK_IMPORTED_MODULE_2__[/* Point */ "f"]({
      position,
      interactive: false
    });
    point.on('drag-start', this._handleDragStartPoint);

    this._updatePointScreenPosition(point);

    this._element.appendChild(point.element);

    this._points.add(point);

    return point;
  }

  _drawDistance(points, options = {}) {
    const interactive = this._mode !== 'view';
    const distance = new _sample__WEBPACK_IMPORTED_MODULE_1__[/* Distance */ "b"]({
      points,
      interactive,
      color: this._defaultColor,
      scale: this._scale,
      ...options
    });

    this._addSampleListeners(distance);

    this._element.appendChild(distance.element);

    return distance;
  }

  _drawAngle(points, options = {}) {
    const interactive = this._mode !== 'view';
    const angle = new _sample__WEBPACK_IMPORTED_MODULE_1__[/* Angle */ "a"]({
      points,
      interactive,
      color: this._defaultColor,
      ...options
    });

    this._addSampleListeners(angle);

    this._element.appendChild(angle.element);

    return angle;
  }

  _emitSelectSamples(samples, eventEmitter) {
    this.emit('sample.select', {
      type: 'sample.select',
      emitter: eventEmitter,
      samples
    });
  }

  _addSampleListeners(sample) {
    sample.on('hover', this._handleHoverSample);
    sample.on('unhover', this._handleUnhoverSample);
    sample.on('select', this._handleSelectSample);
    sample.on('delete', this._handleDeleteSample);
    sample.on('update-position', this._handleUpdateSamplePosition);
    sample.on('update-value', this._handleUpdateSampleValue);
  }

  _removeSampleListeners(sample) {
    sample.off('hover', this._handleHoverSample);
    sample.off('unhover', this._handleUnhoverSample);
    sample.off('select', this._handleSelectSample);
    sample.off('delete', this._handleDeleteSample);
    sample.off('update-position', this._handleUpdateSamplePosition);
    sample.off('update-value', this._handleUpdateSampleValue);
  }

  _cancelCreation() {
    for (const point of this._tempPoints) {
      point.dispose();
    }

    this._tempPoints = [];

    if (this._tempLine) {
      this._tempLine.dispose();

      this._tempLine = null;
    }

    if (this._tempSample) {
      this._tempSample.dispose();

      this._removeSampleListeners(this._tempSample);
    }

    if (this._state === 'adding-point') {
      this._dragPoint(null);
    }

    this._setState('idle');
  }

  _addSample(sample, eventEmitter) {
    if (this._samples.has(sample.id)) {
      throw new Error(`Sample with id "${sample.id}" is already exists`);
    }

    this._samples.set(sample.id, sample);

    this.emit('sample.add', {
      type: 'sample.add',
      emitter: eventEmitter,
      sample
    });

    if (!sample.selected) {
      return;
    }

    if (this._selectionMode === 'single') {
      this._samples.forEach(item => {
        if (sample === item) {
          return;
        }

        item.selected = false;
      });

      this._emitSelectSamples([sample], 'internal');
    } else {
      this._emitSelectSamples(this.selectedSamples, 'internal');
    }
  }

  _deleteSample(sample, eventEmitter) {
    this._samples.delete(sample.id);

    this._removeSampleListeners(sample);

    sample.dispose();

    for (const point of sample.points) {
      this._points.delete(point);

      point.dispose();
    }

    this.emit('sample.delete', {
      type: 'sample.delete',
      emitter: eventEmitter,
      sample
    });

    if (sample.selected) {
      this._emitSelectSamples(this.selectedSamples, 'internal');
    }
  }

  emit(eventType, eventData) {
    return super.emit(eventType, eventData);
  }

  on(eventType, callback) {
    return super.on(eventType, callback);
  }

  off(eventType, callback) {
    return super.off(eventType, callback);
  }

  hide() {
    this._element.style.display = 'none';
  }

  show() {
    this._element.style.display = 'block';
  }

  setScale(scale) {
    this._scale = scale;

    this._samples.forEach(sample => {
      if (sample instanceof _sample__WEBPACK_IMPORTED_MODULE_1__[/* Distance */ "b"]) {
        sample.scale = scale;
      }
    });
  }

  getSamples() {
    return [...this._samples.values()];
  }

  getSampleById(id) {
    const sample = this._samples.get(id);

    return sample === undefined ? null : sample;
  }

  getMode() {
    return this._mode;
  }

  setMode(mode) {
    if (mode === this._mode) {
      return;
    }

    this._mode = mode;

    this._handleDragEndPoint();

    this._cancelCreation();

    if (mode === 'view') {
      this._samples.forEach(sample => {
        sample.selected = false;
        sample.interactive = false;
      });

      this._emitSelectSamples([], 'internal');
    } else {
      this._samples.forEach(sample => {
        sample.interactive = true;
      });
    }
  }

  setSelectionMode(mode) {
    this._selectionMode = mode;
  }

  selectSamples(sampleIds) {
    if (this._mode === 'view') {
      return;
    }

    this._samples.forEach(sample => {
      sample.selected = false;
    });

    for (const id of sampleIds) {
      const sample = this._samples.get(id);

      if (!sample) {
        continue;
      }

      sample.selected = true;
    }

    this._emitSelectSamples(this.selectedSamples, 'external');
  }

  setDefaultColor(color) {
    this._defaultColor = color;
  }

  setFontFamily(font) {
    this._element.style.fontFamily = font;
  }

  addPoint(position) {
    if (this._mode === 'view') {
      return;
    }

    if (this._mode === 'distance') {
      // First point placed
      if (this._state === 'idle') {
        const point0 = this._drawPoint(position);

        const point1 = this._drawPoint(position);

        this._tempPoints = [point0, point1];
        this._tempSample = this._drawDistance([point0, point1], {
          selected: true,
          color: this._defaultColor
        });

        this._dragPoint(point1);

        this._setState('adding-point');

        return;
      } // Second/Last point placed


      if (this._state === 'adding-point') {
        if (this._draggingPoint) {
          this.updatePointPosition(this._draggingPoint, position);

          this._dragPoint(null);
        }

        if (this._tempSample) {
          this._addSample(this._tempSample, 'internal');
        }

        this._setState('idle');

        this._tempPoints = [];
        this._tempSample = null;
        return;
      }
    }

    if (this._mode === 'angle') {
      // First point placed
      if (this._state === 'idle') {
        const point0 = this._drawPoint(position);

        const point1 = this._drawPoint(position);

        this._tempPoints = [point0, point1];
        this._tempLine = new _primitive__WEBPACK_IMPORTED_MODULE_2__[/* Line */ "e"]({
          points: [point0, point1]
        });
        this._tempLine.color = this._defaultColor;

        this._element.prepend(this._tempLine.element);

        this._dragPoint(point1);

        this._setState('adding-point');

        return;
      } // Second point placed


      if (this._state === 'adding-point' && this._tempPoints.length < 3) {
        const point2 = this._drawPoint(position);

        const [point0, point1] = this._tempPoints;

        if (this._tempLine) {
          this._tempLine.dispose();
        }

        this._tempSample = this._drawAngle([point0, point1, point2], {
          selected: true,
          color: this._defaultColor
        });

        this._tempPoints.push(point2);

        if (this._draggingPoint) {
          this.updatePointPosition(this._draggingPoint, position);
        }

        this._dragPoint(point2);

        return;
      } // Third/Last point placed


      if (this._state === 'adding-point') {
        if (this._draggingPoint) {
          this.updatePointPosition(this._draggingPoint, position);

          this._dragPoint(null);
        }

        if (this._tempSample) {
          this._addSample(this._tempSample, 'internal');
        }

        this._setState('idle');

        this._tempPoints = [];
        this._tempSample = null;
      }
    }
  }

  addDistance({
    points,
    ...options
  }) {
    const point0 = this._drawPoint(points[0]);

    const point1 = this._drawPoint(points[1]);

    const distance = this._drawDistance([point0, point1], options);

    this._addSample(distance, 'external');

    return distance;
  }

  addAngle({
    points,
    ...options
  }) {
    const point0 = this._drawPoint(points[0]);

    const point1 = this._drawPoint(points[1]);

    const point2 = this._drawPoint(points[2]);

    const angle = this._drawAngle([point0, point1, point2], options);

    this._addSample(angle, 'external');

    return angle;
  }

  deleteSample(sampleId) {
    const sample = this._samples.get(sampleId);

    if (!sample) {
      return;
    }

    this._deleteSample(sample, 'external');

    this._cancelCreation();
  }

  updatePointPosition(point, position) {
    point.setPosition(position.x, position.y, position.z);
    const containerPosition = this.transpileToScreenCoordinates(position, point);
    point.setContainerPosition(containerPosition.x, containerPosition.y);
  }

  getSampleByPoint(point) {
    for (const sample of this._samples.values()) {
      if (sample.points.includes(point)) {
        return sample;
      }
    }

    return null;
  }

  clearAll() {
    for (const sample of this._samples.values()) {
      this._deleteSample(sample, 'external');
    }

    this._cancelCreation();
  }

}

/***/ }),
/* 76 */,
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ raycaster_Raycaster; });

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/containers/lib/tuple-map.js
var tuple_map = __webpack_require__(395);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/memoize.js


function defaultMakeKey(...args) {
  return args;
}

function memoize(fn, makeKey = defaultMakeKey) {
  const cache = new tuple_map["a" /* TupleMap */]();
  return {
    [fn.name](...args) {
      const key = makeKey(...args);
      let res = cache.get(key);

      if (res === undefined) {
        res = fn(...args);
        cache.set(key, res);
      }

      return res;
    }

  }[fn.name];
}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/generate-function.js
var generate_function = __webpack_require__(96);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/enum/index.js
var _wgetemp_enum = __webpack_require__(74);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var lib = __webpack_require__(1);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var core_lib = __webpack_require__(0);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/raycaster/index.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable template-tag-spacing */




const CullFace = core_lib["D" /* Material */].CullFace;
const axisZ = new lib["n" /* Vector3 */](0, 0, 1);

function compareSqDistances({
  sqDistance: a
}, {
  sqDistance: b
}) {
  return a - b;
}

const OUTPUT_POSITIONS = 1 << 0;
const OUTPUT_NORMALS = 1 << 1;
const OUTPUT_SQ_DISTANCES = 1 << 2;
const OUTPUT_DISTANCES = 1 << 3;
const OUTPUT_FACE_VERTEX_INDICES = 1 << 4;
const ORDER = 1 << 5;
const NEAREST_ONLY = 1 << 6;
const COMPUTE_FACE_VERTEX_INDICES = OUTPUT_FACE_VERTEX_INDICES;
const COMPUTE_DISTANCES = OUTPUT_DISTANCES;
const COMPUTE_SQ_DISTANCES = COMPUTE_DISTANCES | ORDER | NEAREST_ONLY;
const COMPUTE_NORMALS = OUTPUT_NORMALS;
const COMPUTE_POSITIONS = OUTPUT_POSITIONS | COMPUTE_SQ_DISTANCES;
const edge1 = new lib["n" /* Vector3 */]();
const edge2 = new lib["n" /* Vector3 */]();
const h = new lib["n" /* Vector3 */]();
const s = new lib["n" /* Vector3 */]();
const q = new lib["n" /* Vector3 */]();
const position = new lib["n" /* Vector3 */]();
const getPrimitiveHitter = memoize((flags, cullFace, primitiveType, dimension, normalizedType, indexed) => {
  const hitTriangle = generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, {
      Vector3: lib["n" /* Vector3 */],
      sqrt: lib["z" /* sqrt */],
      isFinite: lib["r" /* isFinite */],
      edge1,
      edge2,
      h,
      s,
      q,
      position
    });
    fg.name = 'hitTriangle';
    fg.params = ['hits', 'node', 'renderable', ...(flags & COMPUTE_FACE_VERTEX_INDICES ? ['vertexIndex0', 'vertexIndex1', 'vertexIndex2'] : []), 'position0', 'position1', 'position2', 'ray', 'worldRayOrigin', 'worldMatrix', 'normalMatrix'];
    fg.emit`edge1.copy(position1).subtract(position0)`;
    fg.emit`edge2.copy(position2).subtract(position0)`;
    fg.emit`var direction=ray.direction`;
    fg.emit`h.copy(direction).cross(edge2)`;
    fg.emit`var f=1/edge1.dot(h)`;
    fg.emit`if(!isFinite(f)){return}`;

    if (cullFace === CullFace.BACK) {
      fg.emit`if(f<0){return}`;
    }

    if (cullFace === CullFace.FRONT) {
      fg.emit`if(f>0){return}`;
    }

    fg.emit`var origin=ray.origin`;
    fg.emit`s.copy(origin).subtract(position0)`;
    fg.emit`var u=s.dot(h)*f`;
    fg.emit`if(!(0<=u&&u<=1)){return}`;
    fg.emit`q.copy(s).cross(edge1)`;
    fg.emit`var v=direction.dot(q)*f`;
    fg.emit`if(!(0<=v&&u+v<=1)){return}`;
    fg.emit`var distance=edge2.dot(q)*f`;
    fg.emit`if(!(0<=distance)){return}`;

    if (flags & COMPUTE_POSITIONS) {
      fg.emit`position.copy(direction)`;
      fg.emit`.multiply(distance)`;
      fg.emit`.add(origin)`;
      fg.emit`.applyAffineMatrix(worldMatrix)`;
    }

    if (flags & COMPUTE_SQ_DISTANCES) {
      fg.emit`var sqDistance=worldRayOrigin.sqDistance(position)`;
    }

    if (flags & NEAREST_ONLY) {
      fg.emit`var hit=hits[0]`;
      fg.emit`if(!hit){`;
    } else {
      fg.emit`var hit`;
    }

    fg.emit`hit={`;
    fg.emit`node:null,`;
    fg.emit`renderable:null,`;

    if (flags & COMPUTE_POSITIONS) {
      fg.emit`position:new Vector3(),`;
    }

    if (flags & COMPUTE_NORMALS) {
      fg.emit`normal:new Vector3(),`;
    }

    if (flags & COMPUTE_SQ_DISTANCES) {
      fg.emit`sqDistance:0,`;
    }

    if (flags & COMPUTE_DISTANCES) {
      fg.emit`distance:0,`;
    }

    if (flags & COMPUTE_FACE_VERTEX_INDICES) {
      fg.emit`faceVertexIndex0:0,`;
      fg.emit`faceVertexIndex1:0,`;
      fg.emit`faceVertexIndex2:0,`;
    }

    fg.emit`}`;
    fg.emit`hits.push(hit)`;

    if (flags & NEAREST_ONLY) {
      fg.emit`}else if(sqDistance>hit.sqDistance){return}`;
    }

    fg.emit`hit.node=node`;
    fg.emit`hit.renderable=renderable`;

    if (flags & COMPUTE_POSITIONS) {
      fg.emit`hit.position.copy(position)`;
    }

    if (flags & COMPUTE_NORMALS) {
      fg.emit`hit.normal.copy(edge1).cross(edge2)`;
      fg.emit`.applyLinearMatrix(normalMatrix)`;
      fg.emit`.normalize()`;
    }

    if (flags & COMPUTE_SQ_DISTANCES) {
      fg.emit`hit.sqDistance=sqDistance`;
    }

    if (flags & COMPUTE_DISTANCES) {
      fg.emit`hit.distance=sqrt(sqDistance)`;
    }

    if (flags & COMPUTE_FACE_VERTEX_INDICES) {
      fg.emit`hit.faceVertexIndex0 = vertexIndex0`;
      fg.emit`hit.faceVertexIndex1 = vertexIndex1`;
      fg.emit`hit.faceVertexIndex2 = vertexIndex2`;
    }
  });
  const readPosition = generate_function["a" /* generateFunction */](fg => {
    fg.name = 'readPosition';
    fg.params = ['position', 'vertexIndex', 'positionBuffer', 'positionStride', 'indexBuffer', 'indexStride'];
    fg.emit`var offset=${(() => {
      if (indexed) {
        return 'indexBuffer[vertexIndex*indexStride]*positionStride';
      } else {
        // eslint-disable-line
        return 'vertexIndex*positionStride';
      }
    })()}`;

    for (const _ref of [...'xyz'].slice(0, dimension).entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const i = _ref2[0];
      const a = _ref2[1];
      fg.emit`position.${a}=positionBuffer[offset+${i}]`;
    }

    if (normalizedType !== null && !normalizedType.name.startsWith('Float')) {
      let _$exec = /^(Ui|I)nt(\d+)Array$/.exec(normalizedType.name),
          _$exec2 = _slicedToArray(_$exec, 3),
          signed = _$exec2[1],
          bits = _$exec2[2];

      signed = !signed.startsWith('U');
      bits = +bits;
      fg.emit`position.multiply(${1 / (2 ** (bits - signed) - 1)})`; // eslint-disable-line

      if (signed) {
        fg.emit`position.maxNumber(-1)`;
      }
    }

    if (flags & COMPUTE_FACE_VERTEX_INDICES) {
      fg.emit`return offset`;
    }
  });
  return generate_function["a" /* generateFunction */](fg => {
    Object.assign(fg.ctx, {
      position0: new lib["n" /* Vector3 */](),
      position1: new lib["n" /* Vector3 */](),
      position2: new lib["n" /* Vector3 */](),
      readPosition,
      hitTriangle
    });
    fg.name = 'hitPrimitive';
    fg.params = ['hits', 'node', 'renderable', 'count', 'positionStride', 'positionBuffer', 'indexStride', 'indexBuffer', 'ray', 'worldRayOrigin', 'worldMatrix', 'normalMatrix'];

    if (flags & COMPUTE_FACE_VERTEX_INDICES) {
      fg.emit`var vertexIndex0,vertexIndex1,vertexIndex2`;
    }

    const emitHit = () => {
      fg.emit`hitTriangle(${['hits', 'node', 'renderable', ...(flags & COMPUTE_FACE_VERTEX_INDICES ? ['vertexIndex0', 'vertexIndex1', 'vertexIndex2'] : []), 'position0', 'position1', 'position2', 'ray', 'worldRayOrigin', 'worldMatrix', 'normalMatrix']})`;
    };

    const emitRead = (i, vertexIndex) => {
      fg.emit`${flags & COMPUTE_FACE_VERTEX_INDICES ? `vertexIndex${i}=` : ''}readPosition(${[`position${i}`, `(${vertexIndex})`, 'positionBuffer', 'positionStride', 'indexBuffer', 'indexStride']})`;
    };

    const emitSwap = i => {
      fg.emit`{`;
      fg.emit`var t=position${i}`;
      fg.emit`position${i}=position2`;
      fg.emit`position2=t`;
      fg.emit`}`;
      fg.emit`{`;
      fg.emit`var t=vertexIndex${i}`;
      fg.emit`vertexIndex${i}=vertexIndex2`;
      fg.emit`vertexIndex2=t`;
      fg.emit`}`;
    };

    switch (primitiveType) {
      // eslint-disable-line
      case core_lib["O" /* PrimitiveType */].TRIANGLES:
        fg.emit`for(var i=0,limit=count-2;i<limit;){`;

        for (let i = 0; i < 3; ++i) {
          emitRead(`${i}`, 'i++');
        }

        emitHit();
        fg.emit`}`;
        break;

      case core_lib["O" /* PrimitiveType */].TRIANGLE_STRIP:
        fg.emit`if(count<3){return}`;
        emitRead('0', '0');
        emitRead('1', '1');
        fg.emit`for(var i=2;i<count;++i){`;
        emitRead('2', 'i');
        emitHit();
        fg.emit`if(i&1){`;
        emitSwap('1');
        fg.emit`}else{`;
        emitSwap('0');
        fg.emit`}`;
        fg.emit`}`;
        break;

      case core_lib["O" /* PrimitiveType */].TRIANGLE_FAN:
        fg.emit`if(count<3){return}`;
        emitRead('0', '0');
        emitRead('1', '1');
        fg.emit`for(var i=2;i<count;++i){`;
        emitRead('2', 'i');
        emitHit();
        emitSwap('1');
        fg.emit`}`;
        break;
    }
  });
}, (flags, cullFace, primitiveType, dimension, normalizedType, indexed) => {
  return [!!(flags & COMPUTE_POSITIONS) << 0 | // eslint-disable-line
  !!(flags & COMPUTE_NORMALS) << 1 | // eslint-disable-line
  !!(flags & COMPUTE_SQ_DISTANCES) << 2 | // eslint-disable-line
  !!(flags & COMPUTE_DISTANCES) << 3 | // eslint-disable-line
  !!(flags & COMPUTE_FACE_VERTEX_INDICES) << 4 | // eslint-disable-line
  !!(flags & NEAREST_ONLY) << 5, cullFace, primitiveType, dimension, normalizedType, indexed];
});

class NodeFilter {
  constructor(roots, filter) {
    this._roots = roots;
    this._filter = filter;
    this._decisionCache = new Map();
  }

  filter(node) {
    const decisionCache = this._decisionCache;
    let decision = decisionCache.get(node);

    if (decision === undefined) {
      if (this._roots.has(node)) {
        decision = this._filter(node);
      } else if (node.parent === null || this.filter(node.parent) & raycaster_Raycaster.NodeFilterDecision.SKIP_SUCCESSORS) {
        // eslint-disable-line
        decision = raycaster_Raycaster.NodeFilterDecision.SKIP_SUBTREE; // eslint-disable-line
      } else {
        decision = this._filter(node);
      }

      decisionCache.set(node, decision);
    }

    return decision;
  }

}

const instanceKeys = [];
const raycaster_Raycaster = (() => {
  class Raycaster {
    // eslint-disable-line
    static allowAnyNode() {
      return Raycaster.NodeFilterDecision.CAST_NODE;
    }

    constructor({
      filterNode = Raycaster.allowAnyNode,
      outputPositions = false,
      outputNormals = false,
      outputSqDistances = false,
      outputDistances = false,
      outputFaceVertexIndices = false,
      order = true,
      nearestOnly = true,
      forceCullFace = null,
      ignoreInvisibility = false
    } = {}) {
      this.filterNode = filterNode;
      this._flags = 0;
      this.outputPositions = outputPositions;
      this.outputNormals = outputNormals;
      this.outputSqDistances = outputSqDistances;
      this.outputDistances = outputDistances;
      this.outputFaceVertexIndices = outputFaceVertexIndices;
      this.order = order;
      this.nearestOnly = nearestOnly;
      this.forceCullFace = forceCullFace;
      this.ignoreInvisibility = ignoreInvisibility;
    }

    get outputPositions() {
      return !!(this._flags & OUTPUT_POSITIONS);
    }

    set outputPositions(outputPositions) {
      this._flags ^= (-!!outputPositions ^ this._flags) & OUTPUT_POSITIONS;
    }

    get outputNormals() {
      return !!(this._flags & OUTPUT_NORMALS);
    }

    set outputNormals(outputNormals) {
      this._flags ^= (-!!outputNormals ^ this._flags) & OUTPUT_NORMALS;
    }

    get outputSqDistances() {
      return !!(this._flags & OUTPUT_SQ_DISTANCES);
    }

    set outputSqDistances(outputSqDistances) {
      this._flags ^= (-!!outputSqDistances ^ this._flags) & OUTPUT_SQ_DISTANCES;
    }

    get outputDistances() {
      return !!(this._flags & OUTPUT_DISTANCES);
    }

    set outputDistances(outputDistances) {
      this._flags ^= (-!!outputDistances ^ this._flags) & OUTPUT_DISTANCES;
    }

    get outputFaceVertexIndices() {
      return !!(this._flags & OUTPUT_FACE_VERTEX_INDICES);
    }

    set outputFaceVertexIndices(outputFaceVertexIndices) {
      this._flags ^= (-!!outputFaceVertexIndices ^ this._flags) & OUTPUT_FACE_VERTEX_INDICES;
    }

    get order() {
      return !!(this._flags & ORDER);
    }

    set order(order) {
      this._flags ^= (-!!order ^ this._flags) & ORDER;
    }

    get nearestOnly() {
      return !!(this._flags & NEAREST_ONLY);
    }

    set nearestOnly(nearestOnly) {
      this._flags ^= (-!!nearestOnly ^ this._flags) & NEAREST_ONLY;
    }

    _hitRenderable(hits, node, renderable, ray, worldRayOrigin, worldMatrix, normalMatrix) {
      const geometry = renderable.geometry,
            material = renderable.material;

      if (geometry === null) {
        return;
      }

      if (material.environmentMap instanceof core_lib["D" /* Material */].EnvironmentMapProperties) {
        return;
      }

      const cullFace = this.forceCullFace !== null ? this.forceCullFace : material.cullFace;

      if (cullFace === CullFace.BOTH) {
        return;
      }

      let positions = null;

      for (const attribute of geometry.attributes.values()) {
        if (attribute.semantic === core_lib["d" /* AttributeSemantic */].POSITION) {
          positions = attribute;
          break;
        }
      }

      if (positions === null) {
        console.error('renderable has no position attribute');
        return;
      }

      const _positions = positions,
            positionBuffer = _positions.view,
            vertexData = _positions.vertexData;
      const positionStride = positionBuffer !== null ? positions.stride / positionBuffer.BYTES_PER_ELEMENT : 1;

      if (!Object(lib["s" /* isInteger */])(positionStride)) {
        console.error('position stride must be multiple of component size');
        return;
      }

      let count, indexBuffer, indexStride; // eslint-disable-line

      const _geometry$indices = geometry.indices,
            indices = _geometry$indices === void 0 ? null : _geometry$indices;

      if (indices !== null) {
        count = indices.countElements;
        indexBuffer = indices.view;
        indexStride = indexBuffer !== null ? indices.stride / indexBuffer.BYTES_PER_ELEMENT : 1;

        if (!Object(lib["s" /* isInteger */])(indexStride)) {
          console.error('index stride must be multiple of component size');
          return;
        }
      } else {
        count = positions.countElements;
      }

      const flags = vertexData.empty ? this._flags & NEAREST_ONLY : this._flags;
      const hitPrimitive = getPrimitiveHitter(flags, cullFace, geometry.primitiveType, positions.countComponents, positions.normalized ? positionBuffer.constructor : null, indexBuffer !== null);
      return hitPrimitive(hits, node, renderable, count, positionStride, positionBuffer, indexStride, indexBuffer, ray, worldRayOrigin, worldMatrix, normalMatrix);
    }

    _hitBoundary(hits, node, renderable, localRay, worldRayOrigin, worldMatrix, normalMatrix) {
      let nearestHit;

      if (this.nearestOnly && (nearestHit = hits[0]) !== undefined) {
        // eslint-disable-line
        const _renderable$geometry$ = renderable.geometry.boundingBox,
              boxMin = _renderable$geometry$.min,
              boxMax = _renderable$geometry$.max;
        const origin = localRay.origin,
              direction = localRay.direction;
        const originX = origin.x,
              originY = origin.y,
              originZ = origin.z;
        const recDirectionX = 1 / direction.x;
        const recDirectionY = 1 / direction.y;
        const recDirectionZ = 1 / direction.z;
        let distanceX = ((recDirectionX < 0 ? boxMax : boxMin).x - originX) * recDirectionX;
        let distanceY = ((recDirectionY < 0 ? boxMax : boxMin).y - originY) * recDirectionY;
        let distanceZ = ((recDirectionZ < 0 ? boxMax : boxMin).z - originZ) * recDirectionZ;

        if (Object(lib["t" /* isNaN */])(distanceX)) {
          distanceX = 0;
        }

        if (Object(lib["t" /* isNaN */])(distanceY)) {
          distanceY = 0;
        }

        if (Object(lib["t" /* isNaN */])(distanceZ)) {
          distanceZ = 0;
        }

        const distance = Object(lib["v" /* max */])(distanceX, distanceY, distanceZ, 0);
        position.copy(direction).multiply(distance).add(origin).applyAffineMatrix(worldMatrix);
        const sqDistance = worldRayOrigin.sqDistance(position);

        if (nearestHit.sqDistance < sqDistance) {
          return;
        }
      }

      this._hitRenderable(hits, node, renderable, localRay, worldRayOrigin, worldMatrix, normalMatrix);
    }

    _hitSpatialIndex(hits, nodeFilter, spatialIndex, worldRay) {
      spatialIndex.rayFind(worldRay, instanceKeys);

      for (const _ref3 of instanceKeys) {
        const renderable = _ref3.renderable;
        const node = _ref3.node;

        if (nodeFilter.filter(node) & Raycaster.NodeFilterDecision.SKIP_NODE) {
          continue;
        }

        if (renderable instanceof core_lib["fb" /* SubMesh */]) {
          if (!this.ignoreInvisibility) {
            const material = renderable.material;
            const visible = material.visible;

            const _node$getComponents = node.getComponents([core_lib["qb" /* Visibility */]]),
                  _node$getComponents2 = _slicedToArray(_node$getComponents, 1),
                  visibility = _node$getComponents2[0];

            if (visibility !== null) {
              if (!visibility.visible || !visible) {
                continue;
              }
            }
          }

          const _node$getComponents3 = node.getComponents([core_lib["jb" /* Transform */]]),
                _node$getComponents4 = _slicedToArray(_node$getComponents3, 1),
                worldMatrix = _node$getComponents4[0].worldMatrix;

          const invWorldMatrix = worldMatrix.clone().invert();
          let normalMatrix = null;

          if (this._flags & COMPUTE_NORMALS) {
            normalMatrix = new lib["h" /* LinearMatrix3 */]();
            normalMatrix.copy(invWorldMatrix).transpose();
          }

          const localRay = worldRay.clone().applyAffineMatrix(invWorldMatrix);

          this._hitBoundary(hits, node, renderable, localRay, worldRay.origin, worldMatrix, normalMatrix);
        }
      }
    }

    _hitSprite(hits, node, sprite, viewRay, worldRay, camera) {
      if (camera === null) {
        return;
      }

      const renderable = sprite._spriteRenderable;
      const worldViewMatrix = new lib["b" /* AffineMatrix3 */]();
      const _renderable$material = renderable.material,
            center = _renderable$material.center,
            rotation = _renderable$material.rotation;
      worldViewMatrix.fromTranslation(new lib["n" /* Vector3 */](-center.x, -center.y, 0));

      const _node$getComponents5 = node.getComponents([core_lib["jb" /* Transform */]]),
            _node$getComponents6 = _slicedToArray(_node$getComponents5, 1),
            baseWorldMatrix = _node$getComponents6[0].worldMatrix; // This is not a correct scale extraction, but do it anyway to match
      // sprite rendering shader.


      worldViewMatrix.scale(new lib["n" /* Vector3 */](baseWorldMatrix.axisXPaste(new lib["n" /* Vector3 */]()).length, baseWorldMatrix.axisYPaste(new lib["n" /* Vector3 */]()).length, baseWorldMatrix.axisZPaste(new lib["n" /* Vector3 */]()).length));
      worldViewMatrix.rotate(rotation, axisZ);
      const worldPosition = baseWorldMatrix.translationPaste(new lib["n" /* Vector3 */]());
      worldPosition.applyAffineMatrix(camera.viewMatrix);
      worldViewMatrix.translate(worldPosition);
      const invWorldViewMatrix = worldViewMatrix.clone().invert();
      const invWorldMatrix = camera.viewMatrix.clone().multiply(invWorldViewMatrix);
      let normalMatrix = null;

      if (this._flags & COMPUTE_NORMALS) {
        normalMatrix = new lib["h" /* LinearMatrix3 */]();
        normalMatrix.copy(invWorldMatrix).transpose();
      }

      const worldMatrix = invWorldMatrix.clone().invert();
      const localRay = viewRay.clone().applyAffineMatrix(invWorldViewMatrix);

      this._hitRenderable(hits, node, renderable, localRay, worldRay.origin, worldMatrix, normalMatrix);
    }

    _hitNodeTrees(hits, nodeFilter, nodes, viewRay, worldRay, camera) {
      for (const node of nodes) {
        const filterDecision = nodeFilter.filter(node);

        if (!(filterDecision & Raycaster.NodeFilterDecision.SKIP_NODE)) {
          const _node$getComponents7 = node.getComponents([core_lib["cb" /* Sprite */]]),
                _node$getComponents8 = _slicedToArray(_node$getComponents7, 1),
                sprite = _node$getComponents8[0];

          if (sprite !== null) {
            this._hitSprite(hits, node, sprite, viewRay, worldRay, camera);
          }
        }

        if (!(filterDecision & Raycaster.NodeFilterDecision.SKIP_SUCCESSORS)) {
          this._hitNodeTrees(hits, nodeFilter, node.children, viewRay, worldRay, camera);
        }
      }

      return hits;
    }

    _cast(filterNode, nodes, viewRay, worldRay, camera) {
      if (this.forceCullFace === CullFace.BOTH) {
        return [];
      }

      const nodeSet = new Set(nodes);

      const _nodes = _slicedToArray(nodes, 1),
            node0 = _nodes[0];

      const nodeFilter = new NodeFilter(nodeSet, filterNode);
      const hits = [];

      this._hitNodeTrees(hits, nodeFilter, nodeSet, viewRay, worldRay, camera);

      this._hitSpatialIndex(hits, nodeFilter, node0.scene.spatialIndex, worldRay);

      if (this.order) {
        hits.sort(compareSqDistances);
      }

      return hits;
    }

    cast(nodes, worldRay, {
      filterNode = this.filterNode
    } = {}) {
      return this._cast(filterNode, nodes, worldRay, worldRay, null);
    }

    castFromCamera(nodes, ndCoord, camera, {
      filterNode = this.filterNode
    } = {}) {
      const invProjectionMatrix = camera.projectionMatrix.clone().invert();
      const viewRay = new lib["l" /* Ray3 */]();
      viewRay.origin.set(ndCoord.x, ndCoord.y, -1);
      viewRay.direction.set(0, 0, 1);
      viewRay.applyHomogeneousMatrix(invProjectionMatrix);
      const worldRay = viewRay.clone().applyAffineMatrix(camera.worldMatrix);
      return this._cast(filterNode, nodes, viewRay, worldRay, camera);
    }

  }

  Object.defineProperties(Raycaster, {
    NodeFilterDecision: {
      configurable: true,
      value: Object(_wgetemp_enum["a" /* makeEnum */])([['CAST_NODE', 0b00], ['SKIP_NODE', 0b01], ['SKIP_SUCCESSORS', 0b10], ['SKIP_SUBTREE', 0b11]])
    }
  });
  return Raycaster;
})();

/***/ }),
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export LinearMatrix2 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AffineMatrix2; });
/* unused harmony export HomogeneousMatrix2 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return LinearMatrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AffineMatrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return HomogeneousMatrix3; });
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _to_title_case__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _complex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/* harmony import */ var _quaternion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







const aas = [...'xyzw'];
const ais = [0, 1, 2, 3];
const KINDS = {
  LINEAR: {
    name: 'Linear',
    rd: 0,
    cd: 0
  },
  AFFINE: {
    name: 'Affine',
    rd: 1,
    cd: 0
  },
  HOMOGENEOUS: {
    name: 'Homogeneous',
    rd: 1,
    cd: 1
  }
};

function makeClass(kind, d) {
  const r = d + kind.rd;
  const c = d + kind.cd;
  const is = ais.slice(0, r);
  const js = ais.slice(0, c);
  const as = aas.slice(0, d);
  const Matrix = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_0__[/* generateFunction */ "a"](fg => {
    fg.name = `${kind.name}Matrix${d}`;

    for (const i of is) for (const j of js) {
      fg.params.push(`_${i}${j}`);
    }

    for (const j of js) for (const i of is) {
      fg.emit`this._${i}${j}=${`_${i}${j}===undefined?${+(i === j)}:_${i}${j}`}`;
    }

    if (false) {}
  });

  for (const _ref of Object.entries({
    kind: kind.name.toLowerCase(),
    rowCount: r,
    columnCount: c
  })) {
    var _ref2 = _slicedToArray(_ref, 2);

    const name = _ref2[0];
    const value = _ref2[1];
    Object.defineProperty(Matrix.prototype, name, {
      configurable: true,
      value
    });

    if (false) {}
  }

  if (false) {}

  const defineMethod = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeMethodDefiner */ "b"](Matrix.prototype);
  const defineGetter = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeGetterDefiner */ "a"](Matrix.prototype);
  const defineSetter = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_1__[/* makeSetterDefiner */ "c"](Matrix.prototype);
  const aliasProperty = _wgetemp_codegen__WEBPACK_IMPORTED_MODULE_2__[/* makePropertyAliaser */ "a"](Matrix.prototype);

  for (const srcKind of Object.values(KINDS)) {
    const srcR = d + srcKind.rd;
    const srcC = d + srcKind.cd;

    if (srcR > r || srcC > c) {
      continue;
    }

    const srcIs = ais.slice(0, srcR);
    const srcJs = ais.slice(0, srcC);
    defineMethod(fg => {
      fg.name = `set${srcKind.name}`;

      for (const i of srcIs) for (const j of srcJs) {
        fg.params.push(`_${i}${j}`);
      }

      for (const j of js) for (const i of is) {
        fg.emit`this._${i}${j}=${(() => {
          if (i < srcR && j < srcC) {
            return `_${i}${j}`;
          }

          return +(i === j);
        })()}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
  }

  aliasProperty(`set${kind.name}`, 'set');
  defineMethod(fg => {
    fg.name = 'fromNumber';
    fg.params = ['number'];

    for (const j of js) for (const i of is) {
      fg.emit`this._${i}${j}=${(() => {
        if (i === j && i < d) {
          return 'number';
        }

        return +(i === j);
      })()}`;
    }

    fg.emit`return this`;

    if (false) {}
  });

  for (const srcKind of Object.values(KINDS)) {
    const srcR = d + srcKind.rd;
    const srcC = d + srcKind.cd;

    if (srcR > r || srcC > c) {
      continue;
    }

    defineMethod(fg => {
      fg.name = `from${srcKind.name}Matrix${d}`;
      fg.params = ['matrix'];

      for (const j of js) for (const i of is) {
        fg.emit`this._${i}${j}=${(() => {
          if (i < srcR && j < srcC) {
            return `matrix._${i}${j}`;
          }

          return +(i === j);
        })()}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
    aliasProperty(`from${srcKind.name}Matrix${d}`, `from${srcKind.name}Matrix`);
    aliasProperty(`from${srcKind.name}Matrix${d}`, `from${srcKind.name}${d}`);
    aliasProperty(`from${srcKind.name}Matrix`, `from${srcKind.name}`);

    if (d > 2) {
      defineMethod(fg => {
        fg.name = `from${srcKind.name}Matrix2`;
        fg.params = ['matrix'];

        for (const j of js) for (const i of is) {
          fg.emit`this._${i}${j}=${(() => {
            if (i < d - 1 && j < d - 1) {
              return `matrix._${i}${j}`;
            }

            if (i === d && srcKind.rd && j < d - 1 || j === d && srcKind.cd && i < d - 1 || i === d && srcKind.rd && j === d && srcKind.cd) {
              return `matrix._${i - (i >= d)}${j - (j >= d)}`;
            }

            return +(i === j);
          })()}`;
        }

        fg.emit`return this`;

        if (false) {}
      });
      aliasProperty(`from${srcKind.name}Matrix2`, `from${srcKind.name}2`);
    }
  }

  aliasProperty(`from${kind.name}`, 'copy');

  for (const arrayKind of Object.values(KINDS)) {
    const arrayR = d + arrayKind.rd;
    const arrayC = d + arrayKind.cd;
    const arrayIs = ais.slice(0, arrayR);
    const arrayJs = ais.slice(0, arrayC);

    for (const _ref3 of [['Row', (i, j) => i * arrayC + j], ['Column', (i, j) => j * arrayR + i]]) {
      var _ref4 = _slicedToArray(_ref3, 2);

      const Layout = _ref4[0];
      const getOffset = _ref4[1];

      if (arrayR <= r && arrayC <= c) {
        defineMethod(fg => {
          fg.name = `from${arrayKind.name}${Layout}ArrayAt`;
          fg.params = ['offset', 'array'];

          for (const j of js) for (const i of is) {
            fg.emit`this._${i}${j}=${(() => {
              if (i < arrayR && j < arrayC) {
                return `array[offset+${getOffset(i, j)}]`;
              }

              return +(i === j);
            })()}`;
          }

          fg.emit`return this`;

          if (false) {}
        });
        defineMethod(fg => {
          fg.name = `from${arrayKind.name}${Layout}Array`;
          fg.params = ['array'];
          fg.emit`return this.from${arrayKind.name}${Layout}ArrayAt(${`0,array`})`;

          if (false) {}
        });

        if (arrayKind === kind) {
          aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`, `from${Layout}ArrayAt`);
          aliasProperty(`from${arrayKind.name}${Layout}Array`, `from${Layout}Array`);
        }

        if (Layout === 'Row') {
          aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`, `from${arrayKind.name}ArrayAt`);
          aliasProperty(`from${arrayKind.name}${Layout}Array`, `from${arrayKind.name}Array`);

          if (arrayKind === kind) {
            aliasProperty(`from${Layout}ArrayAt`, 'fromArrayAt');
            aliasProperty(`from${Layout}Array`, 'fromArray');
          }
        }
      }

      if (arrayR >= r && arrayC >= c) {
        defineMethod(fg => {
          fg.name = `to${arrayKind.name}${Layout}ArrayAt`;
          fg.params = ['offset', 'array'];

          for (const j of arrayJs) for (const i of arrayIs) {
            fg.emit`array[offset+${getOffset(i, j)}]=${(() => {
              if (i < r && j < c) {
                return `this._${i}${j}`;
              }

              return +(i === j);
            })()}`;
          }

          fg.emit`return array`;

          if (false) {}
        });
        defineMethod(fg => {
          fg.name = `to${arrayKind.name}${Layout}Array`;
          fg.params = ['array'];
          fg.emit`return this.to${arrayKind.name}${Layout}ArrayAt(${`0,array`})`;

          if (false) {}
        });

        if (arrayKind === kind) {
          aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`, `to${Layout}ArrayAt`);
          aliasProperty(`to${arrayKind.name}${Layout}Array`, `to${Layout}Array`);
        }

        if (Layout === 'Row') {
          aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`, `to${arrayKind.name}ArrayAt`);
          aliasProperty(`to${arrayKind.name}${Layout}Array`, `to${arrayKind.name}Array`);

          if (arrayKind === kind) {
            aliasProperty(`to${Layout}ArrayAt`, 'toArrayAt');
            aliasProperty(`to${Layout}Array`, 'toArray');
          }
        }
      }
    }
  }

  defineMethod(fg => {
    fg.ctx[Matrix.name] = Matrix;
    fg.name = 'clone';
    fg.emit`return new ${Matrix.name}().copy(this)`;

    if (false) {}
  });

  for (const fn of [_functions__WEBPACK_IMPORTED_MODULE_4__[/* isNaN */ "s"], _functions__WEBPACK_IMPORTED_MODULE_4__[/* isFinite */ "q"]]) {
    const name = fn.name,
          Name = Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name);
    defineGetter(fg => {
      fg.ctx[name] = fn;
      fg.name = `some${Name}`;
      fg.emit`return ${js.map(j => {
        return is.map(i => `${name}(this._${i}${j})`).join('||');
      }).join('||')}`;

      if (false) {}
    });
    defineGetter(fg => {
      fg.ctx[name] = fn;
      fg.name = `every${Name}`;
      fg.emit`return ${js.map(j => {
        return is.map(i => `${name}(this._${i}${j})`).join('&&');
      }).join('&&')}`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = 'equals';
    fg.params = ['that'];
    fg.emit`return ${js.map(j => {
      return is.map(i => `this._${i}${j}===that._${i}${j}`).join('&&');
    }).join('&&')}`;

    if (false) {}
  });

  if (c === r) {
    defineMethod(fg => {
      fg.name = 'transpose';

      for (const j of js) for (const i of is) {
        if (i <= j) {
          continue;
        }

        fg.emit`${['var '].slice(i !== 1)}t=this._${i}${j}`;
        fg.emit`this._${i}${j}=this._${j}${i}`;
        fg.emit`this._${j}${i}=t`;
      }

      fg.emit`return this`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = 'invert';

    for (const j of js) for (const i of is) {
      fg.emit`var _${i}${j}=this._${i}${j}`;
    }

    if (r === 3 && c === 2) {
      fg.emit`var c02=_10*_21-_20*_11,`;
      fg.emit`c12=_00*_21-_20*_01`;
    } else if (r === 3 && c === 3) {
      fg.emit`var c00=_11*_22-_21*_12,`;
      fg.emit`c01=_10*_22-_20*_12,`;
      fg.emit`c02=_10*_21-_20*_11,`;
      fg.emit`c10=_01*_22-_21*_02,`;
      fg.emit`c11=_00*_22-_20*_02,`;
      fg.emit`c12=_00*_21-_20*_01,`;
      fg.emit`c20=_01*_12-_11*_02,`;
      fg.emit`c21=_00*_12-_10*_02,`;
      fg.emit`c22=_00*_11-_10*_01`;
    } else if (r === 4 && c === 3) {
      fg.emit`var c0103=_21*_32-_31*_22,`;
      fg.emit`c0203=_11*_32-_31*_12,`;
      fg.emit`c0303=_11*_22-_21*_12,`;
      fg.emit`c1203=_01*_32-_31*_02,`;
      fg.emit`c1303=_01*_22-_21*_02,`;
      fg.emit`c2303=_01*_12-_11*_02,`;
      fg.emit`c00=_11*_22-_21*_12,`;
      fg.emit`c01=_10*_22-_20*_12,`;
      fg.emit`c02=_10*_21-_20*_11,`;
      fg.emit`c03=_10*c0103-_20*c0203+_30*c0303,`;
      fg.emit`c10=_01*_22-_21*_02,`;
      fg.emit`c11=_00*_22-_20*_02,`;
      fg.emit`c12=_00*_21-_20*_01,`;
      fg.emit`c13=_00*c0103-_20*c1203+_30*c1303,`;
      fg.emit`c20=_01*_12-_11*_02,`;
      fg.emit`c21=_00*_12-_10*_02,`;
      fg.emit`c22=_00*_11-_10*_01,`;
      fg.emit`c23=_00*c0203-_10*c1203+_30*c2303`;
    } else if (r === 4 && c === 4) {
      fg.emit`var c0101=_22*_33-_32*_23,`;
      fg.emit`c0201=_12*_33-_32*_13,`;
      fg.emit`c0301=_12*_23-_22*_13,`;
      fg.emit`c0102=_21*_33-_31*_23,`;
      fg.emit`c0202=_11*_33-_31*_13,`;
      fg.emit`c0302=_11*_23-_21*_13,`;
      fg.emit`c0103=_21*_32-_31*_22,`;
      fg.emit`c0203=_11*_32-_31*_12,`;
      fg.emit`c0303=_11*_22-_21*_12,`;
      fg.emit`c1201=_02*_33-_32*_03,`;
      fg.emit`c1301=_02*_23-_22*_03,`;
      fg.emit`c1202=_01*_33-_31*_03,`;
      fg.emit`c1302=_01*_23-_21*_03,`;
      fg.emit`c1203=_01*_32-_31*_02,`;
      fg.emit`c1303=_01*_22-_21*_02,`;
      fg.emit`c2301=_02*_13-_12*_03,`;
      fg.emit`c2302=_01*_13-_11*_03,`;
      fg.emit`c2303=_01*_12-_11*_02,`;
      fg.emit`c00=_11*c0101-_21*c0201+_31*c0301,`;
      fg.emit`c01=_10*c0101-_20*c0201+_30*c0301,`;
      fg.emit`c02=_10*c0102-_20*c0202+_30*c0302,`;
      fg.emit`c03=_10*c0103-_20*c0203+_30*c0303,`;
      fg.emit`c10=_01*c0101-_21*c1201+_31*c1301,`;
      fg.emit`c11=_00*c0101-_20*c1201+_30*c1301,`;
      fg.emit`c12=_00*c0102-_20*c1202+_30*c1302,`;
      fg.emit`c13=_00*c0103-_20*c1203+_30*c1303,`;
      fg.emit`c20=_01*c0201-_11*c1201+_31*c2301,`;
      fg.emit`c21=_00*c0201-_10*c1201+_30*c2301,`;
      fg.emit`c22=_00*c0202-_10*c1202+_30*c2302,`;
      fg.emit`c23=_00*c0203-_10*c1203+_30*c2303,`;
      fg.emit`c30=_01*c0301-_11*c1301+_21*c2301,`;
      fg.emit`c31=_00*c0301-_10*c1301+_20*c2301,`;
      fg.emit`c32=_00*c0302-_10*c1302+_20*c2302,`;
      fg.emit`c33=_00*c0303-_10*c1303+_20*c2303`;
    }

    fg.emit`var invDet=1/(${(() => {
      if (c === 2) {
        return '_00*_11-_10*_01';
      }

      return js.map(i => {
        return `${'+-'[i % 2].slice(i === 0)}_${i}0*c${i}0`;
      }).join('');
    })()}),invNegDet=-invDet`;

    if (r === 2 && c === 2) {
      fg.emit`this._00=_11*invDet`;
      fg.emit`this._10=_10*invNegDet`;
      fg.emit`this._01=_01*invNegDet`;
      fg.emit`this._11=_00*invDet`;
    } else if (r === 3 && c === 2) {
      fg.emit`this._00=_11*invDet`;
      fg.emit`this._10=_10*invNegDet`;
      fg.emit`this._20=c02*invDet`;
      fg.emit`this._01=_01*invNegDet`;
      fg.emit`this._11=_00*invDet`;
      fg.emit`this._21=c12*invNegDet`;
    } else {
      for (const j of js) for (const i of is) {
        fg.emit`this._${i}${j}=${(() => {
          if (i < r && j < c) {
            return `c${j}${i}*inv${(i + j) % 2 ? 'Neg' : ''}Det`;
          }

          return +(i === j);
        })()}`;
      }
    }

    fg.emit`return this`;

    if (false) {}
  });

  for (const rightKind of Object.values(KINDS)) {
    const rightR = d + rightKind.rd;
    const rightC = d + rightKind.cd;

    if (rightR > r || rightC > c) {
      continue;
    }

    defineMethod(fg => {
      fg.name = `multiply${rightKind.name}`;
      fg.params = ['right'];

      for (const j of ais.slice(0, Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* min */ "B"])(c, rightR))) {
        for (const i of is) {
          fg.emit`var _${i}${j}=this._${i}${j}`;
        }
      }

      for (const j of ais.slice(0, rightC)) {
        for (const i of ais.slice(0, rightR)) {
          fg.emit`var r${i}${j}=right._${i}${j}`;
        }
      }

      for (const j of ais.slice(0, rightC)) for (const i of is) {
        fg.emit`this._${i}${j}=${[...function* () {
          for (let k = 0; k < Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* max */ "A"])(c, rightR); ++k) {
            const a = i < r && k < c ? `_${i}${k}` : +(i === k);
            const b = k < rightR && j < rightC ? `r${k}${j}` : +(k === j);

            if (a === 0 || b === 0) {// nop
            } else if (a === 1) {
              yield b;
            } else if (b === 1) {
              yield a;
            } else {
              yield `${a}*${b}`;
            }
          }
        }()].join('+')}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
    aliasProperty(`multiply${rightKind.name}`, `apply${rightKind.name}`);
  }

  aliasProperty(`multiply${kind.name}`, 'multiply');
  aliasProperty(`multiply${kind.name}`, 'apply');

  for (const leftKind of Object.values(KINDS)) {
    const leftR = d + leftKind.rd;
    const leftC = d + leftKind.cd;

    if (leftR > r || leftC > c) {
      continue;
    }

    defineMethod(fg => {
      fg.name = `preMultiply${leftKind.name}`;
      fg.params = ['left'];

      for (const j of ais.slice(0, Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* min */ "B"])(leftC, r))) {
        for (const i of ais.slice(0, leftR)) {
          fg.emit`var l${i}${j}=left._${i}${j}`;
        }
      }

      for (const j of js) {
        for (const i of is) {
          fg.emit`var _${i}${j}=this._${i}${j}`;
        }
      }

      for (const j of js) for (const i of ais.slice(0, leftR)) {
        fg.emit`this._${i}${j}=${[...function* () {
          for (let k = 0; k < Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* max */ "A"])(leftC, r); ++k) {
            const a = i < leftR && k < leftC ? `l${i}${k}` : +(i === k);
            const b = k < r && j < c ? `_${k}${j}` : +(k === j);

            if (a === 0 || b === 0) {// nop
            } else if (a === 1) {
              yield b;
            } else if (b === 1) {
              yield a;
            } else {
              yield `${a}*${b}`;
            }
          }
        }()].join('+')}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
    aliasProperty(`preMultiply${leftKind.name}`, `preApply${leftKind.name}`);
  }

  aliasProperty(`preMultiply${kind.name}`, 'preMultiply');
  aliasProperty('preMultiply', 'preApply');
  defineMethod(fg => {
    fg.name = 'multiplyNumber';
    fg.params = ['right'];

    for (const j of js.slice(0, d)) for (const i of is) {
      fg.emit`this._${i}${j}*=right`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'preMultiplyNumber';
    fg.params = ['left'];

    for (const j of js) for (const i of is.slice(0, d)) {
      fg.emit`this._${i}${j}*=left`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineGetter(fg => {
    fg.name = `determinant`;

    if (c > 2) {
      for (const j of js.slice(1)) for (const i of js) {
        fg.emit`var _${i}${j}=this._${i}${j}`;
      }
    }

    if (c === 3) {
      fg.emit`var c00=_11*_22-_21*_12,`;
      fg.emit`c10=_01*_22-_21*_02,`;
      fg.emit`c20=_01*_12-_11*_02`;
    } else if (c === 4) {
      fg.emit`var c0101=_22*_33-_32*_23,`;
      fg.emit`c0201=_12*_33-_32*_13,`;
      fg.emit`c0301=_12*_23-_22*_13,`;
      fg.emit`c1201=_02*_33-_32*_03,`;
      fg.emit`c1301=_02*_23-_22*_03,`;
      fg.emit`c2301=_02*_13-_12*_03,`;
      fg.emit`c00=_11*c0101-_21*c0201+_31*c0301,`;
      fg.emit`c10=_01*c0101-_21*c1201+_31*c1301,`;
      fg.emit`c20=_01*c0201-_11*c1201+_31*c2301,`;
      fg.emit`c30=_01*c0301-_11*c1301+_21*c2301`;
    }

    fg.emit`return ${(() => {
      if (c === 2) {
        return 'this._00*this._11-this._10*this._01';
      }

      return js.map(i => {
        return `${'+-'[i % 2].slice(i === 0)}this._${i}0*c${i}0`;
      }).join('');
    })()}`;

    if (false) {}
  });

  for (const _ref5 of [...as.map((a, i) => {
    return [i, `axis${a.toUpperCase()}`];
  }), [d, 'translation']]) {
    var _ref6 = _slicedToArray(_ref5, 2);

    const i = _ref6[0];
    const param = _ref6[1];
    defineMethod(fg => {
      fg.name = `${param}Paste`;
      fg.params = [param];

      for (const _ref7 of as.entries()) {
        var _ref8 = _slicedToArray(_ref7, 2);

        const j = _ref8[0];
        const a = _ref8[1];
        fg.emit`${param}.${a}=${(() => {
          if (i < d || kind !== KINDS.LINEAR) {
            return `this._${i}${j}`;
          }

          return +(i === j);
        })()}`;
      }

      fg.emit`return ${param}`;

      if (false) {}
    });

    if (i < d || kind !== KINDS.LINEAR) {
      defineMethod(fg => {
        fg.name = `${param}Copy`;
        fg.params = [param];

        for (const _ref9 of as.entries()) {
          var _ref10 = _slicedToArray(_ref9, 2);

          const j = _ref10[0];
          const a = _ref10[1];
          fg.emit`this._${i}${j}=${param}.${a}`;
        }

        fg.emit`return this`;

        if (false) {}
      });
    }
  }

  if (kind !== KINDS.LINEAR) {
    defineMethod(fg => {
      fg.name = 'fromTranslation';
      fg.params = ['translation'];

      for (const j of js) for (const i of is) {
        fg.emit`this._${i}${j}=${(() => {
          if (i === d && j < d) {
            return `translation.${as[j]}`;
          }

          return +(i === j);
        })()}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      fg.name = 'translate';
      fg.params = ['translation'];

      if (kind === KINDS.AFFINE) {
        for (const _ref11 of as.entries()) {
          var _ref12 = _slicedToArray(_ref11, 2);

          const j = _ref12[0];
          const a = _ref12[1];
          fg.emit`this._${d}${j}+=translation.${a}`;
        }
      } else {
        for (const i of is) {
          fg.emit`var _${i}${d}=this._${i}${d}`;
        }

        for (const a of as) {
          fg.emit`var ${a}=translation.${a}`;
        }

        for (const _ref13 of as.entries()) {
          var _ref14 = _slicedToArray(_ref13, 2);

          const j = _ref14[0];
          const a = _ref14[1];

          for (const i of is) {
            fg.emit`this._${i}${j}+=_${i}${d}*${a}`;
          }
        }
      }

      fg.emit`return this`;

      if (false) {}
    });
    defineMethod(fg => {
      fg.name = 'preTranslate';
      fg.params = ['translation'];

      for (const a of as) {
        fg.emit`var ${a}=translation.${a}`;
      }

      for (const j of js) {
        fg.emit`this._${d}${j}+=${as.map((a, i) => {
          return `${a}*this._${i}${j}`;
        }).join('+')}`;
      }

      fg.emit`return this`;

      if (false) {}
    });
  }

  defineMethod(fg => {
    fg.name = 'fromScaling';
    fg.params = ['scaling'];

    for (const j of js) for (const i of is) {
      fg.emit`this._${i}${j}=${(() => {
        if (i === j && i < d) {
          return `scaling.${as[i]}`;
        }

        return +(i === j);
      })()}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'scale';
    fg.params = ['scaling'];

    for (const a of as) {
      fg.emit`var ${a}=scaling.${a}`;
    }

    for (const _ref15 of as.entries()) {
      var _ref16 = _slicedToArray(_ref15, 2);

      const j = _ref16[0];
      const a = _ref16[1];

      for (const i of is) {
        fg.emit`this._${i}${j}*=${a}`;
      }
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'preScale';
    fg.params = ['scaling'];

    for (const a of as) {
      fg.emit`var ${a}=scaling.${a}`;
    }

    for (const j of js) for (const _ref17 of aas.slice(0, d).entries()) {
      var _ref18 = _slicedToArray(_ref17, 2);

      const i = _ref18[0];
      const a = _ref18[1];
      fg.emit`this._${i}${j}*=${a}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  aliasProperty('fromNumber', 'fromUniformScaling');
  aliasProperty('multiplyNumber', 'scaleUniform');
  aliasProperty('preMultiplyNumber', 'preScaleUniform');
  defineMethod(fg => {
    fg.name = 'fromShearing';
    fg.params = ['shearing'];

    for (const j of js) for (const i of is) {
      fg.emit`this._${i}${j}=${(() => {
        if (d === 2) {
          if (i === 1 && j === 0) {
            return 'shearing';
          }
        } else {
          if (i === 1 && j === 0) {
            return 'shearing.z';
          }

          if (i === 2 && j === 0) {
            return 'shearing.y';
          }

          if (i === 2 && j === 1) {
            return 'shearing.x';
          }
        }

        return +(i === j);
      })()}`;
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'shear';
    fg.params = ['shearing'];

    if (d === 2) {
      for (const i of is) {
        fg.emit`this._${i}0+=this._${i}1*shearing`;
      }
    } else {
      for (const i of is) {
        fg.emit`var _${i}1=this._${i}1`;
      }

      for (const i of is) {
        fg.emit`var _${i}2=this._${i}2`;
      }

      for (const a of as) {
        fg.emit`var ${a}=shearing.${a}`;
      }

      for (const i of is) {
        fg.emit`this._${i}0+=_${i}1*z+_${i}2*y`;
      }

      for (const i of is) {
        fg.emit`this._${i}1=_${i}1+_${i}2*x`;
      }
    }

    fg.emit`return this`;

    if (false) {}
  });
  defineMethod(fg => {
    fg.name = 'preShear';
    fg.params = ['shearing'];

    if (d === 2) {
      for (const j of js) {
        fg.emit`this._1${j}+=shearing*this._0${j}`;
      }
    } else {
      for (const a of as) {
        fg.emit`var ${a}=shearing.${a}`;
      }

      for (const j of js) {
        fg.emit`var _0${j}=this._0${j}`;
        fg.emit`var _1${j}=this._1${j}`;
      }

      for (const j of js) {
        fg.emit`this._1${j}=z*_0${j}+_1${j}`;
        fg.emit`this._2${j}+=y*_0${j}+x*_1${j}`;
      }
    }

    fg.emit`return this`;

    if (false) {}
  });

  if (false) {}

  if (d === 2) {
    const tmp = new (kind === KINDS.LINEAR ? Matrix : LinearMatrix2)();
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        SQRT2: Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"])(2)
      });
      fg.name = 'fromReflection';
      fg.params = ['normal'];
      fg.emit`var x=normal.x*SQRT2,`;
      fg.emit`y=normal.y*SQRT2`;
      fg.emit`this._00=1-x*x`;
      fg.emit`this._10=-y*x`;

      if (kind.rd) {
        fg.emit`this._20=0`;
      }

      fg.emit`this._01=this._10`;
      fg.emit`this._11=1-y*y`;

      if (kind.rd) {
        fg.emit`this._21=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}2=${+(i === 2)}`;
        }
      }

      fg.emit`return this`;
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        tmp
      });
      fg.name = 'reflect';
      fg.params = ['normal'];
      fg.emit`return this.multiplyLinear(${`tmp.fromReflection(${fg.params})`})`;
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, {
        tmp
      });
      fg.name = 'preReflect';
      fg.params = ['normal'];
      fg.emit`return this.preMultiplyLinear(${`tmp.fromReflection(${fg.params})`})`;
    });

    const defineTransform = (fromName, name, prepare) => {
      defineMethod(fg => {
        fg.name = fromName;
        prepare(fg);

        for (const j of js) for (const i of is) {
          fg.emit`this._${i}${j}=${(() => {
            if (i < d && j < d) {
              if (i === j) {
                return 're';
              }

              return '-im'.slice(i < j);
            }

            return +(i === j);
          })()}`;
        }

        fg.emit`return this`;
      });
      defineMethod(fg => {
        fg.name = name;

        for (const j of as.keys()) for (const i of is) {
          fg.emit`var _${i}${j}=this._${i}${j}`;
        }

        prepare(fg);

        for (const i of is) {
          fg.emit`this._${i}0=_${i}0*re-_${i}1*im`;
        }

        for (const i of is) {
          fg.emit`this._${i}1=_${i}0*im+_${i}1*re`;
        }

        fg.emit`return this`;
      });
      defineMethod(fg => {
        fg.name = `pre${Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name)}`;
        prepare(fg);

        for (const j of js) for (const i of as.keys()) {
          fg.emit`var _${i}${j}=this._${i}${j}`;
        }

        for (const j of js) {
          fg.emit`this._0${j}=re*_0${j}+im*_1${j}`;
          fg.emit`this._1${j}=re*_1${j}-im*_0${j}`;
        }

        fg.emit`return this`;
      });
    };

    defineTransform('fromRotation', 'rotate', fg => {
      Object.assign(fg.ctx, {
        sin: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sin */ "F"],
        cos: _functions__WEBPACK_IMPORTED_MODULE_4__[/* cos */ "h"]
      });
      fg.params = ['angle'];
      fg.emit`var re=cos(angle),im=sin(angle)`;
    });
    defineTransform('fromRotationBetween', 'rotateBetween', fg => {
      fg.params = ['from', 'to'];
      fg.emit`var re=from.dot(to),im=from.cross(to)`;
    });
    defineTransform('fromComplex', 'applyComplex', fg => {
      fg.params = ['complex'];
      fg.emit`var re=complex.re,im=complex.im`;
    });

    if (false) {}
  } else {
    const tmp = new (kind === KINDS.LINEAR ? Matrix : LinearMatrix3)();

    const defineTransform = (prepare, name) => {
      let fromName, params;
      defineMethod(fg => {
        prepare(fg);
        fromName = fg.name;
        params = [...fg.params];
        fg.emit`return this`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = name;
        fg.params = params;
        fg.emit`return this.multiplyLinear(${`tmp.${fromName}(${params})`})`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = `pre${Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name)}`;
        fg.params = params;
        fg.emit`return this.preMultiplyLinear(${`tmp.${fromName}(${params})`})`;
      });
    };

    defineTransform(fg => {
      Object.assign(fg.ctx, {
        SQRT2: Object(_functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"])(2)
      });
      fg.name = 'fromReflection';
      fg.params = ['normal'];
      fg.emit`var x=normal.x*SQRT2,`;
      fg.emit`y=normal.y*SQRT2,`;
      fg.emit`z=normal.z*SQRT2`;
      fg.emit`this._00=1-x*x`;
      fg.emit`this._10=-y*x`;
      fg.emit`this._20=-z*x`;

      if (kind.rd) {
        fg.emit`this._30=0`;
      }

      fg.emit`this._01=this._10`;
      fg.emit`this._11=1-y*y`;
      fg.emit`this._21=-z*y`;

      if (kind.rd) {
        fg.emit`this._31=0`;
      }

      fg.emit`this._02=this._20`;
      fg.emit`this._12=this._21`;
      fg.emit`this._22=1-z*z`;

      if (kind.rd) {
        fg.emit`this._32=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'reflect');
    defineTransform(fg => {
      Object.assign(fg.ctx, {
        sin: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sin */ "F"],
        cos: _functions__WEBPACK_IMPORTED_MODULE_4__[/* cos */ "h"]
      });
      fg.name = 'fromRotation';
      fg.params = ['angle', 'axis'];
      fg.emit`var s=sin(angle),c=cos(angle),t=1-c,`;
      fg.emit`x=axis.x,y=axis.y,z=axis.z,`;
      fg.emit`xs=x*s,ys=y*s,zs=z*s,`;
      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;
      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;
      fg.emit`this._00=c+x*xt`;
      fg.emit`this._10=xyt-zs`;
      fg.emit`this._20=xzt+ys`;

      if (kind.rd) {
        fg.emit`this._30=0`;
      }

      fg.emit`this._01=xyt+zs`;
      fg.emit`this._11=c+y*yt`;
      fg.emit`this._21=yzt-xs`;

      if (kind.rd) {
        fg.emit`this._31=0`;
      }

      fg.emit`this._02=xzt-ys`;
      fg.emit`this._12=yzt+xs`;
      fg.emit`this._22=c+z*zt`;

      if (kind.rd) {
        fg.emit`this._32=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'rotate');
    defineTransform(fg => {
      Object.assign(fg.ctx, {
        axis: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"]()
      });
      fg.name = 'fromRotationBetween';
      fg.params = ['from', 'to'];
      fg.emit`axis.copy(from).cross(to)`;
      fg.emit`var xs=axis.x,ys=axis.y,zs=axis.z`;
      fg.emit`axis.normalize()`;
      fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;
      fg.emit`var x=axis.x,y=axis.y,z=axis.z,`;
      fg.emit`c=from.dot(to),t=1-c,`;
      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;
      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;
      fg.emit`this._00=c+x*xt`;
      fg.emit`this._10=xyt-zs`;
      fg.emit`this._20=xzt+ys`;

      if (kind.rd) {
        fg.emit`this._30=0`;
      }

      fg.emit`this._01=xyt+zs`;
      fg.emit`this._11=c+y*yt`;
      fg.emit`this._21=yzt-xs`;

      if (kind.rd) {
        fg.emit`this._31=0`;
      }

      fg.emit`this._02=xzt-ys`;
      fg.emit`this._12=yzt+xs`;
      fg.emit`this._22=c+z*zt`;

      if (kind.rd) {
        fg.emit`this._32=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'rotateBetween');
    defineTransform(fg => {
      Object.assign(fg.ctx, {
        sqrt: _functions__WEBPACK_IMPORTED_MODULE_4__[/* sqrt */ "H"]
      });
      fg.name = 'fromComplex';
      fg.params = ['complex', 'axis'];
      fg.emit`var re=complex.re,im=complex.im,`;
      fg.emit`scaling=sqrt(re*re+im*im),t=scaling-re,`;
      fg.emit`x=axis.x,y=axis.y,z=axis.z,`;
      fg.emit`xIm=x*im,yIm=y*im,zIm=z*im,`;
      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;
      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;
      fg.emit`this._00=re+x*xt`;
      fg.emit`this._10=xyt-zIm`;
      fg.emit`this._20=xzt+yIm`;

      if (kind.rd) {
        fg.emit`this._30=0`;
      }

      fg.emit`this._01=xyt+zIm`;
      fg.emit`this._11=re+y*yt`;
      fg.emit`this._21=yzt-xIm`;

      if (kind.rd) {
        fg.emit`this._31=0`;
      }

      fg.emit`this._02=xzt-yIm`;
      fg.emit`this._12=yzt+xIm`;
      fg.emit`this._22=re+z*zt`;

      if (kind.rd) {
        fg.emit`this._32=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'applyComplex');

    if (false) {}

    defineTransform(fg => {
      fg.name = 'fromQuaternion';
      fg.params = ['quaternion'];
      fg.emit`var re=quaternion.re,`;
      fg.emit`imX=quaternion.imX,`;
      fg.emit`imY=quaternion.imY,`;
      fg.emit`imZ=quaternion.imZ,`;
      fg.emit`scaling=re*re+imX*imX+imY*imY+imZ*imZ,`;
      fg.emit`re2=re*2,imX2=imX*2,imY2=imY*2,imZ2=imZ*2,`;
      fg.emit`imXImX2=imX*imX2,imYImY2=imY*imY2,imZImZ2=imZ*imZ2,`;
      fg.emit`reImX2=re*imX2,reImY2=re*imY2,reImZ2=re*imZ2,`;
      fg.emit`imXImY2=imX*imY2,imXImZ2=imX*imZ2,imYImZ2=imY*imZ2`;
      fg.emit`this._00=scaling-(imYImY2+imZImZ2),`;
      fg.emit`this._10=imXImY2+reImZ2,`;
      fg.emit`this._20=imXImZ2-reImY2,`;

      if (kind.rd) {
        fg.emit`this._30=0`;
      }

      fg.emit`this._01=imXImY2-reImZ2,`;
      fg.emit`this._11=scaling-(imXImX2+imZImZ2),`;
      fg.emit`this._21=imYImZ2+reImX2,`;

      if (kind.rd) {
        fg.emit`this._31=0`;
      }

      fg.emit`this._02=imXImZ2+reImY2,`;
      fg.emit`this._12=imYImZ2-reImX2,`;
      fg.emit`this._22=scaling-(imXImX2+imYImY2)`;

      if (kind.rd) {
        fg.emit`this._32=0`;
      }

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'applyQuaternion');

    if (false) {}

    defineTransform(fg => {
      Object.assign(fg.ctx, {
        x: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"](),
        y: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"](),
        z: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"]()
      });
      fg.name = 'fromLookDirection';
      fg.params = ['direction', 'up'];
      fg.emit`z.copy(direction).normalize()`;
      fg.emit`if(!z.everyIsFinite){`;
      fg.emit`z.copy(up).orthogonalize().normalize()`;
      fg.emit`}else{`;
      fg.emit`z.negate()`;
      fg.emit`}`;
      fg.emit`x.copy(up).cross(z)`;
      fg.emit`if(!x.everyIsFinite){`;
      fg.emit`x.copy(z).orthogonalize()`;
      fg.emit`}`;
      fg.emit`x.normalize()`;
      fg.emit`y.copy(z).cross(x)`;

      for (const j of js) for (const i of is) {
        fg.emit`this._${i}${j}=${(() => {
          if (i < 3 && j < 3) {
            return `${as[i]}.${as[j]}`;
          }

          return +(i === j);
        })()}`;
      }
    }, 'lookIn');

    if (false) {}
  }

  if (kind !== KINDS.LINEAR && d === 3) {
    const tmp = new (kind === KINDS.AFFINE ? Matrix : AffineMatrix3)();

    const defineTransform = (prepare, name) => {
      let fromName, params;
      defineMethod(fg => {
        prepare(fg);
        fromName = fg.name;
        params = [...fg.params];
        fg.emit`return this`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = name;
        fg.params = params;
        fg.emit`return this.multiplyAffine(${`tmp.${fromName}(${params})`})`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = `pre${Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name)}`;
        fg.params = params;
        fg.emit`return this.preMultiplyAffine(${`tmp.${fromName}(${params})`})`;
      });
    };

    defineTransform(fg => {
      Object.assign(fg.ctx, {
        direction: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"]()
      });
      fg.name = 'fromLookTarget';
      fg.params = ['origin', 'target', 'up'];
      fg.emit`direction.copy(target).subtract(origin)`;
      fg.emit`this.fromLookDirection(direction,up).translate(origin)`;
    }, 'lookAt');

    if (false) {}

    defineTransform(fg => {
      fg.name = 'fromWebGLOrthographicAsymmetricProjection';
      fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];
      fg.emit`var invNegWidth=1/(left-right),`;
      fg.emit`invNegHeight=1/(bottom-top),`;
      fg.emit`invNegDepth=1/(near-far)`;
      fg.emit`this._00=-2*invNegWidth`;
      fg.emit`this._10=0`;
      fg.emit`this._20=0`;
      fg.emit`this._30=(left+right)*invNegWidth`;
      fg.emit`this._01=0`;
      fg.emit`this._11=-2*invNegHeight`;
      fg.emit`this._21=0`;
      fg.emit`this._31=(bottom+top)*invNegHeight`;
      fg.emit`this._02=0`;
      fg.emit`this._12=0`;
      fg.emit`this._22=2*invNegDepth,`;
      fg.emit`this._32=(near+far)*invNegDepth`;

      if (kind.cd) {
        for (const i of is) {
          fg.emit`this._${i}3=${+(i === 3)}`;
        }
      }
    }, 'projectWebGLOrthographicAsymmetric');

    if (false) {}

    defineTransform(fg => {
      fg.name = 'fromWebGLOrthographicProjection';
      fg.params = ['width', 'height', 'near', 'far'];
      fg.emit`var top=height*.5,right=width*.5`;
      fg.emit`this.fromWebGLOrthographicAsymmetricProjection(${'-right,right,-top,top,near,far'})`;
    }, 'projectWebGLOrthographic');

    if (false) {}
  }

  if (kind === KINDS.HOMOGENEOUS && d === 3) {
    const tmp = new Matrix();

    const defineTransform = (prepare, name) => {
      let fromName, params;
      defineMethod(fg => {
        prepare(fg);
        fromName = fg.name;
        params = [...fg.params];
        fg.emit`return this`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = name;
        fg.params = params;
        fg.emit`return this.multiply(tmp.${fromName}(${params}))`;
      });
      defineMethod(fg => {
        Object.assign(fg.ctx, {
          tmp
        });
        fg.name = `pre${Object(_to_title_case__WEBPACK_IMPORTED_MODULE_3__[/* toTitleCase */ "a"])(name)}`;
        fg.params = params;
        fg.emit`return this.preMultiply(tmp.${fromName}(${params}))`;
      });
    };

    defineTransform(fg => {
      Object.assign(fg.ctx, {
        isFinite: _functions__WEBPACK_IMPORTED_MODULE_4__[/* isFinite */ "q"]
      });
      fg.name = 'fromWebGLAsymmetricPerspectiveProjection';
      fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];
      fg.emit`var near2=near*2,`;
      fg.emit`invWidth=1/(right-left),`;
      fg.emit`invHeight=1/(top-bottom)`;
      fg.emit`this._00=near2*invWidth,`;
      fg.emit`this._10=0`;
      fg.emit`this._20=(left+right)*invWidth`;
      fg.emit`this._30=0`;
      fg.emit`this._01=0`;
      fg.emit`this._11=near2*invHeight`;
      fg.emit`this._21=(bottom+top)*invHeight`;
      fg.emit`this._31=0`;
      fg.emit`this._02=0`;
      fg.emit`this._12=0`;
      fg.emit`if(isFinite(far)){`;
      fg.emit`var invNegDepth=1/(near-far)`;
      fg.emit`this._22=(near+far)*invNegDepth`;
      fg.emit`this._32=near2*far*invNegDepth`;
      fg.emit`}else{`;
      fg.emit`this._22=-1`;
      fg.emit`this._32=-near2`;
      fg.emit`}`;
      fg.emit`this._03=0`;
      fg.emit`this._13=0`;
      fg.emit`this._23=-1`;
      fg.emit`this._33=0`;
    }, 'projectWebGLPerspectiveAsymmetric');

    if (false) {}

    defineTransform(fg => {
      Object.assign(fg.ctx, {
        tan: _functions__WEBPACK_IMPORTED_MODULE_4__[/* tan */ "I"]
      });
      fg.name = 'fromWebGLPerspectiveProjection';
      fg.params = ['aspectRatio', 'verticalFieldOfView', 'near', 'far'];
      fg.emit`var top=near*tan(verticalFieldOfView*.5),`;
      fg.emit`right=top*aspectRatio`;
      fg.emit`this.fromWebGLAsymmetricPerspectiveProjection(${'-right,right,-top,top,near,far'})`;
    }, 'projectWebGLPerspective');

    if (false) {}
  }

  for (const splitKind of [KINDS.LINEAR, KINDS.AFFINE]) {
    if (splitKind.rd > kind.rd) {
      continue;
    }

    defineMethod(fg => {
      fg.name = `from${splitKind.name}SplitTransform`;
      fg.params = ['transform'];
      fg.emit`return this.fromScaling(transform.scaling)`;
      fg.emit`.shear(transform.shearing)`;

      if (d === 2) {
        fg.emit`.applyComplex(transform.complex)`;
      } else {
        fg.emit`.applyQuaternion(transform.quaternion)`;
      }

      if (splitKind !== KINDS.LINEAR) {
        fg.emit`.translate(transform.translation)`;
      }

      if (false) {}
    });
    defineMethod(fg => {
      Object.assign(fg.ctx, d === 2 ? {
        tmpVector: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector2 */ "a"](),
        tmpComplex: new _complex__WEBPACK_IMPORTED_MODULE_6__[/* Complex */ "a"]()
      } : {
        tmpVector: new _vectors__WEBPACK_IMPORTED_MODULE_5__[/* Vector3 */ "b"](),
        tmpQuaternion: new _quaternion__WEBPACK_IMPORTED_MODULE_7__[/* Quaternion */ "a"]()
      });
      fg.name = `fromInverted${splitKind.name}SplitTransform`;
      fg.params = ['transform'];

      if (d === 3) {
        fg.emit`var shearing=transform.shearing`;
      }

      if (splitKind !== KINDS.LINEAR) {
        fg.emit`return this.fromTranslation(${'tmpVector.copy(transform.translation).negate()'})`;

        if (d === 2) {
          fg.emit`.applyComplex(${'tmpComplex.copy(transform.complex).invert()'})`;
        } else {
          fg.emit`.applyQuaternion(${'tmpQuaternion.copy(transform.quaternion).invert()'})`;
        }
      } else {
        if (d === 2) {
          fg.emit`return this.fromComplex(${'tmpComplex.copy(transform.complex).invert()'})`;
        } else {
          fg.emit`return this.fromQuaternion(${'tmpQuaternion.copy(transform.quaternion).invert()'})`;
        }
      }

      if (d === 2) {
        fg.emit`.shear(-transform.shearing)`;
      } else {
        fg.emit`.shear(tmpVector.set(${['-shearing.x', 'shearing.x*shearing.z-shearing.y', '-shearing.z']}))`;
      }

      fg.emit`.scale(${'tmpVector.copy(transform.scaling).preDivideNumber(1)'})`;

      if (false) {}
    });

    if (splitKind === kind) {
      aliasProperty(`from${splitKind.name}SplitTransform`, 'fromSplitTransform');
      aliasProperty(`fromInverted${splitKind.name}SplitTransform`, 'fromInvertedSplitTransform');
    }
  }

  return Matrix;
}

const LinearMatrix2 = makeClass(KINDS.LINEAR, 2);
const AffineMatrix2 = makeClass(KINDS.AFFINE, 2);
const HomogeneousMatrix2 = makeClass(KINDS.HOMOGENEOUS, 2);
const LinearMatrix3 = makeClass(KINDS.LINEAR, 3);
const AffineMatrix3 = makeClass(KINDS.AFFINE, 3);
const HomogeneousMatrix3 = makeClass(KINDS.HOMOGENEOUS, 3);

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export exposeFromWorker */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createWorker; });
/* eslint-disable no-restricted-globals */

/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
function exposeFromWorker(fn) {
  const handleMessage = async event => {
    let message;

    try {
      const result = await fn(...event.data);
      message = {
        state: 'success',
        result,
        error: null
      };
    } catch (error) {
      message = {
        state: 'error',
        result: null,
        error
      };
    }

    self.postMessage(message);
  }; // Could be only one expose per worker with this implementation


  if (self.__handleMessage) {
    self.removeEventListener('message', self.__handleMessage);
  }

  self.__handleMessage = handleMessage;
  self.addEventListener('message', handleMessage);
}
function createWorker(LoaderWorker) {
  const run = async (...args) => {
    const worker = new LoaderWorker();
    const result = await new Promise((resolve, reject) => {
      worker.onmessage = event => {
        const message = event.data;

        if (message.state === 'error') {
          reject(message.error);
          return;
        }

        resolve(message.result);
      };

      worker.onerror = event => {
        reject(event);
      };

      worker.postMessage(args);
    });
    worker.terminate();
    return result;
  };

  return run;
}

/***/ }),
/* 84 */,
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ options_OptionsSetuper; });

// CONCATENATED MODULE: ./src/api/options/base.ts
class OptionBase {
  constructor(_store) {
    this._store = _store;
  }

}
// CONCATENATED MODULE: ./src/api/options/antialiasing.ts

class antialiasing_AntialiasingSetuper extends OptionBase {
  get() {
    return { ...this._store.renderer.antialiasing
    };
  }

  set(value) {
    this._store.renderer.setAntialiasing({
      mode: value.mode,
      pixelRatio: value.pixelRatio
    });
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var lib = __webpack_require__(1);

// EXTERNAL MODULE: ./src/global-helpers/index.ts + 13 modules
var global_helpers = __webpack_require__(6);

// CONCATENATED MODULE: ./src/api/options/axes-colors.ts



/**
  * Axes colors options. (Default: `{ x: 'FF0000', y: '00FF00', z: '0000FF' }`)
  *
  * @remarks
  * Affects on `setSectionBox` method and `showOrigin` option.
  *
  * @example
  * ```typescript
  * const axesColors: AxesColorsOptions = { x: 'FFFF00', y: '00FFFF', z: 'FF00FF' };
  * ```
  *
  * @public
  */

class axes_colors_AxesColorsSetuper extends OptionBase {
  get() {
    const {
      x,
      y,
      z
    } = this._store.axes.axesColors;
    return {
      x: Object(global_helpers["d" /* colorToString */])(x),
      y: Object(global_helpers["d" /* colorToString */])(y),
      z: Object(global_helpers["d" /* colorToString */])(z)
    };
  }

  set(value) {
    this._store.axes.setAxesColors({
      x: new lib["k" /* RGBColor */]().fromPackedInteger(parseInt(value.x, 16)),
      y: new lib["k" /* RGBColor */]().fromPackedInteger(parseInt(value.y, 16)),
      z: new lib["k" /* RGBColor */]().fromPackedInteger(parseInt(value.z, 16))
    });
  }

}
// CONCATENATED MODULE: ./src/api/options/camera-controls.ts

/**
 * Camera controls zoom options.
 * @public
 */

class camera_controls_CameraControlsSetuper extends OptionBase {
  get() {
    const {
      enabled,
      keyboard,
      zoom,
      rotation,
      panning,
      damping
    } = this._store.controls;
    return {
      enabled,
      keyboard,
      zoom,
      rotation,
      panning,
      damping
    };
  }

  set(value) {
    const options = typeof value === 'boolean' ? {
      enabled: Boolean(value)
    } : {
      enabled: true,
      ...value
    };

    this._store.controls.setOptions(options);
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var core_lib = __webpack_require__(0);

// EXTERNAL MODULE: ./src/api/utils.ts
var utils = __webpack_require__(15);

// CONCATENATED MODULE: ./src/api/options/camera.ts



/**
 * Camera projection type. (Default: `'perspective'`)
 * @public
 */

var ProjectionTypesPublic;
/**
 * Camera options. (Default: options from the default preset, perspective camera)
 * @public
 */

(function (ProjectionTypesPublic) {
  ProjectionTypesPublic["PERSPECTIVE"] = "perspective";
  ProjectionTypesPublic["ORTHOGRAPHIC"] = "orthographic";
})(ProjectionTypesPublic || (ProjectionTypesPublic = {}));

const ProjectionTypesMapGet = {
  [core_lib["f" /* Camera */].ProjectionTypes.PERSPECTIVE]: ProjectionTypesPublic.PERSPECTIVE,
  [core_lib["f" /* Camera */].ProjectionTypes.ORTHOGRAPHIC]: ProjectionTypesPublic.ORTHOGRAPHIC
};
const ProjectionTypesMapSet = {
  [ProjectionTypesPublic.PERSPECTIVE]: core_lib["f" /* Camera */].ProjectionTypes.PERSPECTIVE,
  [ProjectionTypesPublic.ORTHOGRAPHIC]: core_lib["f" /* Camera */].ProjectionTypes.ORTHOGRAPHIC
};
class camera_CameraSetuper extends OptionBase {
  get() {
    const {
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType,
      fov
    } = this._store.camera.options;
    const mapped = {
      projectionType: ProjectionTypesMapGet[projectionType]
    };
    return {
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      fov,
      ...mapped
    };
  }

  set(value) {
    const {
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType,
      fov
    } = value;
    const options = Object(utils["a" /* cleanObject */])({
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType: projectionType !== undefined ? ProjectionTypesMapSet[projectionType] : undefined,
      fov
    });

    this._store.camera.set(options);
  }

}
// CONCATENATED MODULE: ./src/api/options/coordinate-system.ts

class coordinate_system_CoordinateSystemSetuper extends OptionBase {
  get() {
    return this._store.axes.coordinateSystem;
  }

  set(value) {
    this._store.axes.setCoordinateSystem(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/edge-geometry.ts

/**
 * Edge geometry options. Mode to show object edges. (Default: disabled).
 *
 * @remarks
 * Affects performance. Better not to enable for big models.
 *
 * @public
 */

class edge_geometry_EdgeGeometrySetuper extends OptionBase {
  get() {
    const {
      enabled,
      color
    } = this._store.edges;
    return {
      enabled,
      color
    };
  }

  set(value) {
    const options = typeof value === 'boolean' ? {
      enabled: Boolean(value)
    } : {
      enabled: true,
      ...value
    };

    this._store.edges.setOptions(options);
  }

}
// CONCATENATED MODULE: ./src/api/options/environment.ts

/**
 * IBL (image-based lighting) options.
 * @public
 */

class environment_EnvironmentSetuper extends OptionBase {
  get() {
    return {
      ibl: { ...this._store.environment.ibl
      }
    };
  }

  set(value) {
    this._store.environment.set(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/experimental.ts

/** @public Stats UI options */

class experimental_ExperimentalSetuper extends OptionBase {
  get() {
    const {
      enabled,
      style
    } = this._store.stats;
    return {
      stats: {
        enabled,
        style: { ...style
        }
      }
    };
  }

  set(value) {
    if (value.stats !== undefined) {
      if (typeof value.stats === 'boolean') {
        this._store.stats.setEnabled(value.stats);

        this._store.stats.setStyle(null);
      } else {
        const {
          enabled = true,
          style = null
        } = value.stats;

        this._store.stats.setEnabled(enabled);

        this._store.stats.setStyle(style);
      }
    }
  }

}
// CONCATENATED MODULE: ./src/api/options/ghost-mode.ts

/**
 * Ghost mode options. Allows to see hidden objects as transparent ghosts. (Default: disabled)
 *
 * @remarks
 * Ghost mode could decrease performance.
 *
 * @public
 */

class ghost_mode_GhostModeSetuper extends OptionBase {
  get() {
    return { ...this._store.filter.ghostMode
    };
  }

  set(value) {
    const options = typeof value === 'boolean' ? {
      enabled: Boolean(value)
    } : {
      enabled: true,
      ...value
    };

    this._store.filter.setGhostMode(options);
  }

}
// CONCATENATED MODULE: ./src/api/options/grid.ts

/**
 * Grid options. Enabling showing grids/levels, setting appropriate options for them. (Default: disabled)
 * @public
 */

class grid_GridSetuper extends OptionBase {
  get() {
    return { ...this._store.sectoring
    };
  }

  set(value) {
    const options = typeof value === 'boolean' || !value ? {
      enabled: Boolean(value)
    } : {
      enabled: true,
      ...value
    };

    this._store.sectoring.setEnabled(options.enabled);

    if (options.color) {
      this._store.sectoring.setColor(options.color);
    }
  }

}
// CONCATENATED MODULE: ./src/api/options/logs.ts

/**
 * Enable logging public method calls (available via {@link IndustrialViewer.getDebugInfo} method) (Default: `true`)
 *
 * @public
 */

class logs_LogsSetuper extends OptionBase {
  get() {
    return this._store.debug.logsEnabled;
  }

  set(value) {
    this._store.debug.setLogsEnabled(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/navigation-cube.ts

class navigation_cube_NavigationCubeSetuper extends OptionBase {
  get() {
    return this._store.navigationCube.getOptions();
  }

  set(value) {
    const options = typeof value === 'boolean' ? {
      enabled: Boolean(value)
    } : {
      enabled: true,
      ...value
    };

    this._store.navigationCube.setOptions(options);
  }

}
// CONCATENATED MODULE: ./src/api/options/progressive-rendering.ts

/**
 * Progressive rendering options. When enabled allows to increase fps on big models. (Default: enabled in `'auto'` mode)
 * @public
 */

class progressive_rendering_ProgressiveRenderingSetuper extends OptionBase {
  get() {
    if (this._store.renderer.progressiveRenderer.enabled && this._store.renderer.progressiveRendererAuto) {
      return 'auto';
    }

    return { ...this._store.renderer.progressiveRenderer
    };
  }

  set(value) {
    let options;

    if (typeof value === 'boolean') {
      options = {
        enabled: Boolean(value)
      };

      this._store.renderer.setProgressiveRendererAuto(false);
    } else if (value === 'auto') {
      options = {
        enabled: true
      };

      this._store.renderer.setProgressiveRendererAuto(true);
    } else {
      options = {
        enabled: true,
        ...value
      };

      this._store.renderer.setProgressiveRendererAuto(false);
    }

    this._store.renderer.setProgressiveRenderer(options);
  }

}
// CONCATENATED MODULE: ./src/api/options/selection-color.ts

/**
 * Selection color. (Default: `'FF0000'`)
 * @public
 */

class selection_color_SelectionColorSetuper extends OptionBase {
  get() {
    return this._store.select.color;
  }

  set(value) {
    this._store.select.setColor(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/selection-mode.ts

class selection_mode_SelectionModeSetuper extends OptionBase {
  get() {
    return this._store.select.mode;
  }

  set(value) {
    this._store.select.setMode(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/show-origin.ts

/**
 * Show model's point of origin. (Default: `false`)
 * @public
 */

class show_origin_ShowOriginSetuper extends OptionBase {
  get() {
    return this._store.axes.showOrigin;
  }

  set(value) {
    this._store.axes.setOriginVisibility(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/staging-memory-size.ts

/**
 * Memory size allocation in megabytes. (Default: `128` for desktop and `96` for mobiles)
 *
 * @remarks
 * You could set it to 0 for size auto detection.
 *
 * @public
 */

class staging_memory_size_StagingMemorySizeSetuper extends OptionBase {
  get() {
    return this._store.renderer.stagingMemorySize;
  }

  set(value) {
    this._store.renderer.setStagingMemorySize(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/theme.ts

/**
 * Theme options. (Default: transparent background)
 *
 * @public
 */

class theme_ThemeSetuper extends OptionBase {
  get() {
    return { ...this._store.theme.currentTheme
    };
  }

  set(value) {
    this._store.theme.set(value);
  }

}
// CONCATENATED MODULE: ./src/api/options/index.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





































/**
 * Viewer options.
 * @public
 */

class options_OptionsSetuper {
  constructor(_store) {
    this._store = _store;

    _defineProperty(this, "dictionary", {
      antialiasing: new antialiasing_AntialiasingSetuper(this._store),
      axesColors: new axes_colors_AxesColorsSetuper(this._store),
      cameraControls: new camera_controls_CameraControlsSetuper(this._store),
      camera: new camera_CameraSetuper(this._store),
      coordinateSystem: new coordinate_system_CoordinateSystemSetuper(this._store),
      edgeGeometry: new edge_geometry_EdgeGeometrySetuper(this._store),
      environment: new environment_EnvironmentSetuper(this._store),
      experimental: new experimental_ExperimentalSetuper(this._store),
      ghostMode: new ghost_mode_GhostModeSetuper(this._store),
      grid: new grid_GridSetuper(this._store),
      logs: new logs_LogsSetuper(this._store),
      navigationCube: new navigation_cube_NavigationCubeSetuper(this._store),
      progressiveRendering: new progressive_rendering_ProgressiveRenderingSetuper(this._store),
      selectionColor: new selection_color_SelectionColorSetuper(this._store),
      selectionMode: new selection_mode_SelectionModeSetuper(this._store),
      showOrigin: new show_origin_ShowOriginSetuper(this._store),
      stagingMemorySize: new staging_memory_size_StagingMemorySizeSetuper(this._store),
      theme: new theme_ThemeSetuper(this._store)
    });
  }

  getOptions() {
    const {
      dictionary
    } = this;
    const res = {};
    let key;

    for (key in dictionary) {
      var _dictionary$key;

      if (!((_dictionary$key = dictionary[key]) !== null && _dictionary$key !== void 0 && _dictionary$key.get)) {
        continue;
      } // @ts-ignore  // res[key] is undefined


      res[key] = dictionary[key].get();
    }

    return res;
  }

  setOptions(options) {
    const {
      dictionary
    } = this;
    let k;

    for (k in options) {
      var _dictionary$k;

      if (!((_dictionary$k = dictionary[k]) !== null && _dictionary$k !== void 0 && _dictionary$k.set)) {
        continue;
      }

      const option = options[k];

      if (option === undefined) {
        continue;
      } // @ts-ignore  // .set(arg: never)


      dictionary[k].set(option);
    }
  }

}

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/presets/ibl/studio_small_01_1k_blurred_bw256.hdr
/* harmony default export */ var studio_small_01_1k_blurred_bw256 = ("data:;base64,Iz9SQURJQU5DRQojIE1hZGUgd2l0aCBBZG9iZSBQaG90b3Nob3AKRk9STUFUPTMyLWJpdF9ybGVfcmdiZQoKLVkgMTI4ICtYIDI1NgoCAgEAg6qHqYSoiKcQqKioqampqqqrq6ysra6ur4qwAa+EsEexsbKztLW1tri5u77Cx8/X4Oft8/mAh4+Yn6WqrrCysrCtqKKblpKPjIqHg/vx6eHa1dDNzMvLy8rKysnIyMfGxcTEw8PCwoTBhcAGv7+/vr6+hL2GvBW7u7u6urm5uLe2tbS0s7KxsK+vrq6ErYSuBa+vsLCwhbGLsgWxsbGwsIaviLAJr6+urq2srKuriaoFq6urrKyJrQasrKurqqqDqoephKiIpxCoqKipqamqqqurrKytrq6virABr4SwR7GxsrO0tbW2uLm7vsLHz9fg5+3z+YCHj5ifpaqusLKysK2oopuWko+MioeD+/Hp4drV0M3My8vLysrKycjIx8bFxMTDw8LChMGFwAa/v7++vr6EvYa8Fbu7u7q6ubm4t7a1tLSzsrGwr6+uroSthK4Fr6+wsLCFsYuyBbGxsbCwhq+IsAmvr66uraysq6uJqgWrq6usrImtBqysq6uqqoOqh6mEqIinEKioqKmpqaqqq6usrK2urq+KsAGvhLBHsbGys7S1tba4ubu+wsfP1+Dn7fP5gIePmJ+lqq6wsrKwraiim5aSj4yKh4P78enh2tXQzczLy8vKysrJyMjHxsXExMPDwsKEwYXABr+/v76+voS9hrwVu7u7urq5ubi3trW0tLOysbCvr66uhK2ErgWvr7CwsIWxi7IFsbGxsLCGr4iwCa+vrq6trKyrq4mqBaurq6ysia0GrKyrq6qqyniXef94oHgCAgEAhKiHp4WmAaWFphGnp6eoqKmpqaqqq6ysra6vr42wSbGxsrKztLW2t7i5u7/Ey9Tf6fP8goePmKSwusLJztHS0c7IvrSrpJ2ZlZKNiIP+9evj3NbSz83NzMzLy8vKycjIx8bFxcTDw8OEwinBwcHAwL+/vr69vb28vLy7u7u6urq5ubi4t7a2tbSzsrGwr6+ura2srIWrBqysrK2trYWuja+DrpGtB6yrq6qqqamIqAWpqamqqoSrhKwJq6urqqqpqamohKiHp4WmAaWFphGnp6eoqKmpqaqqq6ysra6vr42wSbGxsrKztLW2t7i5u7/Ey9Tf6fP8goePmKSwusLJztHS0c7IvrSrpJ2ZlZKNiIP+9evj3NbSz83NzMzLy8vKycjIx8bFxcTDw8OEwinBwcHAwL+/vr69vb28vLy7u7u6urq5ubi4t7a2tbSzsrGwr6+ura2srIWrBqysrK2trYWuja+DrpGtB6yrq6qqqamIqAWpqamqqoSrhKwJq6urqqqpqamohKiHp4WmAaWFphGnp6eoqKmpqaqqq6ysra6vr42wSbGxsrKztLW2t7i5u7/Ey9Tf6fP8goePmKSwusLJztHS0c7IvrSrpJ2ZlZKNiIP+9evj3NbSz83NzMzLy8vKycjIx8bFxcTDw8OEwinBwcHAwL+/vr69vb28vLy7u7u6urq5ubi4t7a2tbSzsrGwr6+ura2srIWrBqysrK2trYWuja+DrpGtB6yrq6qqqamIqAWpqamqqoSrhKwJq6urqqqpqamoyHiaef94n3gCAgEAg6aIpYmkFaWlpaamp6eoqKipqqqrrK2trq+vr4mwdrGxsbKys7O0tbW2t7m8wcfQ2+j0gIaOlqKvvczZ5e70+Pj28ObZzMC1rKWgmpWPioWA9u3k3djT0c/Pzs7NzczLy8rJyMfHxsXFxMTEw8PDwsLBwMC/vr69vLy7u7q6ubm5uLi3tra1tLSzsrGwr66trayrqqqEqQGohqmEqoarh6yEq4SqhKmJqgqpqamoqKenpqamhKWEpgSnp6iohKkNqqqqqampqKiop6empoOmiKWJpBWlpaWmpqenqKioqaqqq6ytra6vr6+JsHaxsbGysrOztLW1tre5vMHH0Nvo9ICGjpair73M2eXu9Pj49vDm2czAtayloJqVj4qFgPbt5N3Y09HPz87Ozc3My8vKycjHx8bFxcTExMPDw8LCwcDAv76+vby8u7u6urm5ubi4t7a2tbS0s7KxsK+ura2sq6qqhKkBqIaphKqGq4eshKuEqoSpiaoKqampqKinp6ampoSlhKYEp6eoqISpDaqqqqmpqaioqKenpqaDpoiliaQVpaWlpqanp6ioqKmqqqusra2ur6+vibB2sbGxsrKzs7S1tba3ubzBx9Db6PSAho6Woq+9zNnl7vT4+Pbw5tnMwLWspaCalY+KhYD27eTd2NPRz8/Ozs3NzMvLysnIx8fGxcXExMTDw8PCwsHAwL++vr28vLu7urq5ubm4uLe2trW0tLOysbCvrq2trKuqqoSpAaiGqYSqhquHrISrhKqEqYmqCqmpqaiop6empqaEpYSmBKenqKiEqQ2qqqqpqamoqKinp6amxnieef94nXgCAgEAiaOKohejo6SkpaWlpqanp6ipqaqrrK2trq6vr4iweLGxsbKysrO0tLW1t7m9w8zW4/KAiJGcqbjJ2+39hoyQkpGPioT56NnLv7WtpZ+YkoyGgPXs5NzX1NLS0dHQ0M/Pzs3My8rJyMjHx8bGxcXEw8LCwcC/vr28u7u6ubm4t7e2tbW0s7OysbCvrq2sq6uqqainp6ampomlh6aMp4Smh6WIpgWlpaWkpISjhKKEowekpKWlpaamh6cIpqalpaWkpKSJo4qiF6OjpKSlpaWmpqenqKmpqqusra2urq+viLB4sbGxsrKys7S0tbW3ub3DzNbj8oCIkZypuMnb7f2GjJCSkY+KhPno2cu/ta2ln5iSjIaA9ezk3NfU0tLR0dDQz8/OzczLysnIyMfHxsbFxcTDwsLBwL++vby7u7q5ubi3t7a1tbSzs7KxsK+urayrq6qpqKenpqamiaWHpoynhKaHpYimBaWlpaSkhKOEooSjB6SkpaWlpqaHpwimpqWlpaSkpImjiqIXo6OkpKWlpaamp6eoqamqq6ytra6ur6+IsHixsbGysrKztLS1tbe5vcPM1uPygIiRnKm4ydvt/YaMkJKRj4qE+ejZy7+1raWfmJKMhoD17OTc19TS0tHR0NDPz87NzMvKycjIx8fGxsXFxMPCwsHAv769vLu7urm5uLe3trW1tLOzsrGwr66trKurqqmop6empqaJpYemjKeEpoeliKYFpaWlpKSEo4SihKMHpKSlpaWmpoenCKampaWlpKSkxXiKeYh6jnn/eJx4AgIBAIKhiqCCn4SgGaGhoqKjo6SkpaWmpqeoqKmqq6ytra6vr6+HsISxhLJvs7O0tbm+xtDd7P2Ikp+uvtHm/IiSm6KnqKiknpaNg/Pi0sW6saigmJGKg/zx6ODa19XV1dTU1NPS0dHPzs3My8rKycjIx8bFxMPCwcC+vby7urm4t7a1tLSzsrGwsK+urayrqqmop6ampaSjo6KihKGGoImhiaKFoYigh6GEoIyfCaCgoaGioqOjo4WkCaOjo6KioqGhoYKhiqCCn4SgGaGhoqKjo6SkpaWmpqeoqKmqq6ytra6vr6+HsISxhLJvs7O0tbm+xtDd7P2Ikp+uvtHm/IiSm6KnqKiknpaNg/Pi0sW6saigmJGKg/zx6ODa19XV1dTU1NPS0dHPzs3My8rKycjIx8bFxMPCwcC+vby7urm4t7a1tLSzsrGwsK+urayrqqmop6ampaSjo6KihKGGoImhiaKFoYigh6GEoIyfCaCgoaGioqOjo4WkCaOjo6KioqGhoYKhiqCCn4SgGaGhoqKjo6SkpaWmpqeoqKmqq6ytra6vr6+HsISxhLJvs7O0tbm+xtDd7P2Ikp+uvtHm/IiSm6KnqKiknpaNg/Pi0sW6saigmJGKg/zx6ODa19XV1dTU1NPS0dHPzs3My8rKycjIx8bFxMPCwcC+vby7urm4t7a1tLSzsrGwsK+urayrqqmop6ampaSjo6KihKGGoImhiaKFoYigh6GEoIyfCaCgoaGioqOjo4WkCaOjo6KioqGhocV4iHmMeox5/3iceAICAQCJnoWdHp6enp+foKChoaKio6OkpaWmp6eoqaqrrK2urq+vr4mwiLEvs7i+yNTi84OPnKy+0+mBjZqlr7e8vr25saickIX249PFua+lnJWNhoD16+Ld2diG1zvW1dTT0tHPzs3My8rJyMfGxcPCwb++vLu5uLe2tLOysbCvrq2sq6qpqKempaSjo6KhoJ+fnp2dnZycnIubj5yYm4aahJsInJydnZ6en5+IoIOfhJ6JnoWdHp6enp+foKChoaKio6OkpaWmp6eoqaqrrK2urq+vr4mwiLEvs7i+yNTi84OPnKy+0+mBjZqlr7e8vr25saickIX249PFua+lnJWNhoD16+Ld2diG1zvW1dTT0tHPzs3My8rJyMfGxcPCwb++vLu5uLe2tLOysbCvrq2sq6qpqKempaSjo6KhoJ+fnp2dnZycnIubj5yYm4aahJsInJydnZ6en5+IoIOfhJ6JnoWdHp6enp+foKChoaKio6OkpaWmp6eoqaqrrK2urq+vr4mwiLEvs7i+yNTi84OPnKy+0+mBjZqlr7e8vr25saickIX249PFua+lnJWNhoD16+Ld2diG1zvW1dTT0tHPzs3My8rJyMfGxcPCwb++vLu5uLe2tLOysbCvrq2sq6qpqKempaSjo6KhoJ+fnp2dnZycnIubj5yYm4aahJsInJydnZ6en5+IoIOfhJ7EeId5j3qMef94m3gCAgEAjZsdnJycnZ2enp+foKGhoqKjpKSlpqeoqKmqq6ytrq6QrzKurq6wtbzH1OX4h5Skt8zk/YyaqbbBytDS0MrCtqmcjoLu28q8saeelo+Igffs5N7b2YbaOtnY19bV1NPR0M/NzMvKyMfFw8LAvry7ube2tLOxsK+trKuqqainpqWjoqGgn56dnJybmpqZmJiXl5eclouVjJaDlYWWCpeXl5iYmZqam5uKnIWbjZsdnJycnZ2enp+foKGhoqKjpKSlpqeoqKmqq6ytrq6QrzKurq6wtbzH1OX4h5Skt8zk/YyaqbbBytDS0MrCtqmcjoLu28q8saeelo+Igffs5N7b2YbaOtnY19bV1NPR0M/NzMvKyMfFw8LAvry7ube2tLOxsK+trKuqqainpqWjoqGgn56dnJybmpqZmJiXl5eclouVjJaDlYWWCpeXl5iYmZqam5uKnIWbjZsdnJycnZ2enp+foKGhoqKjpKSlpqeoqKmqq6ytrq6QrzKurq6wtbzH1OX4h5Skt8zk/YyaqbbBytDS0MrCtqmcjoLu28q8saeelo+Igffs5N7b2YbaOtnY19bV1NPR0M/NzMvKyMfFw8LAvry7ube2tLOxsK+trKuqqainpqWjoqGgn56dnJybmpqZmJiXl5eclouVjJaDlYWWCpeXl5iYmZqam5uKnIWbxHiHeZB6i3n/eJt4AgIBAISYiZkempqam5ucnZ2en5+goaGio6OkpaanqKmpqqusrK2th66FrYKshKturLC4xNPk+YiWqL3W8IaVpLTDz9nf4t/YzsGyo5OF8dvKu7ClnZWOh4H26+Pe29ra29vb3Nzb29rZ2NbV1NLRz87My8nHxcPBv727ube1s7GvrqyrqainpqSjoqGfnp2cm5qZmJeWlpWUlJOTkpKEkZCQgpGIkImPkJCFkQuSkpOTlJSVlpaXl46YhJiJmR6ampqbm5ydnZ6fn6ChoaKjo6Slpqeoqamqq6ysra2HroWtgqyEq26ssLjE0+T5iJaovdbwhpWktMPP2d/i39jOwbKjk4Xx28q7sKWdlY6Hgfbr497b2trb29vc3Nvb2tnY1tXU0tHPzszLycfFw8G/vbu5t7Wzsa+urKupqKempKOioZ+enZybmpmYl5aWlZSUk5OSkoSRkJCCkYiQiY+QkIWRC5KSk5OUlJWWlpeXjpiEmImZHpqampubnJ2dnp+foKGhoqOjpKWmp6ipqaqrrKytrYeuha2CrISrbqywuMTT5PmIlqi91vCGlaS0w8/Z3+Lf2M7BsqOThfHbyruwpZ2VjoeB9uvj3tva2tvb29zc29va2djW1dTS0c/OzMvJx8XDwb+9u7m3tbOxr66sq6mop6ako6Khn56dnJuamZiXlpaVlJSTk5KShJGQkIKRiJCJj5CQhZELkpKTk5SUlZaWl5eOmMR4hnmReot5/3ibeAICAQCClYWWhZcfmJiYmZmam5ucnZ2en5+goaGio6SlpqanqKmqqqurq4SshKs9qqqpqaiop6empqers7/P4feHlqm/2faKmqq7ytjj6uvo4NTGtqWUhe7XxLaqoZiRioT98unh3NnZ2trb24TcOdvb2tjX1tTT0c/Ny8nHxcLAvru5trSysK6sqqinpaSioZ+enZuamZeWlZSTkpKRkI+Pjo6NjYyMjI+LiYyEi4OKhYmGioyLhIwMjY2Ojo+PkJGRkpOThJSJlYKVhZaFlx+YmJiZmZqbm5ydnZ6fn6ChoaKjpKWmpqeoqaqqq6urhKyEqz2qqqmpqKinp6amp6uzv8/h94eWqb/Z9oqaqrvK2OPq6+jg1Ma2pZSF7tfEtqqhmJGKhP3y6eHc2dna2tvbhNw529va2NfW1NPRz83LycfFwsC+u7m2tLKwrqyqqKelpKKhn56dm5qZl5aVlJOSkpGQj4+Ojo2NjIyMj4uJjISLg4qFiYaKjIuEjAyNjY6Oj4+QkZGSk5OElImVgpWFloWXH5iYmJmZmpubnJ2dnp+foKGhoqOkpaamp6ipqqqrq6uErISrPaqqqamoqKenpqanq7O/z+H3h5apv9n2ipqqu8rY4+rr6ODUxrallIXu18S2qqGYkYqE/fLp4dzZ2dra29uE3Dnb29rY19bU09HPzcvJx8XCwL67uba0srCurKqop6WkoqGfnp2bmpmXlpWUk5KSkZCPj46OjY2MjIyPi4mMhIuDioWJhoqMi4SMDI2Njo6Pj5CRkZKTk4SUiZXEeIZ5kXqKef94nHgCAgEABJKTk5OElISVHZaWl5eYmJmampucnZ2en5+goaKio6SlpqanqKiohal/qKiop6empaWkpKOioqGhoqatucnc8YWTpr3X9YqbrLzN2+bs7enh1MW0opGB5s67raKZkYuF//Xs493Y1tbX2Nna29vc3Nvb2tnY19XU0tDOy8nHxMG/vLm2tLGvrKqopqSioZ+dnJqZl5aVk5KRkI+OjYyLi4qJiYiIiIeHh4aGDIeHiImKi4yNjY6PkIWRDZCPjo6Mi4qJiIeHhoaLhYmGEoeHh4iIiYqKi4yMjY6Oj5CQkIaRg5IEkpOTk4SUhJUdlpaXl5iYmZqam5ydnZ6fn6ChoqKjpKWmpqeoqKiFqX+oqKinp6alpaSko6KioaGipq25ydzxhZOmvdf1ipusvM3b5uzt6eHUxbSikYHmzrutopmRi4X/9ezj3djW1tfY2drb29zc29va2djX1dTS0M7LycfEwb+8uba0sa+sqqimpKKhn52cmpmXlpWTkpGQj46NjIuLiomJiIiIh4eHhoYMh4eIiYqLjI2Njo+QhZENkI+OjoyLiomIh4eGhouFiYYSh4eHiIiJioqLjIyNjo6PkJCQhpGDkgSSk5OThJSElR2WlpeXmJiZmpqbnJ2dnp+foKGioqOkpaamp6ioqIWpf6ioqKenpqWlpKSjoqKhoaKmrbnJ3PGFk6a91/WKm6y8zdvm7O3p4dTFtKKRgebOu62imZGLhf/17OPd2NbW19jZ2tvb3Nzb29rZ2NfV1NLQzsvJx8TBv7y5trSxr6yqqKakoqGfnZyamZeWlZOSkZCPjo2Mi4uKiYmIiIiHh4eGhgyHh4iJiouMjY2Oj5CFkQ2Qj46OjIuKiYiHh4aGi4WJhhKHh4eIiImKiouMjI2Ojo+QkJCGkYOSxHiGeZF6iXn/eJ14AgIBAAiQkJCRkZKSkoSTGpSUlZWWl5eYmZmam5ycnZ6en6ChoaKjo6Skh6VGpKSjo6KhoaCfn56dnZybm5ygp7PB1OiAjqC30e+HmKi5ydfh5+jj2s2+rZyK9dnCsKKYkImD/fPq4tvW0tDR0tTV1tjZ2YTaYdnY19XU0tDOy8nGw8C9ure0sa6rqaakoqCenJqZl5WUkpGPjo2LiomIh4eGhYWEhIODg4KCgoOEhIaHiYuOkZOWmZyfoaOlp6ipqamop6akoqCdm5iWk5GOjImHhoSDgoGGgIeBFYKCgoODhISFhoeHiImKiouMjI2NjYSOgo8IkJCQkZGSkpKEkxqUlJWVlpeXmJmZmpucnJ2enp+goaGio6OkpIelRqSko6OioaGgn5+enZ2cm5ucoKezwdTogI6gt9Hvh5ioucnX4efo49rNvq2civXZwrCimJCJg/3z6uLb1tLQ0dLU1dbY2dmE2mHZ2NfV1NLQzsvJxsPAvbq3tLGuq6mmpKKgnpyamZeVlJKRj46Ni4qJiIeHhoWFhISDg4OCgoKDhISGh4mLjpGTlpmcn6GjpaeoqampqKempKKgnZuYlpORjoyJh4aEg4KBhoCHgRWCgoKDg4SEhYaHh4iJioqLjIyNjY2EjoKPCJCQkJGRkpKShJMalJSVlZaXl5iZmZqbnJydnp6foKGhoqOjpKSHpUakpKOjoqGhoJ+fnp2dnJubnKCns8HU6ICOoLfR74eYqLnJ1+Hn6OPazb6tnIr12cKwopiQiYP98+ri29bS0NHS1NXW2NnZhNph2djX1dTS0M7LycbDwL26t7SxrquppqSioJ6cmpmXlZSSkY+OjYuKiYiHh4aFhYSEg4ODgoKCg4SEhoeJi46Rk5aZnJ+ho6WnqKmpqainpqSioJ2bmJaTkY6MiYeGhIOCgYaAh4EVgoKCg4OEhIWGh4eIiYqKi4yMjY2NhI6Cj8R4hnmQeol5/3ieeAICAQAkjI2Njo6Pj5CQkJGRkpKTk5SUlZaWl5iZmZqbm5ydnZ6fn6CghqFKoKCgn56dnZybmpmZmJeXlpWVlJaaoay5yd30h5iux+OAkKCwv8zV29vWzcGyopKB5su1pJeOhoD37uXd1tHNysnKy83P0dLU1daE12TW1dTT0c/NysfEwb66t7SxraqopaKgnpyZmJaUkpCPjYuKiYeGhYSDgoKBgYCA//+AgIGDhYeKjpKXnKKnrbO4vsPIzM/S1dbY2NfW1NLPzMnFwb25trGspqGblpGNiISB/vv5h/gd+fn6+vv8/f7/gIGCgoOEhYaGh4iIiYmKiouLjIwkjI2Njo6Pj5CQkJGRkpKTk5SUlZaWl5iZmZqbm5ydnZ6fn6CghqFKoKCgn56dnZybmpmZmJeXlpWVlJaaoay5yd30h5iux+OAkKCwv8zV29vWzcGyopKB5su1pJeOhoD37uXd1tHNysnKy83P0dLU1daE12TW1dTT0c/NysfEwb66t7SxraqopaKgnpyZmJaUkpCPjYuKiYeGhYSDgoKBgYCA//+AgIGDhYeKjpKXnKKnrbO4vsPIzM/S1dbY2NfW1NLPzMnFwb25trGspqGblpGNiISB/vv5h/gd+fn6+vv8/f7/gIGCgoOEhYaGh4iIiYmKiouLjIwkjI2Njo6Pj5CQkJGRkpKTk5SUlZaWl5iZmZqbm5ydnZ6fn6CghqFKoKCgn56dnZybmpmZmJeXlpWVlJaaoay5yd30h5iux+OAkKCwv8zV29vWzcGyopKB5su1pJeOhoD37uXd1tHNysnKy83P0dLU1daE12TW1dTT0c/NysfEwb66t7SxraqopaKgnpyZmJaUkpCPjYuKiYeGhYSDgoKBgYCA//+AgIGDhYeKjpKXnKKnrbO4vsPIzM/S1dbY2NfW1NLPzMnFwb25trGspqGblpGNiISB/vv5h/gd+fn6+vv8/f7/gIGCgoOEhYaGh4iIiYmKiouLjIzFeIV5kHqIecR4gnexeJN3lHgCAgEAIYmKiouLjIyNjY6Oj4+PkJCRkpKTlJWVlpeXmJmZmpqbm4ecTZubmpqZmJeXlpWUk5KRkZCPj46Ojo+TmqSwvtDl/o6iudPvhZSisLvEycnEvLCjlIXu07unl4yE/PHo39fQysXCwMDBw8XHycvNz9HShdOA0tHPzcvIxcK/u7i0sa2qp6ShnpyZl5WTkY+NjIqIh4WEgoGA//78+/r5+fn8gIOGio+WnKSstb7G0Nni6vP6gYSHiYuNjo+Pjo2MioiGhIH++fXw6uPa0ci/taugl46Hgv348/Hv7+7u7+/w8PHy8/T29/n6/P5/gIGCg4OEhYUGhoeHiIiJIYmKiouLjIyNjY6Oj4+PkJCRkpKTlJWVlpeXmJmZmpqbm4ecTZubmpqZmJeXlpWUk5KRkZCPj46Ojo+TmqSwvtDl/o6iudPvhZSisLvEycnEvLCjlIXu07unl4yE/PHo39fQysXCwMDBw8XHycvNz9HShdOA0tHPzcvIxcK/u7i0sa2qp6ShnpyZl5WTkY+NjIqIh4WEgoGA//78+/r5+fn8gIOGio+WnKSstb7G0Nni6vP6gYSHiYuNjo+Pjo2MioiGhIH++fXw6uPa0ci/taugl46Hgv348/Hv7+7u7+/w8PHy8/T29/n6/P5/gIGCg4OEhYUGhoeHiIiJIYmKiouLjIyNjY6Oj4+PkJCRkpKTlJWVlpeXmJmZmpqbm4ecTZubmpqZmJeXlpWUk5KRkZCPj46Ojo+TmqSwvtDl/o6iudPvhZSisLvEycnEvLCjlIXu07unl4yE/PHo39fQysXCwMDBw8XHycvNz9HShdOA0tHPzcvIxcK/u7i0sa2qp6ShnpyZl5WTkY+NjIqIh4WEgoGA//78+/r5+fn8gIOGio+WnKSstb7G0Nni6vP6gYSHiYuNjo+Pjo2MioiGhIH++fXw6uPa0ci/taugl46Hgv348/Hv7+7u7+/w8PHy8/T29/n6/P5/gIGCg4OEhYUGhoeHiIiJxniFeY56h3m+eIl3kniReZF4lnePeAICAQAfhoaHiIiJiYqKi4uLjIyNjY6Pj5CRkZKTk5SVlZaWloeXEZaWlZSUk5KRkI+OjYyLiomJhIiAh4iJjZObpbLB1OuElqnA1/GFkp6or7OzsKiekoXx17+qmYuC9+zj3NTMxcC8ubi4ubq8vsDDxcfJy8zNzs7Pzs3MysjGw7+8uLWxraqmo6CdmpiVk5GPjYuJh4WEgoF//fv59/X08/P1+f+Ei5OcprG9ytfl8v6Fi5GXnaOorbFFtbi6vL6+vr28uri1s7Ctqqelop6alI6IgfPi0cGxo5iOhoD38Ovo5uXm5ubn6Onq7O3v8fL09vj6/P3/gIGBgoODhISFH4aGh4iIiYmKiouLi4yMjY2Oj4+QkZGSk5OUlZWWlpaHlxGWlpWUlJOSkZCPjo2Mi4qJiYSIgIeIiY2Tm6WywdTrhJapwNfxhZKeqK+zs7ConpKF8de/qpmLgvfs49zUzMXAvLm4uLm6vL7Aw8XHycvMzc7Oz87NzMrIxsO/vLi1sa2qpqOgnZqYlZORj42LiYeFhIKBf/37+ff19PPz9fn/hIuTnKaxvcrX5fL+hYuRl52jqK2xRbW4ury+vr69vLq4tbOwraqnpaKempSOiIHz4tHBsaOYjoaA9/Dr6Obl5ubm5+jp6uzt7/Hy9Pb4+vz9/4CBgYKDg4SEhR+GhoeIiImJioqLi4uMjI2Njo+PkJGRkpOTlJWVlpaWh5cRlpaVlJSTkpGQj46NjIuKiYmEiICHiImNk5ulssHU64SWqcDX8YWSnqivs7OwqJ6ShfHXv6qZi4L37OPc1MzFwLy5uLi5ury+wMPFx8nLzM3Ozs/OzczKyMbDv7y4tbGtqqajoJ2amJWTkY+Ni4mHhYSCgX/9+/n39fTz8/X5/4SLk5ymsb3K1+Xy/oWLkZedo6itsUW1uLq8vr6+vby6uLWzsK2qp6WinpqUjoiB8+LRwbGjmI6GgPfw6+jm5ebm5ufo6ers7e/x8vT2+Pr8/f+AgYGCg4OEhIXGeIZ5jHqHebx4i3eMeKJ5iniZd4l4AgIBAB2CgoOEhIWFhoeHh4iIiYmKiouMjI2Ojo+PkJCRkYaSFJGRkI+Pjo2Mi4qJh4aFhYSDgoKChIEugoKEhouSmqazxNnyh5iqvtTqgIqTmp2dmpSMgu3WwKyajIH06uPc1s/HwLu3tISygLO1t7m7vsDCxMbHyMnJyMfGxMK/vLi1sa2ppqKfnJmWlJGPjYqIhoWDgYD9+vj18/Hw7/Dy+ICGj5upuMnb7YCJk5ykrbS8xMzU2+Ln7fH1+Pr7+/v6+Pbz8O3p5uPg3dnV0MrCurCmmo+C7tjEsqOWi4L47ebh3t3d3t/g4eLkE+Xn6evt7/Dy9Pb4+fv8/v+AgYEdgoKDhISFhYaHh4eIiImJioqLjIyNjo6Pj5CQkZGGkhSRkZCPj46NjIuKiYeGhYWEg4KCgoSBLoKChIaLkpqms8TZ8oeYqr7U6oCKk5qdnZqUjILt1sCsmoyB9Orj3NbPx8C7t7SEsoCztbe5u77AwsTGx8jJycjHxsTCv7y4tbGtqaain5yZlpSRj42KiIaFg4GA/fr49fPx8O/w8viAho+bqbjJ2+2AiZOcpK20vMTM1Nvi5+3x9fj6+/v7+vj28/Dt6ebj4N3Z1dDKwrqwppqPgu7YxLKjlouC+O3m4d7d3d7f4OHi5BPl5+nr7e/w8vT2+Pn7/P7/gIGBHYKCg4SEhYWGh4eHiIiJiYqKi4yMjY6Oj4+QkJGRhpIUkZGQj4+OjYyLiomHhoWFhIOCgoKEgS6CgoSGi5KaprPE2fKHmKq+1OqAipOanZ2alIyC7dbArJqMgfTq49zWz8fAu7e0hLKAs7W3ubu+wMLExsfIycnIx8bEwr+8uLWxrammop+cmZaUkY+NioiGhYOBgP36+PXz8fDv8PL4gIaPm6m4ydvtgImTnKSttLzEzNTb4uft8fX4+vv7+/r49vPw7enm4+Dd2dXQysK6sKaaj4Lu2MSyo5aLgvjt5uHe3d3e3+Dh4uQT5efp6+3v8PL09vj5+/z+/4CBgcd4hnmKeod5uniLd4l4rHmIeJ13g3gCAgEAGvz9/oCAgYGCgoODhISFhYaGh4iIiYmKiouLiIyAi4uKiYiHhoWEgoGA//37+vj39/b29/f4+vv9/4GFipKbp7bH2/KGlKW3y97w/4WIiYaB9eTRvqycjoP27Obi3djQycK8t7Oxrq2srKyur7Gztri6vb/AwcLCwsG/vbu4tLGtqaain5uYlZOQjouJh4WDgf/8+fb08e/t7O3x94FeiJOhssfe94iVo7C8ydTf6fP9g4iMkZWZnJ+hoqOkpKSjoqCfnZuZl5WTkY+NioaC+e7h0sOzpJSG8djCr56Qhfjq4NrX1tbX2Nnb3N7g4ePl5+nr7e/w8vP19vj5+xr8/f6AgIGBgoKDg4SEhYWGhoeIiImJioqLi4iMgIuLiomIh4aFhIKBgP/9+/r49/f29vf3+Pr7/f+BhYqSm6e2x9vyhpSlt8ve8P+FiImGgfXk0b6snI6D9uzm4t3Y0MnCvLezsa6trKysrq+xs7a4ur2/wMHCwsLBv727uLSxrammop+bmJWTkI6LiYeFg4H//Pn29PHv7ezt8feBXoiTobLH3veIlaOwvMnU3+nz/YOIjJGVmZyfoaKjpKSko6Kgn52bmZeVk5GPjYqGgvnu4dLDs6SUhvHYwq+ekIX46uDa19bW19jZ29ze4OHj5efp6+3v8PLz9fb4+fsa/P3+gICBgYKCg4OEhIWFhoaHiIiJiYqKi4uIjICLi4qJiIeGhYSCgYD//fv6+Pf39vb39/j6+/3/gYWKkpuntsfb8oaUpbfL3vD/hYiJhoH15NG+rJyOg/bs5uLd2NDJwry3s7GuraysrK6vsbO2uLq9v8DBwsLCwb+9u7i0sa2ppqKfm5iVk5COi4mHhYOB//z59vTx7+3s7fH3gV6Ik6Gyx973iJWjsLzJ1N/p8/2DiIyRlZmcn6Gio6SkpKOioJ+dm5mXlZORj42KhoL57uHSw7OklIbx2MKvnpCF+Org2tfW1tfY2dvc3uDh4+Xn6evt7/Dy8/X2+Pn7g3ereJB3iniIeYV6iHm4eIx3iHiLeZ56iXmHeJ53AgIBABjz9PX2+Pn6+/z+/v+AgIGBgoKDg4SEhYWJhlmFhIOCgYD+/Pn39PLw7uzr6unp6erq7O3v8vT3+/6ChoyVn6y5ydrtgo+er8DP3Obs7erj2Mu7rZ+SiID48u7r5+Ha0srDvri0sKypp6amp6ipq66wsrW3uIS6QLm4tbOwrKmlop6bl5WSj4yKiIWDgYD9+fbz8O7s6+zw+IKKl6a60u6Gl6m7zN7u/YaNk5qgpqyxt73CxsrNz9CE0T7Qz83LycfFwsC+u7m2sq6po5yUjIPy38u4ppWE69G5pZOG9uba1NDP0NHS09XX2Nrc3t/h4+Xn6Orr7e7w8Rjz9PX2+Pn6+/z+/v+AgIGBgoKDg4SEhYWJhlmFhIOCgYD+/Pn39PLw7uzr6unp6erq7O3v8vT3+/6ChoyVn6y5ydrtgo+er8DP3Obs7erj2Mu7rZ+SiID48u7r5+Ha0srDvri0sKypp6amp6ipq66wsrW3uIS6QLm4tbOwrKmlop6bl5WSj4yKiIWDgYD9+fbz8O7s6+zw+IKKl6a60u6Gl6m7zN7u/YaNk5qgpqyxt73CxsrNz9CE0T7Qz83LycfFwsC+u7m2sq6po5yUjIPy38u4ppWE69G5pZOG9uba1NDP0NHS09XX2Nrc3t/h4+Xn6Orr7e7w8Rjz9PX2+Pn6+/z+/v+AgIGBgoKDg4SEhYWJhlmFhIOCgYD+/Pn39PLw7uzr6unp6erq7O3v8vT3+/6ChoyVn6y5ydrtgo+er8DP3Obs7erj2Mu7rZ+SiID48u7r5+Ha0srDvri0sKypp6amp6ipq66wsrW3uIS6QLm4tbOwrKmlop6bl5WSj4yKiIWDgYD9+fbz8O7s6+zw+IKKl6a60u6Gl6m7zN7u/YaNk5qgpqyxt73CxsrNz9CE0T7Qz83LycfFwsC+u7m2sq6po5yUjIPy38u4ppWE69G5pZOG9uba1NDP0NHS09XX2Nrc3t/h4+Xn6Orr7e7w8Yx3m3iYd4p4lHm3eIt3h3iIeal6h3mGeJx3AgIBABbo6uvs7u/w8fLz9Pb39/j5+vv8/f7/ioBb/vz6+Pbz8O7r6Obj4eDe3dzc3N3e3+Hj5uns8PX6/4KGi5KbprG9ydfp/oyZqLS/x8zOzcnCuK6jmpGLh4WDgoD89u7k29PKw7y1r6qmo6GgoKGio6WoqqyvsISygLGvraqopKGdmpeUkY6LiYeEgoD++/f08e7s6+vv94KMmqvB3PuPo7jP5fuIkpylrbW9xMvS2eDn7fP4/P6AgIGBgYCA/vz6+fb08e/s6ebj39rUzsa+tKmek4f44su2oo/73MColIXx4NTNysnKy8zOz9HS1NbX2dvd3uDh4+TmAecW6Orr7O7v8PHy8/T29/f4+fr7/P3+/4qAW/78+vj28/Du6+jm4+Hg3t3c3Nzd3t/h4+bp7PD1+v+ChouSm6axvcnX6f6Mmai0v8fMzs3Jwriuo5qRi4eFg4KA/Pbu5NvTysO8ta+qpqOhoKChoqOlqKqsr7CEsoCxr62qqKShnZqXlJGOi4mHhIKA/vv39PHu7Ovr7/eCjJqrwdz7j6O4z+X7iJKcpa21vcTL0tng5+3z+Pz+gICBgYGAgP78+vn29PHv7Onm49/a1M7GvrSpnpOH+OLLtqKP+9zAqJSF8eDUzcrJysvMzs/R0tTW19nb3d7g4ePk5gHnFujq6+zu7/Dx8vP09vf3+Pn6+/z9/v+KgFv+/Pr49vPw7uvo5uPh4N7d3Nzc3d7f4ePm6ezw9fr/goaLkpumsb3J1+n+jJmotL/HzM7NycK4rqOakYuHhYOCgPz27uTb08rDvLWvqqajoaCgoaKjpaiqrK+whLKAsa+tqqikoZ2al5SRjouJh4SCgP779/Tx7uzr6+/3goyaq8Hc+4+juM/l+4iSnKWttb3Ey9LZ4Oft8/j8/oCAgYGBgID+/Pr59vTx7+zp5uPf2tTOxr60qZ6Th/jiy7aij/vcwKiUhfHg1M3KycrLzM7P0dLU1tfZ293e4OHj5OYB55Z3inifd4x4lnmxeIt3h3iGeZJ6h3uXeoZ5hniadwICAQAX3t/g4ePk5ebn6err7O3u7/Dx8vP09PWF9oD19fPy8O3r6OXj4N3a19XT0tHQz8/Q0dLU19rd4ebr8Pf9goWJjZObpK63v8rX6P2KlqCor7S2uLe0r6iinZqYmJmYl5WSjomD++7g1Mm/t6+ppJ+cmpmZmpudn6KkpqipqqqpqKelop+cmZaTkI2KiIWDgYD8+fbz8O7s6+/2gh+Mm67F4oKVrMPd94iWo6+6xc/Y4eny+oCEiIyPkpWXhpg/l5aWlZSTkpGPjo2LioiGg4D68unf1Me7rqGThvTbw6yWguLCqJKB6dfLxcPCxMXGyMnKzM7P0dLU1dfY2tvcF97f4OHj5OXm5+nq6+zt7u/w8fLz9PT1hfaA9fXz8vDt6+jl4+Dd2tfV09LR0M/P0NHS1Nfa3eHm6/D3/YKFiY2Tm6Sut7/K1+j9ipagqK+0tri3tK+oop2amJiZmJeVko6Jg/vu4NTJv7evqaSfnJqZmZqbnZ+ipKaoqaqqqainpaKfnJmWk5CNioiFg4GA/Pn28/Du7Ovv9oIfjJuuxeKClazD3feIlqOvusXP2OHp8vqAhIiMj5KVl4aYP5eWlpWUk5KRj46Ni4qIhoOA+vLp39THu66hk4b028OsloLiwqiSgenXy8XDwsTFxsjJyszOz9HS1NXX2Nrb3Bfe3+Dh4+Tl5ufp6uvs7e7v8PHy8/T09YX2gPX18/Lw7evo5ePg3drX1dPS0dDPz9DR0tTX2t3h5uvw9/2ChYmNk5ukrre/ytfo/YqWoKivtLa4t7SvqKKdmpiYmZiXlZKOiYP77uDUyb+3r6mkn5yamZmam52foqSmqKmqqqmop6Win5yZlpOQjYqIhYOBgPz59vPw7uzr7/aCH4ybrsXigpWsw933iJajr7rFz9jh6fL6gISIjI+SlZeGmD+XlpaVlJOSkY+OjYuKiIaDgPry6d/Ux7uuoZOG9NvDrJaC4sKokoHp18vFw8LExcbIycrMzs/R0tTV19ja29y+d454mXmseIp3hniGeYx6n3uLeoZ5hXiYdwICAQAs0tPV1tfY2tvc3d7g4eLk5ebn6Onp6urr6+rq6ejn5uPh3tzZ1tPQzcrIxsWExIDFx8jLztLW2+Dm7fT8goaKjpOYn6eutbzEztztgIqSmZ6jp6qsrayqqamqrbK2uLe1saylnpWLge7dz8O4r6ehm5eUk5KSk5WXmZudn6ChoaGgnpyal5SRj4yJh4SCgP77+PXy8O3s7vSAi5qtxuSEmbDK5oGQn669y9jl8PuChwuLkJSYnaGkqKqtroSvQa6trKuqqqmop6ako6KhoJ6cmpeTj4qF/vHk1se5qpyOgOXLsZmD4L+ijPXcy8C8vL2+v8DCw8XGx8nKy8zOz9DRLNLT1dbX2Nrb3N3e4OHi5OXm5+jp6erq6+vq6uno5+bj4d7c2dbT0M3KyMbFhMSAxcfIy87S1tvg5u30/IKGio6TmJ+nrrW8xM7c7YCKkpmeo6eqrK2sqqmpqq2ytri3tbGspZ6Vi4Hu3c/DuK+noZuXlJOSkpOVl5mbnZ+goaGhoJ6cmpeUkY+MiYeEgoD++/j18vDt7O70gIuarcbkhJmwyuaBkJ+uvcvY5fD7gocLi5CUmJ2hpKiqra6Er0GurayrqqqpqKempKOioaCenJqXk4+Khf7x5NbHuaqcjoDly7GZg+C/ooz13MvAvLy9vr/AwsPFxsfJysvMzs/Q0SzS09XW19ja29zd3uDh4uTl5ufo6enq6uvr6urp6Ofm4+He3NnW09DNysjGxYTEgMXHyMvO0tbb4Obt9PyChoqOk5ifp661vMTO3O2AipKZnqOnqqytrKqpqaqtsra4t7WxrKWelYuB7t3Pw7ivp6Gbl5STkpKTlZeZm52foKGhoaCenJqXlJGPjImHhIKA/vv49fLw7ezu9ICLmq3G5ISZsMrmgZCfrr3L2OXw+4KHC4uQlJidoaSoqq2uhK9Brq2sq6qqqainpqSjoqGgnpyal5OPioX+8eTWx7mqnI6A5cuxmYPgv6KM9dzLwLy8vb6/wMLDxcbHycrLzM7P0NG9d494nHmneIp3hniFeYp6qHuKeoV5hHiXdwICAQAUx8jJysvMzs/Q0tPV1tja29zd3t+E4Gbf397d3NrY1dPQzcrHxMG/vbu6ubm5uru9wMPHy9DW3OPr9P2DiI2RlpugpayyuL7Fzdnm94OKj5Wan6WqrrCztrvCydLZ3uDe2tTMwrWnmIn65dTGua6lnZeSjoyLi4yNj5GTlZeEmDiXlpSSj42KiIWDgf/8+fbz8e/t7O/6hpSowuGDmLDM6YSUpLTF1eX0gYeNk5idoqaqr7O3ur3AwoTDQsLBv769vLu6ubi3trW0tLOysK6sqKSgmpSNhv7v39DBsaKThOnLr5X91bKWgN7Iu7a2t7i5uru8vb6/wMHCw8TFxhTHyMnKy8zOz9DS09XW2Nrb3N3e34TgZt/f3t3c2tjV09DNysfEwb+9u7q5ubm6u73Aw8fL0Nbc4+v0/YOIjZGWm6ClrLK4vsXN2eb3g4qPlZqfpaqusLO2u8LJ0tne4N7a1MzCtaeYifrl1Ma5rqWdl5KOjIuLjI2PkZOVl4SYOJeWlJKPjYqIhYOB//z59vPx7+3s7/qGlKjC4YOYsMzphJSktMXV5fSBh42TmJ2ipqqvs7e6vcDChMNCwsG/vr28u7q5uLe2tbS0s7KwrqyopKCalI2G/u/f0MGxopOE6cuvlf3VspaA3si7tra3uLm6u7y9vr/AwcLDxMXGFMfIycrLzM7P0NLT1dbY2tvc3d7fhOBm39/e3dza2NXT0M3Kx8TBv727urm5ubq7vcDDx8vQ1tzj6/T9g4iNkZaboKWssri+xc3Z5veDio+Vmp+lqq6ws7a7wsnS2d7g3trUzMK1p5iJ+uXUxrmupZ2Xko6Mi4uMjY+Rk5WXhJg4l5aUko+NioiFg4H//Pn28/Hv7ezv+oaUqMLhg5iwzOmElKS0xdXl9IGHjZOYnaKmqq+zt7q9wMKEw0LCwb++vby7urm4t7a1tLSzsrCurKikoJqUjYb+79/QwbGik4Tpy6+V/dWyloDeyLu2tre4ubq7vL2+v8DBwsPExca8d5F4nHmkeIt3hXiFeYh6r3uJeoR5hXiVdwICAQB/u7y9vr/BwsPExsjKzM7Q0tPV1tbX19fW1dTS0c/Ny8jFwr+8uba0srGwr6+wsbO2uLzBxszT2uLr9f+EipCWm6Clqq+1usDFzNTd6faBh42TmaCnrrS7wcnT3ur2gISHh4WB+ezcybWikIHr18e4rKGZkoyIhYSDhIWHiYuNjoSQfY+OjIqIhoSBgPz59vTy8O7s7fD8iZy11PmSq8fmg5Slt8na7P2Gjpaco6itsba6vsLFycvO0NLT09PS0M/NzMrJyMbFxMPCwsLBwcC/vry6t7Ktp6GakoqC9uXVxbSkk4LiwqSK5r6cgdzDtrGwsbKzs7S0tba2t7e4ubq6f7u8vb6/wcLDxMbIyszO0NLT1dbW19fX1tXU0tHPzcvIxcK/vLm2tLKxsK+vsLGztri8wcbM09ri6/X/hIqQlpugpaqvtbrAxczU3en2gYeNk5mgp660u8HJ097q9oCEh4eFgfns3Mm1opCB69fHuKyhmZKMiIWEg4SFh4mLjY6EkH2PjoyKiIaEgYD8+fb08vDu7O3w/ImctdT5kqvH5oOUpbfJ2uz9ho6WnKOorbG2ur7CxcnLztDS09PT0tDPzczKycjGxcTDwsLCwcHAv768ureyraehmpKKgvbl1cW0pJOC4sKkiua+nIHcw7axsLGys7O0tLW2tre3uLm6un+7vL2+v8HCw8TGyMrMztDS09XW1tfX19bV1NLRz83LyMXCv7y5trSysbCvr7Cxs7a4vMHGzNPa4uv1/4SKkJaboKWqr7W6wMXM1N3p9oGHjZOZoKeutLvBydPe6vaAhIeHhYH57NzJtaKQgevXx7isoZmSjIiFhIOEhYeJi42OhJB9j46MioiGhIGA/Pn29PLw7uzt8PyJnLXU+ZKrx+aDlKW3ydrs/YaOlpyjqK2xtrq+wsXJy87Q0tPT09LQz83MysnIxsXEw8LCwsHBwL++vLq3sq2noZqSioL25dXFtKSTguLCpIrmvpyB3MO2sbCxsrOztLS1tra3t7i5urq7d5J4kHmGeoh5oXiLd4V4hHmIerR7iHqEeYR4lHcCAgEAErCxsrO0tba3ubu9v8HEx8nLzIXOac3LycfFw8G+vLm2s7Ctq6mop6enqKqsr7O3vMLJ0drj7fiCiI+Vm6KorbO4vcHGzNHY3+fx/ISJkJeepq63wMnU4O38ho6Vm5+gn5uVjYPv176olITt18W2qZ2UjIaB/vv6+/2AgYOFh4SISIeGhYOBgPz59vPx7+7s7Ozx/Yufu9+FnrrZ+4+itcjb7YCJkpqiqa+1ur7CxcjLz9LU19nc3t/f3t3b2dfV09HQzs3LysnJyYXIJ8fFw8C8t7GrpJ2VjYX56NbEsp+M8s+ukO7CnYDYv7KtrKysra2trIStBK6urq8SsLGys7S1tre5u72/wcTHycvMhc5pzcvJx8XDwb68ubazsK2rqainp6eoqqyvs7e8wsnR2uPt+IKIj5Wboqits7i9wcbM0djf5/H8hImQl56mrrfAydTg7fyGjpWbn6Cfm5WNg+/XvqiUhO3XxbapnZSMhoH++/r7/YCBg4WHhIhIh4aFg4GA/Pn28/Hv7uzs7PH9i5+734Weutn7j6K1yNvtgImSmqKpr7W6vsLFyMvP0tTX2dze39/e3dvZ19XT0dDOzcvKycnJhcgnx8XDwLy3sauknZWNhfno1sSyn4zyz66Q7sKdgNi/sq2srKytra2shK0Erq6urxKwsbKztLW2t7m7vb/BxMfJy8yFzmnNy8nHxcPBvry5trOwraupqKenp6iqrK+zt7zCydHa4+34goiPlZuiqK2zuL3BxszR2N/n8fyEiZCXnqaut8DJ1ODt/IaOlZufoJ+blY2D79e+qJSE7dfFtqmdlIyGgf77+vv9gIGDhYeEiEiHhoWDgYD8+fbz8e/u7Ozs8f2Ln7vfhZ662fuPorXI2+2AiZKaoqmvtbq+wsXIy8/S1NfZ3N7f397d29nX1dPR0M7Ny8rJycmFyCfHxcPAvLexq6SdlY2F+ejWxLKfjPLPrpDuwp2A2L+yraysrK2trayErQSurq6vuXeUeI55i3qGeYp4hXePeIx3hHiFeYZ6uXuHeoR5hHiTdwICAQCApaWmp6ipqqyusLK1uLu+wcPFx8jIx8bEwsC+u7i2s7Ctq6imo6KgoKChoqSnq6+0usHK097p9YGIj5aepq60u8HGys/T19vg5u30/YOJj5eepq+5w87a5/eEjZehq7O4u7q2r6aajPzfxKuWhO3Ww7KkmI6GgPfx7u3t7/L2+v0BgISBRYD//Pr39PLv7ezr6urr8P2Ln7ziiKTD5oWZrcLW6/6Ikpujq7K5vsPGyczO0NPV19rc3+Lj5OPi4N7c2dfV1NLQz83LyoTJhcomyMfEwby3squlnZWNhPfl0LymkfvVsZHsvpj50ruuqainp6ampaWEpAOjpKSApaWmp6ipqqyusLK1uLu+wcPFx8jIx8bEwsC+u7i2s7Ctq6imo6KgoKChoqSnq6+0usHK097p9YGIj5aepq60u8HGys/T19vg5u30/YOJj5eepq+5w87a5/eEjZehq7O4u7q2r6aajPzfxKuWhO3Ww7KkmI6GgPfx7u3t7/L2+v0BgISBRYD//Pr39PLv7ezr6urr8P2Ln7ziiKTD5oWZrcLW6/6Ikpujq7K5vsPGyczO0NPV19rc3+Lj5OPi4N7c2dfV1NLQz83LyoTJhcomyMfEwby3squlnZWNhPfl0LymkfvVsZHsvpj50ruuqainp6ampaWEpAOjpKSApaWmp6ipqqyusLK1uLu+wcPFx8jIx8bEwsC+u7i2s7Ctq6imo6KgoKChoqSnq6+0usHK097p9YGIj5aepq60u8HGys/T19vg5u30/YOJj5eepq+5w87a5/eEjZehq7O4u7q2r6aajPzfxKuWhO3Ww7KkmI6GgPfx7u3t7/L2+v0BgISBRYD//Pr39PLv7ezr6urr8P2Ln7ziiKTD5oWZrcLW6/6Ikpujq7K5vsPGyczO0NPV19rc3+Lj5OPi4N7c2dfV1NLQz83LyoTJhcomyMfEwby3squlnZWNhPfl0LymkfvVsZHsvpj50ruuqainp6ampaWEpAOjpKS3d5V4jXmOeoZ5iXiKd4Z4j3eEeIR5h3q8e4Z6hHmDeJN3AgIBABKam5ucnZ6foaOmqKyvs7a6vb+EwYC/vbu4tbKvrKmmpKGfnZybmpucnqGkqa+1vcbQ3On4g4uUnKavuMHJ0Nfc4OTn6uzv8vX7gISKj5adpa64ws7b6vuHkZ2ptcHK0dXV0cm/saKRgeLFq5WD6tK9rJ6Rh//z6uTh4OHj5unt8PP19vb19PLw7uzq6Ofm5ubo7vuJnGa33YajxOqJnrTL4feGkJmiqrK4vsPHyszNz9DR09XW2dzf4eLi4uDe29jW09HQzszLycfGxMPDw8TFxsbHx8bFw8G+urawqqOclIuB7tjBqpP70q2M4bOQ7cu1qqWjoqGgn56dnJuEmhKam5ucnZ6foaOmqKyvs7a6vb+EwYC/vbu4tbKvrKmmpKGfnZybmpucnqGkqa+1vcbQ3On4g4uUnKavuMHJ0Nfc4OTn6uzv8vX7gISKj5adpa64ws7b6vuHkZ2ptcHK0dXV0cm/saKRgeLFq5WD6tK9rJ6Rh//z6uTh4OHj5unt8PP19vb19PLw7uzq6Ofm5ubo7vuJnGa33YajxOqJnrTL4feGkJmiqrK4vsPHyszNz9DR09XW2dzf4eLi4uDe29jW09HQzszLycfGxMPDw8TFxsbHx8bFw8G+urawqqOclIuB7tjBqpP70q2M4bOQ7cu1qqWjoqGgn56dnJuEmhKam5ucnZ6foaOmqKyvs7a6vb+EwYC/vbu4tbKvrKmmpKGfnZybmpucnqGkqa+1vcbQ3On4g4uUnKavuMHJ0Nfc4OTn6uzv8vX7gISKj5adpa64ws7b6vuHkZ2ptcHK0dXV0cm/saKRgeLFq5WD6tK9rJ6Rh//z6uTh4OHj5unt8PP19vb19PLw7uzq6Ofm5ubo7vuJnGa33YajxOqJnrTL4feGkJmiqrK4vsPHyszNz9DR09XW2dzf4eLi4uDe29jW09HQzszLycfGxMPDw8TFxsbHx8bFw8G+urawqqOclIuB7tjBqpP70q2M4bOQ7cu1qqWjoqGgn56dnJuEmrV3lXiOeZF6hXmHeJ93hHiEeYZ6wHuFeoR5g3iSdwICAQBCkJCRkZKTlZeZnKCjp6uvs7e5u7y8u7m3tLGtqqekoZ+cmpmYl5eXmZygpauyu8bS4PCAiZOeqLO+yNLd5u/2+3+BhoJlg4WIjJGXnqWut8HM2Of4hpGeq7nH1eDo7e3q4tbHtqSRgN/Bp5GA48u2pZeLgfLn3tnW1dXX2t7h5Obo6enp6Ofl5OLh4eHi4+n1hZav0oCcvuWHnrbO5/6KlZ6nr7a7wMTHycqFyyLMzs/S1tja29va2NXSz8zKyMbFw8HAvry6uLi4ubq7vL2+hL8ovby5trKtp5+XjoPx2cCnj/HHooHPpYXewK6koJ6cmpmXlZSTkpGQkEKQkJGRkpOVl5mcoKOnq6+zt7m7vLy7ube0sa2qp6Shn5yamZiXl5eZnKClq7K7xtLg8ICJk56os77I0t3m7/b7f4GGgmWDhYiMkZeepa63wczY5/iGkZ6rucfV4Ojt7eri1se2pJGA38GnkYDjy7all4uB8ufe2dbV1dfa3uHk5ujp6eno5+Xk4uHh4eLj6fWFlq/SgJy+5Yeets7n/oqVnqevtrvAxMfJyoXLIszOz9LW2Nrb29rY1dLPzMrIxsXDwcC+vLq4uLi5uru8vb6Evyi9vLm2sq2nn5eOg/HZwKeP8ceigc+lhd7ArqSgnpyamZeVlJOSkZCQQpCQkZGSk5WXmZygo6err7O3ubu8vLu5t7SxraqnpKGfnJqZmJeXl5mcoKWrsrvG0uDwgImTnqizvsjS3ebv9vt/gYaCZYOFiIyRl56lrrfBzNjn+IaRnqu5x9Xg6O3t6uLWx7akkYDfwaeRgOPLtqWXi4Hy597Z1tXV19re4eTm6Onp6ejn5eTi4eHh4uPp9YWWr9KAnL7lh562zuf+ipWep6+2u8DEx8nKhcsizM7P0tbY2tvb2tjV0s/MysjGxcPBwL68uri4uLm6u7y9voS/KL28ubayraefl46D8dnAp4/xx6KBz6WF3sCupKCenJqZl5WUk5KRkJCyd454l3mTeoV5h3idd4R4hHmGesJ7hXqEeYN4kXcCAgEAhIeAiImLjZCTl5ugpamusrS3t7e2tLKuq6ekoJ2bmZiWlZWVlpmdoqmxvMnY6fyIk5+sucbT4Oz3gYaLj5KUlZWVlJKRkI6PkJKWm6GosbrDzdfk84KNmqi3x9fm8/yBgf/36trItKCM9dS3nonz2MGtnY+D9eba087LysvN0NPW2dsG3d3e3d3chNty3N3i6/2No8PtkbHYgZmyzOZ/i5agqbC2u7/Bw8TEw8LBwcDAwMHDxsnMzc3MysjFwr+9uri3tbSzsa+tq6moqKipq6yusLGztLW2tra1s7Cspp+XjYLt07mfht+1kee3ku/KsqWempiWk5GPjYuKiIeHhIeAiImLjZCTl5ugpamusrS3t7e2tLKuq6ekoJ2bmZiWlZWVlpmdoqmxvMnY6fyIk5+sucbT4Oz3gYaLj5KUlZWVlJKRkI6PkJKWm6GosbrDzdfk84KNmqi3x9fm8/yBgf/36trItKCM9dS3nonz2MGtnY+D9eba087LysvN0NPW2dsG3d3e3d3chNty3N3i6/2No8PtkbHYgZmyzOZ/i5agqbC2u7/Bw8TEw8LBwcDAwMHDxsnMzc3MysjFwr+9uri3tbSzsa+tq6moqKipq6yusLGztLW2tra1s7Cspp+XjYLt07mfht+1kee3ku/KsqWempiWk5GPjYuKiIeHhIeAiImLjZCTl5ugpamusrS3t7e2tLKuq6ekoJ2bmZiWlZWVlpmdoqmxvMnY6fyIk5+sucbT4Oz3gYaLj5KUlZWVlJKRkI6PkJKWm6GosbrDzdfk84KNmqi3x9fm8/yBgf/36trItKCM9dS3nonz2MGtnY+D9eba087LysvN0NPW2dsG3d3e3d3chNty3N3i6/2No8PtkbHYgZmyzOZ/i5agqbC2u7/Bw8TEw8LBwcDAwMHDxsnMzc3MysjFwr+9uri3tbSzsa+tq6moqKipq6yusLGztLW2tra1s7Cspp+XjYLt07mfht+1kee3ku/KsqWempiWk5GPjYuKiIeHsHeKeJx5inqCe4h6hXmHeJ13hHiDeYV6xXuFegZ5eXl4eHiRdwICAQAg/Pz9/f+AgoSHi4+UmZ+kqa2wsrSzsrCtqaWinpuZl5aElWKXmp+nsb3M3vKEkZ+uvs3d7f2GjZOZn6SorK6vrq2rqKWhn52cnZ+jqLC4wcvU3uj0gYqVorDB0uP0gYaKi4mE/OrXwauWguHCp5GA5Mu2o5SH+OfZz8jDwcHCxMfKzc/R0obTdNTU1tng7YGUr9SCoMXvj6nE3/qJlZ+orrS4ury8u7q5t7WzsrGwsLCztri6urm3trOwraqopaOioJ+enpyamJaUlJWWl5mbnaCipKaoqqytrayqp6Kbk4n74seskvPGn/vGnP3RtaSbl5SRjouJhoSCgP/9IPz8/f3/gIKEh4uPlJmfpKmtsLK0s7Kwramlop6bmZeWhJVil5qfp7G9zN7yhJGfrr7N3e39ho2TmZ+kqKyur66tq6iloZ+dnJ2fo6iwuMHL1N7o9IGKlaKwwdLj9IGGiouJhPzq18GrloLhwqeRgOTLtqOUh/jn2c/Iw8HBwsTHys3P0dKG03TU1NbZ4O2BlK/UgqDF74+pxN/6iZWfqK60uLq8vLu6ube1s7KxsLCws7a4urq5t7azsK2qqKWjoqCfnp6cmpiWlJSVlpeZm52goqSmqKqsra2sqqeim5OJ++LHrJLzxp/7xpz90bWkm5eUkY6LiYaEgoD//SD8/P39/4CChIeLj5SZn6SprbCytLOysK2ppaKem5mXloSVYpean6exvcze8oSRn66+zd3t/YaNk5mfpKisrq+urauopaGfnZydn6OosLjBy9Te6PSBipWisMHS4/SBhoqLiYT86tfBq5aC4cKnkYDky7ajlIf459nPyMPBwcLEx8rNz9HShtN01NTW2eDtgZSv1IKgxe+PqcTf+omVn6iutLi6vLy7urm3tbOysbCwsLO2uLq6ube2s7Ctqqilo6Kgn56enJqYlpSUlZaXmZudoKKkpqiqrK2trKqnopuTifvix6yS88af+8ac/dG1pJuXlJGOi4mGhIKA//2Fdqh3iXifeYl6hnuHeoV5hnicd4R4hHmFesV7hXoGeXl5eHh4j3eCdgICAQCA7Ozs7e7x9Pn/g4iNk5mepKisr7CwrqyopaGempiXlpaWl5ianqStusvf9oiXqLrO4vaEjpegqLC3vcLHyszNzMrHw765tLCtrKyus7nCzNfh6/X/hYuTnqq5ytzu/4eNkZKRjIT34su0nYjrya2XhezTvKmYiv3p2c3Evrq5ubqAvL7Bw8XHyMnKysrLzc7R1d3uhJq54out1YGbttLug4+aoqmusbOzsrGurKmnpKKgn52dnZ+ipKWko6GfnZqYlZKQjoyLioiIh4aEgoD+gIGChIaJi46RlJeanJ+io6Oin5qTi4Dq0LWagdOphtKlg9a2o5mUkI2JhoJ/+/by8O6A7Ozs7e7x9Pn/g4iNk5mepKisr7CwrqyopaGempiXlpaWl5ianqStusvf9oiXqLrO4vaEjpegqLC3vcLHyszNzMrHw765tLCtrKyus7nCzNfh6/X/hYuTnqq5ytzu/4eNkZKRjIT34su0nYjrya2XhezTvKmYiv3p2c3Evrq5ubqAvL7Bw8XHyMnKysrLzc7R1d3uhJq54out1YGbttLug4+aoqmusbOzsrGurKmnpKKgn52dnZ+ipKWko6GfnZqYlZKQjoyLioiIh4aEgoD+gIGChIaJi46RlJeanJ+io6Oin5qTi4Dq0LWagdOphtKlg9a2o5mUkI2JhoJ/+/by8O6A7Ozs7e7x9Pn/g4iNk5mepKisr7CwrqyopaGempiXlpaWl5ianqStusvf9oiXqLrO4vaEjpegqLC3vcLHyszNzMrHw765tLCtrKyus7nCzNfh6/X/hYuTnqq5ytzu/4eNkZKRjIT34su0nYjrya2XhezTvKmYiv3p2c3Evrq5ubqAvL7Bw8XHyMnKysrLzc7R1d3uhJq54out1YGbttLug4+aoqmusbOzsrGurKmnpKKgn52dnZ+ipKWko6GfnZqYlZKQjoyLioiIh4aEgoD+gIGChIaJi46RlJeanJ+io6Oin5qTi4Dq0LWagdOphtKlg9a2o5mUkI2JhoJ/+/by8O6JdqJ3h3iieYp6h3uGeoV5hnicd4R4g3mFeq97AXqXe4V6Bnl5eXh4eIt3hXYCAgEAgN7d3d7f4ubq8fqBh42TmZ+kqKusrKuopaKem5mXl5eYmp2gpKu1xNjxh5irwNfwhJGdqbS+yNHY3+Xp7e/v7+zo493Wz8nEwL6+wcbO2OTw/IOIjZKYn6m1w9Pm+IWMk5eZl5KKgOrSuqKM8c6ymojy2MGtnI2A7NrMwrq1srGxgLK0tri6vL2/wMHCxMXIzNLc74efwe+UuOOJo7/a9YaRmqClqKmpp6Win5uYlZKPjYuKiYmKjI6Ojo2LioiFg4H9+fXy7+zp5+Ti39vX1NXX2t3i5+3z+oCDh4uOkpWXl5aTjoj+6tK4noXbsYzbq4bZt6KWkIuIg4D58+3o5OHfgN7d3d7f4ubq8fqBh42TmZ+kqKusrKuopaKem5mXl5eYmp2gpKu1xNjxh5irwNfwhJGdqbS+yNHY3+Xp7e/v7+zo493Wz8nEwL6+wcbO2OTw/IOIjZKYn6m1w9Pm+IWMk5eZl5KKgOrSuqKM8c6ymojy2MGtnI2A7NrMwrq1srGxgLK0tri6vL2/wMHCxMXIzNLc74efwe+UuOOJo7/a9YaRmqClqKmpp6Win5uYlZKPjYuKiYmKjI6Ojo2LioiFg4H9+fXy7+zp5+Ti39vX1NXX2t3i5+3z+oCDh4uOkpWXl5aTjoj+6tK4noXbsYzbq4bZt6KWkIuIg4D58+3o5OHfgN7d3d7f4ubq8fqBh42TmZ+kqKusrKuopaKem5mXl5eYmp2gpKu1xNjxh5irwNfwhJGdqbS+yNHY3+Xp7e/v7+zo493Wz8nEwL6+wcbO2OTw/IOIjZKYn6m1w9Pm+IWMk5eZl5KKgOrSuqKM8c6ymojy2MGtnI2A7NrMwrq1srGxgLK0tri6vL2/wMHCxMXIzNLc74efwe+UuOOJo7/a9YaRmqClqKmpp6Win5uYlZKPjYuKiYmKjI6Ojo2LioiFg4H9+fXy7+zp5+Ti39vX1NXX2t3i5+3z+oCDh4uOkpWXl5aTjoj+6tK4noXbsYzbq4bZt6KWkIuIg4D58+3o5OHfinafd4Z4onmMeol7hXqFeYd4m3eEeIN5hXqie5d6jXuGegZ5eXl4eHiJd4d2AgIBAIDQ0NDR0tXY3uXt94GHjpSan6SnqKinpaKfnZuZmpudoKOorbXAz+WBkqa+2POIl6e2xdLe6vT9goWHiYqKiYiGg//37ube2NPR0tbd5vL/ho2TmZ6iqK62wc/slbfH0Nba3NnUy7OM3L2ljvTRtJyK9dvEsJ6Pgu7bzMC3sKypqICpqqyusLKztba4ury/wsjQ3fOKpMn5m8DrjafC3PSEjZSZnJ2dm5iVkY2JhoL/+fTw7Orq7PDz8/Px8O3q5+Pe2tbTz8zJxcK/vLm0sK2srbCzt7zCydDX3+fw+YCEh4mJiIWA8uHMtZ2F3LOP4K+I27agk4yHgvz07ebg29fU0oDQ0NDR0tXY3uXt94GHjpSan6SnqKinpaKfnZuZmpudoKOorbXAz+WBkqa+2POIl6e2xdLe6vT9goWHiYqKiYiGg//37ube2NPR0tbd5vL/ho2TmZ6iqK62wc/slbfH0Nba3NnUy7OM3L2ljvTRtJyK9dvEsJ6Pgu7bzMC3sKypqICpqqyusLKztba4ury/wsjQ3fOKpMn5m8DrjafC3PSEjZSZnJ2dm5iVkY2JhoL/+fTw7Orq7PDz8/Px8O3q5+Pe2tbTz8zJxcK/vLm0sK2srbCzt7zCydDX3+fw+YCEh4mJiIWA8uHMtZ2F3LOP4K+I27agk4yHgvz07ebg29fU0oDQ0NDR0tXY3uXt94GHjpSan6SnqKinpaKfnZuZmpudoKOorbXAz+WBkqa+2POIl6e2xdLe6vT9goWHiYqKiYiGg//37ube2NPR0tbd5vL/ho2TmZ6iqK62wc/slbfH0Nba3NnUy7OM3L2ljvTRtJyK9dvEsJ6Pgu7bzMC3sKypqICpqqyusLKztba4ury/wsjQ3fOKpMn5m8DrjafC3PSEjZSZnJ2dm5iVkY2JhoL/+fTw7Orq7PDz8/Px8O3q5+Pe2tbTz8zJxcK/vLm0sK2srbCzt7zCydDX3+fw+YCEh4mJiIWA8uHMtZ2F3LOP4K+I27agk4yHgvz07ebg29fU0ot2nHeGeIp5inqOeYx6jHuEeoV5h3ibd4R4g3mFeo97r3qIe4Z6Bnl5eXh4eId3iXYCAgEAgMXExcbHys7T2uPt+IKIj5Wan6KkpKSioJ6dnZ6go6essrnCzd70iZyzzuuGl6m7zt/v/oWLkJSYm52dnp2bmJWRjIeC+vLq5uTm6/SAh46XnqWssbW6wMfS/v+FzvT7/f7+/fvtutm7yaaP9dK1nYr128Swn4+C7trLvrStp6SigKGho6WnqKqsrq+ytbi+xdDg946q0IGgxe6Npr7W7P6Gi4+QkI6MiISA+PDo4NrUzsrHxcTFyc3Oz87Ny8nHxMG9ubayr6uopKCcmJOOioiIiYyPlJmgp663wMnT3OXt8vX08erf0b+rlYDWsI3hsInbtZ2Qh4H58Ofg2dTPy8jGgMXExcbHys7T2uPt+IKIj5Wan6KkpKSioJ6dnZ6go6essrnCzd70iZyzzuuGl6m7zt/v/oWLkJSYm52dnp2bmJWRjIeC+vLq5uTm6/SAh46XnqWssbW6wMfS/v+FzvT7/f7+/fvtutm7yaaP9dK1nYr128Swn4+C7trLvrStp6SigKGho6WnqKqsrq+ytbi+xdDg946q0IGgxe6Npr7W7P6Gi4+QkI6MiISA+PDo4NrUzsrHxcTFyc3Oz87Ny8nHxMG9ubayr6uopKCcmJOOioiIiYyPlJmgp663wMnT3OXt8vX08erf0b+rlYDWsI3hsInbtZ2Qh4H58Ofg2dTPy8jGgMXExcbHys7T2uPt+IKIj5Wan6KkpKSioJ6dnZ6go6essrnCzd70iZyzzuuGl6m7zt/v/oWLkJSYm52dnp2bmJWRjIeC+vLq5uTm6/SAh46XnqWssbW6wMfS/v+FzvT7/f7+/fvtutm7yaaP9dK1nYr128Swn4+C7trLvrStp6SigKGho6WnqKqsrq+ytbi+xdDg946q0IGgxe6Npr7W7P6Gi4+QkI6MiISA+PDo4NrUzsrHxcTFyc3Oz87Ny8nHxMG9ubayr6uopKCcmJOOioiIiYyPlJmgp663wMnT3OXt8vX08erf0b+rlYDWsI3hsInbtZ2Qh4H58Ofg2dTPy8jGjHaad4V4iHmReoh5jnoBe4t9BXx7enp6hXmHeJt3g3iEeYZ6invBegZ5eXl4eHiGd4p2AgIBAIC7u7u9vsHFy9Ha5O/7g4qQlZqdn6CgoJ+foKKlqa+1vcbQ3e+DkqW92fqPorfM4fWEjZWboaaqra+wsK+tqqahnJeRi4WA+vb2+YCGjZWfqLG5wMbKz9Tcg5jo+8Tw/n+AgP/75rDPpL6xj/XStJyJ9NnCrp2OgezZybyyqqSgnYCbmpudn6Cio6Woqq6zu8XS5P6TsNeEosTriqC2y93t+YCCgoH/+PDn3tXMxL23sayopqSjpKisr7GysbGwrqyppqOgnJmVkY2Ig/zw5dvV09PV2uHr9oGIkJmjrbfAyc/U1dTPx7utnIntyKaH2q2I2rOai4L47ePb087IxMG+vIC7u7u9vsHFy9Ha5O/7g4qQlZqdn6CgoJ+foKKlqa+1vcbQ3e+DkqW92fqPorfM4fWEjZWboaaqra+wsK+tqqahnJeRi4WA+vb2+YCGjZWfqLG5wMbKz9Tcg5jo+8Tw/n+AgP/75rDPpL6xj/XStJyJ9NnCrp2OgezZybyyqqSgnYCbmpudn6Cio6Woqq6zu8XS5P6TsNeEosTriqC2y93t+YCCgoH/+PDn3tXMxL23sayopqSjpKisr7GysbGwrqyppqOgnJmVkY2Ig/zw5dvV09PV2uHr9oGIkJmjrbfAyc/U1dTPx7utnIntyKaH2q2I2rOai4L47ePb087IxMG+vIC7u7u9vsHFy9Ha5O/7g4qQlZqdn6CgoJ+foKKlqa+1vcbQ3e+DkqW92fqPorfM4fWEjZWboaaqra+wsK+tqqahnJeRi4WA+vb2+YCGjZWfqLG5wMbKz9Tcg5jo+8Tw/n+AgP/75rDPpL6xj/XStJyJ9NnCrp2OgezZybyyqqSgnYCbmpudn6Cio6Woqq6zu8XS5P6TsNeEosTriqC2y93t+YCCgoH/+PDn3tXMxL23sayopqSjpKisr7GysbGwrqyppqOgnJmVkY2Ig/zw5dvV09PV2uHr9oGIkJmjrbfAyc/U1dTPx7utnIntyKaH2q2I2rOai4L47ePb087IxMG+vI12l3eGeIZ5lnqEeY56Cnt8fX5/f3+AgICEfwV+fXt6eoV5h3ibd4N4hHmHeoR7pnqMeZN6hHmDeIV3i3YCAgEAgLOztLa4u7/Ey9Pc5/P/hYuQlJianJ6eoKKlqa+2v8jT3+3/i5qtxeGBlKm/1u2CjZehqbC2ur2/wMC/vLm1sKqknZaQioWCgIGEiZCZpK+6xM3V2+Dl64mb/Kil+ZqmqqqqqaST4oyAqLGZ9dGzmofv1b6qmYv96NbHurGpo56agJeWlpeZmpucnqCkqbC6xtXqg5i124SfvuGDlqm7y9fh5+rp5uDY0Ma9taylnpiUkI2LioqMjpKXmp2en5+enZuZlpOQjIeD/PHk1si7sKijoaGkqK+3ws7c7P6IkpylrLK1tbKso5iK9dW1mPrMpITVsJaH+u3h18/Iwr66t7W0gLOztLa4u7/Ey9Pc5/P/hYuQlJianJ6eoKKlqa+2v8jT3+3/i5qtxeGBlKm/1u2CjZehqbC2ur2/wMC/vLm1sKqknZaQioWCgIGEiZCZpK+6xM3V2+Dl64mb/Kil+ZqmqqqqqaST4oyAqLGZ9dGzmofv1b6qmYv96NbHurGpo56agJeWlpeZmpucnqCkqbC6xtXqg5i124SfvuGDlqm7y9fh5+rp5uDY0Ma9taylnpiUkI2LioqMjpKXmp2en5+enZuZlpOQjIeD/PHk1si7sKijoaGkqK+3ws7c7P6IkpylrLK1tbKso5iK9dW1mPrMpITVsJaH+u3h18/Iwr66t7W0gLOztLa4u7/Ey9Pc5/P/hYuQlJianJ6eoKKlqa+2v8jT3+3/i5qtxeGBlKm/1u2CjZehqbC2ur2/wMC/vLm1sKqknZaQioWCgIGEiZCZpK+6xM3V2+Dl64mb/Kil+ZqmqqqqqaST4oyAqLGZ9dGzmofv1b6qmYv96NbHurGpo56agJeWlpeZmpucnqCkqbC6xtXqg5i124SfvuGDlqm7y9fh5+rp5uDY0Ma9taylnpiUkI2LioqMjpKXmp2en5+enZuZlpOQjIeD/PHk1si7sKijoaGkqK+3ws7c7P6IkpylrLK1tbKso5iK9dW1mPrMpITVsJaH+u3h18/Iwr66t7W0jnaVd4V4hnmpegZ7fH1/gICIgQaAgH99e3qFeYZ4m3eEeIR5rnqUeY16hHmEeIR3jHYCAgEAgK2ur7Cztrq/xs3W4ez3gYaLkJOXmpyfoqass7vG0t/t/IeTorTL5oOVq8La84aSnqmyu8LHyszNzcvJxcC6tK2mn5iRi4aDgoSJkJmjsLzJ1d/o7/b8kJ7+rr2m8JOjqaurqJ+N3JCagaSlg86vl4TpzriklIf349LEubCpo56agJaUlJSVlZWWl5qfpq+6yNrwh5y424KatdP0ipqptsHIzc7MyMG5samgmJGLhoL9+PXz8/T3/IGGi5CUmJudn5+fnZqVkIqD9uXTwa+hlIuFgPz7/oKHjpeir7/Q4/WDipGVl5aSi4Lu1bqghuC4lvbLqZKC8OLWzMS9uLWysK6tgK2ur7Cztrq/xs3W4ez3gYaLkJOXmpyfoqass7vG0t/t/IeTorTL5oOVq8La84aSnqmyu8LHyszNzcvJxcC6tK2mn5iRi4aDgoSJkJmjsLzJ1d/o7/b8kJ7+rr2m8JOjqaurqJ+N3JCagaSlg86vl4TpzriklIf349LEubCpo56agJaUlJSVlZWWl5qfpq+6yNrwh5y424KatdP0ipqptsHIzc7MyMG5samgmJGLhoL9+PXz8/T3/IGGi5CUmJudn5+fnZqVkIqD9uXTwa+hlIuFgPz7/oKHjpeir7/Q4/WDipGVl5aSi4Lu1bqghuC4lvbLqZKC8OLWzMS9uLWysK6tgK2ur7Cztrq/xs3W4ez3gYaLkJOXmpyfoqass7vG0t/t/IeTorTL5oOVq8La84aSnqmyu8LHyszNzcvJxcC6tK2mn5iRi4aDgoSJkJmjsLzJ1d/o7/b8kJ7+rr2m8JOjqaurqJ+N3JCagaSlg86vl4TpzriklIf349LEubCpo56agJaUlJSVlZWWl5qfpq+6yNrwh5y424KatdP0ipqptsHIzc7MyMG5samgmJGLhoL9+PXz8/T3/IGGi5CUmJudn5+fnZqVkIqD9uXTwa+hlIuFgPz7/oKHjpeir7/Q4/WDipGVl5aSi4Lu1bqghuC4lvbLqZKC8OLWzMS9uLWysK6tjnaTd4Z4hnmpegd7fH1/gIGBiIIHgYGAf317eoR5hnibd4R4hXmUeoh5kXqKeYN4inmJeoV5g3iFd4x2AgIBAICqqqyusLO3vMLK0tzm8fyDiIyQlJicoaattb7K2en5hY+bqbrQ6YSVqsDa9IeUoa24wcnO09XW1dPQzMfBurOspJyVjoiEgYGEipOdqrjH1eLv+YGFmKH/rsCyjcPuhY2QkIuC47T8l5qAoZrfq5L/4MawnY6B793Owrixq6WhnICZlpSTk5KRkZOWnKSvvMzf+IufuNf7kqrE3/uLl6KqsLKzsKulnpaPiIL68erl4d7d3d7h5fGNteuUttuAk6a3w8O5q5uJ7MOZ4pjElob56NzTzcvLztXf7P6KmKi4yNfk7vT18OfayLSfienDoobfu6CL+ubXzMK6tLCtq6qpqYCqqqyusLO3vMLK0tzm8fyDiIyQlJicoaattb7K2en5hY+bqbrQ6YSVqsDa9IeUoa24wcnO09XW1dPQzMfBurOspJyVjoiEgYGEipOdqrjH1eLv+YGFmKH/rsCyjcPuhY2QkIuC47T8l5qAoZrfq5L/4MawnY6B793Owrixq6WhnICZlpSTk5KRkZOWnKSvvMzf+IufuNf7kqrE3/uLl6KqsLKzsKulnpaPiIL68erl4d7d3d7h5fGNteuUttuAk6a3w8O5q5uJ7MOZ4pjElob56NzTzcvLztXf7P6KmKi4yNfk7vT18OfayLSfienDoobfu6CL+ubXzMK6tLCtq6qpqYCqqqyusLO3vMLK0tzm8fyDiIyQlJicoaattb7K2en5hY+bqbrQ6YSVqsDa9IeUoa24wcnO09XW1dPQzMfBurOspJyVjoiEgYGEipOdqrjH1eLv+YGFmKH/rsCyjcPuhY2QkIuC47T8l5qAoZrfq5L/4MawnY6B793Owrixq6WhnICZlpSTk5KRkZOWnKSvvMzf+IufuNf7kqrE3/uLl6KqsLKzsKulnpaPiIL68erl4d7d3d7h5fGNteuUttuAk6a3w8O5q5uJ7MOZ4pjElob56NzTzcvLztXf7P6KmKi4yNfk7vT18OfayLSfienDoobfu6CL+ubXzMK6tLCtq6qpqY92kHeHeIZ5p3oLe3t7fH1/gIGCgoKGgwuCgoGBgH99e3l5eYd4m3eFeIV5j3qMeQZ6enp7e3uKfAh7e3t6enl5eYx4kXmEeIR3jXYCAgEAgKiqrK6xtLe8wsjQ2ePt94CFio+UmJ6kq7S/zNzugYuWorDA1OyElKe91e+Fk6CtuMLL0dbZ2djW0s7Jw7y1raWdlo6Igv77/YKJkp6svMzc6/mCiJ2kgK7AtJPYj63E0tjXzr6lhcSBl5r/npC8jfTVvKeViPnm18vAubKtqaWhgJ2al5WTkZCPkZSbpK+/0OX+jqC20fCKnrTL4viGjpWZmpmXko2Hgfft5d/b19XT0tLT1dnmnZWI15jH+ZawyeDu7N7Ks5qBzpnN5825guvYyb21rqqoqKuxu8nb8oWToKy2vsHAu7KlloXoxqeM7MerlYTw3c7DurOtqqempqangKiqrK6xtLe8wsjQ2ePt94CFio+UmJ6kq7S/zNzugYuWorDA1OyElKe91e+Fk6CtuMLL0dbZ2djW0s7Jw7y1raWdlo6Igv77/YKJkp6svMzc6/mCiJ2kgK7AtJPYj63E0tjXzr6lhcSBl5r/npC8jfTVvKeViPnm18vAubKtqaWhgJ2al5WTkZCPkZSbpK+/0OX+jqC20fCKnrTL4viGjpWZmpmXko2Hgfft5d/b19XT0tLT1dnmnZWI15jH+ZawyeDu7N7Ks5qBzpnN5825guvYyb21rqqoqKuxu8nb8oWToKy2vsHAu7KlloXoxqeM7MerlYTw3c7DurOtqqempqangKiqrK6xtLe8wsjQ2ePt94CFio+UmJ6kq7S/zNzugYuWorDA1OyElKe91e+Fk6CtuMLL0dbZ2djW0s7Jw7y1raWdlo6Igv77/YKJkp6svMzc6/mCiJ2kgK7AtJPYj63E0tjXzr6lhcSBl5r/npC8jfTVvKeViPnm18vAubKtqaWhgJ2al5WTkZCPkZSbpK+/0OX+jqC20fCKnrTL4viGjpWZmpmXko2Hgfft5d/b19XT0tLT1dnmnZWI15jH+ZawyeDu7N7Ks5qBzpnN5825guvYyb21rqqoqKuxu8nb8oWToKy2vsHAu7KlloXoxqeM7MerlYTw3c7DurOtqqempqanj3aOd4h4hnmaeoN5inoKe3t7fH5/gIGCgoqDCYKCgYB+fXt5eYZ4nHeFeIZ5i3qOeQd6e3x8fX19i34HfX18e3p5eY94jXmEeIV3jXYCAgEAgKqsrrG0t7u/xMrR2uPs9oCEiY+UmqGpsr7L3O+Cjpupt8fa8IWUpbnP6IGOnKm1v8jP1NfY19XRzcfBurOspJyUjIaA9vHv8vuEj5yru83e7v2FmqKArsC0lN+axeyFj5STjYHiuY3IgZeZ/ZuEnOrKsZ2NgO7e0cjAurWyr6yogKShnZqWk5GQkZSbpbHC1euCkKC0y+WCkqS4y93t+oGEhISB/PTs49zX1NLR0NDP0NDR1OCao7ivjMeDo8Xmg5GYl46B5cSjgsCAkobMquzSwbSpoJmUkY+PkpihrsDU6f2HjpOUko2F9NzBp4/00LOdi/zn1ce8tK2ppqWlpaeogKqsrrG0t7u/xMrR2uPs9oCEiY+UmqGpsr7L3O+Cjpupt8fa8IWUpbnP6IGOnKm1v8jP1NfY19XRzcfBurOspJyUjIaA9vHv8vuEj5yru83e7v2FmqKArsC0lN+axeyFj5STjYHiuY3IgZeZ/ZuEnOrKsZ2NgO7e0cjAurWyr6yogKShnZqWk5GQkZSbpbHC1euCkKC0y+WCkqS4y93t+oGEhISB/PTs49zX1NLR0NDP0NDR1OCao7ivjMeDo8Xmg5GYl46B5cSjgsCAkobMquzSwbSpoJmUkY+PkpihrsDU6f2HjpOUko2F9NzBp4/00LOdi/zn1ce8tK2ppqWlpaeogKqsrrG0t7u/xMrR2uPs9oCEiY+UmqGpsr7L3O+Cjpupt8fa8IWUpbnP6IGOnKm1v8jP1NfY19XRzcfBurOspJyUjIaA9vHv8vuEj5yru83e7v2FmqKArsC0lN+axeyFj5STjYHiuY3IgZeZ/ZuEnOrKsZ2NgO7e0cjAurWyr6yogKShnZqWk5GQkZSbpbHC1euCkKC0y+WCkqS4y93t+oGEhISB/PTs49zX1NLR0NDP0NDR1OCao7ivjMeDo8Xmg5GYl46B5cSjgsCAkobMquzSwbSpoJmUkY+PkpihrsDU6f2HjpOUko2F9NzBp4/00LOdi/zn1ce8tK2ppqWlpaeoj3aNd4h4hnmaeoV5iXoMe3t8fn+AgYKCg4ODhoQLg4ODgoKBgH59e3mGeJt3hniIeYV6kXkGent8fX5+hH+GgIR/Bn5+fXx6eZN4h3mFeIV3jnYCAgEAgK+xtLa5vcHFytDW3ubv+ICFipCWnaWuusjZ7YKPna29zuH2hpSktsrg+IiVoq65wcnO0dPS0MzHwru1rqafl5CIgvft5eHg5O7+iZemtsjZ6vqJ+dSfuLCS3ZzPgZirub++tqeS9cCOxv+TkeDsoOfAp5OE8+LVzMXAvLq4trSxgK6qpqGcmJSSk5edp7TF2vGEkqGyxtz1iJemtcTQ2uHk5uXi3tnU0c7Nzs/R0tLS09PV4JqiwMmzi8OAn7/f/ImPjof32ruc+Lj7mJyHxp/YwLGkmpKLhYH9+vr+hI2Zp7bF0dnd3dnQw7KgjPXUuaOShPTh0MO5sauopqanqKqsgK+xtLa5vcHFytDW3ubv+ICFipCWnaWuusjZ7YKPna29zuH2hpSktsrg+IiVoq65wcnO0dPS0MzHwru1rqafl5CIgvft5eHg5O7+iZemtsjZ6vqJ+dSfuLCS3ZzPgZirub++tqeS9cCOxv+TkeDsoOfAp5OE8+LVzMXAvLq4trSxgK6qpqGcmJSSk5edp7TF2vGEkqGyxtz1iJemtcTQ2uHk5uXi3tnU0c7Nzs/R0tLS09PV4JqiwMmzi8OAn7/f/ImPjof32ruc+Lj7mJyHxp/YwLGkmpKLhYH9+vr+hI2Zp7bF0dnd3dnQw7KgjPXUuaOShPTh0MO5sauopqanqKqsgK+xtLa5vcHFytDW3ubv+ICFipCWnaWuusjZ7YKPna29zuH2hpSktsrg+IiVoq65wcnO0dPS0MzHwru1rqafl5CIgvft5eHg5O7+iZemtsjZ6vqJ+dSfuLCS3ZzPgZirub++tqeS9cCOxv+TkeDsoOfAp5OE8+LVzMXAvLq4trSxgK6qpqGcmJSSk5edp7TF2vGEkqGyxtz1iJemtcTQ2uHk5uXi3tnU0c7Nzs/R0tLS09PV4JqiwMmzi8OAn7/f/ImPjof32ruc+Lj7mJyHxp/YwLGkmpKLhYH9+vr+hI2Zp7bF0dnd3dnQw7KgjPXUuaOShPTh0MO5sauopqanqKqsj3aMd4h4h3mYeoh5iHoKe3t9f4CBgoKDg4mECoODg4KBgYB+fHqFeJx3h3iceQd6e3x9fn9/hYCEgYSACH9/fn59fHp5iXiEd5B4hneOdgICAQCAtrm8v8LGyc7T2N7l7fX9g4eMkpmhqrXD0+f/jZ2uwNPn/ImWpbXH2u+DjpqlsLi/xcjKysjEv7mzraafmJGJg/nt4tnT0NDV4PCCj52uv9Dh8Y3FwouWhdGWzIOhvdTj6+rgzraZ9ryIueb1zvGa7redivnl187HxMHAwMC/vryAubWwq6WfmpeXmqCquMne9oeUorHC1Oj+i5ejrre+xMjKy8vJyMjIyszP09XY2dra3Oaco8HNwJ/upNWEnrbM3OXj2cixmf/LmdeJnZ2GwpjKs6WZkIiB+O7m39va3uf2hI6XnaGjop+Zj4Pt07uomIuA7t3OwrixraqpqqutsLOAtrm8v8LGyc7T2N7l7fX9g4eMkpmhqrXD0+f/jZ2uwNPn/ImWpbXH2u+DjpqlsLi/xcjKysjEv7mzraafmJGJg/nt4tnT0NDV4PCCj52uv9Dh8Y3FwouWhdGWzIOhvdTj6+rgzraZ9ryIueb1zvGa7redivnl187HxMHAwMC/vryAubWwq6WfmpeXmqCquMne9oeUorHC1Oj+i5ejrre+xMjKy8vJyMjIyszP09XY2dra3Oaco8HNwJ/upNWEnrbM3OXj2cixmf/LmdeJnZ2GwpjKs6WZkIiB+O7m39va3uf2hI6XnaGjop+Zj4Pt07uomIuA7t3OwrixraqpqqutsLOAtrm8v8LGyc7T2N7l7fX9g4eMkpmhqrXD0+f/jZ2uwNPn/ImWpbXH2u+DjpqlsLi/xcjKysjEv7mzraafmJGJg/nt4tnT0NDV4PCCj52uv9Dh8Y3FwouWhdGWzIOhvdTj6+rgzraZ9ryIueb1zvGa7redivnl187HxMHAwMC/vryAubWwq6WfmpeXmqCquMne9oeUorHC1Oj+i5ejrre+xMjKy8vJyMjIyszP09XY2dra3Oaco8HNwJ/upNWEnrbM3OXj2cixmf/LmdeJnZ2GwpjKs6WZkIiB+O7m39va3uf2hI6XnaGjop+Zj4Pt07uomIuA7t3OwrixraqpqqutsLOPdox3h3iHeZd6inmIegl7fH6AgYKCg4OLhAmDg4OCgYB/fXuEeJ13iHiaeQl6e3x9fn9/gICLgQqAgIB/f359fHp5h3iJd4t4h3eOdgICAQCAwMPHys3R1dne5Orw9/6Ch4uQlp2lsLzM3/aJmq3B1uyBjZqot8fY6v2IkpymrrW6vb+/vbq2sKqjnZaPiYL57eLYz8jDwcPI0uH1hpOis8PT44np/bjFrIS6+J7A4PqGi4qE89e2lOaq7JWiiqC9666UgurYzMbDwsPFx8jKysmAxsK9tq+noZ2cn6WuvM7j+omWo7C+zd3vgYqTm6KprrO3ury+wMPHzNDV2t7h4+Xm8aKlws7DpoG5+6HG64aVn6WknZGD4r2Y6ajjjJ2chb+Swauek4qC+Ovg1cvDvbzAyNLd5evv8PDt5dnJuKeaj4b76tvOxLu1sbCwsbO2ub2AwMPHys3R1dne5Orw9/6Ch4uQlp2lsLzM3/aJmq3B1uyBjZqot8fY6v2IkpymrrW6vb+/vbq2sKqjnZaPiYL57eLYz8jDwcPI0uH1hpOis8PT44np/bjFrIS6+J7A4PqGi4qE89e2lOaq7JWiiqC9666UgurYzMbDwsPFx8jKysmAxsK9tq+noZ2cn6WuvM7j+omWo7C+zd3vgYqTm6KprrO3ury+wMPHzNDV2t7h4+Xm8aKlws7DpoG5+6HG64aVn6WknZGD4r2Y6ajjjJ2chb+Swauek4qC+Ovg1cvDvbzAyNLd5evv8PDt5dnJuKeaj4b76tvOxLu1sbCwsbO2ub2AwMPHys3R1dne5Orw9/6Ch4uQlp2lsLzM3/aJmq3B1uyBjZqot8fY6v2IkpymrrW6vb+/vbq2sKqjnZaPiYL57eLYz8jDwcPI0uH1hpOis8PT44np/bjFrIS6+J7A4PqGi4qE89e2lOaq7JWiiqC9666UgurYzMbDwsPFx8jKysmAxsK9tq+noZ2cn6WuvM7j+omWo7C+zd3vgYqTm6KprrO3ury+wMPHzNDV2t7h4+Xm8aKlws7DpoG5+6HG64aVn6WknZGD4r2Y6ajjjJ2chb+Swauek4qC+Ovg1cvDvbzAyNLd5evv8PDt5dnJuKeaj4b76tvOxLu1sbCwsbO2ub2Odox3hniJeZV6jXmHegl7fH6AgYKDg4OEhISFhIQIg4OCgoGAfnuEeJ13iHiZeQx6e3x9fn+AgICBgYGIggyBgYGAgH9/fn18enmGeJp3j3YCAgEAgM3Q1Nfb3+Pn7PL4/oKFiIyQlZujrLbE1uuDk6e+1vCEkZ+tvMva6vqEjZWepauvs7S0s7Csp6GblI6Igvnu5NrQyMC7uLe6wMvY6v6LmKa1xNKB6YXK3sWY1o602v6OmZ6elor00KmExIeqtpeov+Sli/TczMO/wMLFyc7S1dfXgNXRysK6saqlo6Wqs8HT5/2KlqKuusbT4vH/ho2TmqCmrLC1ur/Fy9LY3uTp7fH0/6mow8/Dp4TEiLTkiqO5y9je3dXGs5yE1qf4ruaNnZyEvY+9qJyRiYDy49TGuq+moaGjqK2xtLe5urm0rKKZkYmC9+nd0snCvLq5ury+wsXJgM3Q1Nfb3+Pn7PL4/oKFiIyQlZujrLbE1uuDk6e+1vCEkZ+tvMva6vqEjZWepauvs7S0s7Csp6GblI6Igvnu5NrQyMC7uLe6wMvY6v6LmKa1xNKB6YXK3sWY1o602v6OmZ6elor00KmExIeqtpeov+Sli/TczMO/wMLFyc7S1dfXgNXRysK6saqlo6Wqs8HT5/2KlqKuusbT4vH/ho2TmqCmrLC1ur/Fy9LY3uTp7fH0/6mow8/Dp4TEiLTkiqO5y9je3dXGs5yE1qf4ruaNnZyEvY+9qJyRiYDy49TGuq+moaGjqK2xtLe5urm0rKKZkYmC9+nd0snCvLq5ury+wsXJgM3Q1Nfb3+Pn7PL4/oKFiIyQlZujrLbE1uuDk6e+1vCEkZ+tvMva6vqEjZWepauvs7S0s7Csp6GblI6Igvnu5NrQyMC7uLe6wMvY6v6LmKa1xNKB6YXK3sWY1o602v6OmZ6elor00KmExIeqtpeov+Sli/TczMO/wMLFyc7S1dfXgNXRysK6saqlo6Wqs8HT5/2KlqKuusbT4vH/ho2TmqCmrLC1ur/Fy9LY3uTp7fH0/6mow8/Dp4TEiLTkiqO5y9je3dXGs5yE1qf4ruaNnZyEvY+9qJyRiYDy49TGuq+moaGjqK2xtLe5urm0rKKZkYmC9+nd0snCvLq5ury+wsXJjHaNd4Z4iXmUepB5hnoIe3x/gIGCg4OEhIaFhIQKg4OCgYB+e3h4eJ53iniWeQt6e3x9fn+AgIGBgYyCC4GBgIB/f359fHp5hniZd492AgIBAIDc4OTo6+/z+P2BhIeKjZCTmJyiqbO+zeD4i5620e6GlaSzwtLh7/yEi5GYnqOoqqysq6ikoJuVj4mD/fLo39bOx8G9ubi4u8DK1+b3hZCcqLXC8OWFzufRpOqcxe6KnKivrqWXheO5kNaStLyZqL7cnoTn0cO8u77CyM7V2+Dj5YDk4NnQxryzraqrsLnG1+r/ipWgq7XAy9fj7/uDipCXnqWss7rCytLa4unx+P6Bh66nwMzBpoTGjL72mbjV8IKKjo2IgOnNr5Dkrv2u44qZlvmrgruqnpOJgO3byrmqnZOMiYmLjZCTlpmampeTj4qFgPXr4djRy8fFxcbJzNDU2IDc4OTo6+/z+P2BhIeKjZCTmJyiqbO+zeD4i5620e6GlaSzwtLh7/yEi5GYnqOoqqysq6ikoJuVj4mD/fLo39bOx8G9ubi4u8DK1+b3hZCcqLXC8OWFzufRpOqcxe6KnKivrqWXheO5kNaStLyZqL7cnoTn0cO8u77CyM7V2+Dj5YDk4NnQxryzraqrsLnG1+r/ipWgq7XAy9fj7/uDipCXnqWss7rCytLa4unx+P6Bh66nwMzBpoTGjL72mbjV8IKKjo2IgOnNr5Dkrv2u44qZlvmrgruqnpOJgO3byrmqnZOMiYmLjZCTlpmampeTj4qFgPXr4djRy8fFxcbJzNDU2IDc4OTo6+/z+P2BhIeKjZCTmJyiqbO+zeD4i5620e6GlaSzwtLh7/yEi5GYnqOoqqysq6ikoJuVj4mD/fLo39bOx8G9ubi4u8DK1+b3hZCcqLXC8OWFzufRpOqcxe6KnKivrqWXheO5kNaStLyZqL7cnoTn0cO8u77CyM7V2+Dj5YDk4NnQxryzraqrsLnG1+r/ipWgq7XAy9fj7/uDipCXnqWss7rCytLa4unx+P6Bh66nwMzBpoTGjL72mbjV8IKKjo2IgOnNr5Dkrv2u44qZlvmrgruqnpOJgO3byrmqnZOMiYmLjZCTlpmampeTj4qFgPXr4djRy8fFxcbJzNDU2Il2kHeFeIl5k3qSeYd6Cnx/gIGCg4OEhISIhQ2EhISDg4KBgH57eHh4nneLeJJ5DXp6ent8fX5/gICBgYGEgoaDhIILgYGAgH9/fn17enmGeJh3j3YCAgEAgO7y9vr9gIKFh4qNkJOWmZygpauyu8bW64OUqsbmhJWnuMnZ6feCiI2Sl5ygo6anp6akoZ2Yk46Ig/307efi3dnV0c/Nzc3P09jg6/iDjJWfqLTf4YXO6taq9aTP+pGksri3rp+M7sKY35e3vZqovdSW/NzIvbi5vcPL09zk6/DzgPLu593SyL63s7O3v8va7YCKlJ2nsLrEztnk8PyFjJObpKy0vcfQ2uTu94CFio6a8oyhopHvt4W49ZzB5oSUoKmtraedj/7btZHgpuuex+fuzoyv1L+wo5aL/+nUv62cjoP68/Hz+X+DhomKi4qIhoP/9+/o4dvX1dTU1tnc4eXqgO7y9vr9gIKFh4qNkJOWmZygpauyu8bW64OUqsbmhJWnuMnZ6feCiI2Sl5ygo6anp6akoZ2Yk46Ig/307efi3dnV0c/Nzc3P09jg6/iDjJWfqLTf4YXO6taq9aTP+pGksri3rp+M7sKY35e3vZqovdSW/NzIvbi5vcPL09zk6/DzgPLu593SyL63s7O3v8va7YCKlJ2nsLrEztnk8PyFjJObpKy0vcfQ2uTu94CFio6a8oyhopHvt4W49ZzB5oSUoKmtraedj/7btZHgpuuex+fuzoyv1L+wo5aL/+nUv62cjoP68/Hz+X+DhomKi4qIhoP/9+/o4dvX1dTU1tnc4eXqgO7y9vr9gIKFh4qNkJOWmZygpauyu8bW64OUqsbmhJWnuMnZ6feCiI2Sl5ygo6anp6akoZ2Yk46Ig/307efi3dnV0c/Nzc3P09jg6/iDjJWfqLTf4YXO6taq9aTP+pGksri3rp+M7sKY35e3vZqovdSW/NzIvbi5vcPL09zk6/DzgPLu593SyL63s7O3v8va7YCKlJ2nsLrEztnk8PyFjJObpKy0vcfQ2uTu94CFio6a8oyhopHvt4W49ZzB5oSUoKmtraedj/7btZHgpuuex+fuzoyv1L+wo5aL/+nUv62cjoP68/Hz+X+DhomKi4qIhoP/9+/o4dvX1dTU1tnc4eXqhXaTd4V4iHmUepN5h3oKfH+AgYKDg4SEhIiFDISEhIODgoGAfnt4eJ53jXiOeYZ6DHx9fn9/gIGBgYKCgomDhIIKgYGAgH9+fXx7eYZ4iHeFdop3kHYCAgEAgICChIaIioyPkpWYm52go6aprrO7xM/g94qeuNj8kqa7zuHzgYiOk5ebnqGkpqenpqSinpqWko2IhIKA/fv49vTy8fDv8PHy9Pf7gISJjpSaoarT3YTO6dar96XR/JOls7q5sKGN8MSZ4Zi4vZmovMyP8tXDura4vcXO2OPt9fv/gP/89evf1MnBvLu+xdDe74CJkpqjq7S9x9Ld6feDipOcpa+4ws3Y5PD8ho+apK6+k6vIyrSS36Dckbnkh5utvMbLysS4qJWA1quFxo2+8YyP8qDI9drHt6iajP7kzLWhj4Lx5eDg5Ovy+oCDhYaGhYOB/Pfx7Ojl5OTl6Ovv8/j9gICChIaIioyPkpWYm52go6aprrO7xM/g94qeuNj8kqa7zuHzgYiOk5ebnqGkpqenpqSinpqWko2IhIKA/fv49vTy8fDv8PHy9Pf7gISJjpSaoarT3YTO6dar96XR/JOls7q5sKGN8MSZ4Zi4vZmovMyP8tXDura4vcXO2OPt9fv/gP/89evf1MnBvLu+xdDe74CJkpqjq7S9x9Ld6feDipOcpa+4ws3Y5PD8ho+apK6+k6vIyrSS36Dckbnkh5utvMbLysS4qJWA1quFxo2+8YyP8qDI9drHt6iajP7kzLWhj4Lx5eDg5Ovy+oCDhYaGhYOB/Pfx7Ojl5OTl6Ovv8/j9gICChIaIioyPkpWYm52go6aprrO7xM/g94qeuNj8kqa7zuHzgYiOk5ebnqGkpqenpqSinpqWko2IhIKA/fv49vTy8fDv8PHy9Pf7gISJjpSaoarT3YTO6dar96XR/JOls7q5sKGN8MSZ4Zi4vZmovMyP8tXDura4vcXO2OPt9fv/gP/89evf1MnBvLu+xdDe74CJkpqjq7S9x9Ld6feDipOcpa+4ws3Y5PD8ho+apK6+k6vIyrSS36Dckbnkh5utvMbLysS4qJWA1quFxo2+8YyP8qDI9drHt6iajP7kzLWhj4Lx5eDg5Ovy+oCDhYaGhYOB/Pfx7Ojl5OTl6Ovv8/j9mHeFeIZ5mHqPeYl6Cnx/gIGCg4OEhISIhQyEhISDg4KBgH57eHied414jXmGegx7fH1+f4CAgYGCgoKMgwyCgoKBgYB/f358e3mHeId3iHaId492AgIBAEOLjY+Rk5WXmp2go6aoq62ws7e9w8zY6oKTq8jsiqG40Ob7h4+Wm5+jpqiqq6ysq6qopqOfnJmVkpGRkZCQkJGRkpKShJOAlJSUlpeYmZueoqfN24TN6NSn8KDK9Y6grbSzqpuJ6b6U25W2vZmou8SJ6c/AuLa5v8jS3en1/oKFhYSB+Ozg1czHxcbM1eLxgIiQmJ+nr7jCzdnm9oKLlJ6os73I1OLvgI6lxOiGlqfg0+Xky6X7tPij0ICYsMTU4OXk3dC+qJA58MCV3p3UhZiZ/6rkkP7m0b+tnY373sKqloXz49vY2+Hp8fmAgoWGhoWEgoD++vf19fb4+/+BhIaJQ4uNj5GTlZeanaCjpqirrbCzt73DzNjqgpOryOyKobjQ5vuHj5abn6OmqKqrrKyrqqimo5+cmZWSkZGRkJCQkZGSkpKEk4CUlJSWl5iZm56ip83bhM3o1KfwoMr1jqCttLOqm4npvpTblba9mai7xInpz8C4trm/yNLd6fX+goWFhIH47ODVzMfFxszV4vGAiJCYn6evuMLN2eb2gouUnqizvcjU4u+AjqXE6IaWp+DT5eTLpfu0+KPQgJiwxNTg5eTd0L6okDnwwJXendSFmJn/quSQ/ubRv62djfvewqqWhfPj29jb4enx+YCChYaGhYSCgP769/X19vj7/4GEholDi42PkZOVl5qdoKOmqKutsLO3vcPM2OqCk6vI7IqhuNDm+4ePlpufo6aoqqusrKuqqKajn5yZlZKRkZGQkJCRkZKSkoSTgJSUlJaXmJmbnqKnzduEzejUp/CgyvWOoK20s6qbiem+lNuVtr2ZqLvEienPwLi2ub/I0t3p9f6ChYWEgfjs4NXMx8XGzNXi8YCIkJifp6+4ws3Z5vaCi5SeqLO9yNTi74COpcTohpan4NPl5Mul+7T4o9CAmLDE1ODl5N3QvqiQOfDAld6d1IWYmf+q5JD+5tG/rZ2N+97CqpaF8+Pb2Nvh6fH5gIKFhoaFhIKA/vr39fX2+Pv/gYSGiZd3hXiGebF6Cnx/gIGCg4OEhISIhQyEhISDg4KBgH57eHiNd4V4jHeNeIt5hXqEewp8fX5/gICBgYKCjYMNgoKCgYGAgH9+fHt5eYd4hneJdol3iXaEdwICAQBDlpianJ6go6aoq6+xtLa4u73BxszU4vaJnrjagZixy+b/jJijrLG1uLu8vb27uba0s7Kwrqyrqampqqyur7Gztba4uYW6gLm4trSxr62srK3Q24TL48ue4JW85ISUoKalnpB/2bGKzY2wupioubuE48y/ubi7wsvW4u/8g4eKi4qGgvnt4dfRzs/T2+b0gYiPlpyjq7S/ytjm9oONl6KtuMTQ3u2Al8WGwZDB4feOwZyI5reJxIaw4Yulv9Xn8/n48OLPt5yBOM+g7ajhjJ6dg7WDrJaG8tvFsZ6L9dW5oY3+6t/a2+Do8PmAg4aIiYmJiIeGhISDg4SGiIqMj5KUQ5aYmpyeoKOmqKuvsbS2uLu9wcbM1OL2iZ642oGYscvm/4yYo6yxtbi7vL29u7m2tLOysK6sq6mpqaqsrq+xs7W2uLmFuoC5uLa0sa+trKyt0NuEy+PLnuCVvOSElKCmpZ6Qf9mxis2NsLqYqLm7hOPMv7m4u8LL1uLv/IOHiouKhoL57eHX0c7P09vm9IGIj5aco6u0v8rY5vaDjZeirbjE0N7tgJfFhsGQweH3jsGciOa3icSGsOGLpb/V5/P5+PDiz7ecgTjPoO2o4YyenYO1g6yWhvLbxbGei/XVuaGN/urf2tvg6PD5gIOGiImJiYiHhoSEg4OEhoiKjI+SlEOWmJqcnqCjpqirr7G0tri7vcHGzNTi9omeuNqBmLHL5v+MmKOssbW4u7y9vbu5trSzsrCurKupqamqrK6vsbO1tri5hbqAubi2tLGvraysrdDbhMvjy57glbzkhJSgpqWekH/ZsYrNjbC6mKi5u4TjzL+5uLvCy9bi7/yDh4qLioaC+e3h19HOz9Pb5vSBiI+WnKOrtL/K2Ob2g42Xoq24xNDe7YCXxYbBkMHh947BnIjmt4nEhrDhi6W/1efz+fjw4s+3nIE4z6DtqOGMnp2DtYOsloby28Wxnov11bmhjf7q39rb4Ojw+YCDhoiJiYmIh4aEhIODhIaIioyPkpSXd4R4hnmyegp8f4CBgoODhISEiIUMhISEg4OCgYB+e3h4jHeHeIt3jXiKeQV6enp7e4R8C319fn9/gIGBgoKCjoMOgoKBgYCAf359e3p5eXmGeIV3iXaWdwICAQCAoqSmqKqtr7K1uLu9wMLExcjKztTd64GSqcjtjKbC3/6TsNHugoiKjI2NjYf75tXKx8bGxsfIyszO0dTY29/i5ejq7O3t7ezr6OTg29XPysXBvtzbgcHSuI3HhKjM7oWPlJOMgeXCnva2/qCtkqS3sv7ey8C7u7/G0Nvo9oGHjI+AkI+MiIL57ePb2Njb4ev3goiPlZuiqbO9ytjo+YaQm6ayv8zZ6f6b47CXm47Q+oWNm7jupOee1I246pCsx97x/YGA+uvWvaKG1qX1reePoaCHw5nPsp6N/eLKs52I7cuvmYj56+Tk6O/3/4OHio2PkJCPj46NjY2Oj5GTlpibnqCAoqSmqKqtr7K1uLu9wMLExcjKztTd64GSqcjtjKbC3/6TsNHugoiKjI2NjYf75tXKx8bGxsfIyszO0dTY29/i5ejq7O3t7ezr6OTg29XPysXBvtzbgcHSuI3HhKjM7oWPlJOMgeXCnva2/qCtkqS3sv7ey8C7u7/G0Nvo9oGHjI+AkI+MiIL57ePb2Njb4ev3goiPlZuiqbO9ytjo+YaQm6ayv8zZ6f6b47CXm47Q+oWNm7jupOee1I246pCsx97x/YGA+uvWvaKG1qX1reePoaCHw5nPsp6N/eLKs52I7cuvmYj56+Tk6O/3/4OHio2PkJCPj46NjY2Oj5GTlpibnqCAoqSmqKqtr7K1uLu9wMLExcjKztTd64GSqcjtjKbC3/6TsNHugoiKjI2NjYf75tXKx8bGxsfIyszO0dTY29/i5ejq7O3t7ezr6OTg29XPysXBvtzbgcHSuI3HhKjM7oWPlJOMgeXCnva2/qCtkqS3sv7ey8C7u7/G0Nvo9oGHjI+AkI+MiIL57ePb2Njb4ev3goiPlZuiqbO9ytjo+YaQm6ayv8zZ6f6b47CXm47Q+oWNm7jupOee1I246pCsx97x/YGA+uvWvaKG1qX1reePoaCHw5nPsp6N/eLKs52I7cuvmYj56+Tk6O/3/4OHio2PkJCPj46NjY2Oj5GTlpibnqCWd4V4hXmEeoh7p3oHfH+AgYKDg4SEhoUMhISEg4OCgoGAfnt4jHeJeIp3jXiKeQh6ent8fX5+foV/B4CAgYGCgoKGg4KEhoMLgoKBgYCAf359e3qEeYZ4hXeIdpZ3AgIBAEKvsbO1t7m8v8LEx8rMzc/Q0tTX3OX0h5q11oCYtNL1mdmZyvmNl5udnZ2Wh+a6loDr5ujq7fD1+f6BhIeKjI6QkpSElYCTko+NiYWB+vHo4Nnwy9ygrZjqpuCQr83l9v798t/Fp4fQmNKEj/SNpaj12srBvr/Ey9Xh7v2Fi5CUlZWSjoiC+O3m4eDj6PH9hIqQlpuiqrO/zNvs/omUn6u5xtXl+5rx08Ph/+Wlydri6/mJm7LN85S765Csx97w/IGA+erWvSqhhdal9a3okKKjjNKx99O5pJKC5suxmYTiwaiUh/318/b8goaKjpGUlpeEmAyXl5iZmp2foqWoqq1Cr7Gztbe5vL/CxMfKzM3P0NLU19zl9IeatdaAmLTS9ZnZmcr5jZebnZ2dlofmupaA6+bo6u3w9fn+gYSHioyOkJKUhJWAk5KPjYmFgfrx6ODZ8MvcoK2Y6qbgkK/N5fb+/fLfxaeH0JjShI/0jaWo9drKwb6/xMvV4e79hYuQlJWVko6Igvjt5uHg4+jx/YSKkJaboqqzv8zb7P6JlJ+rucbV5fua8dPD4f/lpcna4uv5iZuyzfOUu+uQrMfe8PyBgPnq1r0qoYXWpfWt6JCio4zSsffTuaSSgubLsZmE4sGolIf99fP2/IKGio6RlJaXhJgMl5eYmZqdn6KlqKqtQq+xs7W3uby/wsTHyszNz9DS1Nfc5fSHmrXWgJi00vWZ2ZnK+Y2Xm52dnZaH5rqWgOvm6Ort8PX5/oGEh4qMjpCSlISVgJOSj42JhYH68ejg2fDL3KCtmOqm4JCvzeX2/v3y38Wnh9CY0oSP9I2lqPXaysG+v8TL1eHu/YWLkJSVlZKOiIL47ebh4OPo8f2EipCWm6Kqs7/M2+z+iZSfq7nG1eX7mvHTw+H/5aXJ2uLr+Ymbss3zlLvrkKzH3vD8gYD56ta9KqGF1qX1reiQoqOM0rH307mkkoLmy7GZhOLBqJSH/fXz9vyChoqOkZSWl4SYDJeXmJmanZ+ipaiqrZZ3hHiFeQV6ent7e4h8hHuJepR7hnoIfH6AgYKCg4OMhAmDg4KCgX9+e3iMd4p4iXeNeIl5B3p6e3x9fn+GgIWBg4KGg4KEhoMLgoKBgYCAf359e3qGeYV4hXeFdph3AgIBAIC8vsDCxMbJzM/R1NbY2drb3N3g5O39jKG/5IijweWW+tatkNSBiY2Pj4yF88qKncWdjImLjpGVmJygpKirr7K1t7i5urq5t7SxraijnZeRi4X+gZCL0evYroCx6JCpvczT0sm4oojZo+iaub+bq8iU7dfLxcLEydHb5/WCiZCVmXCbmpiUjoiB+PDr6uvx+YGHjJKXnaSstsLQ4PKDjZmlssDP4PeY8eHig56kisPugoeKjpKXl5SWor3mjKa/1Obx9/bu4My1m4DNn+2o4o6jppLjzJH42L6olILlx6yT+9a5o5SKhYOEh4uPk5eanZ+hhaILo6Olp6msr7K1uLqAvL7AwsTGyczP0dTW2Nna29zd4OTt/Yyhv+SIo8HllvrWrZDUgYmNj4+MhfPKip3FnYyJi46RlZicoKSoq6+ytbe4ubq6ube0sa2oo52XkYuF/oGQi9Hr2K6AseiQqb3M09LJuKKI2aPomrm/m6vIlO3Xy8XCxMnR2+f1gomQlZlwm5qYlI6Igfjw6+rr8fmBh4ySl52krLbC0ODyg42ZpbLAz+D3mPHh4oOepIrD7oKHio6Sl5eUlqK95oymv9Tm8ff27uDMtZuAzZ/tqOKOo6aS48yR+Ni+qJSC5cesk/vWuaOUioWDhIeLj5OXmp2foYWiC6OjpaeprK+ytbi6gLy+wMLExsnMz9HU1tjZ2tvc3eDk7f2Mob/kiKPB5Zb61q2Q1IGJjY+PjIXzyoqdxZ2MiYuOkZWYnKCkqKuvsrW3uLm6urm3tLGtqKOdl5GLhf6BkIvR69iugLHokKm9zNPSybiiiNmj6Jq5v5uryJTt18vFwsTJ0dvn9YKJkJWZcJuamJSOiIH48Ovq6/H5gYeMkpedpKy2wtDg8oONmaWywM/g95jx4eKDnqSKw+6Ch4qOkpeXlJaiveaMpr/U5vH39u7gzLWbgM2f7ajijqOmkuPMkfjYvqiUguXHrJP71rmjlIqFg4SHi4+Tl5qdn6GFogujo6WnqayvsrW4upZ3hHiEeQZ6ent8fX2HfgR9fX18onsLent8fn+AgYKDg4OKhAqDg4KCgYB/fXp4i3eMeId3jXiJeQp6ent8fn+AgYGBjIKOgwyCgoGBgIB/fn17enqGeYR4oncCAgEAgMrMztDS1NfZ3N/h4+Xl5ubm5+nt9oORqMfvkKzQjP2A8vTuu++ChYaFg/3rwf//1fW9qaersLW6v8TJztLX297g4uPk4+Lf3NfSzMa+t6+nnpeQsPHC+IDjs4Kx4IWWoqemn5L/06Ttn8PUwITniYLn1s3JycvR2eLv/YaOlZqegKCgnpmUjoeB+/Xz9fqAhYuQlZugqLG8yNfo+oeSnqy6ydrxle/h7Y6ruayIuuL7g4aIiIT54Ma6w9+Dma/D093i4drNu6aO7b6T3J3ViJ+mlvTpqY/52sCpk4Dfv6OK7cy0o5iSkJCTl5ueoqWoqqytra2urq6wsbO2uby/wsXIgMrMztDS1NfZ3N/h4+Xl5ubm5+nt9oORqMfvkKzQjP2A8vTuu++ChYaFg/3rwf//1fW9qaersLW6v8TJztLX297g4uPk4+Lf3NfSzMa+t6+nnpeQsPHC+IDjs4Kx4IWWoqemn5L/06Ttn8PUwITniYLn1s3JycvR2eLv/YaOlZqegKCgnpmUjoeB+/Xz9fqAhYuQlZugqLG8yNfo+oeSnqy6ydrxle/h7Y6ruayIuuL7g4aIiIT54Ma6w9+Dma/D093i4drNu6aO7b6T3J3ViJ+mlvTpqY/52sCpk4Dfv6OK7cy0o5iSkJCTl5ueoqWoqqytra2urq6wsbO2uby/wsXIgMrMztDS1NfZ3N/h4+Xl5ubm5+nt9oORqMfvkKzQjP2A8vTuu++ChYaFg/3rwf//1fW9qaersLW6v8TJztLX297g4uPk4+Lf3NfSzMa+t6+nnpeQsPHC+IDjs4Kx4IWWoqemn5L/06Ttn8PUwITniYLn1s3JycvR2eLv/YaOlZqegKCgnpmUjoeB+/Xz9fqAhYuQlZugqLG8yNfo+oeSnqy6ydrxle/h7Y6ruayIuuL7g4aIiIT54Ma6w9+Dma/D093i4drNu6aO7b6T3J3ViJ+mlvTpqY/52sCpk4Dfv6OK7cy0o5iSkJCTl5ueoqWoqqytra2urq6wsbO2uby/wsXIlXeFeAt5eXl6enx8fX5/f4WABn9/f359fKR7CXx+f4GBgoODg4eEDIODg4KCgYB/fnt5eIt3jXiFd454iHkIenp7fH5/gIGEgoWDhoKNgw6CgoKBgYCAf359e3p6eoZ5hHihdwICAQBB2Nrc3uDi5Ofq7O7w8fHx8PDw8vb/iJeuz/qXuIDxg4yYp6D4oLK4urm2sKGEs76b+Y/fzM3S2N/l7PL4/oGEhYeEiICHhYOA+/Pr49rQxryyqaHHgsj7geOz/6bI4vP8+vDcv5zpn8TVwomApo7249jS0NDU2uHs+IOLk5qgpKampKCalI2HgoD+/4GFio+UmZ+lrbfCz9/wgo2YpbPD1OuS6t7skrPCuJvomrnP2+Hi3dG+o4jl1NryiZysusTIx8C1pTuT/dKpg8OMv/WSnZWBg8GkjffZvaWP99S0mYLhxrOmoJ2eoaSorK+ytba4uLm5ubq7vL7Aw8fKzdHU1kHY2tze4OLk5+rs7vDx8fHw8PDy9v+Il67P+pe4gPGDjJinoPigsri6ubawoYSzvpv5j9/MzdLY3+Xs8vj+gYSFh4SIgIeFg4D78+vj2tDGvLKpoceCyPuB47P/psji8/z68Ny/nOmfxNXCiYCmjvbj2NLQ0NTa4ez4g4uTmqCkpqakoJqUjYeCgP7/gYWKj5SZn6Wtt8LP3/CCjZils8PU65Lq3uySs8K4m+iauc/b4eLd0b6jiOXU2vKJnKy6xMjHwLWlO5P90qmDw4y/9ZKdlYGDwaSN99m9pY/31LSZguHGs6agnZ6hpKisr7K1tri4ubm5uru8vsDDx8rN0dTWQdja3N7g4uTn6uzu8PHx8fDw8PL2/4iXrs/6l7iA8YOMmKeg+KCyuLq5trChhLO+m/mP38zN0tjf5ezy+P6BhIWHhIiAh4WDgPvz6+Pa0Ma8sqmhx4LI+4Hjs/+myOLz/Prw3L+c6Z/E1cKJgKaO9uPY0tDQ1Nrh7PiDi5OaoKSmpqSgmpSNh4KA/v+BhYqPlJmfpa23ws/f8IKNmKWzw9Trkure7JKzwrib6Jq5z9vh4t3RvqOI5dTa8omcrLrEyMfAtaU7k/3SqYPDjL/1kp2VgYPBpI332b2lj/fUtJmC4cazpqCdnqGkqKyvsrW2uLi5ubm6u7y+wMPHys3R1NaVd4V4Cnl5enp8fX5/gICJgQWAf358fIt7jHyMewd9fn+BgYKCioMJgoKBgH9+fHl4i3eQeIJ3jniIeQp6ent8fn+AgYKCi4OEgouDhIIMgYGAf39+fXx7enp6hXmFeKB3AgIBAIDn6Ors7vDy9ff5+/z9/fz7+vr8gISNnbXXgZ/l4/+Opr3CrIGlu8THxsO7qYrC4NKoiaKD9vj+g4eLjpKWmZyen6GhoaCfnZqWko6JhP/06N3Rxbmu0oTJ+4HiremOoKqvrqiciNmbxNXDiYGrloLu4dvY2Nnd5Oz2gYiQmaCmqm+srKqmoJqTjIiFhISGiY6TmJ6kq7O9ydfn+YeSn628zeOL3NLjj7PFvaL8suWJmaSpqKKXh+W5lPXf4fKGk5+nq6qkmoz51rGN26Lmm8fug4P9j9q5n4ry07eeiOnGqI/22MO2r6ytsLO3ur7AwsSExQ3GxsfJy87R1Njb3+LkgOfo6uzu8PL19/n7/P39/Pv6+vyAhI2dtdeBn+Xj/46mvcKsgaW7xMfGw7upisLg0qiJooP2+P6Dh4uOkpaZnJ6foaGhoJ+dmpaSjomE//To3dHFua7ShMn7geKt6Y6gqq+uqJyI2ZvE1cOJgauWgu7h29jY2d3k7PaBiJCZoKaqb6ysqqagmpOMiIWEhIaJjpOYnqSrs73J1+f5h5KfrbzN44vc0uOPs8W9ovyy5YmZpKmoopeH5bmU9d/h8oaTn6erqqSajPnWsY3bouabx+6Dg/2P2rmfivLTt56I6caoj/bYw7avrK2ws7e6vsDCxITFDcbGx8nLztHU2Nvf4uSA5+jq7O7w8vX3+fv8/f38+/r6/ICEjZ2114Gf5eP/jqa9wqyBpbvEx8bDu6mKwuDSqImig/b4/oOHi46Slpmcnp+hoaGgn52alpKOiYT/9Ojd0cW5rtKEyfuB4q3pjqCqr66onIjZm8TVw4mBq5aC7uHb2NjZ3eTs9oGIkJmgpqpvrKyqpqCak4yIhYSEhomOk5iepKuzvcnX5/mHkp+tvM3ji9zS44+zxb2i/LLliZmkqaiil4fluZT13+HyhpOfp6uqpJqM+daxjdui5pvH7oOD/Y/auZ+K8tO3nojpxqiP9tjDtq+srbCzt7q+wMLEhMUNxsbHycvO0dTY29/i5JN3hngKeXl5ent9fn+AgYqCCoGAf359fHx7e3uWfIl7B31+f4GBgoKIgwqCgoGAf358eXh4ineheId5DHp6e3x+f4CBgoKDg4iEg4OEgomDhIIKgYGAgH9+fn17e4R6hXmEeKB3AgIBAID19/j6/P6AgYKDg4SEhIOCgYGChIqTo7zgicrU9ounxdDBnuGOoq2xsa2jkvGv3OzZr5S4mZGTmJyhpaqusrW3ubq7u7m4tbGtqaOemJKMhf7w4tTFuNiFyfv/1pe5z9jc29bKsYu81MKJga2ch/jq49/f4OPo7/eAh46Xn6assG6ysrCspp+Yko2KiYmLjpOYnaOpsbnE0N/wgYyYprXG2YDAt8uFrcK+pIG8/qC91OPq6d/Otpn4wpf229fh84KJjIuG++TIqovdqPSp3YmfrrjUlPHNsJmF6MmtlP7XtpuF69XGvry8v8PGys3P0YbSDNPU1tjb3uLm6e3w84D19/j6/P6AgYKDg4SEhIOCgYGChIqTo7zgicrU9ounxdDBnuGOoq2xsa2jkvGv3OzZr5S4mZGTmJyhpaqusrW3ubq7u7m4tbGtqaOemJKMhf7w4tTFuNiFyfv/1pe5z9jc29bKsYu81MKJga2ch/jq49/f4OPo7/eAh46Xn6assG6ysrCspp+Yko2KiYmLjpOYnaOpsbnE0N/wgYyYprXG2YDAt8uFrcK+pIG8/qC91OPq6d/Otpn4wpf229fh84KJjIuG++TIqovdqPSp3YmfrrjUlPHNsJmF6MmtlP7XtpuF69XGvry8v8PGys3P0YbSDNPU1tjb3uLm6e3w84D19/j6/P6AgYKDg4SEhIOCgYGChIqTo7zgicrU9ounxdDBnuGOoq2xsa2jkvGv3OzZr5S4mZGTmJyhpaqusrW3ubq7u7m4tbGtqaOemJKMhf7w4tTFuNiFyfv/1pe5z9jc29bKsYu81MKJga2ch/jq49/f4OPo7/eAh46Xn6assG6ysrCspp+Yko2KiYmLjpOYnaOpsbnE0N/wgYyYprXG2YDAt8uFrcK+pIG8/qC91OPq6d/Otpn4wpf229fh84KJjIuG++TIqovdqPSp3YmfrrjUlPHNsJmF6MmtlP7XtpuF69XGvry8v8PGys3P0YbSDNPU1tjb3uLm6e3w84Z3k3gLeXl6e31+f4CBgoKIgweCgoGAf359nXyHewV9fn+AgYqCCIGAf358eXh4ineheId5DHp6e3x+f4CBgoODg4qEg4OFgoWDhYILgYGAgH9/fn18e3uFeoR5hXifdwICAQCAgYKDg4SFhoeIiYqKiomIh4aGh4qPmarE7Ky95oekxdTJqYCv2fiGi4uH/eC5i7zi8Nyzncywqq2yt7zBxsrO0dPV1dTT0c3JxL+5sqylnpePiIDw3sy82YTI9ear0+ft7u7s48qcxsGJga2eiv7x6ebm5+rt8/qBh42VnaWssrdwubm2saylnZeSj42Nj5KXnKKor7fAy9jn+IaRn62+0OmcjZnNkK+zn4C9g6vU+IqUmZeRhevHofzBk+nJv8PN19za0cOvmYHRo/Ss55GtxNyGwp2D4MGnkf3bvKCJ6cWnkP7m1s7LzM/T1trc3t/g4IXfC+Di5ejr7/P3+/6AgIGCg4OEhYaHiImKioqJiIeGhoeKj5mqxOysveaHpMXUyamAr9n4houLh/3guYu84vDcs53MsKqtsre8wcbKztHT1dXU09HNycS/ubKspZ6Xj4iA8N7MvNmEyPXmq9Pn7e7u7OPKnMbBiYGtnor+8enm5ufq7fP6gYeNlZ2lrLK3cLm5trGspZ2Xko+NjY+Sl5yiqK+3wMvY5/iGkZ+tvtDpnI2ZzZCvs5+AvYOr1PiKlJmXkYXrx6H8wZPpyb/Dzdfc2tHDr5mB0aP0rOeRrcTchsKdg+DBp5H927ygienFp5D+5tbOy8zP09ba3N7f4OCF3wvg4uXo6+/z9/v+gICBgoODhIWGh4iJioqKiYiHhoaHio+ZqsTsrL3mh6TF1MmpgK/Z+IaLi4f94LmLvOLw3LOdzLCqrbK3vMHGys7R09XV1NPRzcnEv7myrKWel4+IgPDezLzZhMj15qvT5+3u7uzjypzGwYmBrZ6K/vHp5ubn6u3z+oGHjZWdpayyt3C5ubaxrKWdl5KPjY2Pkpecoqivt8DL2Of4hpGfrb7Q6ZyNmc2Qr7OfgL2Dq9T4ipSZl5GF68eh/MGT6cm/w83X3NrRw6+ZgdGj9Kznka3E3IbCnYPgwaeR/du8oInpxaeQ/ubWzsvMz9PW2tze3+Dghd8L4OLl6Ovv8/f7/oCZeAl5ent9fn+AgYKEg4SEhIMGgoGAf359n3yFewR9fn+AioEHgH9+fHl4eIp3oniHeQp6e3x9f4CBgoODhISGhQaEhISDg4ONgg2BgYCAf39+fXx8e3t7hHqFeYR4nncBeAICAQAIiImJiouMjY6Fj1KOjYyLi4yPlaCyzYmRv/Gbv9HKrIa/+5mvvsbHwLKehM2Sv+Pv27Kg28XCx83T2d7j5+vt7u/u7Onl4NvUzca/uLCooJePhffizbnUgr3Gmr7LhMyAyLWLpYWArJ2LgPXt6uvt8PP4/oOHjZSbpKyzub6/v7y3saqinJeTkZGTlpugpqy0vMbS3++AipeltMba/sbL8bD1jorrtH+r24WbrLi+vLSlkvnLn/O0hcilmZuhpKKbkIDfu5fpq+yYutuBp/fJqI3y0bWdiOzKrZP507OaiPcd5t7b3N/j5uns7e7u7e3s6+vr7O7x9Pj8gIKDhYYIiImJiouMjY6Fj1KOjYyLi4yPlaCyzYmRv/Gbv9HKrIa/+5mvvsbHwLKehM2Sv+Pv27Kg28XCx83T2d7j5+vt7u/u7Onl4NvUzca/uLCooJePhffizbnUgr3Gmr7LhMyAyLWLpYWArJ2LgPXt6uvt8PP4/oOHjZSbpKyzub6/v7y3saqinJeTkZGTlpugpqy0vMbS3++AipeltMba/sbL8bD1jorrtH+r24WbrLi+vLSlkvnLn/O0hcilmZuhpKKbkIDfu5fpq+yYutuBp/fJqI3y0bWdiOzKrZP507OaiPcd5t7b3N/j5uns7e7u7e3s6+vr7O7x9Pj8gIKDhYYIiImJiouMjY6Fj1KOjYyLi4yPlaCyzYmRv/Gbv9HKrIa/+5mvvsbHwLKehM2Sv+Pv27Kg28XCx83T2d7j5+vt7u/u7Onl4NvUzca/uLCooJePhffizbnUgr3Gmr7LhMyAyLWLpYWArJ2LgPXt6uvt8PP4/oOHjZSbpKyzub6/v7y3saqinJeTkZGTlpugpqy0vMbS3++AipeltMba/sbL8bD1jorrtH+r24WbrLi+vLSlkvnLn/O0hcilmZuhpKKbkIDfu5fpq+yYutuBp/fJqI3y0bWdiOzKrZP507OaiPcd5t7b3N/j5uns7e7u7e3s6+vr7O7x9Pj8gIKDhYaYeAx5ent8fn+AgYKDg4OJhAiDg4KBgH9+fZ98hXsDfX5/ioAHf358eXh4eIl3oniIeQx6e3x+f4GCgoOEhISJhQaEhISDg4OKgguBgYGAgH9/fn19fIR7hXqEeYV4mXeFeAICAQCAjo+QkJGSk5SUlZWVlJOSkZCQkZSbprjYt/+1ga7IxKuGw4WqzOj9hISA7tOyjdOTvt/o0KSZ5dnb4ejv9fr/gYKDg4OCgPz28Onh2dHJwLiwpp2Sh/jgx7HI3/PA6O7u7ezr6dqouOqnmYmB9/Hu7vH1+f6BhImOlJujq7O7wcWAxsXCvbaup6Cbl5WVl5qfpKqxucLM2Ob2hI+cq7vO5Iv2iKX1qcC4mOWf04Wguc7c4+HXxq+V9cGS1pbNke3h5ejk2cexmYDPn+ecxvGVypn807GWgd/BqJH72LichOG/pJGD9u7r7O/z9vn7/Pz8+/n49/f3+Pr9gIKEhoiKi42Ajo+QkJGSk5SUlZWVlJOSkZCQkZSbprjYt/+1ga7IxKuGw4WqzOj9hISA7tOyjdOTvt/o0KSZ5dnb4ejv9fr/gYKDg4OCgPz28Onh2dHJwLiwpp2Sh/jgx7HI3/PA6O7u7ezr6dqouOqnmYmB9/Hu7vH1+f6BhImOlJujq7O7wcWAxsXCvbaup6Cbl5WVl5qfpKqxucLM2Ob2hI+cq7vO5Iv2iKX1qcC4mOWf04Wguc7c4+HXxq+V9cGS1pbNke3h5ejk2cexmYDPn+ecxvGVypn807GWgd/BqJH72LichOG/pJGD9u7r7O/z9vn7/Pz8+/n49/f3+Pr9gIKEhoiKi42Ajo+QkJGSk5SUlZWVlJOSkZCQkZSbprjYt/+1ga7IxKuGw4WqzOj9hISA7tOyjdOTvt/o0KSZ5dnb4ejv9fr/gYKDg4OCgPz28Onh2dHJwLiwpp2Sh/jgx7HI3/PA6O7u7ezr6dqouOqnmYmB9/Hu7vH1+f6BhImOlJujq7O7wcWAxsXCvbaup6Cbl5WVl5qfpKqxucLM2Ob2hI+cq7vO5Iv2iKX1qcC4mOWf04Wguc7c4+HXxq+V9cGS1pbNke3h5ejk2cexmYDPn+ecxvGVypn807GWgd/BqJH72LichOG/pJGD9u7r7O/z9vn7/Pz8+/n49/f3+Pr9gIKEhoiKi42YeAp5enx+f4CBgoODhYSDhYSECIODgoGAf359iXyHfY98hXsCfH2KfgZ9e3l4eHiId6R4h3kMenp8fX6AgYKDg4SEi4UHhISEg4OCgoqBCYCAf39+fX18fIV7hHqFeYV4lXeIeAICAQCAk5SVlpaXmJmZmpqamZeWlZSUlpqhrL/o/syc8J6snoG/ha/bgZOfpqehlobkuY7OjbLJwprph/Du9PyBhIeKjI6Oj46Ni4iFgfvz6uHZ0Me+tKmekoXx1ruio96Sm5WQi4iGhP/L0oiThv/38vDx9Pn+gYSGio+UmqKqsrvCyMyAzczIwruzq6Sfm5mZmp6jqK61vcbR3uz9iJOgsMLW7pWQqsyTyeTatYe79pq41e3+goH348mrjN6o8aPPgbKYlpaSivzgwqSFz5bMg6nsuJmA2rmdiOvMspqF5MKljO3KrpmLg/36+/6BgoSEhYWEg4KBgYCAgYKDhYeJi42PkZKAk5SVlpaXmJmZmpqamZeWlZSUlpqhrL/o/syc8J6snoG/ha/bgZOfpqehlobkuY7OjbLJwprph/Du9PyBhIeKjI6Oj46Ni4iFgfvz6uHZ0Me+tKmekoXx1ruio96Sm5WQi4iGhP/L0oiThv/38vDx9Pn+gYSGio+UmqKqsrvCyMyAzczIwruzq6Sfm5mZmp6jqK61vcbR3uz9iJOgsMLW7pWQqsyTyeTatYe79pq41e3+goH348mrjN6o8aPPgbKYlpaSivzgwqSFz5bMg6nsuJmA2rmdiOvMspqF5MKljO3KrpmLg/36+/6BgoSEhYWEg4KBgYCAgYKDhYeJi42PkZKAk5SVlpaXmJmZmpqamZeWlZSUlpqhrL/o/syc8J6snoG/ha/bgZOfpqehlobkuY7OjbLJwprph/Du9PyBhIeKjI6Oj46Ni4iFgfvz6uHZ0Me+tKmekoXx1ruio96Sm5WQi4iGhP/L0oiThv/38vDx9Pn+gYSGio+UmqKqsrvCyMyAzczIwruzq6Sfm5mZmp6jqK61vcbR3uz9iJOgsMLW7pWQqsyTyeTatYe79pq41e3+goH348mrjN6o8aPPgbKYlpaSivzgwqSFz5bMg6nsuJmA2rmdiOvMspqF5MKljO3KrpmLg/36+/6BgoSEhYWEg4KBgYCAgYKDhYeJi42PkZKYeAx5e31+gIGCg4OEhISIhQuEhISDg4KBgH99fYR8jn2NfIZ7iHwGe3t6eXh4iHemeId5DHp7fH1/gIGCg4SEhIWFgoaFhQaEhIODgoKGgYWABX9/fn59hHyEe4V6hHmGeIR3mHgCAgEACJiZmpqbnJydhJ6AnZuamZiZm5+ns8X2o4/isOf23Kz4qNmGnbLBycrDtaKL5bOFvPaQjuWfnYP/goaKjpGUlpiZmZiWlJGOioWB+fDn3dTKwLWpnI6A48WojevCnf3Mp4vx18W0momC+/Xy8vP3+4CDhomMkJWboaixusLJz9PU0s7IwLivqKKenJxenqGmrLK5wcvV4vGBi5ektMfc9pyfxO2j2/nvx5XQiKrM7IONkY+J+969m/W4gqrN54bDsq2nnY7/3r6e+72GuYbWtJiC3r6jjfbWuqKL8Myuk/nUt6GTioWEhIaIioSLEoqJiIeGhYWFhoiKjI6QkpSWlwiYmZqam5ycnYSegJ2bmpmYmZufp7PF9qOP4rDn9tys+KjZhp2ywcnKw7Wii+Wzhbz2kI7ln52D/4KGio6RlJaYmZmYlpSRjoqFgfnw593UysC1qZyOgOPFqI3rwp39zKeL8dfFtJqJgvv18vLz9/uAg4aJjJCVm6GosbrCyc/T1NLOyMC4r6iinpycXp6hpqyyucHL1eLxgYuXpLTH3Pacn8Tto9v578eV0IiqzOyDjZGPifvevZv1uIKqzeeGw7Ktp52O/96+nvu9hrmG1rSYgt6+o4321rqii/DMrpP51Lehk4qFhISGiIqEixKKiYiHhoWFhYaIioyOkJKUlpcImJmampucnJ2EnoCdm5qZmJmbn6ezxfajj+Kw5/bcrPio2YadssHJysO1oovls4W89pCO5Z+dg/+ChoqOkZSWmJmZmJaUkY6KhYH58Ofd1MrAtamcjoDjxaiN68Kd/cyni/HXxbSaiYL79fLy8/f7gIOGiYyQlZuhqLG6wsnP09TSzsjAuK+oop6cnF6eoaassrnBy9Xi8YGLl6S0x9z2nJ/E7aPb+e/HldCIqszsg42Rj4n73r2b9biCqs3nhsOyraedjv/evp77vYa5hta0mILevqON9ta6oovwzK6T+dS3oZOKhYSEhoiKhIsSiomIh4aFhYWGiIqMjpCSlJaXmHgLenx9f4CBgoODhISKhQyEhISDgoKBf359fXySfYx8hHuDeoR5h3iHd6d4iHkLent8fX+AgYKDhISEhYWGhIUHhISEg4KBgYaAhH8Ffn5+fX2EfIR7hXqEeaJ4AgIBAAicnZ6en5+goIShgKCfnZycnZ+lrbnMgLywi9iOlobRlciAnLfP4Orr49O9o4bUoOSWsK+Luq+MhomNkpaZnJ+goaGgn5yZlZGMh4L88+nf1cq+sqSWhu7Or5HtvZTmsordtp6PhoH69PHw8fT4/YGEiIuOkpaboaevuMHJ0dba2tjUzcW8s6ymoqCfdKGlqq+1vcXO2eb1g42ZqLjL4vygpdOCsOeC+9Of3pG22vuMlpuakobtyqaCwoeuytTW+MOxppyPgunMr5Puu5LwzbCXguDBqJH/38KpkfrVtZmC3b+pmpGMi4uNj5CRkpGRkI6Ni4qKiYqLjI6QkpSWmJqbCJydnp6fn6CghKGAoJ+dnJydn6WtucyAvLCL2I6WhtGVyICct8/g6uvj072jhtSg5Jawr4u6r4yGiY2Slpmcn6ChoaCfnJmVkYyHgvzz6d/Vyr6ypJaG7s6vke29lOayit22no+Ggfr08fDx9Pj9gYSIi46Slpuhp6+4wcnR1tra2NTNxbyzrKaioJ90oaWqr7W9xc7Z5vWDjZmouMvi/KCl04Kw54L705/ekbba+4yWm5qShu3KpoLCh67K1Nb4w7GmnI+C6cyvk+67kvDNsJeC4MGokf/fwqmR+tW1mYLdv6makYyLi42PkJGSkZGQjo2LioqJiouMjpCSlJaYmpsInJ2enp+foKCEoYCgn52cnJ2fpa25zIC8sIvYjpaG0ZXIgJy3z+Dq6+PTvaOG1KDklrCvi7qvjIaJjZKWmZyfoKGhoJ+cmZWRjIeC/PPp39XKvrKklobuzq+R7b2U5rKK3baej4aB+vTx8PH0+P2BhIiLjpKWm6Gnr7jBydHW2trY1M3FvLOspqKgn3Shpaqvtb3Fztnm9YONmai4y+L8oKXTgrDngvvTn96Rttr7jJabmpKG7cqmgsKHrsrU1vjDsaacj4LpzK+T7ruS8M2wl4LgwaiR/9/CqZH61bWZgt2/qZqRjIuLjY+QkZKRkZCOjYuKiomKi4yOkJKUlpiam5d4C3l6fH5/gYKDg4SEjIUIhISDg4KBgH6WfYt8hHsGenp6eXl5hniId6h4iHkLent8fn+AgoKDhISEhYaGhIUGhISDgoGAh3+EfoN9hXyEe4V6hXmheAICAQAIn6CgoaGioqKEo4CioaCfn6GjqbLA04TFwpzvnKaV66jij6/N6PyDhIDt07aX77WAqMO/lcq8k4uPk5icoKOmqKiop6ajn5uXko2Ig/zy6N3SxrmrnIv21bSV8b6T4aqByaOMgPXw7ezt8PP4/oKFiY2QlJeboaeutr7I0Nfd4OHe2dLKwbevqqajo3SlqK2zucDI0dzp+YWPm6q7z+aAo6fXh7fuhYDYo+SVut+Bj5qfnpaJ88+qhcaKr8nMvrrvw7Gon5WJ+d/GrZaC4sSrlIHhxKuVg+bJrpeB3byfh+bHsKGXkpGRk5WWl5eXlpWTkY+OjY2NjpCSlJaYmpydngifoKChoaKiooSjgKKhoJ+foaOpssDThMXCnO+cppXrqOKPr83o/IOEgO3TtpfvtYCow7+VyryTi4+TmJygo6aoqKinpqOfm5eSjYiD/PLo3dLGuauci/bVtJXxvpPhqoHJo4yA9fDt7O3w8/j+goWJjZCUl5uhp662vsjQ193g4d7Z0srBt6+qpqOjdKWorbO5wMjR3On5hY+bqrvP5oCjp9eHt+6FgNij5JW634GPmp+elonzz6qFxoqvycy+uu/DsaiflYn538atloLixKuUgeHEq5WD5smul4HdvJ+H5sewoZeSkZGTlZaXl5eWlZORj46NjY2OkJKUlpianJ2eCJ+goKGhoqKihKOAoqGgn5+ho6mywNOExcKc75ymleuo4o+vzej8g4SA7dO2l++1gKjDv5XKvJOLj5OYnKCjpqioqKemo5+bl5KNiIP88ujd0sa5q5yL9tW0lfG+k+GqgcmjjID18O3s7fDz+P6ChYmNkJSXm6Gnrra+yNDX3eDh3tnSysG3r6qmo6N0paits7nAyNHc6fmFj5uqu8/mgKOn14e37oWA2KPklbrfgY+an56WifPPqoXGiq/JzL6678OxqJ+Vifnfxq2WguLEq5SB4cSrlYPmya6Xgd28n4fmx7Chl5KRkZOVlpeXl5aVk5GPjo2NjY6QkpSWmJqcnZ6XeAt5enx+f4GCg4OEhIWFg4aEhQiEhISDgoGAfpd9inyEewZ6enp5eXmEeIl3qXiHeQ96ent8fn+AgoODhISFhYWHhoSFB4SEg4KBgH+HfoZ9hXyFe4V6hHmheAICAQAIoaGioqKjo6OEpICjo6KhoqSnrrfG2ofHx6T7o66e+rXzm7zd+oiOj4qA5MSigcOJsszFm9PEl5CTmJ2hpamsra6urauopKCblpGMhoH57+TZzL+woI/92reX876S3KT2vJeC7+fm5+nt8ff+goaKjpKWmZ2hp620vMXP19/k5+fk39fPxby0rqqnp12prLG2vMPL1d/s+4aQnau80OiCpajYiLnwhoDXouKTuNz+jZicm5SH78yng8SIr8jKuKvKnYyGgPLhz72qmIjx1bulkf/gxKyYhevOs5uF5MKki+7Otqadl5aXmJqEnBOamZeVk5KRkJGSk5WXmZudnp+gCKGhoqKio6OjhKSAo6OioaKkp663xtqHx8ek+6Ounvq185u83fqIjo+KgOTEooHDibLMxZvTxJeQk5idoaWprK2urq2rqKSgm5aRjIaB+e/k2cy/sKCP/dq3l/O+ktyk9ryXgu/n5ufp7fH3/oKGio6SlpmdoaettLzFz9ff5Ofn5N/Xz8W8tK6qp6ddqayxtrzDy9Xf7PuGkJ2rvNDogqWo2Ii58IaA16Lik7jc/o2YnJuUh+/Mp4PEiK/Iyriryp2MhoDy4c+9qpiI8dW7pZH/4MSsmIXrzrObheTCpIvuzramnZeWl5iahJwTmpmXlZOSkZCRkpOVl5mbnZ6foAihoaKioqOjo4SkgKOjoqGipKeut8bah8fHpPujrp76tfObvN36iI6PioDkxKKBw4myzMWb08SXkJOYnaGlqaytrq6tq6ikoJuWkYyGgfnv5NnMv7Cgj/3at5fzvpLcpPa8l4Lv5+bn6e3x9/6ChoqOkpaZnaGnrbS8xc/X3+Tn5+Tf18/FvLSuqqenXamssba8w8vV3+z7hpCdq7zQ6IKlqNiIufCGgNei4pO43P6NmJyblIfvzKeDxIivyMq4q8qdjIaA8uHPvaqYiPHVu6WR/+DErJiF686zm4XkwqSL7s62pp2XlpeYmoScE5qZl5WTkpGQkZKTlZeZm52en6CXeAt5enx+f4GCg4OEhISFhYaEhQeEhIOCgYB+mH2JfIR7BXp6enl5hHiJd6p4h3kMenp7fH5/gIKDg4SEhIWGhoSFB4SEg4KBgH+Ffod9hXyGe4V6hHmheAICAQABoYSig6OFpICjo6Okpqqxu8rfisnIpv+msqGBu/ygw+WBjZSUj4Tsy6iGyo62z8ie18ibk5ecoaWprbCysrKxr6yoo56ZlI6JhP706d3Rw7SjkoDdupjzvZDXn+uyjvXk3+Hk6O71/IKFio6Tl5ueoqass7rCzNXe5evu7erl3dTKwLiyrqysrXOxtbrAx8/Y4u78hpGdq7zQ6IKlqNeGtu6E+9Cb1oyv0fGGj5SSjIDjwp/6u4Opw8ayobiK9enf08a3qJmL+uHJs5+M+t3ErZmH79K3n4nqxqiP9NS8q6Gcmpudn6ChoaCenJqYlpWUk5OUlpeZm52en6ChAaGEooOjhaSAo6OjpKaqsbvK34rJyKb/prKhgbv8oMPlgY2UlI+E7MuohsqOts/IntfIm5OXnKGlqa2wsrKysa+sqKOemZSOiYT+9Ond0cO0o5KA3bqY872Q15/rso715N/h5Oju9fyChYqOk5ebnqKmrLO6wszV3uXr7u3q5d3UysC4sq6srK1zsbW6wMfP2OLu/IaRnau80OiCpajXhrbuhPvQm9aMr9Hxho+UkoyA48Kf+ruDqcPGsqG4ivXp39PGt6iZi/rhybOfjPrdxK2Zh+/St5+J6saoj/TUvKuhnJqbnZ+goaGgnpyamJaVlJOTlJaXmZudnp+goQGhhKKDo4WkgKOjo6SmqrG7yt+Kycim/6ayoYG7/KDD5YGNlJSPhOzLqIbKjrbPyJ7XyJuTl5yhpamtsLKysrGvrKijnpmUjomE/vTp3dHDtKOSgN26mPO9kNef67KO9eTf4eTo7vX8goWKjpOXm56ipqyzusLM1d7l6+7t6uXd1MrAuLKurKytc7G1usDHz9ji7vyGkZ2rvNDogqWo14a27oT70JvWjK/R8YaPlJKMgOPCn/q7g6nDxrKhuIr16d/TxreomYv64cmzn4z63cStmYfv0refierGqI/01LyroZyam52foKGhoJ6cmpiWlZSTk5SWl5mbnZ6foKGXeA55enx+f4GCg4SEhIWFhYaGhIUHhISDgoGAfph9inwLe3t7enp6eXl4eHiJd6t4h3kMenp7fH5/gIKCg4SEhIWGhg2FhYWEhISDgoGAf35+iX2GfIZ7hXqEeaF4AgIBAIKhhaIFo6OjpKSEo4ClqKyzvs7jjMrIpf+msqGAuvugwuSBjJOUj4TsyqiFyY220Mme2MqdlZmeo6issLO0tbWzsa6qpaCblpCLhoH37OHUxrallIHeupjyu43RmeGqh+vd297j6fD5gIWJjpOXm5+jp6yxuMDI0tzl7PH08/Dq4tnPxb23s7CwsrW5vmPEytLa5PD+h5CcqrvO5YCjptCAr+P66r+Nw4CgwN31g4eG/+vQsZHkq/Cctrqolab11cvCua6ilor959G9qpiI9drDrZqI8tW6oovuyquR+djAr6Wfnp+goqSkpKOhn52bmZeElgmYmZucnp+goaGCoYWiBaOjo6SkhKOApaiss77O44zKyKX/prKhgLr7oMLkgYyTlI+E7MqohcmNttDJntjKnZWZnqOorLCztLW1s7GuqqWgm5aQi4aB9+zh1Ma2pZSB3rqY8ruN0Znhqofr3dve4+nw+YCFiY6Tl5ufo6essbjAyNLc5ezx9PPw6uLZz8W9t7OwsLK1ub5jxMrS2uTw/oeQnKq7zuWAo6bQgK/j+uq/jcOAoMDd9YOHhv/r0LGR5KvwnLa6qJWm9dXLwrmuopaK/efRvaqYiPXaw62aiPLVuqKL7sqrkfnYwK+ln56foKKkpKSjoZ+dm5mXhJYJmJmbnJ6foKGhgqGFogWjo6OkpISjgKWorLO+zuOMysil/6ayoYC6+6DC5IGMk5SPhOzKqIXJjbbQyZ7Yyp2VmZ6jqKyws7S1tbOxrqqloJuWkIuGgffs4dTGtqWUgd66mPK7jdGZ4aqH693b3uPp8PmAhYmOk5ebn6OnrLG4wMjS3OXs8fTz8Ori2c/FvbezsLCytbm+Y8TK0trk8P6HkJyqu87lgKOm0ICv4/rqv43DgKDA3fWDh4b/69CxkeSr8Jy2uqiVpvXVy8K5rqKWiv3n0b2qmIj12sOtmojy1bqii+7Kq5H52MCvpZ+en6CipKSko6GfnZuZl4SWCZiZm5yen6ChoZd4Dnl6fH5/gYKDhISEhYWFhoaEhQeEhIOCgYB+mX2JfAt7e3t6enp5eXh4eIh3rHiHeQx6ent8fn+AgYKDhISFhYOGhYUJhISDg4KBgH9+iX2HfIZ7hXqEeaF4AgIBAAGhhqCCoYaigKOlqK21wM/kjcrHo/qjr575s/GZutr3hoyNiP3iwqGAwYmyzcid18uel5ugpaqusrS2tra1sq+rpqGcl5GMh4L67+PWx7imlILeupfvuIrLlNiiguTY2Nzj6vP8g4iNkpebn6Onq7C2vcXO2OLq8vf6+fXv593TycG7t7W1trm9ccLIztXd5vH+hpCbqbjL4fyfnb/pncfYyaT0qd+MqcPY5+7s4c+3nP7Gk8+GnaGThJPXurGqopqQhvrn1MKxoZKE7tbArJqI89e8o4zwzK2T/NvDsqiioKGjpaenp6akoqCenJqZmJiYmZucnZ+foKChAaGGoIKhhqKAo6WorbXAz+SNysej+qOvnvmz8Zm62veGjI2I/eLCoYDBibLNyJ3Xy56Xm6Clqq6ytLa2trWyr6umoZyXkYyHgvrv49bHuKaUgt66l++4isuU2KKC5NjY3OPq8/yDiI2Sl5ufo6ersLa9xc7Y4ury9/r59e/n3dPJwbu3tbW2ub1xwsjO1d3m8f6GkJupuMvh/J+dv+mdx9jJpPSp34ypw9jn7uzhz7ec/saTz4adoZOEk9e6saqimpCG+ufUwrGhkoTu1sCsmojz17yjjPDMrZP828OyqKKgoaOlp6enpqSioJ6cmpmYmJiZm5ydn5+goKEBoYaggqGGooCjpaittcDP5I3Kx6P6o6+e+bPxmbra94aMjYj94sKhgMGJss3IndfLnpeboKWqrrK0tra2tbKvq6ahnJeRjIeC+u/j1se4ppSC3rqX77iKy5TYooLk2Njc4+rz/IOIjZKXm5+jp6uwtr3Fztji6vL3+vn17+fd08nBu7e1tba5vXHCyM7V3ebx/oaQm6m4y+H8n52/6Z3H2Mmk9KnfjKnD2Ofu7OHPt5z+xpPPhp2hk4ST17qxqqKakIb659TCsaGShO7WwKyaiPPXvKOM8Mytk/zbw7KooqCho6Wnp6empKKgnpyamZiYmJmbnJ2fn6CgoZd4C3l6fH5/gYKDg4SEhIWEhoWFB4SEg4KBgH6ZfYl8C3t7e3p6enl5eHh4iHeseIh5DHp7fH1/gIGCg4OEhIuFCoSEhIODgoGAf36IfYh8hnuFeoR5oXgCAgEAgp+GnoCfn6CgoKGhoqSorbXAz+SMxr+b75ymlOil3o2syeP3gYH76dCzlOyy/qfEwZrUyZ6YnKGmq6+ztba3trWyr6unoZyXkoyHgvvw5NfIuKeUgd24ley1hsSOzpv63dTV2+Ls9f+FipCVmp+jp6uvtLrBydLd5/D3/P7++vTr4dfNxXi/u7m5u77BxsvR197n8f2Fjpmmtcbb9JeNpcT7mqabgcSKueuOpbfEysi/sJuD1KPupNHx+Onc/LujnJaQiYHz49PEtaeZjP/o0r6qmYjz17yjjPDMrZP93MSzqaSio6WnqampqKeloqCenJuampqbnJ2en5+goKCCn4aegJ+foKCgoaGipKittcDP5IzGv5vvnKaU6KXejazJ4/eBgfvp0LOU7LL+p8TBmtTJnpicoaarr7O1tre2tbKvq6ehnJeSjIeC+/Dk18i4p5SB3biV7LWGxI7Om/rd1NXb4uz1/4WKkJWan6Onq6+0usHJ0t3n8Pf8/v769Ovh183FeL+7ubm7vsHGy9HX3ufx/YWOmaa1xtv0l42lxPuappuBxIq5646lt8TKyL+wm4PUo+6k0fH46dz8u6OclpCJgfPj08S1p5mM/+jSvqqZiPPXvKOM8Mytk/3cxLOppKKjpaepqamop6WioJ6cm5qampucnZ6fn6CgoIKfhp6An5+goKChoaKkqK21wM/kjMa/m++cppTopd6NrMnj94GB++nQs5Tssv6nxMGa1MmemJyhpquvs7W2t7a1sq+rp6Gcl5KMh4L78OTXyLinlIHduJXstYbEjs6b+t3U1dvi7PX/hYqQlZqfo6err7S6wcnS3efw9/z+/vr06+HXzcV4v7u5ubu+wcbL0dfe5/H9hY6ZprXG2/SXjaXE+5qmm4HEirnrjqW3xMrIv7Cbg9Sj7qTR8fjp3Py7o5yWkImB8+PTxLWnmYz/6NK+qpmI89e8o4zwzK2T/dzEs6mkoqOlp6mpqainpaKgnpybmpqam5ydnp+foKCgl3gLeXp8fn+BgoODhISFhYKGhYUIhISDg4KBgH6ZfYl8Cnt7e3p6enl5eHiJd6x4iHkNent8fX6AgYKDg4SEhIqFCYSEg4OCgYB/foh9iHyHe4V6hHmheAICAQADnZychZuAnJydnZ6en6Gjp6y0v87hibiqi9mMlILLkcP6mLPJ2+Tl3s65n4PPnN6Trq+Py8WemJyip6yws7W2tra0sq+rpqGcl5KNiIL88OTXyLinlIHctpPosIK9iMWU8NfQ09ri7PeBhoySl5yhpamtsbe9xM3W4ev0+4CBgP737+Xb0clsw7+9vb/CxcrO09ng5/D7hIyWorDA0+uM7YSXsc/g1reQ0pC75oaVoKWjnI/806j8s+6SpaqlqdKhkIqFgPXp3M/CtqmdkYb24c26qJeH8dW6oovuyquS+9zEs6mko6Smqaqrq6qop6SioJ6dhJwInZ2enp+fnp4DnZychZuAnJydnZ6en6Gjp6y0v87hibiqi9mMlILLkcP6mLPJ2+Tl3s65n4PPnN6Trq+Py8WemJyip6yws7W2tra0sq+rpqGcl5KNiIL88OTXyLinlIHctpPosIK9iMWU8NfQ09ri7PeBhoySl5yhpamtsbe9xM3W4ev0+4CBgP737+Xb0clsw7+9vb/CxcrO09ng5/D7hIyWorDA0+uM7YSXsc/g1reQ0pC75oaVoKWjnI/806j8s+6SpaqlqdKhkIqFgPXp3M/CtqmdkYb24c26qJeH8dW6oovuyquS+9zEs6mko6Smqaqrq6qop6SioJ6dhJwInZ2enp+fnp4DnZychZuAnJydnZ6en6Gjp6y0v87hibiqi9mMlILLkcP6mLPJ2+Tl3s65n4PPnN6Trq+Py8WemJyip6yws7W2tra0sq+rpqGcl5KNiIL88OTXyLinlIHctpPosIK9iMWU8NfQ09ri7PeBhoySl5yhpamtsbe9xM3W4ev0+4CBgP737+Xb0clsw7+9vb/CxcrO09ng5/D7hIyWorDA0+uM7YSXsc/g1reQ0pC75oaVoKWjnI/806j8s+6SpaqlqdKhkIqFgPXp3M/CtqmdkYb24c26qJeH8dW6oovuyquS+9zEs6mko6Smqaqrq6qop6SioJ6dhJwInZ2enp+fnp6XeAx5enx+f4GCg4OEhISLhQiEhIODgoGAfpl9iXwKe3t7enp6eXl4eIh3lHiDeZZ4iHkOenp8fX5/gIGCg4OEhISHhQuEhISDg4KCgYB/foZ9inyHe4V6hHmheAICAQADm5qZhZiAmZmampucnZ+hpaqyvMvdg5qJ4Kzc6dCk7qLSgZisu8PEvbCdh96tgLTriYrnsbydmZ2ip6yws7W2trWzsa6qpaCclpGMiIP88eXYyLimk4DatJHjrP63gryN59DM0Njh7PeBh42TmJ6jp6uvs7i/xs/Z4+73/oGCgoD68efd08tvxsLAwMLFyMzQ1drg5+/5goqSnaq4yt+AvsPZ6PuFg+3DltaOstHq+oD/9N/Dovy3+p66y9La/KuLgPjw593TyL6zqZ6UioDt2si2pZWF7tK4n4nqxqiP+NnCsqmko6WnqqusrKuqqKakoqCfnp2dhp4DnZ2cA5uamYWYgJmZmpqbnJ2foaWqsrzL3YOaieCs3OnQpO6i0oGYrLvDxL2wnYferYC064mK57G8nZmdoqessLO1tra1s7GuqqWgnJaRjIiD/PHl2Mi4ppOA2rSR46z+t4K8jefQzNDY4ez3gYeNk5ieo6err7O4v8bP2ePu9/6BgoKA+vHn3dPLb8bCwMDCxcjM0NXa4Ofv+YKKkp2quMrfgL7D2ej7hYPtw5bWjrLR6vqA//Tfw6L8t/qeusvS2vyri4D48Ofd08i+s6melIqA7drItqWVhe7SuJ+J6saoj/jZwrKppKOlp6qrrKyrqqimpKKgn56dnYaeA52dnAObmpmFmICZmZqam5ydn6GlqrK8y92DmongrNzp0KTuotKBmKy7w8S9sJ2H3q2AtOuJiuexvJ2ZnaKnrLCztba2tbOxrqqloJyWkYyIg/zx5djIuKaTgNq0keOs/reCvI3n0MzQ2OHs94GHjZOYnqOnq6+zuL/Gz9nj7vf+gYKCgPrx593Ty2/GwsDAwsXIzNDV2uDn7/mCipKdqrjK34C+w9no+4WD7cOW1o6y0er6gP/038Oi/Lf6nrrL0tr8q4uA+PDn3dPIvrOpnpSKgO3ayLallYXu0rifierGqI/42cKyqaSjpaeqq6ysq6qopqSioJ+enZ2GngOdnZyXeAx5enx9f4CBgoODhISKhQmEhISDgoKBf36ZfYl8Cnt7e3p6eXl5eHiId5R4hHmVeIh5DHp6e3x9foCBgYKDg4WEAYWFhAiDg4KCgYB/foR9jXyHe4V6hHmheAICAQCAmZeWlZWUlZWVlpaXmJmanJ+iqK+5xtj26MGZ4pGcke+z/KfS+Y2ZoKGbkIHcsofEhKa6tpyJr5qZnaKnrK+ytLW1tLKvrKikn5uWkYyHg/zx5djJuKaT/9iyj+Cp97H6s4feysjO1uDr9oGHjZOZnqOoq6+zub/H0Nrl7/mAgoOAgoD78uje1M3Hw8LCxMfKztHW2t/l7fWAho6Yo7DA1O2WhY+Xl5eWjfbHlc2Dm624vby0pZDss/uiw9zs/5O7ivHl3tjQyL+3r6adlYyD9eTTwrKhkoPpzrSchuTBo4vx1L6wp6SjpaiqrK2trayqqKakoqGgn5+fnp6enZ2cm5qAmZeWlZWUlZWVlpaXmJmanJ+iqK+5xtj26MGZ4pGcke+z/KfS+Y2ZoKGbkIHcsofEhKa6tpyJr5qZnaKnrK+ytLW1tLKvrKikn5uWkYyHg/zx5djJuKaT/9iyj+Cp97H6s4feysjO1uDr9oGHjZOZnqOoq6+zub/H0Nrl7/mAgoOAgoD78uje1M3Hw8LCxMfKztHW2t/l7fWAho6Yo7DA1O2WhY+Xl5eWjfbHlc2Dm624vby0pZDss/uiw9zs/5O7ivHl3tjQyL+3r6adlYyD9eTTwrKhkoPpzrSchuTBo4vx1L6wp6SjpaiqrK2trayqqKakoqGgn5+fnp6enZ2cm5qAmZeWlZWUlZWVlpaXmJmanJ+iqK+5xtj26MGZ4pGcke+z/KfS+Y2ZoKGbkIHcsofEhKa6tpyJr5qZnaKnrK+ytLW1tLKvrKikn5uWkYyHg/zx5djJuKaT/9iyj+Cp97H6s4feysjO1uDr9oGHjZOZnqOoq6+zub/H0Nrl7/mAgoOAgoD78uje1M3Hw8LCxMfKztHW2t/l7fWAho6Yo7DA1O2WhY+Xl5eWjfbHlc2Dm624vby0pZDss/uiw9zs/5O7ivHl3tjQyL+3r6adlYyD9eTTwrKhkoPpzrSchuTBo4vx1L6wp6SjpaiqrK2trayqqKakoqGgn5+fnp6enZ2cm5qYeA15e31+gIGCgoODhISEh4UKhISEg4OCgYB/fpl9iHyEewd6enl5eHh4iHeTeIV5lXiJeQx6e3x9fn+AgYGCg4OJhAuDg4KCgYB/fn59fY58iHuFeoR5oXgCAgEAgJaVlJOSkZGSkpKTlJWWmJqcoKWstcHR56Tmsvies7Cc+bf8ocPe8fz99ePKqofIirDN1sm40KKXmZ2ip6uvsbO0s7Kwrquno56alZGMiIP88ubZybmnk//YsY7dpvKs8q2B1sTEytPd6PSAhoySmJ2ip6uus7i/x9Da5fD5gIKDgIOA+/Lo3dTNx8TCwsTHys7R1dne4+nx+oOKkpyotsjd/rGqtrivp5+Q9sKLtNfv/YGB+ObJou6fxOL6iqHJi+XUzsnDvbavqKGak4yF++vbzL2tnY6A5Mmvl4Lcu56G6c26raWioqWoqq2urq6trKqopqSjoqGgoJ+enp2cmpmYgJaVlJOSkZGSkpKTlJWWmJqcoKWstcHR56Tmsvies7Cc+bf8ocPe8fz99ePKqofIirDN1sm40KKXmZ2ip6uvsbO0s7Kwrquno56alZGMiIP88ubZybmnk//YsY7dpvKs8q2B1sTEytPd6PSAhoySmJ2ip6uus7i/x9Da5fD5gIKDgIOA+/Lo3dTNx8TCwsTHys7R1dne4+nx+oOKkpyotsjd/rGqtrivp5+Q9sKLtNfv/YGB+ObJou6fxOL6iqHJi+XUzsnDvbavqKGak4yF++vbzL2tnY6A5Mmvl4Lcu56G6c26raWioqWoqq2urq6trKqopqSjoqGgoJ+enp2cmpmYgJaVlJOSkZGSkpKTlJWWmJqcoKWstcHR56Tmsvies7Cc+bf8ocPe8fz99ePKqofIirDN1sm40KKXmZ2ip6uvsbO0s7Kwrquno56alZGMiIP88ubZybmnk//YsY7dpvKs8q2B1sTEytPd6PSAhoySmJ2ip6uus7i/x9Da5fD5gIKDgIOA+/Lo3dTNx8TCwsTHys7R1dne4+nx+oOKkpyotsjd/rGqtrivp5+Q9sKLtNfv/YGB+ObJou6fxOL6iqHJi+XUzsnDvbavqKGak4yF++vbzL2tnY6A5Mmvl4Lcu56G6c26raWioqWoqq2urq6trKqopqSjoqGgoJ+enp2cmpmYmHgLeXp8fX+AgYKCg4OLhAeDg4KBgH9+mn2IfIR7B3p6eXl4eHiId5N4hXmWeIl5Cnp7fH1+f4CBgYKFg4KEhIMJgoKBgH9/fn19jnyJe4V6hHmheAICAQCAlJKRkI+Pjo+Pj5CRkpOVl5mcoaiwu8rc/u2x95mzv7ee+bPtkaW0u7y2qZb7w4qz1OLd0+ytmJWZnqKnq66wsrKysa+sqaainpmVkIyIg/3z59nKuaeT/9ixjdyl76nsqPvPv8DH0Nrl8f2Fi5GWnKClqKyxtr3Fz9rl7/j/goOAgoD58Obc08zGw8HBw8bJzdDT19rf5ev0/oWMlZ+svM/nh8XBy8i5q56M6KzkiJefoqGckv/Mkrvd+o2lzIjZxb+7t7Ksp6GblZCKhPzv4dPFt6iZi/new6qS+tSzl4HgxrSpo6GipKeqra+vr66trKqopqWko6KhoJ+dnJuZl5aAlJKRkI+Pjo+Pj5CRkpOVl5mcoaiwu8rc/u2x95mzv7ee+bPtkaW0u7y2qZb7w4qz1OLd0+ytmJWZnqKnq66wsrKysa+sqaainpmVkIyIg/3z59nKuaeT/9ixjdyl76nsqPvPv8DH0Nrl8f2Fi5GWnKClqKyxtr3Fz9rl7/j/goOAgoD58Obc08zGw8HBw8bJzdDT19rf5ev0/oWMlZ+svM/nh8XBy8i5q56M6KzkiJefoqGckv/Mkrvd+o2lzIjZxb+7t7Ksp6GblZCKhPzv4dPFt6iZi/new6qS+tSzl4HgxrSpo6GipKeqra+vr66trKqopqWko6KhoJ+dnJuZl5aAlJKRkI+Pjo+Pj5CRkpOVl5mcoaiwu8rc/u2x95mzv7ee+bPtkaW0u7y2qZb7w4qz1OLd0+ytmJWZnqKnq66wsrKysa+sqaainpmVkIyIg/3z59nKuaeT/9ixjdyl76nsqPvPv8DH0Nrl8f2Fi5GWnKClqKyxtr3Fz9rl7/j/goOAgoD58Obc08zGw8HBw8bJzdDT19rf5ev0/oWMlZ+svM/nh8XBy8i5q56M6KzkiJefoqGckv/Mkrvd+o2lzIjZxb+7t7Ksp6GblZCKhPzv4dPFt6iZi/new6qS+tSzl4HgxrSpo6GipKeqra+vr66trKqopqWko6KhoJ+dnJuZl5aZeAt5e3x+f4CBgoKDg4iECIODg4KBgH9+m32IfIR7Bnp6eXl4eIp3k3iEeZd4iHkMenp7fH1+f4CBgYKCh4MKgoKCgYB/f359fY58iXuFeoV5oXgCAgEABZKQj46NhIyAjY2Oj5GSlJaZnaOrtcLS5YuQ1YylusK3m+6jy+j6gYH87dOvg7HU5uPd+7SZkpSZnqKmqq2vsLGwr62rqKShnZmUkIyIhP706NvMu6iUgNmyjtyk7qfqpfbLvL3EzNbh7fmDiY+UmZ6ipamutLvDzdjj7fb+gYGB/fbt49nQycR3wL+/wcTHys3Q09ba3+Xs9YCGjpejscLY8o7QydHLuKSU/cCAmqqytbSvpJDlosvriKLGgcu3sq+sqKSfmpWQi4eC+/Dk2My/saOVh/PYvaSN8syskvjYv6+loJ+hpKeqra+wsLCvrqyqqaempKOioJ+dm5mYlpQFkpCPjo2EjICNjY6PkZKUlpmdo6u1wtLli5DVjKW6wreb7qPL6PqBgfzt06+DsdTm4937tJmSlJmeoqaqra+wsbCvrauopKGdmZSQjIiE/vTo28y7qJSA2bKO3KTup+ql9su8vcTM1uHt+YOJj5SZnqKlqa60u8PN2OPt9v6BgYH99u3j2dDJxHfAv7/BxMfKzdDT1trf5ez1gIaOl6OxwtjyjtDJ0cu4pJT9wICaqrK1tK+kkOWiy+uIosaBy7eyr6yopJ+alZCLh4L78OTYzL+xo5WH89i9pI3yzKyS+Ni/r6Wgn6Gkp6qtr7CwsK+urKqpp6ako6Kgn52bmZiWlAWSkI+OjYSMgI2Njo+RkpSWmZ2jq7XC0uWLkNWMpbrCt5vuo8vo+oGB/O3Tr4Ox1Obj3fu0mZKUmZ6ipqqtr7CxsK+tq6ikoZ2ZlJCMiIT+9OjbzLuolIDZso7cpO6n6qX2y7y9xMzW4e35g4mPlJmeoqWprrS7w83Y4+32/oGBgf327ePZ0MnEd8C/v8HEx8rN0NPW2t/l7PWAho6Xo7HC2PKO0MnRy7iklP3AgJqqsrW0r6SQ5aLL64iixoHLt7KvrKikn5qVkIuHgvvw5NjMv7GjlYfz2L2kjfLMrJL42L+vpaCfoaSnqq2vsLCwr66sqqmnpqSjoqCfnZuZmJaUmXgKeXp7fX5/gIGCgoSDgoSFgwWCgYB/fpx9iXwJe3t7enp5eXh4ineTeIN5mHiJeQp6ent8fX5/gICBiYIIgYGAf39+fX2OfIp7hXqEeaJ4AgIBAAWQjo2Mi4SKgIuLjI2OkJGTlpqfpq+6yNnukZjdj6e6vrCQz4KUnqKin5aH36PN4uHc+bKWjpCUmZ6ipqmsrq+vr66sqqekoJyYlJCNiISA9urdzbyqloHbs4/epu+o6qT0yLm6wMnS3ej1gIaLkZaanqKlqrC3wMrV4Orz+/+A/vny6N7VzMXAd727u77Bw8bJzM7R1Nne5Oz2gIeQmqe2yuH/ltvQ1Mark/m+gJmosLSzrqOP5aLN95m/976rp6Win5uYlI+Lh4P/9+/l29DFuKyfkYTt0rmgierGp43x0bqqoZ2dn6Omqq2vsbGxsK+urKupqKako6GfnZuZlpSSBZCOjYyLhIqAi4uMjY6QkZOWmp+mr7rI2e6RmN2Pp7q+sJDPgpSeoqKfloffo83i4dz5spaOkJSZnqKmqayur6+vrqyqp6SgnJiUkI2IhID26t3NvKqWgduzj96m76jqpPTIubrAydLd6PWAhouRlpqeoqWqsLfAytXg6vP7/4D++fLo3tXMxcB3vbu7vsHDxsnMztHU2d7k7PaAh5Cap7bK4f+W29DUxquT+b6AmaiwtLOuo4/los33mb/3vqunpaKfm5iUj4uHg//37+Xb0MW4rJ+RhO3SuaCJ6sanjfHRuqqhnZ2fo6aqra+xsbGwr66sq6mopqSjoZ+dm5mWlJIFkI6NjIuEioCLi4yNjpCRk5aan6avusjZ7pGY3Y+nur6wkM+ClJ6iop+Wh9+jzeLh3Pmylo6QlJmeoqaprK6vr6+urKqnpKCcmJSQjYiEgPbq3c28qpaB27OP3qbvqOqk9Mi5usDJ0t3o9YCGi5GWmp6ipaqwt8DK1eDq8/v/gP758uje1czFwHe9u7u+wcPGyczO0dTZ3uTs9oCHkJqntsrh/5bb0NTGq5P5voCZqLC0s66jj+WizfeZv/e+q6elop+bmJSPi4eD//fv5dvQxbisn5GE7dK5oInqxqeN8dG6qqGdnZ+jpqqtr7GxsbCvrqyrqaimpKOhn52bmZaUkpp4Cnl6e31+f4CBgoKIgwaCgoGAf36efYh8CXt7e3p6eXl4eIp3lHgBeZp4iXkJenp7fH1+f3+AiYEGgIB/fn59jnyMe4V6hHmieAICAQCAj42LiomJiYiJiYqLi4yOj5GTl5uhqbO+zd7zlJnej6WysZvmk6avsrKvqJj7s9Xa2PStkYqMkJWZnaKlqautrq6urauppqOgnJiVkY2JhYH47N/QvqyYg962keGo86vtpvXIt7e9xc/Z5O/7g4iNkpaanaGmrLS8xtHc5/D3+/yA+vTt49nQx8C7uLe3uby/wcTGycvO0tbc4+z2gYmSnqy+0+6HoefVzrOR56vjh5Weo6GbkIDQmMuFseuyoJ2bmZeUkY2KhoP/+fLr5NzTyb6zp5uOgejOtZ2H5sKki+zNtqeem5ueoqaqra+xsrKysbCurauqqKakoqCdm5iWk5GAj42LiomJiYiJiYqLi4yOj5GTl5uhqbO+zd7zlJnej6WysZvmk6avsrKvqJj7s9Xa2PStkYqMkJWZnaKlqautrq6urauppqOgnJiVkY2JhYH47N/QvqyYg962keGo86vtpvXIt7e9xc/Z5O/7g4iNkpaanaGmrLS8xtHc5/D3+/yA+vTt49nQx8C7uLe3uby/wcTGycvO0tbc4+z2gYmSnqy+0+6HoefVzrOR56vjh5Weo6GbkIDQmMuFseuyoJ2bmZeUkY2KhoP/+fLr5NzTyb6zp5uOgejOtZ2H5sKki+zNtqeem5ueoqaqra+xsrKysbCurauqqKakoqCdm5iWk5GAj42LiomJiYiJiYqLi4yOj5GTl5uhqbO+zd7zlJnej6WysZvmk6avsrKvqJj7s9Xa2PStkYqMkJWZnaKlqautrq6urauppqOgnJiVkY2JhYH47N/QvqyYg962keGo86vtpvXIt7e9xc/Z5O/7g4iNkpaanaGmrLS8xtHc5/D3+/yA+vTt49nQx8C7uLe3uby/wcTGycvO0tbc4+z2gYmSnqy+0+6HoefVzrOR56vjh5Weo6GbkIDQmMuFseuyoJ2bmZeUkY2KhoP/+fLr5NzTyb6zp5uOgejOtZ2H5sKki+zNtqeem5ueoqaqra+xsrKysbCurauqqKakoqCdm5iWk5GbeAl5ent9fn+AgYGIggWBgYB/fp99iHwJe3t7enp5eXh4i3eveIh5Cnp6ent8fX5+f3+IgAV/f35+fY18jnuFeoR5ongCAgEAgI6Mi4qJiIiHiIiJiouLjI6PkZSYnaSstsLQ4faVmd2Ll5uO2IqboaWlo5yP7afEyuqojYaIjJCVmZ2hpaiqrK2trayqqKajn5yZlZGOioaC+u/h0sGumoXiuZTmrPqw9Kr5yba1u8LL1d/q9YCFiY6SlpmdoqiwuMPO2ePs8/f4gPXv597UysK7trOysrS3ury+wcPFx8vP1Nri7PiDi5ajs8jh/5Gt9NK3ktmXw+eBio6Nh/reupDTl9eol5STkpCOi4iFgv/58+3n4dvTy8K5rqOXi/3ky7OchuXCpIvtzbWmnZmanaGlqa2wsrOzs7KxsK+urKqopaOgnpuYlZOQgI6Mi4qJiIiHiIiJiouLjI6PkZSYnaSstsLQ4faVmd2Ll5uO2IqboaWlo5yP7afEyuqojYaIjJCVmZ2hpaiqrK2trayqqKajn5yZlZGOioaC+u/h0sGumoXiuZTmrPqw9Kr5yba1u8LL1d/q9YCFiY6SlpmdoqiwuMPO2ePs8/f4gPXv597UysK7trOysrS3ury+wcPFx8vP1Nri7PiDi5ajs8jh/5Gt9NK3ktmXw+eBio6Nh/reupDTl9eol5STkpCOi4iFgv/58+3n4dvTy8K5rqOXi/3ky7OchuXCpIvtzbWmnZmanaGlqa2wsrOzs7KxsK+urKqopaOgnpuYlZOQgI6Mi4qJiIiHiIiJiouLjI6PkZSYnaSstsLQ4faVmd2Ll5uO2IqboaWlo5yP7afEyuqojYaIjJCVmZ2hpaiqrK2trayqqKajn5yZlZGOioaC+u/h0sGumoXiuZTmrPqw9Kr5yba1u8LL1d/q9YCFiY6SlpmdoqiwuMPO2ePs8/f4gPXv597UysK7trOysrS3ury+wcPFx8vP1Nri7PiDi5ajs8jh/5Gt9NK3ktmXw+eBio6Nh/reupDTl9eol5STkpCOi4iFgv/58+3n4dvTy8K5rqOXi/3ky7OchuXCpIvtzbWmnZmanaGlqa2wsrOzs7KxsK+urKqopaOgnpuYlZOQnHgIeXp7fX5/gICIgQSAgH9+oH2IfAl7e3t6enl5eHiLd7B4iHkKenp6e3x9fX5+foV/hH6CfYx8j3uGeoR5ongCAgEAgI6Mi4qJiIeHiIiJiYqLjI2OkJKVmZ+mrrjE0uL1lJjT8vHZpdHo9Pr9+/Heu4eq1Z+HgYOIjJCUmZ2hpKeqq6ytrKuqqKWin5yZlZKPi4eD/PHk1cSxnYjmvpjtsoG3/bD/y7a0ucDJ0tvm8PqBhoqOkZWZnqSstb/K1uDo7/LzgPDq4djOxLy1sK2sra+ytLe5u72+wcTHzNLa4+78hpCcq77V8oqeu/u/ktOOs9Tt+4CA++zUtpXtupyOjIyLioiGhIH++fPt6OPe2dPMxb20qqCVifvjy7SdiOrHqZD107qonpqZnKCkqa2wsrS1tbSzsrGwrqyqp6Sin5yZlpOQgI6Mi4qJiIeHiIiJiYqLjI2OkJKVmZ+mrrjE0uL1lJjT8vHZpdHo9Pr9+/Heu4eq1Z+HgYOIjJCUmZ2hpKeqq6ytrKuqqKWin5yZlZKPi4eD/PHk1cSxnYjmvpjtsoG3/bD/y7a0ucDJ0tvm8PqBhoqOkZWZnqSstb/K1uDo7/LzgPDq4djOxLy1sK2sra+ytLe5u72+wcTHzNLa4+78hpCcq77V8oqeu/u/ktOOs9Tt+4CA++zUtpXtupyOjIyLioiGhIH++fPt6OPe2dPMxb20qqCVifvjy7SdiOrHqZD107qonpqZnKCkqa2wsrS1tbSzsrGwrqyqp6Sin5yZlpOQgI6Mi4qJiIeHiIiJiYqLjI2OkJKVmZ+mrrjE0uL1lJjT8vHZpdHo9Pr9+/Heu4eq1Z+HgYOIjJCUmZ2hpKeqq6ytrKuqqKWin5yZlZKPi4eD/PHk1cSxnYjmvpjtsoG3/bD/y7a0ucDJ0tvm8PqBhoqOkZWZnqSstb/K1uDo7/LzgPDq4djOxLy1sK2sra+ytLe5u72+wcTHzNLa4+78hpCcq77V8oqeu/u/ktOOs9Tt+4CA++zUtpXtupyOjIyLioiGhIH++fPt6OPe2dPMxb20qqCVifvjy7SdiOrHqZD107qonpqZnKCkqa2wsrS1tbSzsrGwrqyqp6Sin5yZlpOQnXgGeXp7fH1+i38BfqF9iHwJe3t7enp6eXh4jHeweId5hHoDe3x8hX2CfoV9jHyRe4Z6hHmieAICAQCAj42MioqJiIiJiYmKiouMjI6PkZOWm6CnsLnF0uDykY+sq5HUhJWfpaqtqp+L4a6Pf/f9g4eMkJSYnKCjpqmrq6ysq6mnpaKgnZmWk4+MiIT/9OfXx7Sgi+zDnfW5h8CFuYXRuLS5v8fP2OLr9f2ChoqNkJWaoKiyvMjS3eXr7+867OTc0si/trCrqKeoqq2vsbO1t7i6vcDFy9Lb5vOBipalt83phJiuy/ul2oyrxNbg5enr5djErpuNhoSFL4SCgf359O7p5N/b1tLNx8C5sKielIn95s+5o4731LWag+LFsaSdm5ygpKmtsLO1hLYPtbSzsa+sqaajoJ2alpSRgI+NjIqKiYiIiYmJioqLjIyOj5GTlpugp7C5xdLg8pGPrKuR1ISVn6Wqraqfi+Guj3/3/YOHjJCUmJygo6apq6usrKupp6WioJ2ZlpOPjIiE//Tn18e0oIvsw531uYfAhbmF0bi0ub/Hz9ji6/X9goaKjZCVmqCosrzI0t3l6+/vOuzk3NLIv7awq6inqKqtr7Gztbe4ur3AxcvS2+bzgYqWpbfN6YSYrsv7pdqMq8TW4OXp6+XYxK6bjYaEhS+EgoH9+fTu6eTf29bSzcfAubConpSJ/ebPuaOO99S1moPixbGknZucoKSprbCztYS2D7W0s7GvrKmmo6CdmpaUkYCPjYyKiomIiImJiYqKi4yMjo+Rk5aboKewucXS4PKRj6yrkdSElZ+lqq2qn4vhro9/9/2Dh4yQlJicoKOmqaurrKyrqaeloqCdmZaTj4yIhP/059fHtKCL7MOd9bmHwIW5hdG4tLm/x8/Y4uv1/YKGio2QlZqgqLK8yNLd5evv7zrs5NzSyL+2sKuop6iqra+xs7W3uLq9wMXL0tvm84GKlqW3zemEmK7L+6XajKvE1uDl6evl2MSum42GhIUvhIKB/fn07unk39vW0s3HwLmwqJ6Uif3mz7mjjvfUtZqD4sWxpJ2bnKCkqa2ws7WEtg+1tLOxr6yppqOgnZqWlJGeeAZ5ent8fX2JfoR9gnydfYh8Cnt7e3p6enl5eHiMd694h3mFeoJ7lnyTe4Z6hXmheAICAQAFkY+NjIuFioCLi4uMjI2NjpCRlJicoqixucTQ3e2M6uG9h6vH2ur6hY2OiYDx6Ony/IOHi4+Tl5ufo6Woqqurq6qpp6WioJ2al5OQjYmFgPbp2sm3o47yyaL/wo7Mj8eO2722ucDGztbf6PD5gIOHio2Rlp2mr7rF0Nri6ezs6ODXzcO5saumpGOjpKaoqqyur7GytLe6vsTL1N7r+oaSoLLI44GUqsLegJWtxNfm8vyChoiIhoSBgICBgYGAgP359fHs5+Le2dXRzsjDvbewqJ+WjILw2sSvmofqyayT/NnAsKahoKGlqa6xtLaFuA63trSyr6yppqKfm5iVkwWRj42Mi4WKgIuLi4yMjY2OkJGUmJyiqLG5xNDd7Yzq4b2Hq8fa6vqFjY6JgPHo6fL8g4eLj5OXm5+jpaiqq6urqqmnpaKgnZqXk5CNiYWA9unaybejjvLJov/CjsyPx47bvba5wMbO1t/o8PmAg4eKjZGWnaavusXQ2uLp7Ozo4NfNw7mxq6akY6OkpqiqrK6vsbK0t7q+xMvU3uv6hpKgssjjgZSqwt6Ala3E1+by/IKGiIiGhIGAgIGBgYCA/fn18ezn4t7Z1dHOyMO9t7Con5aMgvDaxK+ah+rJrJP82cCwpqGgoaWprrG0toW4Dre2tLKvrKmmop+bmJWTBZGPjYyLhYqAi4uLjIyNjY6QkZSYnKKosbnE0N3tjOrhvYerx9rq+oWNjomA8ejp8vyDh4uPk5ebn6OlqKqrq6uqqaeloqCdmpeTkI2JhYD26drJt6OO8smi/8KOzI/Hjtu9trnAxs7W3+jw+YCDh4qNkZadpq+6xdDa4uns7Ojg183DubGrpqRjo6SmqKqsrq+xsrS3ur7Ey9Te6/qGkqCyyOOBlKrC3oCVrcTX5vL8goaIiIaEgYCAgYGBgID9+fXx7Ofi3tnV0c7Iw723sKifloyC8NrEr5qH6smsk/zZwLCmoaChpamusbS2hbgOt7a0sq+sqaain5uYlZOfeAR5eXp7hnyFfYV8nn2HfAp7e3t6enp5eXh4jHeweIZ5hXqIe458lnuGeoR5oXgCAgEABpORkI6NjYWMhI0wjo6Oj5CSlZidoqmwucPP3O+Kuoe88pKrx+iFmKq5xM3Y5fH8goeLj5OXm56ipaephKqAqKeloqCdmpeUkY2KhoH469zMuqaR+dCphc2Y3Zzcne7IvL3ByM7W3eXt9fyBhIeKjpSbo624xM7Y4efq6eTc0si+ta2noqCfoKKkpaepq6ytr7G0ub7Fztjl9IOPnrHI44KVq8Pf+4ybqrjG0tzj6e7y9fj6/P7////+/Pn18e0r6OTf29fU0MzIxL+5s62lnZSKge3Ywq2ZhefHqpH62sS2rainqa2xtLe5uoS7Drq5t7Wyr6yopaGempeVBpORkI6NjYWMhI0wjo6Oj5CSlZidoqmwucPP3O+Kuoe88pKrx+iFmKq5xM3Y5fH8goeLj5OXm56ipaephKqAqKeloqCdmpeUkY2KhoH469zMuqaR+dCphc2Y3Zzcne7IvL3ByM7W3eXt9fyBhIeKjpSbo624xM7Y4efq6eTc0si+ta2noqCfoKKkpaepq6ytr7G0ub7Fztjl9IOPnrHI44KVq8Pf+4ybqrjG0tzj6e7y9fj6/P7////+/Pn18e0r6OTf29fU0MzIxL+5s62lnZSKge3Ywq2ZhefHqpH62sS2rainqa2xtLe5uoS7Drq5t7Wyr6yopaGempeVBpORkI6NjYWMhI0wjo6Oj5CSlZidoqmwucPP3O+Kuoe88pKrx+iFmKq5xM3Y5fH8goeLj5OXm56ipaephKqAqKeloqCdmpeUkY2KhoH469zMuqaR+dCphc2Y3Zzcne7IvL3ByM7W3eXt9fyBhIeKjpSbo624xM7Y4efq6eTc0si+ta2noqCfoKKkpaepq6ytr7G0ub7Fztjl9IOPnrHI44KVq8Pf+4ybqrjG0tzj6e7y9fj6/P7////+/Pn18e0r6OTf29fU0MzIxL+5s62lnZSKge3Ywq2ZhefHqpH62sS2rainqa2xtLe5uoS7Drq5t7Wyr6yopaGempeVoHgFeXl6enqEe4p8nn2HfIR7Bnp6eXl4eI13r3iGeYZ6rHuGeoR5oHgCAgEABZaUkpGQjo8skJGTlpmepKqzvMjX7IWew/abw/SWt9qAk6W3x9bk8PuChoqOkpaanaGjpqiEqYCopqSioJ2al5SRjoqGgfnt3869qZWA2LGN26X0sPu1iODLxsfM0dje5ezz+f+ChIeMkpmirbjDztjg5+nn4djPxbuyqqSgnZydn6GipKWnqKmrrbC0ucHJ1OLyg5Ghts/th5yzzemDkqKxv8zY4urw9Pj6/f+AgIGBgID+/Pj08Cvr5+Pf3NjV0c3KxsK9t7GqopmPhfXeyLKcie3Nr5aC6NTFu7W0tbi6vL6+hb8Nvby5trOwrKikoZ2amAWWlJKRkI6PLJCRk5aZnqSqs7zI1+yFnsP2m8P0lrfagJOlt8fW5PD7goaKjpKWmp2ho6aohKmAqKakoqCdmpeUkY6KhoH57d/OvamVgNixjdul9LD7tYjgy8bHzNHY3uXs8/n/goSHjJKZoq24w87Y4Ofp5+HYz8W7sqqkoJ2cnZ+hoqSlp6ipq62wtLnBydTi8oORobbP7Yecs83pg5Kisb/M2OLq8PT4+v3/gICBgYCA/vz49PAr6+fj39zY1dHNysbCvbexqqKZj4X13siynIntza+WgujUxbu1tLW4ury+voW/Db28ubazsKyopKGdmpgFlpSSkZCOjyyQkZOWmZ6kqrO8yNfshZ7D9pvD9Ja32oCTpbfH1uTw+4KGio6SlpqdoaOmqISpgKimpKKgnZqXlJGOioaB+e3fzr2plYDYsY3bpfSw+7WI4MvGx8zR2N7l7PP5/4KEh4ySmaKtuMPO2ODn6efh2M/Fu7KqpKCdnJ2foaKkpaeoqautsLS5wcnU4vKDkaG2z+2HnLPN6YOSorG/zNji6vD0+Pr9/4CAgYGAgP78+PTwK+vn49/c2NXRzcrGwr23saqimY+F9d7IspyJ7c2vloLo1MW7tbS1uLq8vr6Fvw29vLm2s7CsqKShnZqYoHiEeQZ6enp7e3uJfJ59iHwKe3t7enp5eXh4eI13rniGeYV6j3uGfJl7hnqFeZ54AgIBAAaZl5aUlJOGkjORkZGQkJCPkJGSlZido6u0wM/i+5Cr0oKjzP2bu96BlKa3x9bj7/mBhYmNkZWYnJ+ipaaEqHSnpaOhn5yal5SRjYqGgvru4NG/rJiE4bqW7baJypTapYbr3NfW2d3i6O3z+f6Bg4aLkZmirbjDztjh5+nn4NfNw7mwqKKem5ucnZ+goaOkpaanqaywtr7I1OT4iJmtxeKClazG4oCQoLHAz9zo8fn/gYOEhYeGQoWDgoD8+PPw7Onm4t7b2dXSzsrFvreupJqOgu3VvaeS/ty+pZKD8eDUzMnIyMjHx8bGxsXEw8G/vLi1sayopKGemwaZl5aUlJOGkjORkZGQkJCPkJGSlZido6u0wM/i+5Cr0oKjzP2bu96BlKa3x9bj7/mBhYmNkZWYnJ+ipaaEqHSnpaOhn5yal5SRjYqGgvru4NG/rJiE4bqW7baJypTapYbr3NfW2d3i6O3z+f6Bg4aLkZmirbjDztjh5+nn4NfNw7mwqKKem5ucnZ+goaOkpaanqaywtr7I1OT4iJmtxeKClazG4oCQoLHAz9zo8fn/gYOEhYeGQoWDgoD8+PPw7Onm4t7b2dXSzsrFvreupJqOgu3VvaeS/ty+pZKD8eDUzMnIyMjHx8bGxsXEw8G/vLi1sayopKGemwaZl5aUlJOGkjORkZGQkJCPkJGSlZido6u0wM/i+5Cr0oKjzP2bu96BlKa3x9bj7/mBhYmNkZWYnJ+ipaaEqHSnpaOhn5yal5SRjYqGgvru4NG/rJiE4bqW7baJypTapYbr3NfW2d3i6O3z+f6Bg4aLkZmirbjDztjh5+nn4NfNw7mwqKKem5ucnZ+goaOkpaanqaywtr7I1OT4iJmtxeKClazG4oCQoLHAz9zo8fn/gYOEhYeGQoWDgoD8+PPw7Onm4t7b2dXSzsrFvreupJqOgu3VvaeS/ty+pZKD8eDUzMnIyMjHx8bGxsXEw8G/vLi1sayopKGem6B4g3mEeoN7iXyefYh8C3t7e3p6enl5eHh4jHeueIV5hXqLe498l3uFeoZ5nHgCAgEAgJ2bmZiXl5aWlpWVlZSUk5KSkZGRkpSYnKOrtsPT6ICRp8fxk7bgiKXE54WXqLnI1uPu+ICEiIyQlJebnqGjpaanp6alpKKgnpuZlpOQjYqGgvrv4tPCsJ2J68Whgcud7rSI1KuShPnw7Ozt8PP3+/6BgoaKkZmjrrnF0Nrj6ernNuDWzMK4r6iinpybnJ2eoKGio6SkpaersLfAzd3yhpesxeODl67I5YKUprfJ2ej1gIWJi42PkIeRQ5CQj42LiYeFg4GA/Pn29PHv7erm4tzVzMK3qp2QgurQuKGN+dvDrp2Qhvzy6uTf29fV0tHPzszJxsO/u7ayrammop+AnZuZmJeXlpaWlZWVlJSTkpKRkZGSlJico6u2w9PogJGnx/GTtuCIpcTnhZeoucjW4+74gISIjJCUl5ueoaOlpqenpqWkoqCem5mWk5CNioaC+u/i08KwnYnrxaGBy53utIjUq5KE+fDs7O3w8/f7/oGChoqRmaOuucXQ2uPp6uc24NbMwrivqKKenJucnZ6goaKjpKSlp6uwt8DN3fKGl6zF44OXrsjlgpSmt8nZ6PWAhYmLjY+Qh5FDkJCPjYuJh4WDgYD8+fb08e/t6ubi3NXMwreqnZCC6tC4oY3528OunZCG/PLq5N/b19XS0c/OzMnGw7+7trKtqaain4Cdm5mYl5eWlpaVlZWUlJOSkpGRkZKUmJyjq7bD0+iAkafH8ZO24IilxOeFl6i5yNbj7viAhIiMkJSXm56ho6Wmp6empaSioJ6bmZaTkI2KhoL67+LTwrCdievFoYHLne60iNSrkoT58Ozs7fDz9/v+gYKGipGZo665xdDa4+nq5zbg1szCuK+oop6cm5ydnqChoqOkpKWnq7C3wM3d8oaXrMXjg5euyOWClKa3ydno9YCFiYuNj5CHkUOQkI+Ni4mHhYOBgPz59vTx7+3q5uLc1czCt6qdkILq0Lihjfnbw66dkIb88urk39vX1dLRz87MycbDv7u2sq2ppqKfnniFeYN6hHuJfJ59iHyEewV6enl5eYR4ineteIV5hXqIe5l8k3uFeod5mXgCAgEAD6Kgnp2cm5uampmZmZiYl4SWgJeanqOrtcLS5fyMnbLN8pCt0fuWstHyipuru8nX4u33/4OHi4+Slpmcn6GjpKWlpaSioZ+dmpeVko+MiYWB+vDj1cW0oY730q+P5raP4LCM5sSsnZKKhYKBgICAgYKEh4uSm6WwvMjT3ufr7Ojg1s3DubCpo5+dnZ6foKGio6OkIqWnqa61v83f94qdtNDwi6G61vWMnrLF2Ov8ho2Sl5ueoKGIokOhoJ+enJuZl5WTkY+OjYyLiomIh4WC/fTp3M/AsaGSg+vSu6aUhe/YxLOmnJOMhoD48evm4t7a1tLOycS/ubSwrKilD6Kgnp2cm5uampmZmZiYl4SWgJeanqOrtcLS5fyMnbLN8pCt0fuWstHyipuru8nX4u33/4OHi4+Slpmcn6GjpKWlpaSioZ+dmpeVko+MiYWB+vDj1cW0oY730q+P5raP4LCM5sSsnZKKhYKBgICAgYKEh4uSm6WwvMjT3ufr7Ojg1s3DubCpo5+dnZ6foKGio6OkIqWnqa61v83f94qdtNDwi6G61vWMnrLF2Ov8ho2Sl5ueoKGIokOhoJ+enJuZl5WTkY+OjYyLiomIh4WC/fTp3M/AsaGSg+vSu6aUhe/YxLOmnJOMhoD48evm4t7a1tLOycS/ubSwrKilD6Kgnp2cm5uampmZmZiYl4SWgJeanqOrtcLS5fyMnbLN8pCt0fuWstHyipuru8nX4u33/4OHi4+Slpmcn6GjpKWlpaSioZ+dmpeVko+MiYWB+vDj1cW0oY730q+P5raP4LCM5sSsnZKKhYKBgICAgYKEh4uSm6WwvMjT3ufr7Ojg1s3DubCpo5+dnZ6foKGio6OkIqWnqa61v83f94qdtNDwi6G61vWMnrLF2Ov8ho2Sl5ueoKGIokOhoJ+enJuZl5WTkY+OjYyLiomIh4WC/fTp3M/AsaGSg+vSu6aUhe/YxLOmnJOMhoD48evm4t7a1tLOycS/ubSwrKilnXiFeYR6hHuKfJ19iHyEewZ6enp5eXm5eIV5hXqHe6Z8inuGeop5k3gCAgEACaqnpaSjoqKhoYSggJ+fn6Cho6ettL7L2+6DkKCzyeOClrDP9I+ow+GAkKCvvsvX4uz2/oKGio2RlJibnZ+hoqOjoqKgn52bmJaTkY6LiIWB+vDl18i4p5SC4b+fg9eujea+n4ju1cGxpZyVkI2KiYiIio+Vnqm0wMzY4+vv7+vi2M/Fu7Osp6OioqKjc6SlpqeoqauutLzH1+2ElqzG5oWas8/uiJuvxNrwgoyVnqWrsbW3ubu7vLy7u7u6urm5uLa1s7GvrauqqKempaSko6Khn5yYk42G/e3byrinl4j23sm2pZaI+ubVxrmto5qSjIaC/PXt5+DZ08zGwLq1sa0JqqelpKOioqGhhKCAn5+foKGjp620vsvb7oOQoLPJ44KWsM/0j6jD4YCQoK++y9fi7Pb+goaKjZGUmJudn6Gio6OioqCfnZuYlpORjouIhYH68OXXyLinlILhv5+D166N5r6fiO7VwbGlnJWQjYqJiIiKj5WeqbTAzNjj6+/v6+LYz8W7s6yno6KioqNzpKWmp6ipq660vMfX7YSWrMbmhZqzz+6Im6/E2vCCjJWepauxtbe5u7u8vLu7u7q6ubm4trWzsa+tq6qop6alpKSjoqGfnJiTjYb97dvKuKeXiPbeyballoj65tXGua2jmpKMhoL89e3n4NnTzMbAurWxrQmqp6Wko6KioaGEoICfn5+goaOnrbS+y9vug5Cgs8njgpawz/SPqMPhgJCgr77L1+Ls9v6ChoqNkZSYm52foaKjo6KioJ+dm5iWk5GOi4iFgfrw5dfIuKeUguG/n4PXro3mvp+I7tXBsaWclZCNiomIiIqPlZ6ptMDM2OPr7+/r4tjPxbuzrKejoqKio3OkpaanqKmrrrS8x9fthJasxuaFmrPP7oibr8Ta8IKMlZ6lq7G1t7m7u7y8u7u7urq5ubi2tbOxr62rqqinpqWkpKOioZ+cmJONhv3t28q4p5eI9t7JtqWWiPrm1ca5raOakoyGgvz17efg2dPMxsC6tbGtmniGeYV6hHuLfJ19iXyEe4N6hHm1eIV5hXqGe618iHuHeox5jngCAgEABri1srGvr4WuNK+wsbK0t7vByNPf8IGOm6y+1OuDk6a92fqPpb3Y9IiXprTBzdjj7PT8goWJjJCTlpmbnZ+EoICfnp2bmZeUko+NioeEgfrx5trMva2civPSs5f/1rOXgNy/qJaH9N/NvrKooZuXlJWYnqawvMjU3+ry9fXv593UysG5s66rqqqsra6vsbO1uL3Ezt3whZarxeSEmbHN7YibsMbd9YaSnqmzvcTL0dXY2tzc3d3c3Nzb29rZ2NfW1D3S0M7My8nIx8bFxcTDwr+8uLKro5qRh/zo1MKxoZOG9+LPvq+hlIn+69vMv7SqoZmSi4aA9+7k3NTNxsG8Bri1srGvr4WuNK+wsbK0t7vByNPf8IGOm6y+1OuDk6a92fqPpb3Y9IiXprTBzdjj7PT8goWJjJCTlpmbnZ+EoICfnp2bmZeUko+NioeEgfrx5trMva2civPSs5f/1rOXgNy/qJaH9N/NvrKooZuXlJWYnqawvMjU3+ry9fXv593UysG5s66rqqqsra6vsbO1uL3Ezt3whZarxeSEmbHN7YibsMbd9YaSnqmzvcTL0dXY2tzc3d3c3Nzb29rZ2NfW1D3S0M7My8nIx8bFxcTDwr+8uLKro5qRh/zo1MKxoZOG9+LPvq+hlIn+69vMv7SqoZmSi4aA9+7k3NTNxsG8Bri1srGvr4WuNK+wsbK0t7vByNPf8IGOm6y+1OuDk6a92fqPpb3Y9IiXprTBzdjj7PT8goWJjJCTlpmbnZ+EoICfnp2bmZeUko+NioeEgfrx5trMva2civPSs5f/1rOXgNy/qJaH9N/NvrKooZuXlJWYnqawvMjU3+ry9fXv593UysG5s66rqqqsra6vsbO1uL3Ezt3whZarxeSEmbHN7YibsMbd9YaSnqmzvcTL0dXY2tzc3d3c3Nzb29rZ2NfW1D3S0M7My8nIx8bFxcTDwr+8uLKro5qRh/zo1MKxoZOG9+LPvq+hlIn+69vMv7SqoZmSi4aA9+7k3NTNxsG8l3iHeYZ6hXuLfJ19iXyEe4V6hXmweIV5hXqGe7J8iHuIeo15iXgCAgEABNXQzcuFyYDKzM7R1Njd4+v2gYqUoK6/0uf/jJurvtTuhZapv9bwhZKgrbrF0Nrj6/P7gYSIi4+SlZeZm5ydnZ6dnZuamZeVkpCOi4mGhID78und0cO0pJSE6cuwmIPjxauWhe7VwK2dj4Lv3c7CuLGurrK4wcvW4u33/oD/+fDn3tXNxb+7uiu6u72/wcTIzNLa5PKCjp6zzOqHnLXR8Iqdssnh+oqXpbLAzNfh6vH4/H+BiYJDgYGAgP79+/n39fPy8O/v7u3s6+nm4t3Xz8a8saabkIX24tDAsaSYjYLy4M+/saOXjILz49THu7Gnn5ePiIL68Ojg2gTV0M3LhcmAyszO0dTY3ePr9oGKlKCuv9Ln/4ybq77U7oWWqb/W8IWSoK26xdDa4+vz+4GEiIuPkpWXmZucnZ2enZ2bmpmXlZKQjouJhoSA+/Lp3dHDtKSUhOnLsJiD48WrloXu1cCtnY+C793Owrixrq6yuMHL1uLt9/6A//nw597VzcW/u7oruru9v8HEyMzS2uTygo6es8zqh5y10fCKnbLJ4fqKl6WywMzX4erx+Px/gYmCQ4GBgID+/fv59/Xz8vDv7+7t7Ovp5uLd18/GvLGmm5CF9uLQwLGkmI2C8uDPv7Gjl4yC8+PUx7uxp5+Xj4iC+vDo4NoE1dDNy4XJgMrMztHU2N3j6/aBipSgrr/S5/+Mm6u+1O6Flqm/1vCFkqCtusXQ2uPr8/uBhIiLj5KVl5mbnJ2dnp2dm5qZl5WSkI6LiYaEgPvy6d3Rw7SklITpy7CYg+PFq5aF7tXArZ2Pgu/dzsK4sa6usrjBy9bi7ff+gP/58Ofe1c3Fv7u6K7q7vb/BxMjM0trk8oKOnrPM6oectdHwip2yyeH6ipelssDM1+Hq8fj8f4GJgkOBgYCA/v37+ff18/Lw7+/u7ezr6ebi3dfPxryxppuQhfbi0MCxpJiNgvLgz7+xo5eMgvPj1Me7saefl4+Igvrw6ODak3iJeYZ6hnuMfJ19inyFe4V6h3mReAF5l3iGeYV6hnuMfI99nHyJe4l6jHmFeAICAQA/hYKA/fv7+/z+gIKDhomNkZeeprC8y9vugo6bqbnL3vSGk6O0yNzzhZGdqbXAytPc5Ozz+oCEh4qOkJOVl5mahJtzmpmYlpWTkY+NioiGg4H89Ozi18q9rp+QgufNtaCO/eLKtqWViPjhzbqqm4+E9+ng29ve4+v0/oOHiouJhoL88+vi3NjV1dfa3uPo7vb/hY2Wo7LF3vuPo7zY+I2hts3lgI2cq7rJ2Ob0gIWKjpGUlpiZmYeaQ5mZmJiXlpWUk5KRkJCPj46OjYyLiYeEgPft4tbKvbGkmY6E9ubXybyvo5iOhPXi0cK0p5uQh/zs3tHFurCnn5iSjYg/hYKA/fv7+/z+gIKDhomNkZeeprC8y9vugo6bqbnL3vSGk6O0yNzzhZGdqbXAytPc5Ozz+oCEh4qOkJOVl5mahJtzmpmYlpWTkY+NioiGg4H89Ozi18q9rp+QgufNtaCO/eLKtqWViPjhzbqqm4+E9+ng29ve4+v0/oOHiouJhoL88+vi3NjV1dfa3uPo7vb/hY2Wo7LF3vuPo7zY+I2hts3lgI2cq7rJ2Ob0gIWKjpGUlpiZmYeaQ5mZmJiXlpWUk5KRkJCPj46OjYyLiYeEgPft4tbKvbGkmY6E9ubXybyvo5iOhPXi0cK0p5uQh/zs3tHFurCnn5iSjYg/hYKA/fv7+/z+gIKDhomNkZeeprC8y9vugo6bqbnL3vSGk6O0yNzzhZGdqbXAytPc5Ozz+oCEh4qOkJOVl5mahJtzmpmYlpWTkY+NioiGg4H89Ozi18q9rp+QgufNtaCO/eLKtqWViPjhzbqqm4+E9+ng29ve4+v0/oOHiouJhoL88+vi3NjV1dfa3uPo7vb/hY2Wo7LF3vuPo7zY+I2hts3lgI2cq7rJ2Ob0gIWKjpGUlpiZmYeaQ5mZmJiXlpWUk5KRkJCPj46OjYyLiYeEgPft4tbKvbGkmY6E9ubXybyvo5iOhPXi0cK0p5uQh/zs3tHFurCnn5iSjYiDeYZ4j3mIeod7jXydfYt8hXuHeoh5iniHeZB4iHmFeoV7iXypfYt8inuJeo15AgIBAD6zr6yqqKipqqutsLO3vMLJ0dvn9YKLlqKvvs3e8YKNmaa1xdfp/YmUnqmzvcbP197m7fP6gIOGio2PkpSVl4WYdZeXlpSTkZCOjIqIhoSB/vjw6N7Tx7qsn5GE79jEsaGShvTgzr2un5KF9eDOvrCknJaSkZGTlpmcn6CfnZqWko6Kh4SDg4SGiY2RlpyjrLbD0+b9jZ2xyeSBk6a70uuCkZ+vv9Dg8YCIj5acoaaqra+xsrO0tIa1QrS0s7KysbCurayrqqqpqKempaShn5uXkYyG/vHj1ci7sKWbkomC9ebZy7+yppqPhfjm18i6rqKYjob87uLXzcW+uD6zr6yqqKipqqutsLO3vMLJ0dvn9YKLlqKvvs3e8YKNmaa1xdfp/YmUnqmzvcbP197m7fP6gIOGio2PkpSVl4WYdZeXlpSTkZCOjIqIhoSB/vjw6N7Tx7qsn5GE79jEsaGShvTgzr2un5KF9eDOvrCknJaSkZGTlpmcn6CfnZqWko6Kh4SDg4SGiY2RlpyjrLbD0+b9jZ2xyeSBk6a70uuCkZ+vv9Dg8YCIj5acoaaqra+xsrO0tIa1QrS0s7KysbCurayrqqqpqKempaShn5uXkYyG/vHj1ci7sKWbkomC9ebZy7+yppqPhfjm18i6rqKYjob87uLXzcW+uD6zr6yqqKipqqutsLO3vMLJ0dvn9YKLlqKvvs3e8YKNmaa1xdfp/YmUnqmzvcbP197m7fP6gIOGio2PkpSVl4WYdZeXlpSTkZCOjIqIhoSB/vjw6N7Tx7qsn5GE79jEsaGShvTgzr2un5KF9eDOvrCknJaSkZGTlpmcn6CfnZqWko6Kh4SDg4SGiY2RlpyjrLbD0+b9jZ2xyeSBk6a70uuCkZ+vv9Dg8YCIj5acoaaqra+xsrO0tIa1QrS0s7KysbCurayrqqqpqKempaShn5uXkYyG/vHj1ci7sKWbkomC9ebZy7+yppqPhfjm18i6rqKYjob87uLXzcW+uJR5iXqJe458nX2MfId7iHqqeYV6hnuIfK99jHyKe4p6iHkCAgEAPvn08O7s7Ozt8PL2+4CEiIySmKCps77L2en5hY+ZpLG+zNvr+4aQmaOstb7GzdTb4eft9PqAg4aJjI6RkpSVhpZ1lZSTkpCPjYyKiIeFg4D89u7m3dLHu6+ilouA7NrKu62glYqA793Mva6hlIn/7+HXz8rHxsbHycnJx8TAvLi0sK2srK2wtLm/x8/Z5fKBi5aktcje+YubrsPa84aUo7PE1eb4hY2WnqattLq/w8bJzM3P0NHRhtJB0dHQz87NzMvJyMfGxcTDwsC+u7i0r6mjnJSNhf3v4tXKv7aspJuTi4T56tvNv7OnnJKI/+/g0sW5r6WdlY+JhIA++fTw7uzs7O3w8vb7gISIjJKYoKmzvsvZ6fmFj5mksb7M2+v7hpCZo6y1vsbN1Nvh5+30+oCDhomMjpGSlJWGlnWVlJOSkI+NjIqIh4WDgPz27ubd0se7r6KWi4Ds2sq7raCVioDv3cy9rqGUif/v4dfPysfGxsfJycnHxMC8uLSwraysrbC0ub/Hz9nl8oGLlqS1yN75i5uuw9rzhpSjs8TV5viFjZaepq20ur/DxsnMzc/Q0dGG0kHR0dDPzs3My8nIx8bFxMPCwL67uLSvqaOclI2F/e/i1cq/tqykm5OLhPnq282/s6eckoj/7+DSxbmvpZ2Vj4mEgD759PDu7Ozs7fDy9vuAhIiMkpigqbO+y9np+YWPmaSxvszb6/uGkJmjrLW+xs3U2+Hn7fT6gIOGiYyOkZKUlYaWdZWUk5KQj42MioiHhYOA/Pbu5t3Sx7uvopaLgOzayrutoJWKgO/dzL2uoZSJ/+/h18/Kx8bGx8nJycfEwLy4tLCtrKytsLS5v8fP2eXygYuWpLXI3vmLm67D2vOGlKOzxNXm+IWNlp6mrbS6v8PGyczNz9DR0YbSQdHR0M/OzczLycjHxsXEw8LAvru4tK+po5yUjYX97+LVyr+2rKSbk4uE+erbzb+zp5ySiP/v4NLFua+lnZWPiYSAjHmOeop7kHyefY18iXuIeqF5iHqGe4h8tH2NfIp7jnoCAgEAP7CsqqinpqanqautsLS4vcPK0tvm8f6GjpegqrS/y9jm9IGJkZmiqrK6wsjP1drf5Orv9fqAg4aJi46QkpOUlISVgJSUk5KRkI+OjIuKiIeFg4H99/Do39XLwbaroJaNhPnq287BtqqglYyC8+LTxLesopuUkIyKiIeHhoWDgf759fHv7ezu8fX7goaMkpqirLjG1ej9i5mpu8/l/YuZqLjI2ev9iJGao6y1vcXM0tjc4OTn6evs7u7v8PDx8fDw8O/uPe3s6unn5uXk4uHg3tzZ1tLNyMG6s6ujm5OMhf7y6N3UysG4sKeelY2F+uvd0MO3rKKYj4f/8uXa0MjAurQ/sKyqqKempqepq62wtLi9w8rS2+bx/oaOl6CqtL/L2Ob0gYmRmaKqsrrCyM/V2t/k6u/1+oCDhomLjpCSk5SUhJWAlJSTkpGQj46Mi4qIh4WDgf338Ojf1cvBtquglo2E+erbzsG2qqCVjILz4tPEt6yim5SQjIqIh4eGhYOB/vn18e/t7O7x9fuChoySmqKsuMbV6P2Lmam7z+X9i5mouMjZ6/2IkZqjrLW9xczS2Nzg5Ofp6+zu7u/w8PHx8PDw7+497ezq6efm5eTi4eDe3NnW0s3Iwbqzq6Obk4yF/vLo3dTKwbiwp56VjYX6693Qw7esopiPh//y5drQyMC6tD+wrKqop6amp6mrrbC0uL3DytLb5vH+ho6XoKq0v8vY5vSBiZGZoqqyusLIz9Xa3+Tq7/X6gIOGiYuOkJKTlJSElYCUlJOSkZCPjoyLioiHhYOB/ffw6N/Vy8G2q6CWjYT56tvOwbaqoJWMgvPi08S3rKKblJCMioiHh4aFg4H++fXx7+3s7vH1+4KGjJKaoqy4xtXo/YuZqbvP5f2Lmai4yNnr/YiRmqOstb3FzNLY3ODk5+nr7O7u7/Dw8fHw8PDv7j3t7Orp5+bl5OLh4N7c2dbSzcjBurOro5uTjIX+8ujd1MrBuLCnnpWNhfrr3dDDt6yimI+H//Ll2tDIwLq0lnqLe5N8n32OfIt7k3qLeYx6h3uIfLl9jnyLe4l6AgIBAD/28e7r6unp6uvu8fT4/oGFiY2TmJ+mrrfAytTf6veBiI+WnqWttLzCyc7T2Nzg5Ojs8fb8gIOGiYuOj5GSk5OElHiTk5KSkZGQj46NjIuKiIeFg4H89e7l3dTKwbivpp6Wj4iB9und0cW6r6SbkYiB8+fc08zGwr68uri1s7Cuq6mnpqWmp6qtsri+xs/Z5fOBipSfrb3O4fWGkp+uvc7f8IGKlJ2nsLrDy9Tc4+rw9fr9gIKDhIWFhoaGhz+GhoWFhIOCgoGA//38+ff08Ovm4NnSysK5samim5SOiYT99Ovh2M7Eu7GonpaOhv7w49fLwLatpJ2Wj4qFgfs/9vHu6+rp6err7vH0+P6BhYmNk5ifpq63wMrU3+r3gYiPlp6lrbS8wsnO09jc4OTo7PH2/ICDhomLjo+RkpOThJR4k5OSkpGRkI+OjYyLioiHhYOB/PXu5d3UysG4r6aelo+Igfbp3dHFuq+km5GIgfPn3NPMxsK+vLq4tbOwrqupp6alpqeqrbK4vsbP2eXzgYqUn629zuH1hpKfrr3O3/CBipSdp7C6w8vU3OPq8PX6/YCCg4SFhYaGhoc/hoaFhYSDgoKBgP/9/Pn39PDr5uDZ0srCubGpopuUjomE/fTr4djOxLuxqJ6Wjob+8OPXy8C2raSdlo+KhYH7P/bx7uvq6enq6+7x9Pj+gYWJjZOYn6aut8DK1N/q94GIj5aepa20vMLJztPY3ODk6Ozx9vyAg4aJi46PkZKTk4SUeJOTkpKRkZCPjo2Mi4qIh4WDgfz17uXd1MrBuK+mnpaPiIH26d3RxbqvpJuRiIHz59zTzMbCvry6uLWzsK6rqaempaanqq2yuL7Gz9nl84GKlJ+tvc7h9YaSn669zt/wgYqUnaewusPL1Nzj6vD1+v2AgoOEhYWGhoaHP4aGhYWEg4KCgYD//fz59/Tw6+bg2dLKwrmxqaKblI6JhP306+HYzsS7saielo6G/vDj18vAtq2knZaPioWB+456kHuWfKF9kHyMe6B6iXuIfJF9mH6XfY58j3sBegICAQA/qKWjoaCgn6CgoqOlp6qtsbW6wMbN1N3m7/iBhoySmJ+lrLO5wMbM0tba3uDj5uns7/T5/oGEh4qMjpCRkpOThpR2k5OTkpKRkZCPjo6Ni4qIhoSC/vfw6OHZ0cnCurOspp+YkouF/fHl2c7Dua+nn5iTjoqHhIKA/fr28+/t6uno6Onr7/T6gIWKkJaeprC7x9bm+IaQnKm2xdXl9oONlp+psrzGz9jh6fH5gIOGiIqMjpCRkpOUlIeVPpSUk5OSkZCPjo2Mi4mIhoSB/vfw6eHY0MjAuLGrpJ+ZlI+KhoH47uTaz8W8sqqhmZKLhPzw5dvSycK7tbCsP6ilo6GgoJ+goKKjpaeqrbG1usDGzdTd5u/4gYaMkpifpayzucDGzNLW2t7g4+bp7O/0+f6BhIeKjI6QkZKTk4aUdpOTk5KSkZGQj46OjYuKiIaEgv738Ojh2dHJwrqzrKafmJKLhf3x5dnOw7mvp5+Yk46Kh4SCgP369vPv7erp6Ojp6+/0+oCFipCWnqawu8fW5viGkJyptsXV5faDjZafqbK8xs/Y4enx+YCDhoiKjI6QkZKTlJSHlT6UlJOTkpGQj46NjIuJiIaEgf738Onh2NDIwLixq6SfmZSPioaB+O7k2s/FvLKqoZmSi4T88OXb0snCu7WwrD+opaOhoKCfoKCio6Wnqq2xtbrAxs3U3ebv+IGGjJKYn6Wss7nAxszS1tre4OPm6ezv9Pn+gYSHioyOkJGSk5OGlHaTk5OSkpGRkI+Ojo2LioiGhIL+9/Do4dnRycK6s6ymn5iSi4X98eXZzsO5r6efmJOOioeEgoD9+vbz7+3q6ejo6evv9PqAhYqQlp6msLvH1ub4hpCcqbbF1eX2g42Wn6myvMbP2OHp8fmAg4aIioyOkJGSk5SUh5U+lJSTk5KRkI+OjYyLiYiGhIH+9/Dp4djQyMC4saukn5mUj4qGgfju5NrPxbyyqqGZkouE/PDl29LJwru1sKyae5p8o32SfJJ7j3qNe4l8jn2lfpR9jnyLewICAQA/4N3a2NbV1dXW19ja3N/i5urv9fuBhIiMkZWan6SqsLa8wsjN09jd4eTm6Onr7O7x9Pf8gIOFiIuNj5GSk5SUjJVylJSUk5OSkZCPjYuJh4SC/vjx6+Te2NLMxr+5s6yln5iSi4X+8+je1c3Gwbu3tLGurKqopaSioaCfoKGipKissLa8w8vU3+r3g4uUnqm1wtDf7v6HkJmiq7S+x9Da4+z0/IKGiY2Qk5WYmpudnp+goaKihaM+oqKhoJ+enZybmpiXlZSSj42KhoP/9+7m3tbOx8G7ta+qpaGcl5KMh4L67+Xc0snAt7CooJqTjoiD//fw6uU/4N3a2NbV1dXW19ja3N/i5urv9fuBhIiMkZWan6SqsLa8wsjN09jd4eTm6Onr7O7x9Pf8gIOFiIuNj5GSk5SUjJVylJSUk5OSkZCPjYuJh4SC/vjx6+Te2NLMxr+5s6yln5iSi4X+8+je1c3Gwbu3tLGurKqopaSioaCfoKGipKissLa8w8vU3+r3g4uUnqm1wtDf7v6HkJmiq7S+x9Da4+z0/IKGiY2Qk5WYmpudnp+goaKihaM+oqKhoJ+enZybmpiXlZSSj42KhoP/9+7m3tbOx8G7ta+qpaGcl5KMh4L67+Xc0snAt7CooJqTjoiD//fw6uU/4N3a2NbV1dXW19ja3N/i5urv9fuBhIiMkZWan6SqsLa8wsjN09jd4eTm6Onr7O7x9Pf8gIOFiIuNj5GSk5SUjJVylJSUk5OSkZCPjYuJh4SC/vjx6+Te2NLMxr+5s6yln5iSi4X+8+je1c3Gwbu3tLGurKqopaSioaCfoKGipKissLa8w8vU3+r3g4uUnqm1wtDf7v6HkJmiq7S+x9Da4+z0/IKGiY2Qk5WYmpudnp+goaKihaM+oqKhoJ+enZybmpiXlZSSj42KhoP/9+7m3tbOx8G7ta+qpaGcl5KMh4L67+Xc0snAt7CooJqTjoiD//fw6uWUe598p32UfKV7i3yOfap+lX2QfIV7AgIBAAWRj42Mi4WKPYuLjI6PkZOVmJueoaWprLC1ub7Cx8zS19zh5ent7/Hx8vLy8/T2+Px/goWHio2PkZKUlJWWlpaXl5eYmJiImW6YmJiXlpWUkpCOjIqHhYOA/Pbx7Ofh3NbQycO8ta6ooZuVj4uGgv749O/s6ebj4N7c2tnY19jZ297i5uzy+YGFi5CXnqewusbS3uz6hIyUnaWut7/I0drj7PT9goeLj5KWmZyfoaSmqKmrrK2uroWvPq6urayrqqmopqWkoqCenJqXlJCNiYWB+/Pr5N3W0MrFwLu3sq2oo56Yk46Ig/306uHY0MjAubOtp6KempaTBZGPjYyLhYo9i4uMjo+Rk5WYm56hpamssLW5vsLHzNLX3OHl6e3v8fHy8vLz9Pb4/H+ChYeKjY+RkpSUlZaWlpeXl5iYmIiZbpiYmJeWlZSSkI6MioeFg4D89vHs5+Hc1tDJw7y1rqihm5WPi4aC/vj07+zp5uPg3tza2djX2Nnb3uLm7PL5gYWLkJeep7C6xtLe7PqEjJSdpa63v8jR2uPs9P2Ch4uPkpaZnJ+hpKaoqausra6uha8+rq6trKuqqaimpaSioJ6cmpeUkI2JhYH78+vk3dbQysXAu7eyraijnpiTjoiD/fTq4djQyMC5s62nop6alpMFkY+NjIuFij2Li4yOj5GTlZibnqGlqaywtbm+wsfM0tfc4eXp7e/x8fLy8vP09vj8f4KFh4qNj5GSlJSVlpaWl5eXmJiYiJlumJiYl5aVlJKQjoyKh4WDgPz28ezn4dzW0MnDvLWuqKGblY+LhoL++PTv7Onm4+De3NrZ2NfY2dve4ubs8vmBhYuQl56nsLrG0t7s+oSMlJ2lrre/yNHa4+z0/YKHi4+Slpmcn6Gkpqipq6ytrq6Frz6urq2sq6qpqKalpKKgnpyal5SQjYmFgfvz6+Td1tDKxcC7t7KtqKOemJOOiIP99Orh2NDIwLmzraeinpqWk7J8rX2WfJh7jnyPfa9+ln2RfAICAQAGtrSysK+uha1Arq+wsbO0tri7vcDDxsnN0NPX29/j5+vw9Pf6/P39/Pz7+vr6/P6AgoSHioyPkZOVlpeYmJmZmZqam5ycnZ2enoefa56enZ2cmpmXlpSSkI6MioiGhIL/+vTv6eLc1c7Hwbu1sKumo6Cdm5mXlZSSkY+Ojo2NjY6QkZOWmZygpauwt7/H0Nrl8P2FjJOaoqmyusLK09vj6/P8goaKjpKWmp2hpKeqrK6wsrS1tre4hrk9uLe3tbSzsrCvraupp6WjoJ2alpKOioaD/vfx6uXf2tXRzMfDvrm0r6qkn5qVkIuHgvzz6+Pc1tDKxcG9uQa2tLKwr66FrUCur7Cxs7S2uLu9wMPGyc3Q09fb3+Pn6/D09/r8/f38/Pv6+vr8/oCChIeKjI+Rk5WWl5iYmZmZmpqbnJydnZ6eh59rnp6dnZyamZeWlJKQjoyKiIaEgv/69O/p4tzVzsfBu7Wwq6ajoJ2bmZeVlJKRj46OjY2NjpCRk5aZnKClq7C3v8fQ2uXw/YWMk5qiqbK6wsrT2+Pr8/yChoqOkpaanaGkp6qsrrCytLW2t7iGuT24t7e1tLOysK+tq6mnpaOgnZqWko6KhoP+9/Hq5d/a1dHMx8O+ubSvqqSfmpWQi4eC/PPr49zW0MrFwb25Bra0srCvroWtQK6vsLGztLa4u73Aw8bJzdDT19vf4+fr8PT3+vz9/fz8+/r6+vz+gIKEh4qMj5GTlZaXmJiZmZmampucnJ2dnp6Hn2uenp2dnJqZl5aUkpCOjIqIhoSC//r07+ni3NXOx8G7tbCrpqOgnZuZl5WUkpGPjo6NjY2OkJGTlpmcoKWrsLe/x9Da5fD9hYyTmqKpsrrCytPb4+vz/IKGio6SlpqdoaSnqqyusLK0tba3uIa5Pbi3t7W0s7Kwr62rqaelo6CdmpaSjoqGg/738erl39rV0czHw765tK+qpJ+alZCLh4L88+vj3NbQysXBvbmxfLR9s3yQfbN+mX2MfAICAQBP4N3a2dfW1dTU09TU1NXW19ja293f4ePl5+nr7vDz9vn8gIGCg4SFhISDgoGBgICBgoOFiIqNj5KUlpiZmpucnJ2dnp+foKGio6SlpaampoWnLaampaWko6Khn56dm5qYl5WTkY+NioeFgv338erk3tnU0MzIxsPBv727uri3toS1OLa3ubu+wcXKz9Tb4ury/IOIjpWboqmwt77GzdXd5Ozz+4GFiIyQlJicoKOnqq2ws7W4uru9vr/AhsE9wMC/vr27uri3tbOxr62qqKWhnpuXk4+LiISB/fjz7unl4NzX08/KxcC7trGtqKOemZSQjIiEgPv18Ovn40/g3drZ19bV1NTT1NTU1dbX2Nrb3d/h4+Xn6evu8PP2+fyAgYKDhIWEhIOCgYGAgIGCg4WIio2PkpSWmJmam5ycnZ2en5+goaKjpKWlpqamhactpqalpaSjoqGfnp2bmpiXlZORj42Kh4WC/ffx6uTe2dTQzMjGw8G/vbu6uLe2hLU4tre5u77BxcrP1Nvi6vL8g4iOlZuiqbC3vsbN1d3k7PP7gYWIjJCUmJygo6eqrbCztbi6u72+v8CGwT3AwL++vbu6uLe1s7GvraqopaGem5eTj4uIhIH9+PPu6eXg3NfTz8rFwLu2sa2oo56ZlJCMiISA+/Xw6+fjT+Dd2tnX1tXU1NPU1NTV1tfY2tvd3+Hj5efp6+7w8/b5/ICBgoOEhYSEg4KBgYCAgYKDhYiKjY+SlJaYmZqbnJydnZ6fn6ChoqOkpaWmpqaFpy2mpqWlpKOioZ+enZuamJeVk5GPjYqHhYL99/Hq5N7Z1NDMyMbDwb+9u7q4t7aEtTi2t7m7vsHFys/U2+Lq8vyDiI6Vm6KpsLe+xs3V3eTs8/uBhYiMkJSYnKCjp6qtsLO1uLq7vb6/wIbBPcDAv769u7q4t7Wzsa+tqqiloZ6bl5OPi4iEgf348+7p5eDc19PPysXAu7axraijnpmUkIyIhID79fDr5+OhfMt9qHySfbh+nH2GfAICAQAJhYSCgYCA/v79hvxC/f3+/4CAgIGCgoKDhISFhoeIiYqLi4yMi4qJh4aFhISFhYeJi46Qk5WXmZudnp+goaGio6SlpqeoqaurrK2ur6+vhbCAr6+vrq6trKyrqqmop6ako6GfnZuZlpOQjYqIhYKA/Pj18vDt6+no5uXj4uLh4eLi5OXo6+7y9vyBhIiMkJWan6Wrsri+xcvS2eDn7fT7gYSHi46SlZmcoKSoq6+ytbi7vcDBw8XGx8jIyMnJyMjHxsXEwsG/vbu6uLWzsa6rqKUqop6bl5OQjYqHhIKA+/fz7+vn497a1dHNyMS/urWxrKejn5uXlJGOjImHCYWEgoGAgP7+/Yb8Qv39/v+AgICBgoKCg4SEhYaHiImKi4uMjIuKiYeGhYSEhYWHiYuOkJOVl5mbnZ6foKGhoqOkpaanqKmrq6ytrq+vr4WwgK+vr66uraysq6qpqKempKOhn52bmZaTkI2KiIWCgPz49fLw7evp6Obl4+Li4eHi4uTl6Ovu8vb8gYSIjJCVmp+lq7K4vsXL0tng5+30+4GEh4uOkpWZnKCkqKuvsrW4u73AwcPFxsfIyMjJycjIx8bFxMLBv727uri1s7Guq6ilKqKem5eTkI2Kh4SCgPv38+/r5+Pe2tXRzcjEv7q1sayno5+bl5SRjoyJhwmFhIKBgID+/v2G/EL9/f7/gICAgYKCgoOEhIWGh4iJiouLjIyLiomHhoWEhIWFh4mLjpCTlZeZm52en6ChoaKjpKWmp6ipq6usra6vr6+FsICvr6+urq2srKuqqainpqSjoZ+dm5mWk5CNioiFgoD8+PXy8O3r6ejm5ePi4uHh4uLk5ejr7vL2/IGEiIyQlZqfpauyuL7Fy9LZ4Oft9PuBhIeLjpKVmZygpKirr7K1uLu9wMHDxcbHyMjIycnIyMfGxcTCwb+9u7q4tbOxrquopSqinpuXk5CNioeEgoD79/Pv6+fj3trV0c3IxL+6tbGsp6Ofm5eUkY6MiYeGfY184X2afJZ9vn6efQICAQAKnJqZl5aVlZSTk4SSjJEBkISRNJKTk5SUlJOTkZCOjYuKiYmJioyNkJKVl5qcnqChoqSlpqeoqaqrrK6vsLKztLW2t7i5ubmJuiW5ubm4uLe2trW0s7Kwr62rqKajoZ6cmZeVk5KQj46NjIuLiomJhIg5iYmKi42PkJOVmJygpKissbe8wsfN09nf5evw9/yBhIeKjZCTlpmdoKSoq6+ztrm8v8LExsjKy8zNhs48zczLysjGxcPBv727uLa0sa6rqKWhnpuXlJGPjIqIhoSCgP369vLu6ubi3trV0czIw7+7trOvq6iloqCeCpyamZeWlZWUk5OEkoyRAZCEkTSSk5OUlJSTk5GQjo2LiomJiYqMjZCSlZeanJ6goaKkpaanqKmqq6yur7Cys7S1tre4ubm5ibolubm5uLi3tra1tLOysK+tq6imo6GenJmXlZOSkI+OjYyLi4qJiYSIOYmJiouNj5CTlZicoKSorLG3vMLHzdPZ3+Xr8Pf8gYSHio2Qk5aZnaCkqKuvs7a5vL/CxMbIysvMzYbOPM3My8rIxsXDwb+9u7i2tLGuq6iloZ6bl5SRj4yKiIaEgoD9+vby7urm4t7a1dHMyMO/u7azr6uopaKgngqcmpmXlpWVlJOThJKMkQGQhJE0kpOTlJSUk5ORkI6Ni4qJiYmKjI2QkpWXmpyeoKGipKWmp6ipqqusrq+wsrO0tba3uLm5uYm6Jbm5ubi4t7a2tbSzsrCvrauopqOhnpyZl5WTkpCPjo2Mi4uKiYmEiDmJiYqLjY+Qk5WYnKCkqKyxt7zCx83T2d/l6/D3/IGEh4qNkJOWmZ2gpKirr7O2uby/wsTGyMrLzM2GzjzNzMvKyMbFw8G/vbu4trSxrquopaGem5eUkY+MioiGhIKA/fr28u7q5uLe2tXRzMjDv7u2s6+rqKWioJ7/faN9xH6afQICAQAcs7Gvrq2rqqmpqKenpqWlpKSjo6OioaGgn5+enoidNZybmpiWlJKQj46Ojo+RkpWXmpyeoaOkpqipqqytrq+xsrS1t7i6u72+v8DBwsPDxMTExcXFiMaExVrExMPCwcC/vbu5t7Wzsa+trKqpqKempaWko6OioqGhoqKio6Smp6msrrG0uLzAxMjN0tfc4ebr8fb7gIKFh4qNj5KVl5qdoKSnq66ytbm8wMPFyMrMztDR0tOE1D3T0tHQzs3LycfFw8G/vbq4trOwraqnpKGem5iWk5GPjYyKiIaFg4KA/fr28u/r5+Le2tXRzcrGw7+8ure1HLOxr66tq6qpqainp6alpaSko6OjoqGhoJ+fnp6InTWcm5qYlpSSkI+Ojo6PkZKVl5qcnqGjpKaoqaqsra6vsbK0tbe4uru9vr/AwcLDw8TExMXFxYjGhMVaxMTDwsHAv727ube1s7GvrayqqainpqWlpKOjoqKhoaKioqOkpqeprK6xtLi8wMTIzdLX3OHm6/H2+4CChYeKjY+SlZeanaCkp6uusrW5vMDDxcjKzM7Q0dLThNQ909LR0M7Ny8nHxcPBv726uLazsK2qp6ShnpuYlpORj42MioiGhYOCgP369vLv6+fi3trV0c3KxsO/vLq3tRyzsa+urauqqamop6empaWkpKOjo6KhoaCfn56eiJ01nJuamJaUkpCPjo6Oj5GSlZeanJ6ho6SmqKmqrK2ur7GytLW3uLq7vb6/wMHCw8PExMTFxcWIxoTFWsTEw8LBwL+9u7m3tbOxr62sqqmop6alpaSjo6KioaGioqKjpKanqayusbS4vMDEyM3S19zh5uvx9vuAgoWHio2PkpWXmp2gpKerrrK1ubzAw8XIyszO0NHS04TUPdPS0dDOzcvJx8XDwb+9uri2s7CtqqekoZ6bmJaTkY+NjIqIhoWDgoD9+vby7+vn4t7a1dHNysbDv7y6t7X/faB9zH6VfQICAQBdycfFxMLBwL++vby7urm4t7a1tbSzsrGvrq2sq6qpqKinp6ampKOhn52bmJeVlJSUlZaYm52foqSmqKqsrq+wsrS1t7i6u72/wMLExcfIycvMzM3Oz8/Q0NHR0tLSh9OC1IXTVNLR0M7Ny8nIxsXEw8LBwL+/vr29vLy8u7u7vLy9vr/AwsTHyczQ09fb3+Lm6+/0+PyAgoSHiYuNkJKUlpmbnqCjpqmtsLS4u7/CxcjLztDS1NbX2ITZPdjX1tXT0c/Ny8nHxcPBvry6t7Wyr6yqp6Shn5yamJaUkpGPjo2LiomHhoSDgf/79/Pv6+fk4NzZ1tPQzstdycfFxMLBwL++vby7urm4t7a1tbSzsrGvrq2sq6qpqKinp6ampKOhn52bmJeVlJSUlZaYm52foqSmqKqsrq+wsrS1t7i6u72/wMLExcfIycvMzM3Oz8/Q0NHR0tLSh9OC1IXTVNLR0M7Ny8nIxsXEw8LBwL+/vr29vLy8u7u7vLy9vr/AwsTHyczQ09fb3+Lm6+/0+PyAgoSHiYuNkJKUlpmbnqCjpqmtsLS4u7/CxcjLztDS1NbX2ITZPdjX1tXT0c/Ny8nHxcPBvry6t7Wyr6yqp6Shn5yamJaUkpGPjo2LiomHhoSDgf/79/Pv6+fk4NzZ1tPQzstdycfFxMLBwL++vby7urm4t7a1tbSzsrGvrq2sq6qpqKinp6ampKOhn52bmJeVlJSUlZaYm52foqSmqKqsrq+wsrS1t7i6u72/wMLExcfIycvMzM3Oz8/Q0NHR0tLSh9OC1IXTVNLR0M7Ny8nIxsXEw8LBwL+/vr29vLy8u7u7vLy9vr/AwsTHyczQ09fb3+Lm6+/0+PyAgoSHiYuNkJKUlpmbnqCjpqmtsLS4u7/CxcjLztDS1NbX2ITZPdjX1tXT0c/Ny8nHxcPBvry6t7Wyr6yqp6Shn5yamJaUkpGPjo2LiomHhoSDgf/79/Pv6+fk4NzZ1tPQzsv/fZ191H6QfQICAQBp3tzb2dfW1NPS0M/OzczKycjHxsTDwsC+vbu5uLa1tLOysbCvraupp6Sin52cm5qbnJ2foaOmqKqsrrCytLa3ubu9vsDCxMXHycvNztDS09TW19jZ2drb3Nzd3d7e39/f4ODg4eHi4+PjhOQU4+Lh4N/e3dzb29rZ2djY19fW1taG1TjW19jZ29zf4eTm6u3w8/f6/YCCg4WHiYuNj5GTlZeYmpyfoaOmqayvsra6vcHEyMvO0dTW2Nrc3YTePd3c29nX1dPRzszKyMbEwsC+u7m2tLGvrKmnpKKgnpyamZeWlZSTkpGPjo2MioiHhYOB//z49fHu6+jm4+Fp3tzb2dfW1NPS0M/OzczKycjHxsTDwsC+vbu5uLa1tLOysbCvraupp6Sin52cm5qbnJ2foaOmqKqsrrCytLa3ubu9vsDCxMXHycvNztDS09TW19jZ2drb3Nzd3d7e39/f4ODg4eHi4+PjhOQU4+Lh4N/e3dzb29rZ2djY19fW1taG1TjW19jZ29zf4eTm6u3w8/f6/YCCg4WHiYuNj5GTlZeYmpyfoaOmqayvsra6vcHEyMvO0dTW2Nrc3YTePd3c29nX1dPRzszKyMbEwsC+u7m2tLGvrKmnpKKgnpyamZeWlZSTkpGPjo2MioiHhYOB//z49fHu6+jm4+Fp3tzb2dfW1NPS0M/OzczKycjHxsTDwsC+vbu5uLa1tLOysbCvraupp6Sin52cm5qbnJ2foaOmqKqsrrCytLa3ubu9vsDCxMXHycvNztDS09TW19jZ2drb3Nzd3d7e39/f4ODg4eHi4+PjhOQU4+Lh4N/e3dzb29rZ2djY19fW1taG1TjW19jZ29zf4eTm6u3w8/f6/YCCg4WHiYuNj5GTlZeYmpyfoaOmqayvsra6vcHEyMvO0dTW2Nrc3YTePd3c29nX1dPRzszKyMbEwsC+u7m2tLGvrKmnpKKgnpyamZeWlZSTkpGPjo2MioiHhYOB//z49fHu6+jm4+H/fZl93X6LfQICAQCA8vDu7evp6Obl4+Lg393c29nY1tTT0c/Ny8nHxcPCwL+9vLq5t7Syr6yqp6WjoqKio6WmqKutr7Gztbe5u72/wcPFx8nKzM7Q0tTW2Nrb3d7g4eLj5eXm5+jp6erq6+vr7Ozt7u/w8fLz9PX19vb19fX08/Py8vLx8fHw8PDv7+4C7u6F7Tju7/Dx8vP19/n8/oCCg4SFh4iJi4yOkJGTlJaYmZudnqCipKaoq66xtbi8v8PHys7R1Nfa3d/g4oTjPeLh393b2dfU0tDNy8nHxcPBv726uLazsa6sqqelo6Kgn56dm5uamZiXlpWUkpGPjoyKiYeFhIKB//z69/WA8vDu7evp6Obl4+Lg393c29nY1tTT0c/Ny8nHxcPCwL+9vLq5t7Syr6yqp6WjoqKio6WmqKutr7Gztbe5u72/wcPFx8nKzM7Q0tTW2Nrb3d7g4eLj5eXm5+jp6erq6+vr7Ozt7u/w8fLz9PX19vb19fX08/Py8vLx8fHw8PDv7+4C7u6F7Tju7/Dx8vP19/n8/oCCg4SFh4iJi4yOkJGTlJaYmZudnqCipKaoq66xtbi8v8PHys7R1Nfa3d/g4oTjPeLh393b2dfU0tDNy8nHxcPBv726uLazsa6sqqelo6Kgn56dm5uamZiXlpWUkpGPjoyKiYeFhIKB//z69/WA8vDu7evp6Obl4+Lg393c29nY1tTT0c/Ny8nHxcPCwL+9vLq5t7Syr6yqp6WjoqKio6WmqKutr7Gztbe5u72/wcPFx8nKzM7Q0tTW2Nrb3d7g4eLj5eXm5+jp6erq6+vr7Ozt7u/w8fLz9PX19vb19fX08/Py8vLx8fHw8PDv7+4C7u6F7Tju7/Dx8vP19/n8/oCCg4SFh4iJi4yOkJGTlJaYmZudnqCipKaoq66xtbi8v8PHys7R1Nfa3d/g4oTjPeLh393b2dfU0tDNy8nHxcPBv726uLazsa6sqqelo6Kgn56dm5uamZiXlpWUkpGPjoyKiYeFhIKB//z69/X/fZN96X6FfQICAQBtgoGA//37+vj39fPy8O7t6+nn5uTi4N7b2dfV0tDOzMvJx8XDwb67uLWysK6sq6urrK2vsbO1t7m7vb/Bw8XHycvNz9LU1tja3N7g4uPl5+nq7O3u8PHy8/T19fb29/f3+Pj5+vv9/v+AgYKCgpKDi4J2g4OEhYaGh4mKi4yNjo+QkZKTlJWXmJqbnZ6goaKkpaepq66ws7e6vsHFyc3R1Njb3uHj5efo6eno5+bk4uDd29jV09DOzMrIxsTCwL68uri1s7GurKupp6alpKOioaGgn56dnJuamZeWlJORkI6Ni4qIh4aEg22CgYD//fv6+Pf18/Lw7u3r6efm5OLg3tvZ19XS0M7My8nHxcPBvru4tbKwrqyrq6usra+xs7W3ubu9v8HDxcfJy83P0tTW2Nrc3uDi4+Xn6ers7e7w8fLz9PX19vb39/f4+Pn6+/3+/4CBgoKCkoOLgnaDg4SFhoaHiYqLjI2Oj5CRkpOUlZeYmpudnqChoqSlp6mrrrCzt7q+wcXJzdHU2Nve4ePl5+jp6ejn5uTi4N3b2NXT0M7MysjGxMLAvry6uLWzsa6sq6mnpqWko6KhoaCfnp2cm5qZl5aUk5GQjo2LioiHhoSDbYKBgP/9+/r49/Xz8vDu7evp5+bk4uDe29nX1dLQzszLycfFw8G+u7i1srCurKurq6ytr7Gztbe5u72/wcPFx8nLzc/S1NbY2tze4OLj5efp6uzt7vDx8vP09fX29vf39/j4+fr7/f7/gIGCgoKSg4uCdoODhIWGhoeJiouMjY6PkJGSk5SVl5iam52eoKGipKWnqauusLO3ur7BxcnN0dTY297h4+Xn6Onp6Ofm5OLg3dvY1dPQzszKyMbEwsC+vLq4tbOxrqyrqaempaSjoqGhoJ+enZybmpmXlpSTkZCOjYuKiIeGhIODfuV9/36ZfgICAQBbi4qJiIeGhYSDgoGBgP78+vn39fPx7uzq5+Xi4N7c2dfV09HOy8nFwr+8ube2tbS0tba4ury+v8HDxcfJy87Q0tTX2dvd3+Hk5ujq7O7v8fP19/j6+/z+/4CAgIaBEYKCg4OEhYaHiImKiouLjIyMkY2GjDaNjY2Ojo+QkZGSk5SVlZaWl5iZmpucnZ+goaOkpaeoqautrrGztrm8wMTIzNDU19vf4+bo6+2E7j3t6+nn5OHf3NnW1NHPzcvJyMbEwsC+vLm3tbOysK6trKuqqqmoqKempaSjoqGgn52cm5mYlpWTkpGPjo2MW4uKiYiHhoWEg4KBgYD+/Pr59/Xz8e7s6ufl4uDe3NnX1dPRzsvJxcK/vLm3trW0tLW2uLq8vr/Bw8XHycvO0NLU19nb3d/h5Obo6uzu7/Hz9ff4+vv8/v+AgICGgRGCgoODhIWGh4iJioqLi4yMjJGNhow2jY2Njo6PkJGRkpOUlZWWlpeYmZqbnJ2foKGjpKWnqKmrra6xs7a5vMDEyMzQ1Nfb3+Pm6OvthO497evp5+Th39zZ1tTRz83LycjGxMLAvry5t7WzsrCurayrqqqpqKinpqWko6KhoJ+dnJuZmJaVk5KRj46NjFuLiomIh4aFhIOCgYGA/vz6+ff18/Hu7Orn5eLg3tzZ19XT0c7LycXCv7y5t7a1tLS1tri6vL6/wcPFx8nLztDS1NfZ293f4eTm6Ors7u/x8/X3+Pr7/P7/gICAhoERgoKDg4SFhoeIiYqKi4uMjIyRjYaMNo2NjY6Oj5CRkZKTlJWVlpaXmJmam5ydn6Cho6Slp6ipq62usbO2ubzAxMjM0NTX29/j5ujr7YTuPe3r6efk4d/c2dbU0c/Ny8nIxsTCwL68ube1s7Kwrq2sq6qqqaiop6alpKOioaCfnZybmZiWlZOSkY+OjYyNfst9/36pfgICAQBak5KRkI+OjYyLiomIh4aFhIOCgYD//fr49vPx7uzp5+Ti4N3a19TRzcrHxMLAv7+/wMHCxMbHycvNztDT1dfZ3N7h4+Xn6ezu8PL09vj6/P5/gIGCg4SEhYaGhocUiIiIiYmKi4yNj5CRkpOTlJSVlZWElomXi5Z0l5eYmJmZmpubm5ycnZ2enp+goaKkpaanqaqrrK2vsLK0trm8v8LGys7S19vf4+fq7fDy8/T09PLw7uzp5uPg3drX1dLQzs3LycfFw8G/vby6uLe1tLOysrGwsK+urq2sq6qpqKalpKOioJ+enJuamZeWlZRak5KRkI+OjYyLiomIh4aFhIOCgYD//fr49vPx7uzp5+Ti4N3a19TRzcrHxMLAv7+/wMHCxMbHycvNztDT1dfZ3N7h4+Xn6ezu8PL09vj6/P5/gIGCg4SEhYaGhocUiIiIiYmKi4yNj5CRkpOTlJSVlZWElomXi5Z0l5eYmJmZmpubm5ycnZ2enp+goaKkpaanqaqrrK2vsLK0trm8v8LGys7S19vf4+fq7fDy8/T09PLw7uzp5uPg3drX1dLQzs3LycfFw8G/vby6uLe1tLOysrGwsK+urq2sq6qpqKalpKOioJ+enJuamZeWlZRak5KRkI+OjYyLiomIh4aFhIOCgYD//fr49vPx7uzp5+Ti4N3a19TRzcrHxMLAv7+/wMHCxMbHycvNztDT1dfZ3N7h4+Xn6ezu8PL09vj6/P5/gIGCg4SEhYaGhocUiIiIiYmKi4yNj5CRkpOTlJSVlZWElomXi5Z0l5eYmJmZmpubm5ycnZ2enp+goaKkpaanqaqrrK2vsLK0trm8v8LGys7S19vf4+fq7fDy8/T09PLw7uzp5uPg3drX1dLQzs3LycfFw8G/vby6uLe1tLOysrGwsK+urq2sq6qpqKalpKOioJ+enJuamZeWlZSUfrx9/36xfgICAQBcmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoD//fr39fLw7ern5ODd2dbT0M7My8vLzM3Oz9HS1NXX2drd3+Hj5ujr7fDy9Pb4+vz+gIGCg4SFhoeIiYqLi4yNjY2GjhWPj5CRkpOUlZeYmZqbnJydnZ2enp6Nn4eeCZ+fn6CgoKGhoYSiJ6Ojo6SkpaanqaqrrK6vsLGys7S1t7m7vsHFyc3R1dre4+fr7/L194T5Pff18/Dt6ubj4N3a2NXT0dDOzMrJx8XDwsC+vby7urq5ubi4t7a1tLOysbCvrq2sq6qop6alo6KhoJ+dnJtcmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoD//fr39fLw7ern5ODd2dbT0M7My8vLzM3Oz9HS1NXX2drd3+Hj5ujr7fDy9Pb4+vz+gIGCg4SFhoeIiYqLi4yNjY2GjhWPj5CRkpOUlZeYmZqbnJydnZ2enp6Nn4eeCZ+fn6CgoKGhoYSiJ6Ojo6SkpaanqaqrrK6vsLGys7S1t7m7vsHFyc3R1dre4+fr7/L194T5Pff18/Dt6ubj4N3a2NXT0dDOzMrJx8XDwsC+vby7urq5ubi4t7a1tLOysbCvrq2sq6qop6alo6KhoJ+dnJtcmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoD//fr39fLw7ern5ODd2dbT0M7My8vLzM3Oz9HS1NXX2drd3+Hj5ujr7fDy9Pb4+vz+gIGCg4SFhoeIiYqLi4yNjY2GjhWPj5CRkpOUlZeYmZqbnJydnZ2enp6Nn4eeCZ+fn6CgoKGhoYSiJ6Ojo6SkpaanqaqrrK6vsLGys7S1t7m7vsHFyc3R1dre4+fr7/L194T5Pff18/Dt6ubj4N3a2NXT0dDOzMrJx8XDwsC+vby7urq5ubi4t7a1tLOysbCvrq2sq6qop6alo6KhoJ+dnJuafrF9/362fgICAQBaoaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhYSCgYD9+/j08e7q5+Pg3dva2djY2dnb3N3e3+Hi5Obo6uzu8fP2+Pr9/4CBgoOEhYaHiImLjI2Oj5CRkpKThpQUlZWVlpaXmJmbnJ2foKGio6SkpaWEpouniqaHp4aoZqmpqqusra6vsLGys7S1tre4ubu8v8HEx8vP09jc4ebq7vL2+fv9/v79/Pr39PHt6ubj4N3a2NbU0tHPzszKycfGxcTDwsHBwMDAv7++vby7urm4t7W0s7KxsK6trKuqqaimpaSjolqhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeFhIKBgP37+PTx7urn4+Dd29rZ2NjZ2dvc3d7f4eLk5ujq7O7x8/b4+v3/gIGCg4SFhoeIiYuMjY6PkJGSkpOGlBSVlZWWlpeYmZucnZ+goaKjpKSlpYSmi6eKpoenhqhmqamqq6ytrq+wsbKztLW2t7i5u7y/wcTHy8/T2Nzh5uru8vb5+/3+/v38+vf08e3q5uPg3drY1tTS0c/OzMrJx8bFxMPCwcHAwMC/v769vLu6ubi3tbSzsrGwrq2sq6qpqKalpKOiWqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4WEgoGA/fv49PHu6ufj4N3b2tnY2NnZ29zd3t/h4uTm6Ors7vHz9vj6/f+AgYKDhIWGh4iJi4yNjo+QkZKSk4aUFJWVlZaWl5iZm5ydn6ChoqOkpKWlhKaLp4qmh6eGqGapqaqrrK2ur7CxsrO0tba3uLm7vL/BxMfLz9PY3OHm6u7y9vn7/f7+/fz69/Tx7erm4+Dd2tjW1NLRz87MysnHxsXEw8LBwcDAwL+/vr28u7q5uLe1tLOysbCurayrqqmopqWko6KgfqZ9/367fgICAQBbqKempaSjoqGgn56dnJuamZiXlpaVlJOSkY+OjYuKiYeGhIKB//v49fHu7Ono5+bm5+fo6err7O3v8PLz9fj6/P+AgYKDhYaHiImKi4yNjo+QkZOUlZaXmJmamoabF5ycnJ2en6Cho6Slp6ipqqqrrKysra2tja6UrSaurq+vsLGytLW2t7e4ubq7u7y9vsDCxMfKztLW2t/k6O3y9vn8/4SAGv/9+vf08Ozp5uLg3dvZ19XU0tHQzs3My8rJhMiExxvGxcXEwsG/vr27urm4t7W0s7KxsK+urayrqqlbqKempaSjoqGgn56dnJuamZiXlpaVlJOSkY+OjYuKiYeGhIKB//v49fHu7Ono5+bm5+fo6err7O3v8PLz9fj6/P+AgYKDhYaHiImKi4yNjo+QkZOUlZaXmJmamoabF5ycnJ2en6Cho6Slp6ipqqqrrKysra2tja6UrSaurq+vsLGytLW2t7e4ubq7u7y9vsDCxMfKztLW2t/k6O3y9vn8/4SAGv/9+vf08Ozp5uLg3dvZ19XU0tHQzs3My8rJhMiExxvGxcXEwsG/vr27urm4t7W0s7KxsK+urayrqqlbqKempaSjoqGgn56dnJuamZiXlpaVlJOSkY+OjYuKiYeGhIKB//v49fHu7Ono5+bm5+fo6err7O3v8PLz9fj6/P+AgYKDhYaHiImKi4yNjo+QkZOUlZaXmJmamoabF5ycnJ2en6Cho6Slp6ipqqqrrKysra2tja6UrSaurq+vsLGytLW2t7e4ubq7u7y9vsDCxMfKztLW2t/k6O3y9vn8/4SAGv/9+vf08Ozp5uLg3dvZ19XU0tHQzs3My8rJhMiExxvGxcXEwsG/vr27urm4t7W0s7KxsK+urayrqqmkfp19/n6Ef71+AgIBAFyurayrqqmop6empaSjoqGgn56dnZybmpmYl5aVk5KQj42LioiGhYOBgP37+ff29vX29vf4+fn6+/z9/oCBgoOEhYaHiImKi4yNjo+QkZKUlZaXmZqbnJ6foKChoYWiFqOjo6Slpqeoqqusra6vsLGxsrKzs7OPtI+zKrKysrOzs7S1tre4ubq8vL2+vr+/wMDBwsTFx8rN0NTY3OHm6u/0+Pv+gISBGoD//Pn28u/r6OXi393b2tjX1tXU0tHQ0M/PiM4bzc3My8nIxsTDwcC/vby7urm4t7a1tLOysbCvXK6trKuqqainp6alpKOioaCfnp2dnJuamZiXlpWTkpCPjYuKiIaFg4GA/fv59/b29fb29/j5+fr7/P3+gIGCg4SFhoeIiYqLjI2Oj5CRkpSVlpeZmpucnp+goKGhhaIWo6OjpKWmp6iqq6ytrq+wsbGysrOzs4+0j7MqsrKys7OztLW2t7i5ury8vb6+v7/AwMHCxMXHys3Q1Njc4ebq7/T4+/6AhIEagP/8+fby7+vo5eLf3dva2NfW1dTS0dDQz8+IzhvNzczLycjGxMPBwL+9vLu6ubi3trW0s7KxsK9crq2sq6qpqKenpqWko6KhoJ+enZ2cm5qZmJeWlZOSkI+Ni4qIhoWDgYD9+/n39vb19vb3+Pn5+vv8/f6AgYKDhIWGh4iJiouMjY6PkJGSlJWWl5mam5yen6CgoaGFohajo6OkpaanqKqrrK2ur7CxsbKys7Ozj7SPsyqysrKzs7O0tba3uLm6vLy9vr6/v8DAwcLExcfKzdDU2Nzh5urv9Pj7/oCEgRqA//z59vLv6+jl4t/d29rY19bV1NLR0NDPz4jOG83NzMvJyMbEw8HAv728u7q5uLe2tbSzsrGwr6l+kn3/foR+hn+8fgICAQAutLOysbCvr66trKuqqaiop6alpaSjo6KhoJ+enJuamJaVk5GQjoyLiYeGhYSDg4SChIMmhISFhYaGh4iJiouMjY6PkJGSk5SVlpeYmZucnZ+goaOkpaanqKiFqROqqqurrK2ur7Cxs7S1tba3t7i4hbmKuoy5hrgqt7e4uLi5ubq7vb6/wMHCw8PExMTFxcXGx8nLzdDT19re4+fs8fX5/P+AhIEXgP/9+vf08O3q5+Ti4N7d3NvZ2NfW1tWG1IbVGtTT0dDOzMvJx8bEw8LAv769vLu6ubi3t7a1LrSzsrGwr6+urayrqqmoqKempaWko6OioaCfnpybmpiWlZORkI6Mi4mHhoWEg4OEgoSDJoSEhYWGhoeIiYqLjI2Oj5CRkpOUlZaXmJmbnJ2foKGjpKWmp6iohakTqqqrq6ytrq+wsbO0tbW2t7e4uIW5irqMuYa4Kre3uLi4ubm6u72+v8DBwsPDxMTExcXFxsfJy83Q09fa3uPn7PH1+fz/gISBF4D//fr39PDt6ufk4uDe3dzb2djX1tbVhtSG1RrU09HQzszLycfGxMPCwL++vby7urm4t7e2tS60s7KxsK+vrq2sq6qpqKinpqWlpKOjoqGgn56cm5qYlpWTkZCOjIuJh4aFhIODhIKEgyaEhIWFhoaHiImKi4yNjo+QkZKTlJWWl5iZm5ydn6Cho6SlpqeoqIWpE6qqq6usra6vsLGztLW1tre3uLiFuYq6jLmGuCq3t7i4uLm5uru9vr/AwcLDw8TExMXFxcbHycvN0NPX2t7j5+zx9fn8/4CEgReA//369/Tw7ern5OLg3t3c29nY19bW1YbUhtUa1NPR0M7My8nHxsTDwsC/vr28u7q5uLe3trX/fr9+hn+8fgICAQAturm4t7a2tbSzsrGwsK+ura2srKuqqqmoqKelpKOhoJ6dm5mXlpSSkZCOjYyMiosmjIyMjY6Oj5CRkpOUlZaWl5iZmpucnZ6foKKjpaanqaqrrK2ur6+EsBKxsbKys7S1tre4ubq6u7y8vb2Fvo2/i76FvRC8vL29vb6/wMHCw8TGx8fIhMkWysrKy8zNztDT1tnc4OTp7fH1+fz/gISBFoD//fv39PHu6+jm5OPh4N/e3dzb2tqF2SLa2tvb3Nzc29rZ2NbU0tDOzMvJyMfFxMPDwsHAv769vLu6Lbq5uLe2trW0s7KxsLCvrq2trKyrqqqpqKinpaSjoaCenZuZl5aUkpGQjo2MjIqLJoyMjI2Ojo+QkZKTlJWWlpeYmZqbnJ2en6Cio6Wmp6mqq6ytrq+vhLASsbGysrO0tba3uLm6uru8vL29hb6Nv4u+hb0QvLy9vb2+v8DBwsPExsfHyITJFsrKysvMzc7Q09bZ3ODk6e3x9fn8/4CEgRaA//379/Tx7uvo5uTj4eDf3t3c29rahdki2trb29zc3Nva2djW1NLQzszLycjHxcTDw8LBwL++vby7ui26ubi3tra1tLOysbCwr66traysq6qqqaiop6Wko6Ggnp2bmZeWlJKRkI6NjIyKiyaMjIyNjo6PkJGSk5SVlpaXmJmam5ydnp+goqOlpqepqqusra6vr4SwErGxsrKztLW2t7i5urq7vLy9vYW+jb+LvoW9ELy8vb29vr/AwcLDxMbHx8iEyRbKysrLzM3O0NPW2dzg5Ont8fX5/P+AhIEWgP/9+/f08e7r6Obk4+Hg397d3Nva2oXZItra29vc3Nzb2tnY1tTS0M7My8nIx8XEw8PCwcC/vr28u7r/fr9+hn+8fgICAQAuv76+vby7u7q5uLe3trW1tLOzsrKxsbCwr66trKqpp6ako6GfnpybmZiXlpWUlImThJQ4lZaWl5iZmZqbnJ2dnp+goaKjpKWmqKmqrK2vsLGys7S1tra3t7e4uLi5urq7vL2+vr/AwcHCwsKbw4XChcENwsLDxMXGx8jJy8zMzYTOFs/Pz9DQ0dLU1tnb3uLl6e3x9fj7/v+FgDz+/Pr39PHv7Oro5+Xk4+Lh4N/f3t7d3d3e3t/g4OHi4uLh4d/e3NrY1dPR0M7Ny8rJyMfHxsXEw8LBwcAuv76+vby7u7q5uLe3trW1tLOzsrKxsbCwr66trKqpp6ako6GfnpybmZiXlpWUlImThJQ4lZaWl5iZmZqbnJ2dnp+goaKjpKWmqKmqrK2vsLGys7S1tra3t7e4uLi5urq7vL2+vr/AwcHCwsKbw4XChcENwsLDxMXGx8jJy8zMzYTOFs/Pz9DQ0dLU1tnb3uLl6e3x9fj7/v+FgDz+/Pr39PHv7Oro5+Xk4+Lh4N/f3t7d3d3e3t/g4OHi4uLh4d/e3NrY1dPR0M7Ny8rJyMfHxsXEw8LBwcAuv76+vby7u7q5uLe3trW1tLOzsrKxsbCwr66trKqpp6ako6GfnpybmZiXlpWUlImThJQ4lZaWl5iZmZqbnJ2dnp+goaKjpKWmqKmqrK2vsLGys7S1tra3t7e4uLi5urq7vL2+vr/AwcHCwsKbw4XChcENwsLDxMXGx8jJy8zMzYTOFs/Pz9DQ0dLU1tnb3uLl6e3x9fj7/v+FgDz+/Pr39PHv7Oro5+Xk4+Lh4N/f3t7d3d3e3t/g4OHi4uLh4d/e3NrY1dPR0M7Ny8rJyMfHxsXEw8LBwcD/fsB+hX+8fgICAQAuxMTDwsLBwMC/vr29vLu7urq5ubm4uLe3trW0s7Kxr62sqqmnpqSjoaCfnp6dnY2cNp2dnp6foKChoqKjpKSlpqeoqKqrrK2vsLKztLa3uLm6u7y8vb29vr6/v8DAwcLCw8TExcXGxojHjciKx4nGDcfIycrLzM3Oz9DR0tKF0yzU1NXV1tja3N7h4+bq7fD09/n8/f7////+/Pr49vTx8O7s6unn5uXk5OPi4oXhBuLj4+Tl5oTnGubk4+Hf3NrY1tTS0dDPzs3My8rKycjHx8bFLsTEw8LCwcDAv769vby7u7q6ubm5uLi3t7a1tLOysa+trKqpp6ako6Ggn56enZ2NnDadnZ6en6CgoaKio6SkpaanqKiqq6ytr7Cys7S2t7i5uru8vL29vb6+v7/AwMHCwsPExMXFxsaIx43IiseJxg3HyMnKy8zNzs/Q0dLShdMs1NTV1dbY2tze4ePm6u3w9Pf5/P3+/////vz6+Pb08fDu7Orp5+bl5OTj4uKF4Qbi4+Pk5eaE5xrm5OPh39za2NbU0tHQz87NzMvKysnIx8fGxS7ExMPCwsHAwL++vb28u7u6urm5ubi4t7e2tbSzsrGvrayqqaempKOhoJ+enp2djZw2nZ2enp+goKGioqOkpKWmp6ioqqusra+wsrO0tre4ubq7vLy9vb2+vr+/wMDBwsLDxMTFxcbGiMeNyIrHicYNx8jJysvMzc7P0NHS0oXTLNTU1dXW2Nrc3uHj5urt8PT3+fz9/v////78+vj29PHw7uzq6efm5eTk4+LiheEG4uPj5OXmhOca5uTj4d/c2tjW1NLR0M/OzczLysrJyMfHxsX/fv9+gn4CAgEAEsnJyMjHxsbFxMTDwsLBwcDAwIS/Fr6+vby7urm4trWzsrCvrayrqainp6aEpYykNaWlpqamp6ioqamqqqusra2ur7Cxs7S2t7i6u7y+v8DBwcLDw8PExMXFxcbGx8jIycnJysrKoMuHyg3Ly8zNzs/Q0tPU1dXWhdc42NjY2dna293f4ePl6Ort8PL19/n6+/z8/Pv6+Pb18/Lw7u3s6unp6Ofm5uXl5eTk5eXm5ufo6eqE6xrq6efl4+De3NrY1tXU09LR0NDPzs3NzMvLyhLJycjIx8bGxcTEw8LCwcHAwMCEvxa+vr28u7q5uLa1s7Kwr62sq6mop6emhKWMpDWlpaampqeoqKmpqqqrrK2trq+wsbO0tre4uru8vr/AwcHCw8PDxMTFxcXGxsfIyMnJycrKyqDLh8oNy8vMzc7P0NLT1NXV1oXXONjY2NnZ2tvd3+Hj5ejq7fDy9ff5+vv8/Pz7+vj29fPy8O7t7Orp6ejn5ubl5eXk5OXl5ubn6OnqhOsa6unn5ePg3tza2NbV1NPS0dDQz87NzczLy8oSycnIyMfGxsXExMPCwsHBwMDAhL8Wvr69vLu6ubi2tbOysK+trKupqKenpoSljKQ1paWmpqanqKipqaqqq6ytra6vsLGztLa3uLq7vL6/wMHBwsPDw8TExcXFxsbHyMjJycnKysqgy4fKDcvLzM3Oz9DS09TV1daF1zjY2NjZ2drb3d/h4+Xo6u3w8vX3+fr7/Pz8+/r49vXz8vDu7ezq6eno5+bm5eXl5OTl5ebm5+jp6oTrGurp5+Xj4N7c2tjW1dTT0tHQ0M/Ozc3My8vK/37/foJ+AgIBABHOzc3MzMvLysnJyMjHx8bGxoXFF8TExMPCwcC+vby6ube2tbOysbCvr66uhK2NrDCtra2urq+vsLCxsbKys7S1tre4ubu8vb/AwcPExcbGx8jIyMnJysrKy8vMzMzNzc2JzpnPh84Pz8/Q0dHS09XW19jZ2drahNuE3FLd3t/g4ePl5+nr7e/x8/X29/j4+fj49/b19PPy8O/u7ezr6urp6ejo6Ofn5+jo6err7O3u7u/v7u3s6ujm5OLg3tza2djX1tXU1NPS0tHQ0M/PEc7NzczMy8vKycnIyMfHxsbGhcUXxMTEw8LBwL69vLq5t7a1s7KxsK+vrq6ErY2sMK2tra6ur6+wsLGxsrKztLW2t7i5u7y9v8DBw8TFxsbHyMjIycnKysrLy8zMzM3NzYnOmc+Hzg/Pz9DR0dLT1dbX2NnZ2tqE24TcUt3e3+Dh4+Xn6evt7/Hz9fb3+Pj5+Pj39vX08/Lw7+7t7Ovq6unp6Ojo5+fn6Ojp6uvs7e7u7+/u7ezq6Obk4uDe3NrZ2NfW1dTU09LS0dDQz88Rzs3NzMzLy8rJycjIx8fGxsaFxRfExMTDwsHAvr28urm3trWzsrGwr6+uroStjawwra2trq6vr7CwsbGysrO0tba3uLm7vL2/wMHDxMXGxsfIyMjJycrKysvLzMzMzc3Nic6Zz4fOD8/P0NHR0tPV1tfY2dna2oTbhNxS3d7f4OHj5efp6+3v8fP19vf4+Pn4+Pf29fTz8vDv7u3s6+rq6eno6Ojn5+fo6Onq6+zt7u7v7+7t7Oro5uTi4N7c2tnY19bV1NTT0tLR0NDPz/9+/36CfgICAQAP0tLR0dDQz8/Ozs3NzMzMh8sXysrKycjHxsXEwsG/vr28u7q5uLe3traEtYe0hbOFtCa1tbW2tra3t7i5ubq7vL2+wMHCw8XGx8jJysvLzMzNzc7Ozs/Pz4XQjdGd0hHT09TV1dbX2Nna29zd3d7e3oXfEuDg4eLj5OXm6Orr7e/w8vP09YX2EPX19PPy8fDv7+7t7Ozs6+uH6iXr6+zt7u/w8fHx8O/u7evp5+Ti4d/e3Nva2dnY19fW1tXU1NPTD9LS0dHQ0M/Pzs7NzczMzIfLF8rKysnIx8bFxMLBv769vLu6ubi3t7a2hLWHtIWzhbQmtbW1tra2t7e4ubm6u7y9vsDBwsPFxsfIycrLy8zMzc3Ozs7Pz8+F0I3RndIR09PU1dXW19jZ2tvc3d3e3t6F3xLg4OHi4+Tl5ujq6+3v8PLz9PWF9hD19fTz8vHw7+/u7ezs7Ovrh+ol6+vs7e7v8PHx8fDv7u3r6efk4uHf3tzb2tnZ2NfX1tbV1NTT0w/S0tHR0NDPz87Ozc3MzMyHyxfKysrJyMfGxcTCwb++vby7urm4t7e2toS1h7SFs4W0JrW1tba2tre3uLm5uru8vb7AwcLDxcbHyMnKy8vMzM3Nzs7Oz8/PhdCN0Z3SEdPT1NXV1tfY2drb3N3d3t7ehd8S4ODh4uPk5ebo6uvt7/Dy8/T1hfYQ9fX08/Lx8O/v7u3s7Ozr64fqJevr7O3u7/Dx8fHw7+7t6+nn5OLh397c29rZ2djX19bW1dTU09P/fv9+gn4CAgEAD9bW1dXU1NTT09LS0tHR0YjQFM/Pzs7NzMvKyMfGxMPCwcHAv76+hL2GvJC7Iby8vL29vr6/v8DBwsPExcfIycrLzM3Oz8/Q0NHR0dLS0ovTkdST1RPW1tbX19jZ2tvc3d7e3+Dg4eHhhOIT4+Pj5OTl5ufo6ers7e7w8fLz84b0DvPz8vHx8O/v7u7u7e3tiOwl7e3u7/Dx8fLy8vHx7+7s6+nn5ePi4N/e3d3c29va2tnZ2NjX1w/W1tXV1NTU09PS0tLR0dGI0BTPz87OzczLysjHxsTDwsHBwL++voS9hryQuyG8vLy9vb6+v7/AwcLDxMXHyMnKy8zNzs/P0NDR0dHS0tKL05HUk9UT1tbW19fY2drb3N3e3t/g4OHh4YTiE+Pj4+Tk5ebn6Onq7O3u8PHy8/OG9A7z8/Lx8fDv7+7u7u3t7YjsJe3t7u/w8fHy8vLx8e/u7Ovp5+Xj4uDf3t3d3Nvb2trZ2djY19cP1tbV1dTU1NPT0tLS0dHRiNAUz8/Ozs3My8rIx8bEw8LBwcC/vr6EvYa8kLshvLy8vb2+vr+/wMHCw8TFx8jJysvMzc7Pz9DQ0dHR0tLSi9OR1JPVE9bW1tfX2Nna29zd3t7f4ODh4eGE4hPj4+Pk5OXm5+jp6uzt7vDx8vPzhvQO8/Py8fHw7+/u7u7t7e2I7CXt7e7v8PHx8vLy8fHv7uzr6efl4+Lg397d3dzb29ra2dnY2NfX/37/foJ+AgIBAAza2dnZ2NjY19fW1taJ1YTUFdPT0tHQz87Ny8rJyMjHxsbFxcTExIXDhsKNwYTCGMPDxMTFxsfIycrLzM3Oz8/Q0dLS09PU1IjVkdaO14vYE9nZ2dra29zc3d7f4ODh4uLj4+OE5BTl5eXm5ufn6Ojp6uvs7e7v8PDx8YfyBfHx8fDwhO+G7oTtCO7u7u/v8PHxhfIa8fDv7ezq6Ofl5OPi4eDf397e3d3c3Nvb29oM2tnZ2djY2NfX1tbWidWE1BXT09LR0M/OzcvKycjIx8bGxcXExMSFw4bCjcGEwhjDw8TExcbHyMnKy8zNzs/P0NHS0tPT1NSI1ZHWjteL2BPZ2dna2tvc3N3e3+Dg4eLi4+PjhOQU5eXl5ubn5+jo6err7O3u7/Dw8fGH8gXx8fHw8ITvhu6E7Qju7u7v7/Dx8YXyGvHw7+3s6ujn5eTj4uHg39/e3t3d3Nzb29vaDNrZ2dnY2NjX19bW1onVhNQV09PS0dDPzs3LysnIyMfGxsXFxMTEhcOGwo3BhMIYw8PExMXGx8jJysvMzc7Pz9DR0tLT09TUiNWR1o7Xi9gT2dnZ2trb3Nzd3t/g4OHi4uPj44TkFOXl5ebm5+fo6Onq6+zt7u/w8PHxh/IF8fHx8PCE74buhO0I7u7u7+/w8fGF8hrx8O/t7Oro5+Xk4+Lh4N/f3t7d3dzc29vb2v9+/36CfgICAQAI3d3c3Nzb29uE2orZGNjY2NfX1tXU1NLR0NDPzs3MzMvLy8rKyoXJhsiQxxjIyMjJycrKy8zNzc7P0NHS0tPU1NXW1taE15TYjdmJ2obbEdzc3d3e3t/g4eHi4+Pk5OXlhOaE5w/o6Onp6erq6+zs7e7u7++E8ITxhvCI74fuB+/v7/Dw8fGF8hrx8O/u7Ovp6Ofm5eTj4+Lh4eHg4N/f3t7e3Qjd3dzc3Nvb24TaitkY2NjY19fW1dTU0tHQ0M/OzczMy8vLysrKhcmGyJDHGMjIyMnJysrLzM3Nzs/Q0dLS09TU1dbW1oTXlNiN2YnahtsR3Nzd3d7e3+Dh4eLj4+Tk5eWE5oTnD+jo6enp6urr7Ozt7u7v74TwhPGG8Ijvh+4H7+/v8PDx8YXyGvHw7+7s6+no5+bl5OPj4uHh4eDg39/e3t7dCN3d3Nzc29vbhNqK2RjY2NjX19bV1NTS0dDQz87NzMzLy8vKysqFyYbIkMcYyMjIycnKysvMzc3Oz9DR0tLT1NTV1tbWhNeU2I3ZidqG2xHc3N3d3t7f4OHh4uPj5OTl5YTmhOcP6Ojp6enq6uvs7O3u7u/vhPCE8YbwiO+H7gfv7+/w8PHxhfIa8fDv7uzr6ejn5uXk4+Pi4eHh4ODf397e3t3/fv9+gn4CAgEABeDg39/fhN6E3YvcFNvb29rZ2NjX1tXU09PS0tHR0NDQhM+GzobNjsyEzRPOzs/Q0NHS0tPU1NXW1tfX2NjYhdmF2oTZitqN24fcht0U3t7e39/g4OHi4uPk5OXl5ubn5+eE6ITpDurq6uvr6+zs7O3t7u7uoO8j8PDx8fHy8vLx8fDv7u3r6uno5+bm5eXk5OPj4uLi4eHh4OAF4ODf39+E3oTdi9wU29vb2tnY2NfW1dTT09LS0dHQ0NCEz4bOhs2OzITNE87Oz9DQ0dLS09TU1dbW19fY2NiF2YXahNmK2o3bh9yG3RTe3t7f3+Dg4eLi4+Tk5eXm5ufn54TohOkO6urq6+vr7Ozs7e3u7u6g7yPw8PHx8fLy8vHx8O/u7evq6ejn5ubl5eTk4+Pi4uLh4eHg4AXg4N/f34TehN2L3BTb29va2djY19bV1NPT0tLR0dDQ0ITPhs6GzY7MhM0Tzs7P0NDR0tLT1NTV1tbX19jY2IXZhdqE2YrajduH3IbdFN7e3t/f4ODh4uLj5OTl5ebm5+fnhOiE6Q7q6urr6+vs7Ozt7e7u7qDvI/Dw8fHx8vLy8fHw7+7t6+rp6Ofm5uXl5OTj4+Li4uHh4eDg/37/foJ+AgIBAIPiheGF4IvfEt7e3t3c3Nva2tnY19fW1tXV1YTUh9OH0pHRFNLS0tPT1NTV1dbW19fY2NnZ2trakduJ3Izdht6F3xTg4ODh4eHi4+Pk5OXl5ubn5+jo6ITpheqF64TshO2K7pjvgvCG8RLw7+/u7ezr6uno6Ofn5ubm5eWE5ATj4+Pig+KF4YXgi98S3t7e3dzc29ra2djX19bW1dXVhNSH04fSkdEU0tLS09PU1NXV1tbX19jY2dna2tqR24ncjN2G3oXfFODg4OHh4eLj4+Tk5eXm5ufn6OjohOmF6oXrhOyE7YrumO+C8IbxEvDv7+7t7Ovq6ejo5+fm5ubl5YTkBOPj4+KD4oXhheCL3xLe3t7d3Nzb2trZ2NfX1tbV1dWE1IfTh9KR0RTS0tLT09TU1dXW1tfX2NjZ2dra2pHbidyM3Ybehd8U4ODg4eHh4uPj5OTl5ebm5+fo6OiE6YXqheuE7ITtiu6Y74LwhvES8O/v7u3s6+rp6Ojn5+bm5uXlhOQE4+Pj4v9+/36CfgICAQCE5IbjheKK4RHg4ODf397d3dzb29ra2tnZ2YXYhteJ1pHVENbW1tfX2NjY2dna2trb29uF3JDdjN6I34XgheEU4uLi4+Pj5OTl5ebm5+fo6Ojp6emF6obrh+yL7Yfule+H8A7v7+7t7Ozr6urp6ejo6ITnhOaE5YTkhuOF4orhEeDg4N/f3t3d3Nvb2tra2dnZhdiG14nWkdUQ1tbW19fY2NjZ2dra2tvb24XckN2M3ojfheCF4RTi4uLj4+Pk5OXl5ubn5+jo6Onp6YXqhuuH7Ivth+6V74fwDu/v7u3s7Ovq6unp6OjohOeE5oTlhOSG44XiiuER4ODg39/e3d3c29va2trZ2dmF2IbXidaR1RDW1tbX19jY2NnZ2tra29vbhdyQ3YzeiN+F4IXhFOLi4uPj4+Tk5eXm5ufn6Ojo6enpheqG64fsi+2H7pXvh/AO7+/u7ezs6+rq6eno6OiE54TmhOX/fv9+gn4CAgEAhOaG5YbkieMO4uLi4eHg4N/f3t7d3d2F3IXbidqK2YnYhdmE2oPbhNyE3ZDeh9+N4IbhhOKE4wzk5OTl5ebm5ufn6OiE6YXqiOuK7I3thu6K74fuh+8I7u7u7e3s6+uE6oTpheiF5wHmhOaG5YbkieMO4uLi4eHg4N/f3t7d3d2F3IXbidqK2YnYhdmE2oPbhNyE3ZDeh9+N4IbhhOKE4wzk5OTl5ebm5ufn6OiE6YXqiOuK7I3thu6K74fuh+8I7u7u7e3s6+uE6oTpheiF5wHmhOaG5YbkieMO4uLi4eHg4N/f3t7d3d2F3IXbidqK2YnYhdmE2oPbhNyE3ZDeh9+N4IbhhOKE4wzk5OTl5ebm5ufn6OiE6YXqiOuK7I3thu6K74fuh+8I7u7u7e3s6+uE6oTpheiF5wHm/37/foJ+AgIBAILoh+eF5orlhOQK4+Pi4uHh4eDg4ITfht6K3YzciNuH3IXdhd6N34jgjeGI4oTjheQO5eXl5ubm5+fo6Ojp6emF6ovrk+yG7ZzuCe3t7ezs7Ovr64fqhumF6ILoh+eF5orlhOQK4+Pi4uHh4eDg4ITfht6K3YzciNuH3IXdhd6N34jgjeGI4oTjheQO5eXl5ubm5+fo6Ojp6emF6ovrk+yG7ZzuCe3t7ezs7Ovr64fqhumF6ILoh+eF5orlhOQK4+Pi4uHh4eDg4ITfht6K3YzciNuH3IXdhd6N34jgjeGI4oTjheQO5eXl5ubm5+fo6Ojp6emF6ovrk+yG7ZzuCe3t7ezs7Ovr64fqhumF6P9+/36CfgICAQCD6YjohueI5oTlCeTk5OPj4+Li4obhhuCQ35Peht+L4IzhiOKO44XkhOUJ5ubm5+fn6OjohOmF6o7rleyG7Y3uje2E7IbriuqG6YPpiOiG54jmhOUJ5OTk4+Pj4uLihuGG4JDfk96G34vgjOGI4o7jheSE5Qnm5ubn5+fo6OiE6YXqjuuV7Ibtje6N7YTshuuK6obpg+mI6IbniOaE5Qnk5OTj4+Pi4uKG4YbgkN+T3obfi+CM4YjijuOF5ITlCebm5ufn5+jo6ITpheqO65Xshu2N7o3thOyG64rqhun/fv9+gn4CAgEAiumG6InnhOaE5YTkhuOH4pLhkuCP4YviieOP5IXlhOaE54PohOmE6pXrk+yX7YnsjuuK6orphuiJ54TmhOWE5Ibjh+KS4ZLgj+GL4onjj+SF5YTmhOeD6ITphOqV65Psl+2J7I7riuqK6YboieeE5oTlhOSG44fikuGS4I/hi+KJ44/kheWE5oTng+iE6YTqleuT7JftieyO64rq/37/foJ+AgIBAIjqhumI6IbnheaF5YjklOOk4ovjkeSI5YTmhOeE6ITphOqb65Hsj+2M7JXrhuqI6obpiOiG54XmheWI5JTjpOKL45HkiOWE5oTnhOiE6YTqm+uR7I/tjOyV64bqiOqG6YjohueF5oXliOSU46Tii+OR5IjlhOaE54TohOmE6pvrkeyP7YzsleuG6v9+/36CfgICAQCK6ofpiOiG54XmiOWY5KTjjOSS5YbmhOeE6ITpheqe64Psh+uc7Jzrg+qK6ofpiOiG54XmiOWY5KTjjOSS5YbmhOeE6ITpheqe64Psh+uc7Jzrg+qK6ofpiOiG54XmiOWY5KTjjOSS5YbmhOeE6ITpheqe64Psh+uc7Jzrg+r/fv9+gn4=");
// EXTERNAL MODULE: ./src/presets/_utils.ts
var _utils = __webpack_require__(26);

// CONCATENATED MODULE: ./src/presets/default.ts


/** @public */

const Default = {
  environment: {
    ibl: {
      src: studio_small_01_1k_blurred_bw256,
      name: 'studio_small_01_1k_blurred_bw256',
      luminance: 15000
    }
  },
  camera: {
    aperture: 7.9,
    shutterSpeed: 0.008,
    ISO: 100,
    expComp: 0
  },
  theme: {
    background: ''
  }
};
Object(_utils["a" /* wrapPreset */])(Default, 'default');
/* harmony default export */ var presets_default = __webpack_exports__["default"] = (Default);

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ measure_Measure; });

// EXTERNAL MODULE: ./node_modules/objectmodel/dist/object-model.js
var object_model = __webpack_require__(9);

// EXTERNAL MODULE: ./src/api/validation/utils.ts
var utils = __webpack_require__(10);

// EXTERNAL MODULE: ./src/api/validation/validator.ts
var validator = __webpack_require__(91);

// CONCATENATED MODULE: ./src/api/validation/measure.ts
/* eslint-disable new-cap, import/order */



const setMode = [Object(object_model["b" /* BasicModel */])(['view', 'edit', 'distance', 'angle'])];
const getSamples = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(String), null])];
const setSamples = [Object(object_model["a" /* ArrayModel */])(Object(utils["a" /* SealedModel */])({
  id: String,
  type: Object(object_model["b" /* BasicModel */])(['distance', 'angle']),
  points: Object(object_model["a" /* ArrayModel */])(utils["c" /* Vector3Model */]),
  value: Object(object_model["b" /* BasicModel */])([Number, undefined]),
  unit: Object(object_model["b" /* BasicModel */])([String, undefined]),
  visible: Object(object_model["b" /* BasicModel */])([Boolean, undefined]),
  dynamic: Object(object_model["b" /* BasicModel */])([Boolean, undefined]),
  color: Object(object_model["b" /* BasicModel */])([String, undefined])
}))];
const selectSamples = [Object(object_model["b" /* BasicModel */])([Object(object_model["a" /* ArrayModel */])(String), null])];
const setOptions = [Object(utils["a" /* SealedModel */])({
  selectionMode: [Object(object_model["b" /* BasicModel */])(['none', 'single', 'multi'])],
  defaultColor: [String],
  fontFamily: [String]
})];
const searchSamples = [Object(utils["a" /* SealedModel */])({
  type: Object(object_model["b" /* BasicModel */])(['distance', 'angle', undefined]),
  selected: Object(object_model["b" /* BasicModel */])([Boolean, undefined])
})];
const APIValidator = new validator["a" /* Validator */]({
  setMode,
  getSamples,
  setSamples,
  selectSamples,
  searchSamples,
  setOptions
});
// EXTERNAL MODULE: ./src/api/utils.ts
var api_utils = __webpack_require__(15);

// CONCATENATED MODULE: ./src/api/measure.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/** @public Measure API. */
class measure_Measure {
  /** @internal */

  /** @internal */
  get _store() {
    return this._app.store;
  }
  /** @internal */


  constructor(app)
  /* Need any (not App) to avoid import App types to d.ts */
  {
    _defineProperty(this, "_app", void 0);

    this._app = app;
  } // eslint-disable-line

  /**
   * Get measure mode state
   *
   * @example
   * ```js
   * const modeState = widget3d.measure.getMode();
   * ```
   */


  getMode() {
    return this._store.measure.mode;
  }
  /**
   * Set measure mode state
   *
   * @example
   * ```js
   * widget3d.measure.setMode('angle');
   * ```
   */


  setMode(mode) {
    APIValidator.run('setMode', mode);

    this._store.measure.setMode(mode);
  }
  /**
   * Get particular samples by array of ids.
   *
   * @remarks
   * `null` is returned if sample wasn't found
   *
   * @example
   * ```js
   * // Get sample with id 'distance_0'
   * const samples = widget3d.measure.getSamples(['distance_0']);
   * ```
   */


  getSamples(ids) {
    const store = this._store;

    if (!store.load.isLoaded) {
      Object(api_utils["c" /* throwDueToModelLoad */])();
    }

    APIValidator.run('getSamples', ids);
    const samples = !ids ? [...store.measure.samples.values()] : ids.map(id => store.measure.samples.get(id) || null);
    return samples.map(sample => {
      if (!sample) {
        return null;
      }

      return {
        id: sample.id,
        type: sample.type,
        visible: sample.visible,
        dynamic: sample.dynamic,
        value: sample.value,
        color: sample.color,
        unit: sample.unit,
        points: sample.points.map(point => store.axes.getExternalPosition(point))
      };
    });
  }
  /**
   * Deletes all old samples and set new sample list.
   *
   * @example
   * ```js
   * widget3d.measure.setSamples([{
   *     id: 'd0',
   *     type: 'distance',
   *     points: [{ x: 0, y: 0, z: 0 }, { x: 10, y: 5, z: 0 }]
   * }, {
   *     id: 'a0',
   *     type: 'angle',
   *     points: [{ x: 0, y: 0, z: 0 }, { x: 10, y: 5, z: 0 }, { x: 10, y: 15, z: 5 }]
   * }]);
   * ```
   */


  setSamples(samples) {
    const store = this._store;

    if (!store.load.isLoaded) {
      Object(api_utils["c" /* throwDueToModelLoad */])();
    }

    APIValidator.run('setSamples', samples);
    const samplesWithInternalCoordinates = samples.map(sample => ({ ...sample,
      points: sample.points.map(point => store.axes.getInternalPosition(point))
    }));
    store.measure.setSamples(samplesWithInternalCoordinates);
  }
  /**
   * Search samples by parameters.
   *
   * @example
   * ```js
   * // Find all selected samples with type 'angle'
   * widget3d.measure.searchSamples({ type: 'angle', selected: true });
   * ```
   */


  searchSamples(searchParams) {
    const store = this._store;

    if (!store.load.isLoaded) {
      Object(api_utils["c" /* throwDueToModelLoad */])();
    }

    APIValidator.run('searchSamples', searchParams);
    const searchKeys = Object.keys(searchParams);
    const foundIds = [];

    for (const sample of store.measure.samples.values()) {
      if (searchKeys.every(searchKey => searchParams[searchKey] === sample[searchKey])) {
        foundIds.push(sample.id);
      }
    }

    return foundIds;
  }
  /**
   * Set measure options
   *
   * @example
   * ```js
   * // Set default color
   * widget3d.measure.setOptions({ defaultColor: 'FF00FF' });
   * ```
   */


  setOptions(options) {
    const store = this._store;

    if (!store.load.isLoaded) {
      Object(api_utils["c" /* throwDueToModelLoad */])();
    }

    APIValidator.run('setOptions', options);
    store.measure.setOptions(options);
  }
  /**
   * Select samples by ids
   *
   * @example
   * ```js
   * // Selection
   * widget3d.measure.selectSamples(['sample_1', 'sample_2']);
   *
   * // Deselection:
   * await widget3d.measure.selectSamples([]);
   * await widget3d.measure.selectSamples(null);
   * ```
   */


  selectSamples(sampleIds) {
    const store = this._store;

    if (!store.load.isLoaded) {
      Object(api_utils["c" /* throwDueToModelLoad */])();
    }

    APIValidator.run('selectSamples', sampleIds);
    store.measure.selectSamples(sampleIds === null ? [] : sampleIds);
  }

}

/* harmony default export */ var measure = __webpack_exports__["b"] = (measure_Measure);


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RGBELoader; });
/* harmony import */ var _wge_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




class BufferStream {
  constructor(buffer) {
    this._buffer = buffer;
    this._position = 0;
  }

  read(count) {
    const position = this._position;
    this._position += count;
    return this._buffer.subarray(position, position + count);
  }

  get position() {
    return this._position;
  }

}

class RGBELoader {
  constructor({
    src,
    loader,
    name,
    luminance
  }) {
    this.maxEnvLuminance = 0;

    this.promise = (async () => {
      let buffer = src;

      if (typeof src === 'string') {
        buffer = await loader.load(src, {
          type: Uint8Array
        });
      } else if (!ArrayBuffer.isView(src) || src instanceof DataView) {
        throw new Error(`RGBELoader: unexpected image source: ${src}`);
      }

      return Object.assign(this._parse(luminance, buffer), {
        name
      });
    })();
  }

  get assets() {
    return (async () => this.promise)();
  }

  _parse(luminance, buffer) {
    const _this$_readHeader = this._readHeader(buffer),
          width = _this$_readHeader.width,
          height = _this$_readHeader.height,
          end = _this$_readHeader.end;

    const bufferF32 = new Float32Array(width * height * 4);
    const bufferUI16 = new Uint16Array(width * height * 4);

    if (!(bufferF32 instanceof Float32Array) || bufferF32.length !== width * height * 4) {
      throw new Error('RGBELoader: unable to allocate pixel buffer space');
    }

    if (!(bufferUI16 instanceof Uint16Array) || bufferUI16.length !== width * height * 4) {
      throw new Error('RGBELoader: unable to allocate pixel buffer space');
    }

    const subBuffer = buffer.subarray(end);

    if (!(subBuffer instanceof Uint8Array) || subBuffer.length === 0) {
      throw new Error('RGBELoader: unable to allocate data buffer space');
    }

    this._readPixelsRLE(subBuffer, bufferF32, width, height);

    this._luminanceScale = luminance / this.maxEnvLuminance;

    this._scaleLuminance(width * height, bufferF32, bufferUI16);

    const customImageData = new _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* CustomImageData */ "m"](_wge_core__WEBPACK_IMPORTED_MODULE_0__[/* CustomImageData */ "m"].Type.RGBE, width, height, 1, _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* PixelDataFormat */ "N"].RGBA, _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* InternalFormat */ "v"].RGBA16F, _wge_core__WEBPACK_IMPORTED_MODULE_0__[/* DataType */ "n"].HALF_FLOAT, bufferUI16);
    customImageData._extraBuffer = bufferF32;
    return {
      customImageData,
      maxEnvLuminance: this.maxEnvLuminance
    };
  }

  _readHeader(buffer) {
    const VALID_MAGIC_TOKEN = 0x01;
    const VALID_FORMAT = 0x02;
    const VALID_DIMENSIONS = 0x04;
    const RGBE_VALID = VALID_MAGIC_TOKEN | VALID_FORMAT | VALID_DIMENSIONS;
    const commentRe = /^#(.+)/mg;
    const gammaRe = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/m;
    const exposureRe = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/m;
    const formatRe = /^\s*FORMAT=(\S+)\s*$/m;
    const dimensionsRe = /^\s*-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/m;
    const header = {
      valid: 0,
      string: String.fromCharCode(...buffer.subarray(0, 256)),
      comments: '',
      programType: 'RGBE',
      format: '',
      gamma: 1,
      exposure: 1,
      width: 0,
      height: 0
    };
    header.end = header.string.lastIndexOf('\n') + 1;
    const comments = header.string.match(commentRe);

    if (comments instanceof Array && comments.includes('#?RADIANCE')) {
      header.valid |= VALID_MAGIC_TOKEN;
    }

    const gamma = header.string.match(gammaRe);
    if (gamma) header.gamma = parseFloat(gamma[1], 10);
    const exposure = header.string.match(exposureRe);
    if (exposure) header.exposure = parseFloat(exposure[1], 10);
    const format = header.string.match(formatRe);

    if (format) {
      const _format$slice = format.slice(1),
            _format$slice2 = _slicedToArray(_format$slice, 1),
            value = _format$slice2[0];

      header.format = value;
      header.valid |= VALID_FORMAT;
    }

    const dimensions = header.string.match(dimensionsRe);

    if (dimensions) {
      const _dimensions$slice$map = dimensions.slice(1).map(value => parseInt(value, 10)),
            _dimensions$slice$map2 = _slicedToArray(_dimensions$slice$map, 2),
            height = _dimensions$slice$map2[0],
            width = _dimensions$slice$map2[1];

      header.width = width;
      header.height = height;
      header.valid |= VALID_DIMENSIONS;
    }

    if (header.valid !== RGBE_VALID) {
      throw new Error(`RGBELoader read error ${header.valid}`);
    }

    return header;
  }

  _readPixelsRLE(buffer, data, width, height) {
    const scanlineWidth = width;
    const stream = new BufferStream(buffer);
    const readFlat = scanlineWidth < 8 || scanlineWidth > 0x7fff;
    const fileRLE = buffer[0] !== 2 || buffer[1] !== 2 || buffer[2] & 0x80;

    if (readFlat || fileRLE) {
      this._readPixels(stream, data, width * height);

      return; // throw new Error('RGBELoader: only RLE layout supported');
    }

    const scanlineBuffer = new Uint8Array(scanlineWidth * 4);

    if (!(scanlineBuffer instanceof Uint8Array) || scanlineBuffer.length !== scanlineWidth * 4) {
      throw new Error('RGBELoader: unable to allocate scanline buffer space');
    }

    const rgbeBuffer = [0, 0, 0, 0];
    const rgbaBuffer = new Float32Array([0, 0, 0, 1]);
    let scanlineNumber = height;
    let offset = width * height;

    while (scanlineNumber > 0 && stream.position < buffer.byteLength) {
      if (stream.position + 4 > buffer.byteLength) {
        throw new Error('RGBELoader: out of buffer array');
      }

      const rgbe = stream.read(4);

      if (scanlineWidth !== (rgbe[2] << 8 | rgbe[3])) {
        throw new Error(`RGBELoader: wrong scanline width: ${scanlineWidth}`);
      }

      let begin = 0;

      for (let i = 0; i < 4; ++i) {
        const end = (i + 1) * scanlineWidth;

        while (begin < end) {
          const buf = stream.read(2);
          const isEncodedRun = buf[0] > 128; // Whether run of the same value or not.

          let count = buf[0] - 128 * isEncodedRun;

          if (count === 0 || count > end - begin) {
            throw new Error('RGBELoader: bad scanline data');
          }

          if (isEncodedRun) {
            scanlineBuffer.fill(buf[1], begin, begin + count);
          } else {
            scanlineBuffer.fill(buf[1], begin, ++begin);
            if (--count > 0) scanlineBuffer.set(stream.read(count), begin);
          }

          begin += count;
        }
      }

      for (let i = scanlineWidth - 1; i >= 0; --i) {
        rgbeBuffer[0] = scanlineBuffer[i + 0 * scanlineWidth];
        rgbeBuffer[1] = scanlineBuffer[i + 1 * scanlineWidth];
        rgbeBuffer[2] = scanlineBuffer[i + 2 * scanlineWidth];
        rgbeBuffer[3] = scanlineBuffer[i + 3 * scanlineWidth];
        data.set(this._rgbe2rgb(rgbeBuffer, rgbaBuffer), --offset * 4);
      }

      --scanlineNumber;
    }
  }

  _readPixels(stream, data, pixelsNumber) {
    const rgba = new Float32Array([0, 0, 0, 1]);

    for (let i = 0; i < pixelsNumber; ++i) {
      const rgbe = stream.read(4);
      data.set(this._rgbe2rgb(rgbe, rgba), i * 4);
    }
  }

}

Object.assign(RGBELoader.prototype, {
  _rgbe2rgb: function __rgbe2rgb() {
    const RGB2XYZ = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__[/* LinearMatrix3 */ "h"]().set(0.4124564, 0.2126729, 0.0193339, 0.3575761, 0.7151522, 0.1191920, 0.1804375, 0.0721750, 0.9503041);
    const colorXYZ = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__[/* Vector3 */ "n"]();
    return function _rgbe2rgb(rgbe, rgba) {
      const scale = Math.pow(2, rgbe[3] - 128) / 256;
      colorXYZ.fromArray(rgbe).multiply(scale);
      colorXYZ.applyLinearMatrix(RGB2XYZ);
      this.maxEnvLuminance = Math.max(this.maxEnvLuminance, colorXYZ.y);
      colorXYZ.toArray(rgba);
      return rgba;
    };
  }(),
  _scaleLuminance: function __scaleLuminance() {
    const XYZ2RGB = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__[/* LinearMatrix3 */ "h"]().set(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);
    const XYZColor = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__[/* Vector3 */ "n"]();
    const xyYColor = new _wgetemp_math__WEBPACK_IMPORTED_MODULE_1__[/* Vector3 */ "n"]();

    const convertXYZ2xyY = (XYZ, xyY) => {
      const denominator = 1.0 / (XYZ.x + XYZ.y + XYZ.z);
      xyY.set(XYZ.x * denominator, XYZ.y * denominator, XYZ.y);

      if (!xyY.everyIsFinite) {
        xyY.fromNumber(0);
      }
    };

    const convertxyY2XYZ = (xyY, XYZ) => {
      XYZ.set(xyY.x * xyY.z / xyY.y, xyY.z, (1.0 - xyY.x - xyY.y) * xyY.z / xyY.y);

      if (!XYZ.everyIsFinite) {
        XYZ.fromNumber(0);
      }
    };

    const bufferViewF32 = new Float32Array(1);
    const bufferViewI32 = new Int32Array(bufferViewF32.buffer);

    const toHalfFloat = f32 => {
      bufferViewF32[0] = f32;

      const _bufferViewI = _slicedToArray(bufferViewI32, 1),
            i32 = _bufferViewI[0];

      let bits = i32 >> 16 & 0x8000; // Get the sign.

      let m = i32 >> 12 & 0x07ff; // Keep one extra bit for rounding.

      const e = i32 >> 23 & 0xff; // Using int is faster here.
      // If zero, or denormal, or exponent underflows too much for a denormal half, return signed zero.

      if (e < 103) return bits; // If NaN, return NaN. If Inf or exponent overflow, return Inf.

      if (e > 142) {
        bits |= 0x7c00; // If exponent was 0xff and one mantissa bit was set,
        // it means NaN, not Inf, so make sure we set one mantissa bit too.

        bits |= (e === 0xff ? 0 : 1) && i32 & 0x007fffff;
        return bits;
      } // If exponent underflows but not too much, return a denormal.


      if (e < 113) {
        m |= 0x0800; // Extra rounding may overflow and set mantissa to 0 and exponent to 1, which is OK.

        bits |= (m >> 114 - e) + (m >> 113 - e & 1);
        return bits;
      }

      bits |= e - 112 << 10 | m >> 1; // Extra rounding. An overflow will set mantissa to 0 and increment the exponent, which is OK.

      bits += m & 1;
      return bits;
    };

    return function _scaleLuminance(pixelsNumber, bufferF32, bufferUI16) {
      for (let i = 0; i < pixelsNumber; ++i) {
        const rgba32f = bufferF32.subarray(i * 4, i * 4 + 4);
        XYZColor.fromArray(rgba32f);
        convertXYZ2xyY(XYZColor, xyYColor);
        xyYColor.z *= this._luminanceScale;
        convertxyY2XYZ(xyYColor, XYZColor);
        XYZColor.applyLinearMatrix(XYZ2RGB);
        XYZColor.toArray(rgba32f);
        const rgba16f = bufferUI16.subarray(i * 4, i * 4 + 4);
        rgba16f.set(rgba32f.map(f32 => toHalfFloat(f32)));
      }
    };
  }()
});


/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, float, POSITION, 0);\n\n#ifdef GLES_3\n    out vec2 vUV;\n#else\n    varying vec2 vUV;\n#endif\n\nvoid main() {\n    #ifdef GLES_3\n        vUV = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);\n    #else\n        float x = mod(floor(position), 2.) * 2.;\n        float y = mod(floor(position * .5), 2.) * 2.;\n\n        vUV = vec2(x, y);\n    #endif\n\n    gl_Position = vec4(vUV * 2. - 1., 0., 1.);\n}\n"

/***/ }),
/* 90 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@wg/industrial-viewer\",\"version\":\"6.0.0\",\"private\":true,\"main\":\"dist/index.js\",\"files\":[\"dist/index.*(js|d.ts)\",\"dist/presets/*.*(js|d.ts)\",\"dist/extensions/*.*(js|d.ts)\",\"dist/tsdoc-metadata.json\",\"dist/*.md\"],\"engines\":{\"node\":\">=12.14.1\"},\"scripts\":{\"start\":\"gulp serve\",\"build\":\"gulp build\",\"clean:dist-dts\":\"rimraf dist-dts/\",\"clean:dist-docs-md\":\"rimraf dist-docs-md/\",\"generate:dts:tsc\":\"npm run clean:dist-dts && tsc --emitDeclarationOnly --project tsconfig.json --declaration --outDir dist-dts\",\"generate:dts\":\"npm run generate:dts:tsc && node bin/dts-creator.js\",\"generate:docs:md\":\"npm run clean:dist-docs-md && npm run generate:dts && api-documenter markdown -i docs-report -o dist-docs-md\",\"generate:docs:html\":\"npm run generate:docs:md && gulp docs\",\"generate:docs:html:only\":\"npm run generate:docs:md && gulp docs:only\",\"build:package\":\"gulp build:package && npm run generate:dts\",\"build:docs\":\"gulp docs\",\"link\":\"npm -C ../../ run link\",\"bootstrap\":\"npm -C ../../ run bootstrap\",\"test:unit:dev\":\"jest --watch\",\"test:unit:ci\":\"jest\",\"test-dev\":\"cross-env VIS_OS_NAME_OVERRIDE=Linux testcafe chrome test/functional/tests/**/**/*.js -s screenshots --live\",\"test-dev:fast\":\"cross-env VIS_OS_NAME_OVERRIDE=Linux testcafe -c 4 chrome test/functional/tests/**/**/*.js -s screenshots --live\",\"test-dev:remote\":\"cross-env IMAGE_COMPARE_SKIP=true testcafe remote test/functional/tests/**/**/*.js -s screenshots --live --qr-code\",\"test-dev:generate\":\"cross-env VIS_GENERATE_NEW_ONLY=true VIS_OS_NAME_OVERRIDE=Linux npm run test-dev\",\"test-dev:safari\":\"testcafe safari test/functional/tests/**/**/*.js -s screenshots --live\",\"test-ci\":\"cross-env CI=true testcafe chrome,firefox -c 6 test/functional/tests/**/**/*.js -s path=screenshots -r teamcity --quarantine-mode\",\"test-ci-windows\":\"cross-env CI=true testcafe chrome,firefox,edge test/functional/tests/**/**/*.js -s screenshots -r teamcity --quarantine-mode\",\"copy-test-assets\":\"gulp copy:test-assets\",\"vis-test-generate\":\"VIS_GENERATE_NEW_ONLY=true testcafe chrome,firefox test/functional/tests/**/**/*.js -s screenshots --fixture-meta vis=true\",\"vis-test-generate-ci\":\"VIS_GENERATE_NEW_ONLY=true testcafe chrome,firefox -c 2 test/functional/tests/**/**/*.js -s screenshots --fixture-meta vis=true -r teamcity\",\"vis-test-generate-windows-ci\":\"cross-env VIS_GENERATE=true testcafe chrome,firefox,edge test/functional/tests/**/**/*.js -s screenshots --fixture-meta vis=true -r teamcity\",\"benchmark\":\"testcafe chrome test/benchmark/**/**/*.js -r teamcity --app \\\"http-server ../examples/dist\\\"\",\"benchmark-dev\":\"testcafe chrome test/benchmark/**/**/*.js --live\",\"benchmark-dev:generate\":\"cross-env VIS_GENERATE_NEW_ONLY=true npm run benchmark-dev\",\"deploy:docs\":\"rsync -av dist-docs/ wgdemos@b3.webgears3d.com:/mnt/b3-volume/b3/industrial-viewer/\",\"publish:package\":\"npm run bootstrap && npm run build:package && cd dist && npm publish\",\"publish:docs\":\"npm run generate:docs:html && npm run deploy:docs\",\"create-edges\":\"node ./bin/edge-creator.js\"},\"devDependencies\":{\"@sentry/browser\":\"^5.18.0\",\"@wg/api-file-upload\":\"^1.0.0\",\"@wg/industrial-testcafe-helpers\":\"^1.0.0\",\"@wg/measures\":\"^1.0.0\",\"del\":\"^2.2.2\",\"fs-readdir-recursive\":\"^1.1.0\",\"gulp\":\"^4.0.2\",\"gulp-gzip\":\"^1.2.0\",\"gulp-load-plugins\":\"^1.2.0\",\"gulp-rsync\":\"0.0.5\",\"gulp-useref\":\"^3.0.5\",\"gulp-util\":\"^3.0.8\",\"ip\":\"^1.1.5\",\"merge-stream\":\"^2.0.0\",\"minimatch\":\"^3.0.4\",\"mobx\":\"^4.15.7\",\"mobx-react-lite\":\"^2.0.7\",\"objectmodel\":\"^4.2.2\",\"wg-fps-stats\":\"^5.0.2\",\"zip-a-folder\":\"0.0.10\"},\"jest\":{\"verbose\":true,\"testMatch\":[\"**/test/unit/**/*.js\",\"**/?(*.)+(spec|test).js\"],\"transform\":{\"^.+\\\\.(js|ts)$\":\"ts-jest\"},\"transformIgnorePatterns\":[],\"reporters\":[\"default\",\"jest-teamcity\"]}}");

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Validator; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable @typescript-eslint/no-explicit-any */
class Validator {
  constructor(methodsModels) {
    _defineProperty(this, "_methods", void 0);

    const methodsModelsIterable = Object.entries(methodsModels);
    const methods = new Map();

    for (const [methodName, methodModel] of methodsModelsIterable) {
      this._setErrorCollector(methodName, methodModel);

      methods.set(methodName, args => {
        return this._validate(methodModel, args);
      });
    }

    this._methods = methods;
  } // this is hack for optional generics (now supports up to 4 arguments)


  run(methodName, ...args) {
    const methodValidator = this._methods.get(methodName);

    if (!methodValidator) {
      throw new Error(`Can't validate unknown method "${methodName}"`);
    }

    return methodValidator(args);
  }

  _setErrorCollector(methodName, methodModel) {
    methodModel.forEach((argumentModel, i) => {
      Object.defineProperty(argumentModel, 'errorCollector', {
        configurable: true,
        writable: true,
        value: errors => {
          const {
            message
          } = errors[0];
          const modelName = argumentModel.name !== 'Model' ? ` must be ${argumentModel.name}, where` : '';
          throw new Error(`API.${methodName} => argument[${i}]${modelName} ${message}`);
        }
      });
    });
  }

  _validate(methodModel, args) {
    const result = [];
    methodModel.forEach((argumentModel, i) => {
      result.push(argumentModel(args[i]));
    });
    return result;
  }

}

/***/ }),
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateFunction; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

class FunctionGenerator {
  constructor() {
    this.doc = [];
    this.ctx = {};
    this.strict = true;
    this.name = '';
    this.params = [];
    this._code = [];
  }

  emit(strings, ...values) {
    const code = this._code;
    code.push(strings[0]);

    for (const _ref of values.entries()) {
      var _ref2 = _slicedToArray(_ref, 2);

      const i = _ref2[0];
      const value = _ref2[1];
      code.push(value, strings[i + 1]);
    }

    code.push('\n');
  }

  _compile() {
    const ctx = new Map(Object.entries(this.ctx));
    const strict = this.strict;
    const code = this._code;
    code.unshift(`return function(${this.params}){\n`);

    if (strict) {
      code.unshift('\'use strict\';');
    }

    ;
    code.push('}\n');

    try {
      // eslint-disable-next-line no-new-func
      const fn = new Function(...ctx.keys(), code.join(''))(...ctx.values());
      Object.defineProperty(fn, 'name', {
        configurable: true,
        value: this.name
      });

      if (false) {}

      return fn;
    } finally {
      code.pop();

      if (strict) {
        code.shift();
      }

      code.shift();
    }
  }

}

function generateFunction(generate) {
  const fg = new FunctionGenerator();
  generate(fg);
  return fg._compile();
}

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return makePropertyAliaser; });
function makePropertyAliaser(object) {
  return function aliasProperty(name, alias) {
    const descriptor = Object.getOwnPropertyDescriptor(object, name);

    if (false) {}

    Object.defineProperty(object, alias, descriptor);
  };
}

/***/ }),
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */
/***/ (function(module, exports) {

module.exports = "\nuniform vec3 color;\nuniform float opacity;\n\n#pragma include(math.glsl)\n\n#ifdef SRGB_OUTPUT\n    #pragma include(rgbToSrgbFunc.glsl)\n#endif\n\n#ifdef COLOR_MAP\n    #ifdef GLES_3\n        in vec2 vColorMapUv;\n    #else\n        varying vec2 vColorMapUv;\n    #endif\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #ifdef GLES_3\n        in vec3 vInstanceUniqueColor;\n    #else\n        varying vec3 vInstanceUniqueColor;\n    #endif // GLES_3\n#endif\n\n#pragma fragOutputs\n\nvoid main()\n{\n    // TODO:: vertex color support\n    vec3 outColor = color;\n    float alpha = opacity;\n\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n        #pragma fragOutput(INSTANCE_COLOR, rgba, vec4(vInstanceUniqueColor, 1.0))\n    #endif\n\n    #ifdef COLOR_MAP\n        vec4 texelColor = _colorMapReadFunc(vColorMapUv);\n\n        outColor *= texelColor.rgb;\n        alpha *= texelColor.a;\n    #endif\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 RGB_HDR = outColor * alpha;\n        #else\n            vec3 RGB_HDR = outColor;\n        #endif\n\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, vec4(RGB_HDR, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        vec3 XYZ = RGB2XYZ * outColor;\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, RGB2LogLUV(outColor))\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n        #ifdef SRGB_OUTPUT\n            const float gammaOutput = 0.41666;\n\n            outColor = rgbToSrgb(outColor, gammaOutput);\n        #endif\n\n        #ifdef PREMULTIPLIED_ALPHA\n            outColor *= alpha;\n        #endif\n\n        #pragma fragOutput(DEFAULT, rgba, vec4(outColor, alpha))\n    #endif\n}\n"

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, vec3, POSITION, 0);\n\n#ifdef CUBE\n    #define IGNORE_TRANSLATION\n\n    #pragma include(matrixRoutines.glsl)\n    #pragma include(clipPositionParams.glsl)\n    #pragma include(transformAttributesVert.glsl)\n#endif\n\n#ifdef SCREEN_QUAD\n    #ifdef GLES_3\n    out vec2 vScreenQuadTexCoords;\n    #else\n    varying vec2 vScreenQuadTexCoords;\n    #endif\n#elif defined(CUBE)\n    #ifdef GLES_3\n    out vec3 vCubeMapTexCoords;\n    #else\n    varying vec3 vCubeMapTexCoords;\n    #endif\n#endif\n\nvoid main() {\n    #ifdef SCREEN_QUAD\n        // TODO:: hack for frustum culling\n        vScreenQuadTexCoords = position.xy *.1 * .5 + .5;\n\n        vec4 clipPosition = vec4(position.xy * .1, 1., 1.);\n\n    #elif defined(CUBE)\n        #pragma include(transformVert.glsl)\n        #pragma include(viewPositionVert.glsl)\n        #pragma include(clipPositionVert.glsl)\n\n        clipPosition.z = clipPosition.w * 0.9999;\n\n        vCubeMapTexCoords = normalize(position);\n    #endif\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(50)))

/***/ }),
/* 114 */,
/* 115 */
/***/ (function(module, exports) {



/***/ }),
/* 116 */
/***/ (function(module, exports) {



/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#ifdef GLES_3\n    out vec3 vPositionWorld;\n#else\n    varying vec3 vPositionWorld;\n#endif"

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = "#ifdef GLES_3\n    in vec3 vPositionWorld;\n#else\n    varying vec3 vPositionWorld;\n#endif"

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "vPositionWorld = vec3(worldPosition);"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(customColor, vec3, INSTANCE_CUSTOM_0, 1);\n\n#if (OUTPUT_MASK & CUSTOM_COLOR_OUTPUT_MASK)\n    #ifdef SELECTION_OVERLAY\n        #ifdef GLES_3\n            out vec3 vCustomColor;\n        #else\n            varying vec3 vCustomColor;\n        #endif\n    #endif\n#endif"

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & CUSTOM_COLOR_OUTPUT_MASK)\n    #ifdef SELECTION_OVERLAY\n        #ifdef GLES_3\n            in vec3 vCustomColor;\n        #else\n            varying vec3 vCustomColor;\n        #endif\n    #endif\n#endif"

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & CUSTOM_COLOR_OUTPUT_MASK)\n    #ifdef SELECTION_OVERLAY\n        vCustomColor = customColor;\n    #endif\n#endif"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & CUSTOM_COLOR_OUTPUT_MASK)\n    #ifdef SELECTION_OVERLAY\n        if (vCustomColor == vec3(0.0, 0.0, 0.0)) { discard; }\n        #pragma fragOutput(CUSTOM_COLOR, rgba, vec4(vCustomColor, 1.0))\n    #else\n        discard;\n        // need this line to avoid no FragColor errors\n        #pragma fragOutput(CUSTOM_COLOR, rgba, vec4(0.0, 0.0, 0.0, 1.0))\n    #endif\n#endif"

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(ignoreRaycast, float, INSTANCE_CUSTOM_2, 1);\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #ifdef GLES_3\n        out float vIgnoreRaycast;\n    #else\n        varying float vIgnoreRaycast;\n    #endif\n#endif"

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #ifdef GLES_3\n        in float vIgnoreRaycast;\n    #else\n        varying float vIgnoreRaycast;\n    #endif\n#endif"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\nvIgnoreRaycast = ignoreRaycast;\n#endif"

/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = "#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\nif (vIgnoreRaycast > 0.) {\n    discard;\n}\n#endif"

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "if (checkBoxLength(boxOccluderMin, boxOccluderMax) > 0.001 && !insideBox3D(vPositionWorld, boxOccluderMin, boxOccluderMax)) {\n    discard;\n}"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 boxOccluderMin;\nuniform vec3 boxOccluderMax;\n\nbool insideBox3D(vec3 v, vec3 bottomLeft, vec3 topRight) {\n    vec3 vMin = min(bottomLeft, topRight);\n    vec3 vMax = max(bottomLeft, topRight);\n\n    return (\n        v.x >= vMin.x && v.x <= vMax.x &&\n        v.y >= vMin.y && v.y <= vMax.y &&\n        v.z >= vMin.z && v.z <= vMax.z\n    );\n}\n\nfloat checkBoxLength(vec3 a, vec3 b) { // delete if shader can recompile\n    return length(a - b);\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef SKINNING\nmat3 matrixNormal = transpose(inverse(mat3_cast(matrixWorldView * transpose(boneTransform))));\n#else\nmat3 matrixNormal = transpose(inverse(mat3_cast(matrixWorldView)));\n#endif\n\n#define MPI 3.141592653589793238462643383\n\nfloat polar = normal.x * MPI;\nfloat azimuthal = normal.y * MPI;\nfloat sinp = sin(polar);\nfloat cosp = cos(polar);\nfloat sina = sin(azimuthal);\nfloat cosa = cos(azimuthal);\nvec3 objectNormal;\nobjectNormal.x = sinp * cosa;\nobjectNormal.y = sinp * sina;\nobjectNormal.z = cosp;\n\n#if defined(NORMAL_MORPH_COUNT)\n#if NORMAL_MORPH_COUNT > 0\nobjectNormal += morphWeights[0] * morphNormal0;\n#endif\n\n#if NORMAL_MORPH_COUNT > 1\nobjectNormal += morphWeights[1] * morphNormal1;\n#endif\n\n#if NORMAL_MORPH_COUNT > 2\nobjectNormal += morphWeights[2] * morphNormal2;\n#endif\n\n#if NORMAL_MORPH_COUNT > 3\nobjectNormal += morphWeights[3] * morphNormal3;\n#endif\n\n#if NORMAL_MORPH_COUNT > 4\nobjectNormal += morphWeights[4] * morphNormal4;\n#endif\n\n#if NORMAL_MORPH_COUNT > 5\nobjectNormal += morphWeights[5] * morphNormal5;\n#endif\n\n#if NORMAL_MORPH_COUNT > 6\nobjectNormal += morphWeights[6] * morphNormal6;\n#endif\n\n#if NORMAL_MORPH_COUNT > 7\nobjectNormal += morphWeights[7] * morphNormal7;\n#endif\n#endif\n\nvec3 normalizedViewSpaceNormal = normalize(matrixNormal * objectNormal);\n\nvNormal = normalizedViewSpaceNormal;\n"

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _common__WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _common__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _events__WEBPACK_IMPORTED_MODULE_1__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _events__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(134);
/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_methods__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _methods__WEBPACK_IMPORTED_MODULE_2__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _methods__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));




/***/ }),
/* 132 */
/***/ (function(module, exports) {



/***/ }),
/* 133 */
/***/ (function(module, exports) {



/***/ }),
/* 134 */
/***/ (function(module, exports) {



/***/ }),
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, vec3, POSITION, 0);\n// TODO:: vertex color support\n// #pragma attribute(color, vec{3, 4}, COLOR, 0);\n\n#pragma include(morphParamsVert.glsl)\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n#ifdef COLOR_MAP\n#pragma include(colorMapParamsVert.glsl)\n#pragma include(transformUv.glsl)\n#endif\n\nvoid main() {\n    #pragma include(transformVert.glsl)\n    #pragma include(clipPositionVert.glsl)\n\n    #ifdef COLOR_MAP\n    vColorMapUv = transformUv(colorMapTransform, _colorMapUv);\n    #endif\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, vec3, POSITION, 0);\n#pragma attribute(normal, vec3, NORMAL, 0);\n\n#pragma include(morphParamsVert.glsl)\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n#if defined(ALBEDO_MAP) || defined(NORMAL_MAP) || defined(METALNESS_ROUGHNESS_MAP) || defined(AMBIENT_OCCLUSION_MAP) || defined(EMISSIVE_MAP)\n#pragma include(transformUv.glsl)\n\n#if defined(ALBEDO_MAP)\n#pragma include(albedoMapParamsVert.glsl)\n#endif\n\n#if defined(NORMAL_MAP)\n#pragma include(normalMapParamsVert.glsl)\n#endif\n\n#pragma include(metalnessRoughnessMapParamsVert.glsl)\n#pragma include(ambientOcclusionMapParamsVert.glsl)\n#pragma include(emissiveMapParamsVert.glsl)\n\n#endif // end: if any possible map\n\n#pragma include(skinningParamsVert.glsl)\n\n#pragma include(worldSpaceVaryingsParamsVert.glsl)\n\n#ifdef GLES_3\nout vec3 vNormal;\nout vec3 vViewPosition;\n#else\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#endif\n\nvoid main() {\n    #pragma include(transformVert.glsl)\n    #pragma include(viewPositionVert.glsl)\n    #pragma include(clipPositionVert.glsl)\n    #pragma include(matrixWorldView.glsl)\n    #pragma include(normalVert.glsl)\n\n    vViewPosition = viewPosition.xyz;\n\n    #ifdef ALBEDO_MAP\n    vAlbedoMapUv = transformUv(albedoMapTransform, _albedoMapUv);\n    #endif\n\n    #ifdef NORMAL_MAP\n    vNormalMapUv = transformUv(normalMapTransform, _normalMapUv);\n    #endif\n\n    #ifdef METALNESS_ROUGHNESS_MAP\n    vMetalnessRoughnessMapUv = transformUv(metalnessRoughnessMapTransform, _metalnessRoughnessMapUv);\n    #endif\n\n    #ifdef AMBIENT_OCCLUSION_MAP\n    vAmbientOcclusionMapUv = transformUv(ambientOcclusionMapTransform, _ambientOcclusionMapUv);\n    #endif\n\n    #ifdef EMISSIVE_MAP\n    vEmissiveMapTransformUv = transformUv(emissiveMapTransform, _emissiveMapUv);\n    #endif\n\n    #pragma include(worldSpaceVaryingsVert.glsl)\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = "\nuniform vec3 albedo;\nuniform float opacity;\nuniform float metalness;\nuniform float roughness;\nuniform float normalIncidenceFresnel;   // default value is for plastic high (0.05)\n\n#ifdef CLEAR_COAT\nuniform float clearCoatStrength;\nuniform float clearCoatRoughness;\n#endif\n\n#pragma include(materialPBR.glsl)\n\n#pragma include(toneMappingFragParams.glsl)\n\n#ifdef SRGB_OUTPUT\n#pragma include(rgbToSrgbFunc.glsl)\n#endif\n\nuniform vec3 emissiveFactor;\nuniform float emissiveLuminance;\n\n#if defined(ALBEDO_MAP)\n#ifdef GLES_3\nin vec2 vAlbedoMapUv;\n#else\nvarying vec2 vAlbedoMapUv;\n#endif\n#endif\n\n#if defined(NORMAL_MAP)\n#ifdef GLES_3\nin vec2 vNormalMapUv;\n#else\nvarying vec2 vNormalMapUv;\n#endif\n#pragma include(normalMapParamsFrag.glsl)\n#endif\n\n#if defined(METALNESS_ROUGHNESS_MAP)\n#ifdef GLES_3\nin vec2 vMetalnessRoughnessMapUv;\n#else\nvarying vec2 vMetalnessRoughnessMapUv;\n#endif\n#endif\n\n#pragma include(ambientOcclusionMapParamsFrag.glsl)\n\n#pragma include(emissiveMapParamsFrag.glsl)\n\n#pragma include(iblSH.glsl)\n#pragma include(diffuseIlluminanceMapParamsFrag.glsl)\n#pragma include(preFilteredEnvMapParamsFrag.glsl)\n\n#pragma include(worldSpaceFragContextParamsFrag.glsl)\n\n#pragma include(worldSpaceVaryingsParamsFrag.glsl)\n\n#pragma include(lightsParamsFrag.glsl)\n#pragma include(attenuation.glsl)\n\n#ifdef GLES_3\nin vec3 vNormal;\nin vec3 vViewPosition;\n#else\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#ifdef GLES_3\nin vec3 vInstanceUniqueColor;\n#else\nvarying vec3 vInstanceUniqueColor;\n#endif // GLES_3\n#endif\n\n#pragma fragOutputs\n\nvoid main() {\n    vec3 directLightDiffuse = vec3(0.0);\n    vec3 directLightSpecular = vec3(0.0);\n    vec3 indirectLightDiffuse = vec3(0.0);\n    vec3 indirectLightSpecular = vec3(0.0);\n    vec3 reflectedLight = vec3(0.0);\n    // TODO:: move gltf extension from map to material.\n    vec3 emittedLight = emissiveFactor;\n    vec3 indirectLight = vec3(0.0);\n\n    #pragma include(emissiveMapFrag.glsl)\n\n    DirectLightFragContext    directLightFragContext;\n    IndirectLightFragContext  indirectLightFragContext;\n\n    MaterialPBR material;\n\n    float alpha = opacity;\n\n    vec3 albedo_ = albedo;\n\n    #pragma include(albedoMapFrag.glsl)\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #pragma include(normalMapFrag.glsl)\n\n    #pragma include(worldSpaceFragContextFrag.glsl)\n\n    #pragma include(materialPBRFrag.glsl)\n\n    #pragma fragOutput(NORMALS, xyz, normal * 0.5 + 0.5)\n    #pragma fragOutput(VIEW_POSITION, xyz, vViewPosition)\n    #pragma fragOutput(HYPERBOLIC_DEPTH_RGBA, rgba, encodeNormalizedFloatRGBA(gl_FragCoord.z))\n    #pragma fragOutput(COLOR_0, rgba, vec4(albedo_, alpha))\n    #pragma fragOutput(COLOR_1, rgb, vec3(normalIncidenceFresnel, material.roughness, material.metalness))\n    #pragma fragOutput(EMISSIVE, rgba, vec4(emittedLight, alpha))\n\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #pragma fragOutput(INSTANCE_COLOR, rgba, vec4(vInstanceUniqueColor, 1.0))\n    #endif\n\n    #if (OUTPUT_MASK & DIRECT_LIGHT_OUTPUT_MASK)\n    vec3 view = -normalize(vViewPosition);\n\n    directLightFragContext.nv = clamp(dot(normal, view), EPSILON, 1.);\n\n    #if defined(DIRECT_SHADOW_CASTERS_COUNT) && DIRECT_SHADOW_CASTERS_COUNT > 0\n        float depth = hyperbolicDepthToLinearNormalized(gl_FragCoord.z * 2.0 - 1.0, cameraNearFar[0], cameraNearFar[1]);\n        int cascadeIndex = cascadeIndex(depth);\n    #endif\n\n    #if DIRECTIONAL_LIGHTS_COUNT > 0\n    {\n        DirectionalLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < DIRECTIONAL_LIGHTS_COUNT; ++lightIndex) {\n            light = directionalLight[lightIndex];\n\n            vec3 l = -light.viewSpaceDirection;\n\n            vec3 h = normalize(l + view);\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.luminance = light.luminance; // nt\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(directShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    #if POINT_LIGHTS_COUNT > 0\n    {\n        PointLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < POINT_LIGHTS_COUNT; ++lightIndex) {\n            light = pointLight[lightIndex];\n\n            float size = light.size;\n\n            float invSqAttenRadius = light.invAttenRadius;\n\n            vec3 lightToFrag = light.viewSpacePosition - vViewPosition;\n\n            float atten = distanceAttenuation(lightToFrag, size * size, invSqAttenRadius);\n\n            vec3 l = normalize(lightToFrag);\n\n            vec3 h = normalize(l + view);\n\n            directLightFragContext.luminance = light.luminousIntensity * saturate(atten); // lm / sr * 1 / m^2 === nt\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(omniShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    #if SPOT_LIGHTS_COUNT > 0\n    {\n        SpotLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < SPOT_LIGHTS_COUNT; lightIndex++) {\n            light = spotLight[lightIndex];\n\n            float size = light.size;\n\n            float invSqAttenRadius = light.invAttenRadius;\n\n            vec3 l = light.viewSpacePosition - vViewPosition;\n\n            float atten = distanceAttenuation(l, size * size, invSqAttenRadius);\n\n            l = normalize(l);\n\n            vec3 h = normalize(l + view);\n\n            atten *= angleAttenuation(l, -light.viewSpaceDirection, light.lightAngleScale, light.lightAngleOffset);\n\n            directLightFragContext.luminance = light.luminousIntensity * saturate(atten); // lm / sr * 1 / m^2 === nt\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(spotShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    reflectedLight = directLightDiffuse + directLightSpecular;\n    #endif // (OUTPUT_MASK & DIRECT_LIGHT_OUTPUT_MASK)\n\n    #pragma fragOutput(DIRECT_DIFFUSE, rgba, vec4(directLightDiffuse, alpha))\n    #pragma fragOutput(DIRECT_SPECULAR, rgba, vec4(directLightSpecular, alpha))\n\n    #if (OUTPUT_MASK & INDIRECT_LIGHT_OUTPUT_MASK)\n    #ifdef WORLD_SPACE_FRAG_CONTEXT\n    indirectLightFragContext.viewWorld = viewWorld;\n    indirectLightFragContext.normalWorld = normalWorld;\n    #endif\n\n    #ifdef USE_AMBIENT_LIGHT\n    indirectLightFragContext.luminanceDiffuse = ambientLight.luminance;\n    #else\n        #if defined(DIFFUSE_ILLUMINANCE_MAP) && defined(WORLD_SPACE_FRAG_CONTEXT)\n        {\n            #ifdef GLES_3\n                vec3 luminance = texture(_illuminanceMap, normalWorld).rgb;\n            #else\n                vec3 luminance = LogLuv2RGB(textureCube(_illuminanceMap, normalWorld));\n            #endif\n\n            indirectLightFragContext.luminanceDiffuse = luminance;\n        }\n        #elif defined(SH_BAND_COUNT) && defined(WORLD_SPACE_FRAG_CONTEXT) && SH_BAND_COUNT > 0\n            indirectLightFragContext.luminanceDiffuse = illuminanceSH(normalWorld);\n        #else\n            indirectLightFragContext.luminanceDiffuse = vec3(1.0);\n        #endif\n\n        #if defined(PRE_FILTERED_ENV_MAP) && defined(WORLD_SPACE_FRAG_CONTEXT)\n        {\n            vec3 R = normalize(reflect(-viewWorld, normalWorld));\n\n            vec3 luminance = prefilteredEnvMapColor(R, material.roughness);\n\n            indirectLightFragContext.luminanceSpecular = luminance;\n\n            #ifdef CLEAR_COAT\n            indirectLightFragContext.luminanceClearCoat = prefilteredEnvMapColor(R, material.clearCoatRoughness);\n            #endif\n        }\n        #else\n            indirectLightFragContext.luminanceSpecular = vec3(1.0);\n        #endif\n    #endif\n\n    #pragma include(ambientOcclusionMapFrag.glsl)\n\n    indirectLightFunc(material, indirectLightFragContext);\n\n    indirectLightDiffuse = indirectLightFragContext.diffuse;\n    indirectLightSpecular = indirectLightFragContext.specular;\n    #endif // (OUTPUT_MASK & INDIRECT_LIGHT_OUTPUT_MASK)\n\n    #pragma fragOutput(INDIRECT_DIFFUSE, rgba, vec4(indirectLightDiffuse, alpha))\n    #pragma fragOutput(INDIRECT_SPECULAR, rgba, vec4(indirectLightSpecular, alpha))\n\n    #pragma fragOutput(DIFFUSE, rgba, vec4(indirectLightDiffuse + directLightDiffuse, alpha))\n    #pragma fragOutput(SPECULAR, rgba, vec4(indirectLightSpecular + directLightSpecular, alpha))\n\n    #pragma fragOutput(TM_DIFFUSE, rgba, vec4(toneMappingFunc(indirectLightDiffuse + directLightDiffuse), alpha))\n    #pragma fragOutput(TM_SPECULAR, rgba, vec4(toneMappingFunc(indirectLightSpecular + directLightSpecular), alpha))\n\n    reflectedLight += (indirectLightDiffuse + indirectLightSpecular);\n\n    vec3 outgoingLight = emittedLight + reflectedLight;\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 RGB_HDR = outgoingLight * alpha;\n        #else\n            vec3 RGB_HDR = outgoingLight;\n        #endif\n\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, vec4(RGB_HDR, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 XYZ = RGB2XYZ * outgoingLight * alpha;\n        #else\n            vec3 XYZ = RGB2XYZ * outgoingLight;\n        #endif\n\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec4 logLUV = RGB2LogLUV(outgoingLight) * alpha;\n        #else\n            vec4 logLUV = RGB2LogLUV(outgoingLight);\n        #endif\n\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, logLUV)\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n    outgoingLight = ACESToneMapping(outgoingLight * manualExposure);\n\n    #ifdef SRGB_OUTPUT\n    const float gammaOutput = 0.41666;\n\n    outgoingLight = rgbToSrgb(outgoingLight, gammaOutput);\n    #endif\n\n    #ifdef PREMULTIPLIED_ALPHA\n    outgoingLight *= alpha;\n    #endif\n\n    #pragma fragOutput(DEFAULT, rgba, vec4(outgoingLight, alpha))\n    #endif // DEFAULT_OUTPUT_MASK\n}\n"

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = "#ifdef EQUIRECTANGULAR_FORMAT\n    const vec2 invAtan = vec2(.1591, .3183);\n\n    uniform sampler2D _colorMap;\n#else\n    uniform samplerCube _colorMap;\n#endif\n\n\n#ifdef GLES_3\n    in vec3 vCubeMapTexCoords;\n#else\n    varying vec3 vCubeMapTexCoords;\n#endif\n\n#pragma include(math.glsl)\n\n#if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n    #pragma include(toneMappingFragParams.glsl)\n#endif\n\n#ifdef SRGB_OUTPUT\n    #pragma include(rgbToSrgbFunc.glsl)\n#endif\n\n#pragma fragOutputs\n\n#ifndef GLES_3\n    vec4 texture(sampler2D colorMap, in vec2 texCoord)\n    {\n        return texture2D(colorMap, texCoord);\n    }\n\n    vec4 texture(samplerCube colorMap, in vec3 texCoord)\n    {\n        return textureCube(colorMap, texCoord);\n    }\n\n    vec4 textureLod(sampler2D colorMap, in vec2 texCoord, in float lod)\n    {\n        return texture2DLodEXT(colorMap, texCoord, lod);\n    }\n\n    vec4 textureLod(samplerCube colorMap, in vec3 texCoord, in float lod)\n    {\n        return textureCubeLodEXT(colorMap, texCoord, lod);\n    }\n#endif\n\nvec4 sampleEnvironmentMap(in vec3 sampleVector)\n{\n    #ifdef EQUIRECTANGULAR_FORMAT\n        vec2 texCoord = vec2(atan(sampleVector.z, sampleVector.x), asin(sampleVector.y));\n        texCoord = texCoord * invAtan + .5;\n\n        #ifdef MIP_LEVEL\n            vec4 texel = textureLod(_colorMap, texCoord, float(MIP_LEVEL));\n        #else\n            vec4 texel = textureLod(_colorMap, texCoord, 0.);\n        #endif\n    #else\n        #ifdef MIP_LEVEL\n            vec4 texel = textureLod(_colorMap, sampleVector, float(MIP_LEVEL));\n        #else\n            vec4 texel = texture(_colorMap, sampleVector);\n        #endif\n    #endif\n\n    return texel;\n}\n\nvoid main()\n{\n    vec3 sampleVector = normalize(vCubeMapTexCoords);\n    vec4 outColor = sampleEnvironmentMap(sampleVector);\n\n    #ifdef USE_LOG_LUV\n        outColor = vec4(LogLuv2RGB(outColor), 1.);\n    #endif\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, outColor)\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        vec3 XYZ = RGB2XYZ * vec3(outColor);\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, outColor.a))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, RGB2LogLUV(vec3(outColor)))\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n        outColor.rgb = ACESToneMapping(outColor.rgb * manualExposure);\n\n        #ifdef SRGB_OUTPUT\n            const float gammaOutput = .41666;\n            outColor.rgb = rgbToSrgb(outColor.rgb, gammaOutput);\n        #endif\n\n        #pragma fragOutput(DEFAULT, rgba, outColor)\n    #endif\n\n    outColor.a = 1.;\n}\n"

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = "#pragma include(math.glsl)\n#pragma include(trowbridgeReitzNDF.glsl)\n#pragma include(geometryFunc.glsl)\n\n\n#if defined(PRE_FILTERING_ENV_MAP)\nuniform float roughness;\n\n#ifdef SAMPLE_MIP_LEVEL\n    uniform float resolution;\n#endif\n#endif\n\n#ifdef BRDF_CONVOLUTION\nuniform sampler2D _environmentMap;\n#else\n    #ifdef EQUIRECTANGULAR_FORMAT\n        const vec2 invAtan = vec2(.1591, .3183);\n\n        uniform sampler2D _environmentMap;\n    #else\n        uniform samplerCube _environmentMap;\n    #endif\n#endif\n\n#ifdef BRDF_CONVOLUTION\n#ifdef GLES_3\n    in vec2 vScreenQuadTexCoords;\n#else\n    varying vec2 vScreenQuadTexCoords;\n#endif\n#else\n#ifdef GLES_3\n    in vec3 vCubeMapTexCoords;\n#else\n    varying vec3 vCubeMapTexCoords;\n#endif\n#endif\n\n\n#if defined(PRE_FILTERING_ENV_MAP) ||  defined(BRDF_CONVOLUTION)\n#ifdef GLES_3\n    const uint kSAMPLES_NUMBER = uint(SAMPLES_NUMBER);\n#else\n    const int kSAMPLES_NUMBER = SAMPLES_NUMBER;\n#endif\n#endif\n\n#ifdef RADIANCE_CONVOLUTION\nconst float kSAMPLING_DELTA = float(SAMPLING_DELTA);\n#endif\n\n\n#ifdef GLES_3\nout vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\n\n\n\n#ifndef GLES_3\nvec4 texture(sampler2D colorMap, in vec2 texCoord)\n{\n    return texture2D(colorMap, texCoord);\n}\n\nvec4 texture(samplerCube colorMap, in vec3 texCoord)\n{\n    return textureCube(colorMap, texCoord);\n}\n\n#ifdef SAMPLE_MIP_LEVEL\n    vec4 textureLod(sampler2D colorMap, in vec2 texCoord, in float lod)\n    {\n        return texture2DLodEXT(colorMap, texCoord, lod);\n    }\n\n    vec4 textureLod(samplerCube colorMap, in vec3 texCoord, in float lod)\n    {\n        return textureCubeLodEXT(colorMap, texCoord, lod);\n    }\n#endif\n#endif\n\n\n\n#if defined(PRE_FILTERING_ENV_MAP) || defined(RADIANCE_CONVOLUTION)\n#ifdef SAMPLE_MIP_LEVEL\nvec4 sampleEnvironmentMap(in vec3 sampleVector, in float mipLevel)\n#else\nvec4 sampleEnvironmentMap(in vec3 sampleVector)\n#endif\n{\n    #ifdef EQUIRECTANGULAR_FORMAT\n        vec2 texCoord = vec2(atan(sampleVector.z, sampleVector.x), asin(sampleVector.y));\n        texCoord = texCoord * invAtan + .5;\n    #else\n        vec3 texCoord = sampleVector;\n    #endif\n\n    #ifdef SAMPLE_MIP_LEVEL\n        vec4 texel = textureLod(_environmentMap, texCoord, mipLevel);\n    #else\n        vec4 texel = texture(_environmentMap, texCoord);\n    #endif\n\n    return texel;\n}\n#endif\n\n\n#ifdef RADIANCE_CONVOLUTION\nvec4 integrateIrradiance(in vec3 samplingVector)\n{\n    vec3 normal = normalize(samplingVector);\n    vec3 irradiance = vec3(0.);\n\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(up, normal);\n    up = cross(normal, right);\n\n    int samplesNumber = 0;\n\n    float cosPhi = 0., sinPhi = 0.;\n    float cosTheta = 0., sinTheta = 0.;\n\n    for (float phi = 0.; phi < 2. * PI; phi += kSAMPLING_DELTA) {\n        cosPhi = cos(phi);\n        sinPhi = sin(phi);\n\n        for (float theta = 0.; theta < .5 * PI; theta += kSAMPLING_DELTA) {\n            cosTheta = cos(theta);\n            sinTheta = sin(theta);\n\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n\n            // tangent space to world\n            vec3 sampleVector = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;\n\n            vec3 outColor = sampleEnvironmentMap(normalize(sampleVector)).rgb;\n\n            irradiance += outColor * cosTheta * sinTheta;\n\n            ++samplesNumber;\n        }\n    }\n\n    irradiance = pow2(PI) * irradiance / float(samplesNumber);\n\n    return vec4(irradiance, 1.);\n}\n#endif\n\n#if defined(PRE_FILTERING_ENV_MAP) || defined(BRDF_CONVOLUTION)\n    #ifdef GLES_3\n        float radicalInverseVanDerCorpus(uint bits)\n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n\n        vec2 sequenceHammersley(uint i, uint n)\n        {\n            return vec2(float(i) / float(n), radicalInverseVanDerCorpus(i));\n        }\n    #else // GLES_3\n        float radicalInverseVanDerCorpus(int n, int base)\n        {\n            float invBase = 1. / float(base);\n            float denom = 1.;\n            float result = 0.;\n\n            for (int i = 0; i < 32; ++i) {\n                if (n > 0) {\n                    denom = mod(float(n), 2.);\n                    result += denom * invBase;\n                    invBase = invBase *.5;\n                    n = int(float(n) *.5);\n                }\n            }\n\n            return result;\n        }\n\n        vec2 sequenceHammersley(int i, int n)\n        {\n            return vec2(float(i) / float(n), radicalInverseVanDerCorpus(i, 2));\n        }\n    #endif // GLES_3\n\n    vec3 importanceSample(vec2 xi, vec3 n, float roughness)\n    {\n        float a = pow2(roughness);\n\n        float phi = 2. * PI * xi.x;\n        float cosTheta = sqrt((1. - xi.y) / (1. + (pow2(a) - 1.) * xi.y));\n        float sinTheta = sqrt(1. - pow2(cosTheta));\n\n        // from spherical coordinates to cartesian coordinates\n        vec3 h;\n\n        h.x = cos(phi) * sinTheta;\n        h.y = sin(phi) * sinTheta;\n        h.z = cosTheta;\n\n        // from tangent-space vector to world-space sample vector\n        vec3 up = abs(n.z) < .999 ? vec3(0., 0., 1.) : vec3(1., 0., 0.);\n        vec3 tangent = normalize(cross(up, n));\n        vec3 bitangent = cross(n, tangent);\n\n        vec3 sampleVec = tangent * h.x + bitangent * h.y + n * h.z;\n\n        return sampleVec;\n        // return normalize(sampleVec);\n    }\n#endif\n\n#ifdef PRE_FILTERING_ENV_MAP\nvec3 preFilteredEnvMap(in vec3 samplingVector, in float roughness)\n{\n    float a = pow2(roughness);\n    float a2 = pow2(a);\n\n    vec3 n = normalize(samplingVector);\n    vec3 r = n;\n    vec3 v = r;\n\n    float totalWeight = 0.;\n    vec3 prefilteredColor = vec3(0.);\n\n#ifdef GLES_3\n    for (uint i = 0u; i < kSAMPLES_NUMBER; ++i) {\n#else\n    for (int i = 0; i < kSAMPLES_NUMBER; ++i) {\n#endif\n        vec2 xi = sequenceHammersley(i, kSAMPLES_NUMBER);\n        vec3 h  = importanceSample(xi, n, roughness);\n        vec3 l  = normalize(2. * dot(v, h) * h - v);\n\n        float nh = saturate(dot(n, h));\n        float nl = saturate(dot(n, l));\n\n        if (nl > 0.) {\n            #ifdef SAMPLE_MIP_LEVEL\n            float d = normalDistributionFunc(a2, nh);\n\n            float hv = saturate(dot(h, v));\n            float pdf = d * nh / (4. * hv) + .0001;\n\n            float saTexel  = 4. * PI / (6. * resolution * resolution);\n            float saSample = 1. / (float(kSAMPLES_NUMBER) * pdf + .0001);\n\n            float mipLevel = roughness == 0. ? 0. : .5 * log2(saSample / saTexel);\n\n            prefilteredColor += sampleEnvironmentMap(l, mipLevel).rgb * nl;\n            #else\n            prefilteredColor += sampleEnvironmentMap(l).rgb * nl;\n            #endif\n\n            totalWeight += nl;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    return prefilteredColor;\n}\n#endif\n\n\n#ifdef BRDF_CONVOLUTION\nvec2 integrateBRDF(in float nv, in float roughness)\n{\n    vec3 v;\n\n    v.x = sqrt(1. - pow2(nv));\n    v.y = 0.;\n    v.z = nv;\n\n    float a_ = 0.;\n    float b_ = 0.;\n\n    vec3 n = vec3(0., 0., 1.);\n\n    float a = pow2(roughness);\n\n    #ifdef GLES_3\n    for (uint i = 0u; i < kSAMPLES_NUMBER; ++i) {\n    #else\n    for (int i = 0; i < kSAMPLES_NUMBER; ++i) {\n    #endif\n        vec2 xi = sequenceHammersley(i, kSAMPLES_NUMBER);\n        vec3 h = importanceSample(xi, n, roughness);\n        vec3 l = normalize(2. * dot(v, h) * h - v);\n\n        float nl = saturate(l.z);\n        float nh = saturate(h.z);\n        float vh = saturate(dot(v, h));\n\n        if (nl > 0.) {\n            float g = geometryIBLFunc(nl, nv, a);\n            float gVis = (g * vh) / (nh * nv);\n            float fc = pow(1. - vh, 5.);\n\n            a_ += (1. - fc) * gVis;\n            b_ += fc * gVis;\n        }\n    }\n\n    a_ /= float(kSAMPLES_NUMBER);\n    b_ /= float(kSAMPLES_NUMBER);\n\n    return vec2(a_, b_);\n}\n#endif\n\nvoid main()\n{\n    #ifdef RADIANCE_CONVOLUTION\n        fragColor = integrateIrradiance(vCubeMapTexCoords);\n    #elif defined(PRE_FILTERING_ENV_MAP)\n        fragColor = vec4(preFilteredEnvMap(vCubeMapTexCoords, roughness), 1.);\n    #elif defined(BRDF_CONVOLUTION)\n        fragColor = vec4(integrateBRDF(vScreenQuadTexCoords.x, vScreenQuadTexCoords.y), 0., 1.);\n    #endif\n\n    #ifndef GLES_3\n        fragColor = RGB2LogLUV(fragColor.rgb);\n    #endif\n}\n"

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 center;\nuniform float rotation;\n\n#pragma attribute(position, vec2, POSITION, 0)\n\n#define VIEW_TO_CLIP_POSITION\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n#pragma include(transformAttributesVert.glsl)\n\n#ifdef COLOR_MAP\n#pragma include(colorMapParamsVert.glsl)\n#pragma include(transformUv.glsl)\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#pragma include(math.glsl)\n#endif\n\nvoid main() {\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    vInstanceUniqueColor = encodeFloatRGB(instanceIdentifiers.y);\n    #endif\n\n    #ifdef COLOR_MAP\n    vec2 uv = position * 0.5 + 0.5;\n    uv.y = 1.0 - uv.y;\n\n    vColorMapUv = transformUv(colorMapTransform, uv);\n    #endif\n\n    mat4 matrixWorld = transpose(mat4(transform1, transform2, transform3, transform4));\n\n    mat4 matrixWorlView = viewMatrix * matrixWorld;\n\n    vec4 viewPosition = matrixWorlView * vec4(0.0, 0.0, 0.0, 1.0);\n\n    float scx = length(matrixWorld[0].xyz);\n    float scy = length(matrixWorld[1].xyz);\n\n    float csr = cos(rotation);\n    float snr = sin(rotation);\n\n    vec3 spriteXfrm1 = vec3(csr * scx, snr * scx, 0.0);\n    vec3 spriteXfrm2 = vec3(-snr * scy, csr * scy, 0.0);\n    vec3 spriteXfrm3 = vec3(center.xy, 1.0);\n\n    mat3 spriteXfrm = mat3(spriteXfrm1, spriteXfrm2, spriteXfrm3);\n\n    vec3 spritePos = spriteXfrm * vec3(position, 1.0);\n\n    viewPosition.xy += spritePos.xy;\n\n    gl_Position = projectionMatrix * viewPosition;\n}\n"

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, vec3, POSITION, 0);\n\n#pragma include(morphParamsVert.glsl)\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n#pragma include(skinningParamsVert.glsl)\n\n\n#ifdef OMNI_DIRECTIONAL_CASTER\n    #ifdef GLES_3\n        out vec4 vViewPosition;\n    #else\n        varying vec4 vViewPosition;\n    #endif\n#endif\n\n\nvoid main() {\n    #pragma include(transformVert.glsl)\n    #pragma include(viewPositionVert.glsl)\n    #pragma include(clipPositionVert.glsl)\n\n    #ifdef OMNI_DIRECTIONAL_CASTER\n        vViewPosition = viewPosition;\n    #endif\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = "#ifdef ALPHA_TEST\n    uniform float opacity;\n#endif\n\n#ifdef GLES_3\nout vec4 fragColor; // TODO:: must correspond with current RT\n#endif\n\n#ifndef GLES_3\n#pragma include(math.glsl)\n#endif\n\n\n#ifdef OMNI_DIRECTIONAL_CASTER\n    #ifdef GLES_3\n        in vec4 vViewPosition;\n    #else\n        varying vec4 vViewPosition;\n    #endif\n#endif\n\n\nvoid main()\n{\n    #ifdef ALPHA_TEST\n        float alpha = opacity;\n    #endif\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #ifdef OMNI_DIRECTIONAL_CASTER\n        float depth = length(vViewPosition.xyz) / float(OMNI_DIRECTIONAL_CASTERS_ZFAR);\n        #ifdef GLES_3\n            gl_FragDepth = depth;\n        #else\n            gl_FragColor = encodeNormalizedFloatRGBA(depth);\n        #endif\n    #else\n        #ifdef GLES_3\n            fragColor = vec4(vec3(gl_FragCoord.z), 1.0);\n        #else\n            gl_FragColor = encodeNormalizedFloatRGBA(gl_FragCoord.z);\n        #endif\n    #endif\n}\n"

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, vec3, POSITION, 0);\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n\nvoid main()\n{\n    #pragma include(transformVert.glsl)\n    #pragma include(clipPositionVert.glsl)\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = "\nuniform vec3 color;\nuniform float opacity;\n\n#ifdef GLES_3\n    out vec4 fragColor;\n#else\n    #define fragColor gl_FragColor\n#endif\n\n\nvoid main()\n{\n    vec3 outColor = color;\n    float alpha = opacity;\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #ifdef PREMULTIPLIED_ALPHA\n    outColor *= alpha;\n    #endif\n\n    fragColor.rgb = outColor;\n    fragColor.a = alpha;\n}\n"

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = "\n#pragma attribute(position, vec2, POSITION, 0)\n\n#ifdef GLES_3\nout vec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\n\nvoid main() {\n    vec2 uv = position * 0.5 + 0.5;\n\n    vUv = uv;\n\n    gl_Position = vec4(position, 0.5, 1.0);\n}\n"

/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef GLES_3\nout vec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\n\nuniform float srcRect[4];\nuniform float dstRect[4];\n\nuniform sampler2D src;\n\n#ifdef GLES_3\nout vec4 fragColor;\n#endif\n\n#ifndef GLES_3\n#define texture(s, coords) texture2D(s, coords)\n#endif\n\nvoid main() {\n    vec2 dstUv = vec2(0.0);\n\n    dstUv.x =\n        step(dstRect[0], vUv.x) *\n        step(vUv.x, dstRect[0] + dstRect[2]) *\n        clamp((vUv.x - dstRect[0]) / dstRect[2], 0.0, 1.0);\n\n    dstUv.y =\n            step(dstRect[1], vUv.y) *\n            step(vUv.y, dstRect[1] + dstRect[3]) *\n            clamp((vUv.y - dstRect[1]) / dstRect[3], 0.0, 1.0);\n\n    vec2 srcUv = vec2(dstUv.x * srcRect[2] + srcRect[0], dstUv.y * srcRect[3] + srcRect[1]);\n\n    vec4 dstColor = texture(src, srcUv);\n\n    #ifdef GLES_3\n    fragColor = dstColor;\n    #else\n    gl_FragColor = dstColor;\n    #endif\n}\n"

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef MATH_GLSL\n#define MATH_GLSL\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define EPSILON 1e-6\n\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n#define luminanceThreshold (2.0 / 256.0)\n\nfloat pow2(const in float x) { return x * x; }\nfloat pow3(const in float x) { return x * x * x; }\nfloat pow4(const in float x) { float x2 = x * x; return x2 * x2; }\nfloat pow5(const in float x) { float x2 = x * x; return x2 * x2 * x; }\n\nfloat log10(const in float value)\n{\n    return log(value) / log(10.);\n}\n\nfloat hyperbolicDepthToLinear(const in float hyperbolicDepth, const in float zNear, const in float zFar)\n{\n    return -2.0 * zNear * zFar / (hyperbolicDepth * (zFar - zNear) - (zFar + zNear));\n}\n\nfloat hyperbolicDepthToLinearNormalized(const in float hyperbolicDepth, const in float zNear, const in float zFar)\n{\n    return (hyperbolicDepthToLinear(hyperbolicDepth, zNear, zFar) - zNear) / zFar;\n}\n\nvec4 encodeNormalizedFloatRGBA(const in float v)\n{\n    const vec4 multiplier = vec4(1.0, 255.0, 65025.0, 16581375.0);\n    const vec4 divider = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n\n    vec4 enc = multiplier * v;\n\n    enc = fract(enc);\n    enc -= enc.yzww * divider;\n\n    return enc;\n}\n\nfloat decodeNormalizedFloatRGBA(const in vec4 rgba)\n{\n    return dot(rgba, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n\nvec3 encodeFloatRGB(const in float v)\n{\n    vec3 rgb = vec3(0.);\n\n   rgb.r = floor(v / 65536.);\n   rgb.g = floor((v  - rgb.r * 65536.) / 256.);\n   rgb.b = floor(v - rgb.r * 65536. - rgb.g * 256.);\n\n   return rgb / 255.;\n}\n\nfloat decodeFloatRGB(const in vec3 rgb)\n{\n    return rgb.z + rgb.y * 256. + rgb.x * 65536.;\n}\n\nconst mat3 RGB2XYZ = mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n);\n\nconst mat3 XYZ2RGB = mat3(\n    3.2404542, -0.9692660, 0.0556434,\n    -1.5371385, 1.8760108, -0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n);\n\nvec3 XYZ2xyY(const in vec3 XYZ)\n{\n    float denominator = 1.0 / (XYZ.x + XYZ.y + XYZ.z);\n\n    return vec3(\n        XYZ.x * denominator,\n        XYZ.y * denominator,\n        XYZ.y\n    );\n}\n\nvec3 xyY2XYZ(const in vec3 xyY)\n{\n    return vec3(\n        xyY.x * xyY.z / xyY.y,\n        xyY.z,\n        (1.0 - xyY.x - xyY.y) * xyY.z / xyY.y\n    );\n}\n\nvec3 RGB2xyY(const in vec3 RGB)\n{\n    return XYZ2xyY(RGB2XYZ * RGB);\n}\n\nvec3 xyY2RGB(const in vec3 xyY)\n{\n    vec3 XYZ = xyY2XYZ(xyY);\n\n    return XYZ2RGB * XYZ;\n}\n\nconst mat3 LogLUVEncode = mat3(\n    0.2209, 0.3390, 0.4184,\n    0.1138, 0.6780, 0.7319,\n    0.0102, 0.1130, 0.2969\n);\n\nconst mat3 LogLUVDecode = mat3(\n    6.0013, -2.700, -1.7995,\n    -1.332, 3.1029, -5.7720,\n    0.3007, -1.088,  5.6268\n);\n\n// https://mynameismjp.wordpress.com/2008/12/12/logluv-encoding-for-hdr/\nvec4 RGB2LogLUV(const in vec3 RGB)\n{\n    vec4 result;\n\n    vec3 Xp_Y_XYZp = max(LogLUVEncode * RGB, vec3(1.e-6));\n\n    result.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\n    float Le = 2. * log2(Xp_Y_XYZp.y) + 127.;\n\n    result.w = fract(Le);\n    result.z = (Le - floor(result.w * 255.) / 255.) / 255.;\n\n    return result;\n}\n\nvec3 LogLuv2RGB(const in vec4 LogLuv)\n{\n    float Le = LogLuv.z * 255. + LogLuv.w;\n\n    vec3 Xp_Y_XYZp;\n\n    Xp_Y_XYZp.y = exp2((Le - 127.) * .5);\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / LogLuv.y;\n    Xp_Y_XYZp.x = LogLuv.x * Xp_Y_XYZp.z;\n\n    vec3 RGB = LogLUVDecode * Xp_Y_XYZp;\n\n    return max(RGB, 0.);\n}\n\n\n// Lambert Azimuthal Equal-Area projection\nvec2 packNormalToRG16F(const in vec3 n)\n{\n    float f = sqrt(8. * n.z + 8.);\n\n    return n.xy / f + .5;\n}\n\n// Lambert Azimuthal Equal-Area projection\nvec3 unpackNormalFromRG16F(const in vec2 enc)\n{\n    vec2 fenc = enc * 4. - 2.;\n    float f = dot(fenc, fenc);\n    float g = sqrt(1. - f / 4.);\n\n    vec3 n = vec3(fenc * g, 1. - f / 2.);\n\n    return n;\n}\n\nfloat linearRGBToLuminosity(const in vec3 linearRGB)\n{\n    return dot(linearRGB, vec3(0.2126729, 0.7151522, 0.0721750));\n}\n\nfloat linearRGBToPerceivedLuminosity(const in vec3 linearRGB)\n{\n    return dot(linearRGB, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 sample4x4Pattern(const in sampler2D colorMap, const in vec2 uv, const in vec2 texelSize, const in float delta)\n{\n    vec4 sum = vec4(0.);\n\n#ifdef GLES_3\n    sum += texture(colorMap, uv + texelSize * vec2(-1., +1.) * delta);\n    sum += texture(colorMap, uv + texelSize * vec2(+1., +1.) * delta);\n    sum += texture(colorMap, uv + texelSize * vec2(-1., -1.) * delta);\n    sum += texture(colorMap, uv + texelSize * vec2(+1., -1.) * delta);\n#else\n    sum += texture2D(colorMap, uv + texelSize * vec2(-1., +1.) * delta);\n    sum += texture2D(colorMap, uv + texelSize * vec2(+1., +1.) * delta);\n    sum += texture2D(colorMap, uv + texelSize * vec2(-1., -1.) * delta);\n    sum += texture2D(colorMap, uv + texelSize * vec2(+1., -1.) * delta);\n#endif\n\n    return sum * .25;\n}\n\nvec4 sample3x3Pattern(const in sampler2D colorMap, const in vec2 uv, const in vec2 texelSize)\n{\n    vec4 sum = vec4(0.);\n\n#ifdef GLES_3\n    sum += texture(colorMap, uv + texelSize * vec2(-.5, +.5)) * 4. / 9.;\n    sum += texture(colorMap, uv + texelSize * vec2(+1., +.5)) * 2. / 9.;\n    sum += texture(colorMap, uv + texelSize * vec2(-.5, -1.)) * 2. / 9.;\n    sum += texture(colorMap, uv + texelSize * vec2(+1., -1.)) * 1. / 9.;\n#else\n    sum += texture2D(colorMap, uv + texelSize * vec2(-.5, +.5)) * 4. / 9.;\n    sum += texture2D(colorMap, uv + texelSize * vec2(+1., +.5)) * 2. / 9.;\n    sum += texture2D(colorMap, uv + texelSize * vec2(-.5, -1.)) * 2. / 9.;\n    sum += texture2D(colorMap, uv + texelSize * vec2(+1., -1.)) * 1. / 9.;\n#endif\n\n    return sum;\n}\n\n#endif // MATH_GLSL\n"

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = "\nmat3 mat3_cast(const in mat4 m) { // solve problem with intel HD and safari.\n    return mat3(m[0].xyz, m[1].xyz, m[2].xyz);\n}\n\n#ifndef GLES_3\n#ifndef HAS_INCLUDED_MATRIX_ROUTINES_CHUNK\n#define HAS_INCLUDED_MATRIX_ROUTINES_CHUNK\n\nfloat determinant(const in mat2 m)\n{\n    return m[0].x * m[1].y - m[0].y * m[1].x;\n}\n\nfloat determinant(const in mat3 m)\n{\n    // float a = m[0].x, b = m[0].y, c = m[0].z;\n    // float d = m[1].x, e = m[1].y, f = m[1].z;\n    // float g = m[2].x, h = m[2].y, i = m[2].z;\n\n    // return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\n    return  m[0].x * (m[1].y * m[2].z - m[2].y * m[1].z)\n            - m[1].x * (m[0].y * m[2].z - m[2].y * m[0].z)\n            + m[2].x * (m[0].y * m[1].z - m[1].y * m[0].z);\n}\n\nmat2 transpose(const in mat2 m)\n{\n    mat2 tmp;\n\n\ttmp[0] = vec2(m[0].x, m[1].x);\n\ttmp[1] = vec2(m[0].y, m[1].y);\n\n\treturn tmp;\n}\n\nmat4 transpose(const in mat4 m)\n{\n    mat4 tmp;\n\n\ttmp[0] = vec4(m[0].x, m[1].x, m[2].x, m[3].x);\n\ttmp[1] = vec4(m[0].y, m[1].y, m[2].y, m[3].y);\n\ttmp[2] = vec4(m[0].z, m[1].z, m[2].z, m[3].z);\n\ttmp[3] = vec4(m[0].w, m[1].w, m[2].w, m[3].w);\n\n\treturn tmp;\n}\n\nmat3 transpose(const in mat3 m)\n{\n    mat3 tmp;\n\n\ttmp[0] = vec3(m[0].x, m[1].x, m[2].x);\n\ttmp[1] = vec3(m[0].y, m[1].y, m[2].y);\n\ttmp[2] = vec3(m[0].z, m[1].z, m[2].z);\n\n\treturn tmp;\n}\n\nmat2 inverse(const in mat2 m)\n{\n    return mat2(m[1].y,-m[0].y, -m[1].x, m[0].x) / (m[0].x * m[1].y - m[0].y * m[1].x);\n}\n\nmat3 inverse(const in mat3 m)\n{\n    float a00 = m[0].x, a01 = m[0].y, a02 = m[0].z;\n    float a10 = m[1].x, a11 = m[1].y, a12 = m[1].z;\n    float a20 = m[2].x, a21 = m[2].y, a22 = m[2].z;\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = a12 * a20 - a22 * a10;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (a02 * a21 - a22 * a01), (a12 * a01 - a02 * a11),\n                b11, (a22 * a00 - a02 * a20), (a02 * a10 - a12 * a00),\n                b21, (a01 * a20 - a21 * a00), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(const in mat4 m)\n{\n    float\n    a00 = m[0].x, a01 = m[0].y, a02 = m[0].z, a03 = m[0].w,\n    a10 = m[1].x, a11 = m[1].y, a12 = m[1].z, a13 = m[1].w,\n    a20 = m[2].x, a21 = m[2].y, a22 = m[2].z, a23 = m[2].w,\n    a30 = m[3].x, a31 = m[3].y, a32 = m[3].z, a33 = m[3].w,\n\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n\n    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n#endif\n#endif\n"

/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef VIEW_TO_CLIP_POSITION\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n#else\nuniform mat4 viewProjectionMatrix;\n#endif\n"

/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef VIEW_TO_CLIP_POSITION\nvec4 clipPosition = projectionMatrix * viewPosition;\n#else\nvec4 clipPosition = viewProjectionMatrix * worldPosition;\n#endif"

/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = "\n#pragma attribute(transform1, vec4, INSTANCE_TRANSFORM_1, 1);\n#pragma attribute(transform2, vec4, INSTANCE_TRANSFORM_2, 1);\n#pragma attribute(transform3, vec4, INSTANCE_TRANSFORM_3, 1);\n\nconst vec4 transform4 = vec4(0.0, 0.0, 0.0, 1.0);\n\n#if defined(SKINNING) || (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#pragma attribute(instanceIdentifiers, vec2, INSTANCE_IDENTIFIERS, 1);\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#pragma include(math.glsl)\n\n#ifdef GLES_3\nout vec3 vInstanceUniqueColor;\n#else\nvarying vec3 vInstanceUniqueColor;\n#endif // GLES_3\n\n#endif // instance color output\n#endif // instanceIdentifiers attribute\n\n"

/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "\nmat4 matrixWorld = transpose(mat4(transform1, transform2, transform3, transform4));\n\n#ifdef SKINNING\nmat4 boneTransform =\n    boneWeights.x * getBoneMatrix(instanceIdentifiers.x, boneIndices.x) +\n    boneWeights.y * getBoneMatrix(instanceIdentifiers.x, boneIndices.y) +\n    boneWeights.z * getBoneMatrix(instanceIdentifiers.x, boneIndices.z) +\n    boneWeights.w * getBoneMatrix(instanceIdentifiers.x, boneIndices.w);\n\n#ifdef IGNORE_TRANSLATION\nvec4 objectPosition = vec4(position, 0.0) * boneTransform;\n#else\nvec4 objectPosition = vec4(position, 1.0) * boneTransform;\n#endif\n\n#else\n#ifdef IGNORE_TRANSLATION\nvec4 objectPosition = vec4(position, 0.0);\n#else\nvec4 objectPosition = vec4(position, 1.0);\n#endif\n#endif\n\n#if defined(POSITION_MORPH_COUNT)\n#if POSITION_MORPH_COUNT > 0\nobjectPosition.xyz += morphWeights[0] * morphPosition0;\n#endif\n\n#if POSITION_MORPH_COUNT > 1\nobjectPosition.xyz += morphWeights[1] * morphPosition1;\n#endif\n\n#if POSITION_MORPH_COUNT > 2\nobjectPosition.xyz += morphWeights[2] * morphPosition2;\n#endif\n\n#if POSITION_MORPH_COUNT > 3\nobjectPosition.xyz += morphWeights[3] * morphPosition3;\n#endif\n\n#if POSITION_MORPH_COUNT > 4\nobjectPosition.xyz += morphWeights[4] * morphPosition4;\n#endif\n\n#if POSITION_MORPH_COUNT > 5\nobjectPosition.xyz += morphWeights[5] * morphPosition5;\n#endif\n\n#if POSITION_MORPH_COUNT > 6\nobjectPosition.xyz += morphWeights[6] * morphPosition6;\n#endif\n\n#if POSITION_MORPH_COUNT > 7\nobjectPosition.xyz += morphWeights[7] * morphPosition7;\n#endif\n#endif\n\nvec4 worldPosition = matrixWorld * objectPosition;\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\nvInstanceUniqueColor = encodeFloatRGB(instanceIdentifiers.y);\n#endif\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef VIEW_TO_CLIP_POSITION\nvec4 viewPosition = viewMatrix * worldPosition;\n#endif\n"

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef SKINNING\nmat3 matrixNormal = transpose(inverse(mat3_cast(matrixWorldView * transpose(boneTransform))));\n#else\nmat3 matrixNormal = transpose(inverse(mat3_cast(matrixWorldView)));\n#endif\n\nvec3 objectNormal = normal.xyz;\n\n#if defined(NORMAL_MORPH_COUNT)\n#if NORMAL_MORPH_COUNT > 0\nobjectNormal += morphWeights[0] * morphNormal0;\n#endif\n\n#if NORMAL_MORPH_COUNT > 1\nobjectNormal += morphWeights[1] * morphNormal1;\n#endif\n\n#if NORMAL_MORPH_COUNT > 2\nobjectNormal += morphWeights[2] * morphNormal2;\n#endif\n\n#if NORMAL_MORPH_COUNT > 3\nobjectNormal += morphWeights[3] * morphNormal3;\n#endif\n\n#if NORMAL_MORPH_COUNT > 4\nobjectNormal += morphWeights[4] * morphNormal4;\n#endif\n\n#if NORMAL_MORPH_COUNT > 5\nobjectNormal += morphWeights[5] * morphNormal5;\n#endif\n\n#if NORMAL_MORPH_COUNT > 6\nobjectNormal += morphWeights[6] * morphNormal6;\n#endif\n\n#if NORMAL_MORPH_COUNT > 7\nobjectNormal += morphWeights[7] * morphNormal7;\n#endif\n#endif\n\nvec3 normalizedViewSpaceNormal = normalize(matrixNormal * objectNormal);\n\nvNormal = normalizedViewSpaceNormal;\n"

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = "\nvec2 transformUv(mat3 _xfrm, vec2 _uv) {\n    return (_xfrm * vec3(_uv, 1.0)).xy;\n}\n"

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = "\nuniform mat3 colorMapTransform;\n#ifdef GLES_3\nout vec2 vColorMapUv;\n#else\nvarying vec2 vColorMapUv;\n#endif\n"

/***/ }),
/* 188 */
/***/ (function(module, exports) {

module.exports = "\nuniform mat3 albedoMapTransform;\n#ifdef GLES_3\nout vec2 vAlbedoMapUv;\n#else\nvarying vec2 vAlbedoMapUv;\n#endif\n"

/***/ }),
/* 189 */
/***/ (function(module, exports) {

module.exports = "\nuniform mat3 normalMapTransform;\n#ifdef GLES_3\nout vec2 vNormalMapUv;\n#else\nvarying vec2 vNormalMapUv;\n#endif\n"

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = "\nuniform float normalScale;\n\n// if any questions: http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html\nvec3 getViewSpaceNormalFromMap(vec3 viewNormal, vec3 viewPosition, vec2 uv) {\n    vec3 q0 = dFdx(viewPosition);\n    vec3 q1 = dFdy(viewPosition);\n\n    vec2 st0 = dFdx(uv.st);\n    vec2 st1 = dFdy(uv.st);\n\n    float flip = sign(st1.t * st0.s - st0.t * st1.s);\n\n    vec3 S = normalize((q0 * st1.t - q1 * st0.t) * flip);\n    vec3 T = normalize((-q0 * st1.s + q1 * st0.s) * flip);\n    vec3 N = normalize(viewNormal);\n\n    mat3 toView = mat3(S, T, N);\n\n    // TODO:: maybe create chunk with rgb to normal function\n    vec3 tsNormal = _normalMapReadFunc(uv).xyz * 2.0 - 1.0;\n\n    tsNormal.xy *= normalScale;\n\n    return normalize(toView * tsNormal);\n}\n"

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef METALNESS_ROUGHNESS_MAP\nuniform mat3 metalnessRoughnessMapTransform;\n#ifdef GLES_3\nout vec2 vMetalnessRoughnessMapUv;\n#else\nvarying vec2 vMetalnessRoughnessMapUv;\n#endif\n#endif\n"

/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef AMBIENT_OCCLUSION_MAP\nfloat ambientOcclusion = _ambientOcclusionMapReadFunc(vAmbientOcclusionMapUv).r;\n\nvec3 luminanceDiffuse_ = indirectLightFragContext.luminanceDiffuse;\nvec3 luminanceSpecular_ = indirectLightFragContext.luminanceSpecular;\n\nindirectLightFragContext.luminanceDiffuse =\n    mix(luminanceDiffuse_, luminanceDiffuse_ * ambientOcclusion, ambientOcclusionStrength);\n\nindirectLightFragContext.luminanceSpecular =\n    mix(luminanceSpecular_, luminanceSpecular_ * ambientOcclusion, ambientOcclusionStrength);\n\n#pragma fragOutput(COLOR_2, ba, vec2(ambientOcclusion, ambientOcclusionStrength))\n#endif\n"

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = "#ifdef AMBIENT_OCCLUSION_MAP\nuniform mat3 ambientOcclusionMapTransform;\n\n#ifdef GLES_3\nout vec2 vAmbientOcclusionMapUv;\n#else\nvarying vec2 vAmbientOcclusionMapUv;\n#endif\n#endif\n"

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef AMBIENT_OCCLUSION_MAP\n#ifdef GLES_3\nin vec2 vAmbientOcclusionMapUv;\n#else\nvarying vec2 vAmbientOcclusionMapUv;\n#endif\n\nuniform float ambientOcclusionStrength;\n#endif\n"

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = "#ifdef WORLD_SPACE_VARYINGS\n\n#ifdef GLES_3\nout vec3 vPositionWorld;\n#else\nvarying vec3 vPositionWorld;\n#endif\n\n#endif\n"

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = "#ifdef WORLD_SPACE_VARYINGS\n\n#ifdef GLES_3\nin vec3 vPositionWorld;\n#else\nvarying vec3 vPositionWorld;\n#endif\n\n#endif\n"

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = "    #ifdef WORLD_SPACE_VARYINGS\n\n    vPositionWorld = vec3(worldPosition);\n\n    #endif\n"

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = "#ifdef WORLD_SPACE_FRAG_CONTEXT\nuniform mat4 cameraWorldMatrix;\n#endif"

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = "    #ifdef WORLD_SPACE_FRAG_CONTEXT\n\n    vec3 camPos = vec3(cameraWorldMatrix[3]);\n\n    vec3 viewWorld = normalize(camPos - vPositionWorld);\n\n    vec3 normalWorld = normalize((cameraWorldMatrix * vec4(normal, 0.)).xyz);\n\n    #endif\n"

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = "\n#if defined(SH_BAND_COUNT) && SH_BAND_COUNT > 0\n#define SH_COUNT SH_BAND_COUNT * SH_BAND_COUNT\nuniform vec3 iblSH[SH_COUNT];\n\nvec3 illuminanceSH(const in vec3 n)\n{\n    return max(\n    #if SH_BAND_COUNT >= 1\n    iblSH[0]\n    #endif\n\n    #if SH_BAND_COUNT >= 2\n    + iblSH[1] * n.x\n    + iblSH[2] * n.y\n    + iblSH[3] * n.z\n    #endif\n\n    #if SH_BAND_COUNT == 3\n    + iblSH[4] * n.x * n.z\n    + iblSH[5] * n.z * n.y\n    + iblSH[6] * n.y * n.x\n    + iblSH[7] * (3.0 * n.z * n.z - 1.0)\n    + iblSH[8] * (n.x * n.x - n.y * n.y)\n    #endif\n\n    , vec3(0.0));\n}\n#endif\n"

/***/ }),
/* 201 */
/***/ (function(module, exports) {

module.exports = "#ifdef DIFFUSE_ILLUMINANCE_MAP\nuniform samplerCube _illuminanceMap;\n#endif\n"

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports = "#ifdef PRE_FILTERED_ENV_MAP\nuniform samplerCube _preFilteredEnvMap;\n\nuniform float maxReflectionLOD;\n\nvec3 prefilteredEnvMapColor(const in vec3 envMapSamplingVector, const in float roughness)\n{\n    float lod = maxReflectionLOD * roughness;\n\n    #ifdef GLES_3\n        vec3 preFilteredEnvColor = textureLod(_preFilteredEnvMap, envMapSamplingVector, lod).rgb;\n    #else\n        vec3 preFilteredEnvColor = LogLuv2RGB(textureCubeLodEXT(_preFilteredEnvMap, envMapSamplingVector, lod));\n    #endif\n\n    return preFilteredEnvColor;\n}\n#endif"

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = "\n#if defined(ALBEDO_MAP)\nvec4 albedoMap = _albedoMapReadFunc(vAlbedoMapUv);\n\nalpha *= albedoMap.a;\nalbedo_ *= albedoMap.rgb;\n#endif\n"

/***/ }),
/* 204 */
/***/ (function(module, exports) {

module.exports = "\n#if defined(NORMAL_MAP)\nvec3 normal = getViewSpaceNormalFromMap(vNormal, vViewPosition, vNormalMapUv);\n#else\nvec3 normal = normalize(vNormal);\n#endif\n\n#if defined(HAS_BACK_SIDE)\nnormal *= (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\n"

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = "\n#if defined(METALNESS_ROUGHNESS_MAP)\nvec2 metalnessRoughnessMap = _metalnessRoughnessMapReadFunc(vMetalnessRoughnessMapUv).bg;\n\nmaterial.metalness *= metalnessRoughnessMap.r;\nmaterial.roughness *= metalnessRoughnessMap.g;\n#endif\n"

/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef TROWBRIDGE_REITZ_NDF\n#define TROWBRIDGE_REITZ_NDF\nfloat normalDistributionFunc(const in float a2, const in float nh) {\n    float denom = max(EPSILON, pow2(nh) * (a2 - 1.0) + 1.0);\n\n    return RECIPROCAL_PI * a2 / pow2(denom);\n}\n#endif\n"

/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef SPECULAR_BRDF_GEOMETRY_FUNC\n#define SPECULAR_BRDF_GEOMETRY_FUNC\n\nfloat geometryIBLFunc(in float nl, in float nv, in float a)\n{\n    float k = 0.5 * a;\n\n    float gl = k + (1.0 - k) * nl;\n    float gv = k + (1.0 - k) * nv;\n\n    return (nl * nv) / max(gl * gv, EPSILON);\n}\n\nfloat geometryFunc(const in float a2, const in float nl, const in float nv) {\n    float gl = nl + sqrt(a2 + (1.0 - a2) * pow2(nl));\n    float gv = nv + sqrt(a2 + (1.0 - a2) * pow2(nv));\n\n    return 1.0 / max(gl * gv, EPSILON);\n}\n\n#endif\n"

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n#pragma include(schlickFunc.glsl)\n#pragma include(materialPBR.glsl)\n#pragma include(lightFragContext.glsl)\n\nvec3 burleyBRDF(const in DirectLightFragContext directLightFragContext, const in MaterialPBR material)\n{\n    vec3 f0 = vec3(1.0);\n\n    float fd90 = material.energyBias + 2.0 * pow2(directLightFragContext.hl) * material.roughness;\n\n    vec3 f90 = vec3(fd90);\n\n    float lightScatter = schlickFunc(f0, f90 , directLightFragContext.nl).r;\n    float viewScatter = schlickFunc(f0, f90 , directLightFragContext.nv).r;\n\n    return material.albedo * material.energyFactor * lightScatter * viewScatter * RECIPROCAL_PI;\n}\n"

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n#pragma include(materialPBR.glsl)\n#pragma include(lightFragContext.glsl)\n\nvec3 lambertBRDF(const in DirectLightFragContext directLightFragContext, const in MaterialPBR material) {\n    return material.albedo * RECIPROCAL_PI;\n}\n\nvec3 lambertBRDF(const in MaterialPBR material) {\n    return material.albedo * RECIPROCAL_PI;\n}\n"

/***/ }),
/* 210 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n#pragma include(schlickFunc.glsl)\n#pragma include(materialPBR.glsl)\n#pragma include(lightFragContext.glsl)\n#pragma include(trowbridgeReitzNDF.glsl)\n#pragma include(geometryFunc.glsl)\n\nvec3 specularBRDF(const in DirectLightFragContext directLightFragContext, const in MaterialPBR material) {\n    vec3 f90 = vec3(1.0);\n\n    vec3 f = schlickFunc(material.f0, f90, directLightFragContext.hv);\n\n    float d = normalDistributionFunc(material.alpha2, directLightFragContext.nh);\n\n    float g = geometryFunc(material.alpha2, directLightFragContext.nl, directLightFragContext.nv);\n\n    return f * d * g;\n}\n\n#ifdef CLEAR_COAT\nfloat clearCoatBRDF(const in float f, const in DirectLightFragContext directLightFragContext, const in MaterialPBR material)\n{\n    float alpha2 = pow2(material.clearCoatAlpha);\n\n    float d = normalDistributionFunc(alpha2, directLightFragContext.nh);\n\n    float g = 0.25 / max(EPSILON, pow2(directLightFragContext.hl));\n\n    return d * g * f;\n}\n#endif\n"

/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = "\nmat4 matrixWorldView = viewMatrix * matrixWorld;\n"

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n#pragma include(schlickFunc.glsl)\n#pragma include(materialPBR.glsl)\n#pragma include(lightFragContext.glsl)\n\n#if DIRECTIONAL_LIGHTS_COUNT > 0\nstruct DirectionalLight {\n    vec3 luminance;\n    vec3 viewSpaceDirection;\n};\n\nuniform DirectionalLight directionalLight[DIRECTIONAL_LIGHTS_COUNT];\n#endif\n\n#ifdef USE_AMBIENT_LIGHT\nstruct AmbientLight {\n    vec3 luminance;\n};\n\nuniform AmbientLight ambientLight;\n#endif\n\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3    luminousIntensity;\n    vec3    viewSpacePosition;\n    float   size;\n    float   invAttenRadius;\n};\n\nuniform PointLight pointLight[POINT_LIGHTS_COUNT];\n#endif\n\n#if SPOT_LIGHTS_COUNT > 0\nstruct SpotLight {\n    vec3    luminousIntensity;\n    vec3    viewSpacePosition;\n    vec3    viewSpaceDirection;\n    float   size;\n    float   invAttenRadius;\n    float   lightAngleScale;\n    float   lightAngleOffset;\n};\n\nuniform SpotLight spotLight[SPOT_LIGHTS_COUNT];\n#endif\n\n#pragma include(lambertBRDF.glsl)\n\n#if defined(BURLEY_DIFFUSE)\n#pragma include(burleyBRDF.glsl)\n#define diffuseBRDF burleyBRDF\n#elif defined(LAMBERT_DIFFUSE)\n#define diffuseBRDF lambertBRDF\n#endif\n\n#ifdef BRDF_LUT\nuniform sampler2D _brdfLUT;\n#endif\n\n#pragma include(specularBRDF.glsl)\n\n#pragma include(shadowMapParamsFrag.glsl)\n\n\nvoid directLightFunc(const in MaterialPBR material, inout DirectLightFragContext directLightFragContext)\n{\n    vec3 luminance = directLightFragContext.luminance;\n\n    float lighted = directLightFragContext.lighted;\n\n    luminance *= lighted;\n\n    float cosTheta = directLightFragContext.nl;\n\n    vec3 fd = diffuseBRDF(directLightFragContext, material);\n    vec3 fr = specularBRDF(directLightFragContext, material);\n\n    #ifdef CLEAR_COAT\n    vec3 clearCoatF0 = vec3(0.04); // always polyurethane\n    float clearCoat = material.clearCoat;\n    float clearCoatF = schlickFunc(clearCoatF0, vec3(1.0), directLightFragContext.hl).r * clearCoat;\n    float frc = clearCoatBRDF(clearCoatF, directLightFragContext, material);\n\n    directLightFragContext.diffuse = fd * luminance * cosTheta * (1.0 - clearCoatF);\n    directLightFragContext.specular = (fr + frc) * luminance * cosTheta * pow2(1.0 - clearCoatF);\n    #else\n    directLightFragContext.diffuse = fd * luminance * cosTheta;\n    directLightFragContext.specular = fr * luminance * cosTheta;\n    #endif\n}\n\nvoid indirectLightFunc(const in MaterialPBR material, inout IndirectLightFragContext indirectLightFragContext)\n{\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n\n    vec3 viewWorld = indirectLightFragContext.viewWorld;\n    vec3 normalWorld = indirectLightFragContext.normalWorld;\n\n    float nv = saturate(dot(normalWorld, viewWorld));\n\n    vec3 f0 = material.f0;\n    vec3 f90 = max(vec3(1.0 - material.roughness), f0);\n\n    vec3 F = schlickFunc(f0, f90, nv);\n\n    vec3 diffuseSpecularTradeOff = vec3(1.0) - F;\n\n    vec3 fd = lambertBRDF(material) * diffuseSpecularTradeOff;\n\n    vec3 fr = vec3(0.0);\n\n    #ifdef BRDF_LUT\n    {\n        #ifdef GLES_3\n        vec2 brdf = texture(_brdfLUT, vec2(nv, material.roughness)).rg;\n        #else\n        vec2 brdf = LogLuv2RGB(texture2D(_brdfLUT, vec2(nv, material.roughness))).rg;\n        #endif\n\n        fr = (F * brdf.x + brdf.y);\n    }\n    #endif\n\n    diffuse = fd * indirectLightFragContext.luminanceDiffuse;\n    specular = fr * indirectLightFragContext.luminanceSpecular;\n\n    #ifdef CLEAR_COAT\n    vec3 clearCoatF0 = vec3(0.04); // always polyurethane\n    float clearCoat = material.clearCoat;\n    float clearCoatF = schlickFunc(clearCoatF0, vec3(1.0), nv).r * clearCoat;\n\n    diffuse *= (1.0 - clearCoatF);\n    specular *= pow2(1.0 - clearCoatF);\n    specular += indirectLightFragContext.luminanceClearCoat * clearCoatF;\n    #endif\n\n    indirectLightFragContext.diffuse = diffuse;\n    indirectLightFragContext.specular = specular;\n}\n"

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef SCHLICK_FUNC\n#define SCHLICK_FUNC\n\nvec3 schlickFunc(const in vec3 f0, const in vec3 f90, const in float u) {\n    return f0 + (f90 - f0) * pow5(1.0 - u);\n}\n\n#endif\n"

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef MATERIAL_PBR\n#define MATERIAL_PBR\n\nvec3 computeF0(const in float _normalIncidenceFresnel, const in float _metalness, const in vec3 _albedo) {\n    vec3 f0 = mix(vec3(_normalIncidenceFresnel), _albedo, _metalness);\n\n    #ifdef CLEAR_COAT\n    f0 = sqrt(f0);\n\n    vec3 numerator = vec3(1.0) - 5.0 * f0;\n    numerator *= numerator;\n\n    vec3 denom = vec3(5.0) - f0;\n    denom *= denom;\n\n    f0 = numerator / denom;\n    #endif\n\n    return f0;\n}\n\nstruct MaterialPBR {\n    vec3 albedo;\n    vec3 f0;\n    float metalness;\n    float roughness;\n    float roughnessSq;\n    float alpha2;\n    float clearCoat;\n    float clearCoatRoughness;\n    float clearCoatAlpha;\n    float energyBias;\n    float energyFactor;\n};\n#endif\n"

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = "\n#ifndef LIGHT_FRAG_CONTEXT\n#define LIGHT_FRAG_CONTEXT\n\nstruct DirectLightFragContext {\n    vec3 luminance;\n    float nv;\n    float hv;\n    float nl;\n    float nh;\n    float hl;\n\n    float lighted;\n\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct IndirectLightFragContext {\n    vec3 luminanceDiffuse;\n    vec3 luminanceSpecular;\n    vec3 luminanceClearCoat;\n    vec3 viewWorld;\n    vec3 normalWorld;\n\n    vec3 diffuse;\n    vec3 specular;\n};\n\n#endif\n"

/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = "\nmaterial.metalness = metalness;\nmaterial.roughness = roughness;\n\n#pragma include(metalnessRoughnessMapFrag.glsl)\n\nmaterial.albedo = albedo_ * (1.0 - material.metalness);\nmaterial.roughnessSq = pow2(material.roughness);\nmaterial.alpha2 = pow2(material.roughnessSq);\nmaterial.energyBias = mix(0.0, 0.5, material.roughness);\nmaterial.energyFactor = mix(1.0,  1.0 / 1.51, material.roughness);\nmaterial.f0 = computeF0(normalIncidenceFresnel, saturate(material.metalness), albedo_);\n\n#ifdef CLEAR_COAT\n#pragma include(clearCoatFrag.glsl)\n#endif\n"

/***/ }),
/* 217 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n\nfloat smoothAttenFactor(const in float sqDistance, const in float invSqAttenRadius) {\n    float factor = sqDistance * invSqAttenRadius;\n    float smoothFactor = saturate(1.0 - factor * factor);\n\n    return smoothFactor * smoothFactor;\n}\n\nfloat distanceAttenuation(const in vec3 lightVector, const in float sqSize, const in float invSqAttenRadius) {\n    float sqDistance = dot(lightVector, lightVector);\n    float atten = 1.0 / max(sqDistance, sqSize);\n\n    atten *= smoothAttenFactor(sqDistance, invSqAttenRadius);\n\n    return atten; // 1 / m^2\n}\n\nfloat angleAttenuation(\n    const in vec3 lightVector,\n    const in vec3 lightDir,\n    const in float lightAngleScale,\n    const in float lightAngleOffset)\n{\n    float ld = dot(lightVector, lightDir);\n    float atten = saturate(ld * lightAngleScale + lightAngleOffset);\n\n    atten *= atten;\n\n    return atten;\n}\n"

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = "\n#pragma include(math.glsl)\n\nuniform float manualExposure;\n\n#ifdef FILMIC_TM_CURVE\n    uniform vec3 filmicCurveSettingsA;\n    uniform vec3 filmicCurveSettingsB;\n#endif\n\n\nfloat computeEV100FromAvgLuminance(const in float avgLuminance)\n{\n    // http://en.wikipedia.org/wiki/Film_speed\n    return log2(avgLuminance * 100. / 12.5);\n}\n\nfloat convertEV100ToExposure(const in float EV100)\n{\n    // https://en.wikipedia.org/wiki/Film_speed#Saturation-based_speed\n    float maxLuminance = 1.2 * exp2(EV100);\n    return 1. / maxLuminance;\n}\n\nfloat convertEV100ToLuminance(const in float EV100)\n{\n    // http://en.wikipedia.org/wiki/Film_speed\n    return exp2(EV100) * 12.5 / 100.;\n}\n\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    .59719, .35458, .04823,\n    .07600, .90834, .01566,\n    .02840, .13383, .83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(const in vec3 v)\n{\n    vec3 a = v * (v + .0245786) - .000090537;\n    vec3 b = v * (.983729 * v + .4329510) + .238081;\n\n    return a / b;\n}\n\nvec3 ACESFittedToneMapping(const in vec3 sRGB)\n{\n    vec3 color = sRGB * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = saturate(color);\n\n    return color;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESToneMapping(const in vec3 RGB)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n\n    return (RGB * (A * RGB + B)) / (RGB * (C * RGB + D) + E);\n}\n\n// http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\nvec3 toneMapDragoLogarithmic(const in vec3 hdrColor, const float maxLuminance)\n{\n    const float bias = .75;\n\n    float scalefactor = 3. / log10(maxLuminance + 1.1);\n\n    vec3 XYZ = RGB2XYZ * hdrColor;\n    vec3 xyY = XYZ2xyY(XYZ);\n\n    float pixelLuminance = xyY.z * manualExposure;\n\n    float luminanceScale = pixelLuminance / maxLuminance;\n    float luminanceDensityModulation = pow(luminanceScale, log(bias) / log(.5));\n\n    float mappedLuminance = scalefactor * log(pixelLuminance + 1.) / log(2. + luminanceDensityModulation * 8.);\n\n    xyY.z = mappedLuminance;\n\n    return xyY2RGB(xyY);\n}\n\nvec3 Uncharted2Func(float A, float B, float C, float D, float E, float F, vec3 x)\n{\n    return ((x *(A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}  \n\nvec3 toneMapU2Func(float A, float B, float C, float D, float E, float F, vec3 color, float numMultiplier)\n{  \n    vec3 numerator = Uncharted2Func(A, B, C, D, E, F, color);\n    numerator = max(numerator, 0.0);\n    numerator.rgb *= numMultiplier;\n\n    vec3 denominator = Uncharted2Func(A, B, C, D, E, F, vec3(11.2));\n    denominator = max(denominator, 1.0e-6);\n\n    return numerator / denominator;\n}\n\nvec3 toneMappingUncharted2Func(vec3 HDRColor, const float avgLuminance)\n{\n    const vec3 A = vec3(0.25, 0.30606, 0.09975);\n    const vec3 B = vec3(0.35, 0.025, 0.4);\n    const vec3 C = vec3(0.24516, 1.5019, 0.5);\n    \n    float _avgLuminance = clamp(avgLuminance, 1.0e-4, 1.0e+9);\n\n    float scaledWhitePoint = C.x * 11.2;\n\n    float luma = _avgLuminance / scaledWhitePoint;\n    luma = pow(luma, C.z);\n\n    luma = luma * scaledWhitePoint;\n    luma = C.x / luma;\n\n    vec3 color = toneMapU2Func(\n        A.x, A.y, A.z,\n        B.x, B.y, B.z,\n        luma * HDRColor, C.y\n    );\n\n    return color;\n}\n\nvec3 toneMappingFunc(const in vec3 hdrColor)\n{\n    vec3 XYZ = RGB2XYZ * hdrColor;\n    vec3 xyY = XYZ2xyY(XYZ);\n\n    xyY.z *= manualExposure;\n\n    XYZ = xyY2XYZ(xyY);\n\n    vec3 lin = XYZ2RGB * XYZ;\n\n    vec3 ldr = saturate(lin / (1.0  + lin));\n\n    return ldr;\n}\n\n#ifdef FILMIC_TM_CURVE\n    vec3 filmicCurveToneMapping(const in vec3 colorLDR)\n    {\n        vec3 x0 = vec3(filmicCurveSettingsA.x);\n        vec3 y0 = vec3(filmicCurveSettingsA.y);\n\n        vec3 x1 = vec3(filmicCurveSettingsB.x);\n        vec3 y1 = vec3(filmicCurveSettingsB.y);\n\n        vec3 exponent = vec3(filmicCurveSettingsA.z);\n        vec3 W = vec3(filmicCurveSettingsB.z);\n\n        vec3 c = clamp(colorLDR, vec3(0.), W);\n\n        bvec3 toePart = lessThan(c, x0);\n        bvec3 shoulderPart = greaterThanEqual(c, x1);\n        bvec3 linearPart = equal(toePart, shoulderPart);\n\n        vec3 toe = y0 * pow(c / x0, exponent);\n        vec3 linear = c - x0 + y0;\n        vec3 shoulder = 1. - (1. - y1) * pow((W - c) / (W - x1), (W - x1) / (1. - y1));\n\n        return toe * vec3(toePart) + linear * vec3(linearPart) + shoulder * vec3(shoulderPart);\n    }\n#endif\n"

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = "\nvec3 rgbToSrgb(const in vec3 saturatedColorRGB, const in float gammaCorrection)\n{\n    vec3 sRGBLo = saturatedColorRGB * 12.92;\n    vec3 sRGBHi = (pow(abs(saturatedColorRGB) , vec3(gammaCorrection)) * 1.055) - 0.055;\n\n    return mix(sRGBHi, sRGBLo, vec3(lessThanEqual(saturatedColorRGB, vec3(0.0031308))));\n}\n\n\nvec4 linearRGB2sRGB(const in vec4 linearRGBColor, const in vec4 gammaCompression)\n{\n    vec4 sRGBLo = linearRGBColor * 12.92;\n    vec4 sRGBHi = (pow(abs(linearRGBColor), gammaCompression) * 1.055) - 0.055;\n\n    const vec4 edge = vec4(0.0031308);\n\n    return mix(sRGBHi, sRGBLo, vec4(lessThanEqual(linearRGBColor, edge)));\n}\n\nvec4 sRGB2linearRGB(const in vec4 sRGBColor, const in vec4 gammaExpansion)\n{\n    const vec4 zero = vec4(0.);\n\n    vec4 x = sRGBColor / 12.92;\n    vec4 y = pow(max((sRGBColor + .055) / 1.055, zero), gammaExpansion);\n\n    const vec4 edge = vec4(.04045);\n\n    return mix(y, x, vec4(lessThanEqual(sRGBColor, edge)));\n}\n"

/***/ }),
/* 220 */
/***/ (function(module, exports) {

module.exports = "    #ifdef ALPHA_TEST\n    if (alpha < float(ALPHA_TEST)) discard;\n\n    alpha = 1.0;\n    #endif\n"

/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef SHADOW_MAPPING\n\n    #if defined(DIRECT_SHADOW_CASTERS_COUNT) && DIRECT_SHADOW_CASTERS_COUNT > 0\n        // #define DEBUG_SHADOW_CASCADES\n\n        uniform float cameraNearFar[2];\n\n        const int kCASCADED_SHADOW_MAPS_SAMPLERS_COUNT = DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT;\n\n        uniform float frustumSplits[CSM_CASCADES_COUNT];\n\n        uniform mat4 directShadowCastersTransforms[kCASCADED_SHADOW_MAPS_SAMPLERS_COUNT];\n\n        uniform int directShadowCastersMask[DIRECTIONAL_LIGHTS_COUNT];\n\n        #ifdef GLES_3\n        #define POISSON_FILTERING\n        uniform highp sampler2DArrayShadow directShadowCastersSamplers;\n        #else\n        uniform sampler2D directShadowCastersSamplers[kCASCADED_SHADOW_MAPS_SAMPLERS_COUNT];\n        uniform float shadowMapSize;\n\n        #define SAMPLE_CSM_CASTER(I, N, V) else if (I == N) rgba = texture2D(directShadowCastersSamplers[N], V);\n        #endif\n\n        int cascadeIndex(const in float depth)\n        {\n            int cascadeIndex = 0;\n\n            // https://github.com/SaschaWillems/Vulkan/blob/master/data/shaders/shadowmappingcascade/scene.frag#L80\n            for (int i = 0; i < CSM_CASCADES_COUNT; ++i) {\n                if (depth < frustumSplits[i]) {\n                    cascadeIndex = i;\n                    break;\n                }\n            }\n\n            return cascadeIndex;\n        }\n    #endif\n\n    #if defined(SPOT_SHADOW_CASTERS_COUNT) && SPOT_SHADOW_CASTERS_COUNT > 0\n        uniform int spotShadowCastersMask[SPOT_LIGHTS_COUNT];\n\n        uniform mat4 spotShadowCastersTransforms[SPOT_SHADOW_CASTERS_COUNT];\n\n        #ifdef GLES_3\n        #define POISSON_FILTERING\n        uniform highp sampler2DArrayShadow spotShadowCastersSamplers;\n        #else\n        uniform sampler2D spotShadowCastersSamplers[SPOT_SHADOW_CASTERS_COUNT];\n        uniform float spotCastersShadowMapSize;\n\n        #define SAMPLE_SPOT_SHADOW_CASTER(I, N, V) else if (I == N) rgba = texture2D(spotShadowCastersSamplers[N], V);\n        #endif\n    #endif\n\n    #if defined(OMNI_SHADOW_CASTERS_COUNT) && OMNI_SHADOW_CASTERS_COUNT > 0\n        uniform int omniShadowCastersMask[POINT_LIGHTS_COUNT];\n\n        #ifdef GLES_3\n        uniform highp samplerCubeShadow omniShadowCastersSamplers[OMNI_SHADOW_CASTERS_COUNT];\n        #else\n        uniform highp samplerCube omniShadowCastersSamplers[OMNI_SHADOW_CASTERS_COUNT];\n        #endif\n\n        #ifdef GLES_3\n            #define GRID_SAMPLING_DISK_SIZE 20\n\n            const vec4 kGRID_SAMPLING_DISK[GRID_SAMPLING_DISK_SIZE] = vec4[](\n                vec4(1.0, 1.0,  1.0, 0.0), vec4( 1.0, -1.0,  1.0, 0.0), vec4(-1.0, -1.0,  1.0, 0.0), vec4(-1.0, 1.0,  1.0, 0.0), \n                vec4(1.0, 1.0, -1.0, 0.0), vec4( 1.0, -1.0, -1.0, 0.0), vec4(-1.0, -1.0, -1.0, 0.0), vec4(-1.0, 1.0, -1.0, 0.0),\n                vec4(1.0, 1.0,  0.0, 0.0), vec4( 1.0, -1.0,  0.0, 0.0), vec4(-1.0, -1.0,  0.0, 0.0), vec4(-1.0, 1.0,  0.0, 0.0),\n                vec4(1.0, 0.0,  1.0, 0.0), vec4(-1.0,  0.0,  1.0, 0.0), vec4( 1.0,  0.0, -1.0, 0.0), vec4(-1.0, 0.0, -1.0, 0.0),\n                vec4(0.0, 1.0,  1.0, 0.0), vec4( 0.0, -1.0,  1.0, 0.0), vec4( 0.0, -1.0, -1.0, 0.0), vec4( 0.0, 1.0, -1.0, 0.0)\n            );\n\n            #define SAMPLE_OMNI_SHADOW_CASTER(N, V) case N: shaded += 1.0 - texture(omniShadowCastersSamplers[N], V); break;\n        #else\n            #define SAMPLE_OMNI_SHADOW_CASTER(I, N, V) else if (I == N) rgba = textureCube(omniShadowCastersSamplers[N], V);\n        #endif\n\n    #endif\n\n    #ifdef POISSON_FILTERING\n        const float kSPREAD_VALUE = 8.0e+3;\n\n        // http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#poisson-sampling\n        const int kPOISSON_DISK_SIZE = 16;\n\n        vec2 kPOISSON_DISK[kPOISSON_DISK_SIZE] = vec2[kPOISSON_DISK_SIZE](\n            vec2(-0.94201624, -0.39906216),\n            vec2(0.94558609, -0.76890725),\n            vec2(-0.094184101, -0.92938870),\n            vec2(0.34495938, 0.29387760),\n            vec2(-0.91588581, 0.45771432),\n            vec2(-0.81544232, -0.87912464),\n            vec2(-0.38277543, 0.27676845),\n            vec2(0.97484398, 0.75648379),\n            vec2(0.44323325, -0.97511554),\n            vec2(0.53742981, -0.47373420),\n            vec2(-0.26496911, -0.41893023),\n            vec2(0.79197514, 0.19090188),\n            vec2(-0.24188840, 0.99706507),\n            vec2(-0.81409955, 0.91437590),\n            vec2(0.19984126, 0.78641367),\n            vec2(0.14383161, -0.14100790)\n        );\n\n        // http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#stratified-poisson-sampling\n        float random(const vec3 seed, const int i)\n        {\n            vec4 seed4 = vec4(seed, i);\n            float dot_product = dot(seed4, vec4(12.9898, 78.233, 45.164, 94.673));\n            return fract(sin(dot_product) * 43758.5453);\n        }\n    #endif\n    \n#endif\n"

/***/ }),
/* 222 */
/***/ (function(module, exports) {

module.exports = "\n    #if defined(DIRECT_SHADOW_CASTERS_COUNT) && DIRECT_SHADOW_CASTERS_COUNT > 0\n\n        int casterIndex = directShadowCastersMask[lightIndex];\n\n        if (casterIndex != -1) {\n            float shaded = 0.;\n\n            float bias = max(MIN_BIAS, MAX_BIAS * (1. - directLightFragContext.nl));\n\n            vec3 projCoords;\n            float currentDepth;\n\n            float closestDepth = 0.;\n\n        #ifdef GLES_3\n            int samplingIndex = casterIndex * CSM_CASCADES_COUNT + cascadeIndex;\n\n        #else\n\n            for (int samplingIndex = 0; samplingIndex < kCASCADED_SHADOW_MAPS_SAMPLERS_COUNT; ++samplingIndex) {\n                int _cascadeIndex = samplingIndex - casterIndex * CSM_CASCADES_COUNT;\n\n                if (_cascadeIndex == cascadeIndex) {\n        #endif\n\n                    vec4 fragPositionLightSpace = directShadowCastersTransforms[samplingIndex] * vec4(vPositionWorld, 1.);\n\n                    projCoords = fragPositionLightSpace.xyz;\n                    projCoords /= fragPositionLightSpace.w;\n\n                    projCoords = projCoords * .5 + .5;\n                    projCoords.z -= bias;\n\n                    currentDepth = projCoords.z;\n\n        #ifdef GLES_3\n                    for (int k = 0; k < 4; ++k) {\n                        int idx = int(16. * random(gl_FragCoord.xyy, k)) % 16;\n\n                        vec4 p = vec4(projCoords.xy + kPOISSON_DISK[idx] / kSPREAD_VALUE, samplingIndex, projCoords.z);\n\n                        shaded += 1. - texture(directShadowCastersSamplers, p);\n                    }\n\n                    shaded *= .25;\n\n        #else\n\n                    vec2 texelSize = vec2(shadowMapSize);\n\n                    vec4 rgba = vec4(0.);\n\n                    for (int x = -2; x <= 2; ++x) {\n                        for (int y = -2; y <= 2; ++y) {\n                            vec2 samplingVector = projCoords.xy + vec2(x, y) * texelSize;\n\n                            if (samplingIndex == 0)\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 1\n                                rgba = texture2D(directShadowCastersSamplers[0], samplingVector);\n                            #else\n                                ;\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 2\n                                SAMPLE_CSM_CASTER(samplingIndex, 1, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 3\n                                SAMPLE_CSM_CASTER(samplingIndex, 2, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 4\n                                SAMPLE_CSM_CASTER(samplingIndex, 3, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 5\n                                SAMPLE_CSM_CASTER(samplingIndex, 4, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 6\n                                SAMPLE_CSM_CASTER(samplingIndex, 5, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 7\n                                SAMPLE_CSM_CASTER(samplingIndex, 6, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 8\n                                SAMPLE_CSM_CASTER(samplingIndex, 7, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 9\n                                SAMPLE_CSM_CASTER(samplingIndex, 8, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 10\n                                SAMPLE_CSM_CASTER(samplingIndex, 9, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 11\n                                SAMPLE_CSM_CASTER(samplingIndex, 10, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 12\n                                SAMPLE_CSM_CASTER(samplingIndex, 11, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 13\n                                SAMPLE_CSM_CASTER(samplingIndex, 12, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 14\n                                SAMPLE_CSM_CASTER(samplingIndex, 13, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 15\n                                SAMPLE_CSM_CASTER(samplingIndex, 14, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 16\n                                SAMPLE_CSM_CASTER(samplingIndex, 15, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 17\n                                SAMPLE_CSM_CASTER(samplingIndex, 16, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 18\n                                SAMPLE_CSM_CASTER(samplingIndex, 17, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 19\n                                SAMPLE_CSM_CASTER(samplingIndex, 18, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 20\n                                SAMPLE_CSM_CASTER(samplingIndex, 19, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 21\n                                SAMPLE_CSM_CASTER(samplingIndex, 20, samplingVector)\n                            #endif\n\n                            #if DIRECT_SHADOW_CASTERS_COUNT * CSM_CASCADES_COUNT >= 22\n                                SAMPLE_CSM_CASTER(samplingIndex, 21, samplingVector)\n                            #endif\n\n                            closestDepth = decodeNormalizedFloatRGBA(rgba);\n\n                            shaded += currentDepth > closestDepth ? 1. : 0.;\n                        }\n                    }\n\n                    shaded *= .04;\n\n                    break;\n                }\n            }\n        #endif\n\n            shaded *= currentDepth > 1. ? 0. : 1.;\n\n            shaded *= any(lessThan(projCoords.xy, vec2(0.))) ? 0. : 1.;\n            shaded *= any(greaterThan(projCoords.xy, vec2(1.))) ? 0. : 1.;\n\n            directLightFragContext.lighted = 1. - shaded * float(SHADOW_SATURATION);\n        }\n\n    #endif\n"

/***/ }),
/* 223 */
/***/ (function(module, exports) {

module.exports = "\n    #if defined(SPOT_SHADOW_CASTERS_COUNT) && SPOT_SHADOW_CASTERS_COUNT > 0\n\n        int casterIndex = spotShadowCastersMask[lightIndex];\n\n        if (casterIndex != -1) {\n            float shaded = 0.;\n\n            float bias = max(MIN_BIAS, MAX_BIAS * (1. - directLightFragContext.nl));\n\n            vec3 projCoords;\n            float currentDepth;\n\n            float closestDepth = 0.;\n\n        #ifdef GLES_3\n            int samplingIndex = casterIndex;\n\n        #else\n\n            for (int samplingIndex = 0; samplingIndex < SPOT_SHADOW_CASTERS_COUNT; ++samplingIndex) {\n                if (samplingIndex != casterIndex)\n                    continue;\n        #endif\n\n                vec4 fragPositionLightSpace = spotShadowCastersTransforms[samplingIndex] * vec4(vPositionWorld, 1.);\n\n                projCoords = fragPositionLightSpace.xyz;\n                projCoords /= fragPositionLightSpace.w;\n\n                projCoords = projCoords * .5 + .5;\n                projCoords.z -= bias;\n\n                currentDepth = projCoords.z;\n\n        #ifdef GLES_3\n                for (int k = 0; k < 4; ++k) {\n                    int idx = int(16. * random(gl_FragCoord.xyy, k)) % 16;\n\n                    vec4 p = vec4(projCoords.xy + kPOISSON_DISK[idx] / kSPREAD_VALUE, samplingIndex, projCoords.z);\n\n                    shaded += 1. - texture(spotShadowCastersSamplers, p);\n                }\n\n                shaded *= .25;\n\n        #else\n\n                vec2 texelSize = vec2(spotCastersShadowMapSize);\n                vec4 rgba = vec4(0.);\n\n                for (int x = -2; x <= 2; ++x) {\n                    for (int y = -2; y <= 2; ++y) {\n                        vec2 samplingVector = projCoords.xy + vec2(x, y) * texelSize;\n\n                        if (samplingIndex == 0)\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 1\n                            rgba = texture2D(spotShadowCastersSamplers[0], samplingVector);\n                        #else\n                            ;\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 2\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 1, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 3\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 2, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 4\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 3, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 5\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 4, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 6\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 5, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 7\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 6, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 8\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 7, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 9\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 8, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 10\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 9, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 11\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 10, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 12\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 11, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 13\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 12, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 14\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 13, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 15\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 14, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 16\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 15, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 17\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 16, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 18\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 17, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 19\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 18, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 20\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 19, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 21\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 20, samplingVector)\n                        #endif\n\n                        #if SPOT_SHADOW_CASTERS_COUNT >= 22\n                            SAMPLE_SPOT_SHADOW_CASTER(samplingIndex, 21, samplingVector)\n                        #endif\n\n                        closestDepth = decodeNormalizedFloatRGBA(rgba);\n\n                        shaded += currentDepth > closestDepth ? 1. : 0.;\n                    }\n                }\n\n                shaded *= .04;\n\n                break;\n            }\n        #endif\n\n            shaded *= currentDepth > 1. ? 0. : 1.;\n\n            shaded *= any(lessThan(projCoords.xy, vec2(0.))) ? 0. : 1.;\n            shaded *= any(greaterThan(projCoords.xy, vec2(1.))) ? 0. : 1.;\n\n            directLightFragContext.lighted = 1. - shaded * float(SHADOW_SATURATION);\n        }\n\n    #endif\n"

/***/ }),
/* 224 */
/***/ (function(module, exports) {

module.exports = "\n    #if defined(OMNI_SHADOW_CASTERS_COUNT) && OMNI_SHADOW_CASTERS_COUNT > 0\n\n        int omniShadowCasterIndex = omniShadowCastersMask[lightIndex];\n\n        if (omniShadowCasterIndex != -1) {\n            float bias = max(MIN_BIAS, MAX_BIAS * (1. - directLightFragContext.nl));\n\n            vec4 samplingVector = cameraWorldMatrix * vec4(-lightToFrag, 0.);\n            samplingVector.w = (length(samplingVector.xyz) - bias) / float(OMNI_DIRECTIONAL_CASTERS_ZFAR);\n\n            float shaded = 0.;\n\n        #ifdef GLES_3\n            float diskRadius = (1. + samplingVector.w) * .0064;\n\n            for (int sample_index = 0; sample_index < GRID_SAMPLING_DISK_SIZE; ++sample_index) {\n                vec4 offset = kGRID_SAMPLING_DISK[sample_index] * diskRadius;\n\n                switch (omniShadowCasterIndex) {\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 1\n                        SAMPLE_OMNI_SHADOW_CASTER(0, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 2\n                        SAMPLE_OMNI_SHADOW_CASTER(1, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 3\n                        SAMPLE_OMNI_SHADOW_CASTER(2, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 4\n                        SAMPLE_OMNI_SHADOW_CASTER(3, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 5\n                        SAMPLE_OMNI_SHADOW_CASTER(4, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 6\n                        SAMPLE_OMNI_SHADOW_CASTER(5, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 7\n                        SAMPLE_OMNI_SHADOW_CASTER(6, samplingVector + offset)\n                    #endif\n                    #if OMNI_SHADOW_CASTERS_COUNT >= 8\n                        SAMPLE_OMNI_SHADOW_CASTER(7, samplingVector + offset)\n                    #endif\n\n                    default:\n                        break;\n                }\n            }\n\n            shaded /= float(GRID_SAMPLING_DISK_SIZE);\n\n        #else\n\n            for (int samplingIndex = 0; samplingIndex < OMNI_SHADOW_CASTERS_COUNT; ++samplingIndex) {\n                if (samplingIndex != omniShadowCasterIndex) continue;\n\n                float diskRadius = (1. + samplingVector.w) * .2;\n\n                const float offset = .1;\n                const float samples = 4.;\n\n                vec4 rgba = vec4(0.);\n\n                for (float x = -offset; x < offset; x += offset / (samples * .5)) {\n                    for (float y = -offset; y < offset; y += offset / (samples * .5)) {\n                        vec3 offset2 = vec3(x, y, 0.) * diskRadius;\n                        vec3 p = samplingVector.xyz + offset2;\n\n                        if (samplingIndex == 0)\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 1\n                            rgba = textureCube(omniShadowCastersSamplers[0], p);\n                        #else\n                            ;\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 2\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 1, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 3\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 2, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 4\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 3, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 5\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 4, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 6\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 5, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 7\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 6, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 8\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 7, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 9\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 8, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 10\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 9, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 11\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 10, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 12\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 11, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 13\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 12, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 14\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 13, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 15\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 14, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 16\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 15, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 17\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 16, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 18\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 17, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 19\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 18, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 20\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 19, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 21\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 20, p)\n                        #endif\n\n                        #if OMNI_SHADOW_CASTERS_COUNT >= 22\n                            SAMPLE_OMNI_SHADOW_CASTER(samplingIndex, 21, p)\n                        #endif\n\n                        float closestDepth = decodeNormalizedFloatRGBA(rgba);\n\n                        shaded += samplingVector.w > closestDepth ? 1. : 0.;\n                    }\n                }\n\n                shaded /= pow2(samples);\n\n                break;\n            }\n        #endif\n\n            shaded *= samplingVector.w > float(OMNI_DIRECTIONAL_CASTERS_ZFAR) ? 0. : 1.;\n\n            directLightFragContext.lighted = 1. - shaded * float(SHADOW_SATURATION);\n        }\n\n    #endif\n"

/***/ }),
/* 225 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef SKINNING\nuniform sampler2D bonesMap;\n\n#pragma attribute(boneIndices, vec4, BONE_INDICES, 0);\n#pragma attribute(boneWeights, vec4, BONE_WEIGHTS, 0);\n\nmat4 getBoneMatrix(const float instanceIdx, const float index) {\n    float pixelsPerBone = 3.0;\n\n    float dx = 1.0 / float(BONES_TEXTURE_WIDTH);\n    float dy = 1.0 / float(BONES_TEXTURE_HEIGHT);\n\n    float x = index * pixelsPerBone;\n    float y = (instanceIdx + 0.5) * dy;\n\n#ifdef GLES_3\n    vec4 v1 = texture(bonesMap, vec2((x + 0.5) * dx, y));\n    vec4 v2 = texture(bonesMap, vec2((x + 1.5) * dx, y));\n    vec4 v3 = texture(bonesMap, vec2((x + 2.5) * dx, y));\n#else\n    vec4 v1 = texture2D(bonesMap, vec2((x + 0.5) * dx, y));\n    vec4 v2 = texture2D(bonesMap, vec2((x + 1.5) * dx, y));\n    vec4 v3 = texture2D(bonesMap, vec2((x + 2.5) * dx, y));\n#endif\n    vec4 v4 = vec4(0.0, 0.0, 0.0, 1.0);\n\n    mat4 bone = mat4(v1, v2, v3, v4);\n\n    return bone;\n}\n#endif\n"

/***/ }),
/* 226 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef EMISSIVE_MAP\nuniform mat3 emissiveMapTransform;\n\n#ifdef GLES_3\nout vec2 vEmissiveMapTransformUv;\n#else\nvarying vec2 vEmissiveMapTransformUv;\n#endif\n#endif\n\n"

/***/ }),
/* 227 */
/***/ (function(module, exports) {

module.exports = "\n    #ifdef EMISSIVE_MAP\n\n    emittedLight *= _emissiveMapReadFunc(vEmissiveMapTransformUv).rgb * emissiveLuminance;\n\n    #endif\n"

/***/ }),
/* 228 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef EMISSIVE_MAP\n    #ifdef GLES_3\n    in vec2 vEmissiveMapTransformUv;\n    #else\n    varying vec2 vEmissiveMapTransformUv;\n    #endif\n#endif\n\n"

/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports = "\n#if defined(POSITION_MORPH_COUNT) || defined(NORMAL_MORPH_COUNT)\n\n#if POSITION_MORPH_COUNT > NORMAL_MORPH_COUNT\n#define MORPH_TARGET_COUNT POSITION_MORPH_COUNT\n#else\n#define MORPH_TARGET_COUNT NORMAL_MORPH_COUNT\n#endif\n\nuniform float morphWeights[MORPH_TARGET_COUNT];\n\n#endif\n"

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = "\nmaterial.clearCoat = clearCoatStrength;\nmaterial.clearCoatRoughness = clamp(clearCoatRoughness, 0.089, 1.0);\nmaterial.clearCoatAlpha = pow2(material.clearCoatRoughness);\n"

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return throttle; });
// TODO Better use lodash/throttle
// eslint-disable-line @typescript-eslint/no-explicit-any
function throttle(callback, timeLimit) {
  let wait = false;
  return function (...args) {
    if (wait) {
      return;
    } // @ts-ignore ('this' has any type error)


    callback.apply(this, args);
    wait = true;
    setTimeout(() => {
      wait = false;
    }, timeLimit);
  };
}

/***/ }),
/* 232 */
/***/ (function(module, exports) {

module.exports = "#pragma attribute(position, float, POSITION, 0);\n\n#ifdef GLES_3\n    out vec2 vUV;\n#else\n    varying vec2 vUV;\n#endif\n\n\nvoid main()\n{\n    #ifdef GLES_3\n        vUV = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);\n\n    #else\n\n        float x = mod(floor(position), 2.) * 2.;\n        float y = mod(floor(position * .5), 2.) * 2.;\n\n        vUV = vec2(x, y);\n    #endif\n\n    gl_Position = vec4(vUV * 2. - 1., 0., 1.);\n}\n"

/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports = "#pragma include(math.glsl)\n\n#ifdef GLES_3\n    in vec2 vUV;\n#else\n    varying vec2 vUV;\n#endif\n\nuniform sampler2D colorMap0;\n\nuniform vec2 texelSize;\n\n#ifdef GLES_3\n    layout (location = 0) out vec4 fragColor0;\n#else\n    #define fragColor0               gl_FragColor\n\n    vec4 texture(sampler2D colorMap, const in vec2 texCoord)\n    {\n        return texture2D(colorMap, texCoord);\n    }\n#endif\n\nuniform float weights[KERNEL_SIZE];\nuniform float offsets[KERNEL_SIZE];\n\nvec4 gaussianBlur(const in sampler2D colorMap, const in vec2 _step)\n{\n    vec4 sum = texture(colorMap, vUV) * weights[0];\n\n#if defined(BLUR_VERTICAL_PASS) && !defined(GLES_3)\n    sum = vec4(LogLuv2RGB(sum), 1.);\n#endif\n\n    for (int i = 1; i < KERNEL_SIZE; ++i) {\n        vec2 uv0 = vUV + offsets[i] * _step;\n        vec2 uv1 = vUV - offsets[i] * _step;\n\n    #if defined(BLUR_VERTICAL_PASS) && !defined(GLES_3)\n        sum += vec4(LogLuv2RGB(texture(colorMap, uv0)), 1. / weights[i]) * weights[i];\n        sum += vec4(LogLuv2RGB(texture(colorMap, uv1)), 1. / weights[i]) * weights[i];\n    #else\n        sum += texture(colorMap, uv0) * weights[i];\n        sum += texture(colorMap, uv1) * weights[i];\n    #endif\n    }\n\n    return sum;\n}\n\nvoid main()\n{\n#ifdef BLUR_HORIZONTAL_PASS\n    const vec2 direction = vec2(1., 0.);\n\n#elif defined(BLUR_VERTICAL_PASS)\n    const vec2 direction = vec2(0., 1.);\n\n#endif\n\n    vec4 color = gaussianBlur(colorMap0, direction * texelSize);\n\n#ifndef GLES_3\n    color = RGB2LogLUV(vec3(color));\n#endif\n\n    fragColor0 = color;\n}\n"

/***/ }),
/* 234 */
/***/ (function(module, exports) {

module.exports = "#define CUSTOM_COLOR_OUTPUT_MASK 2097152\n\n#pragma attribute(position, vec3, POSITION, 0);\n#pragma attribute(normal, vec3, NORMAL, 0); // TODO 3ES-258\n\n#pragma include(morphParamsVert.glsl)\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n#if defined(ALBEDO_MAP) || defined(NORMAL_MAP) || defined(METALNESS_ROUGHNESS_MAP) || defined(AMBIENT_OCCLUSION_MAP) || defined(EMISSIVE_MAP)\n#pragma include(transformUv.glsl)\n\n#if defined(ALBEDO_MAP)\n#pragma include(albedoMapParamsVert.glsl)\n#endif\n\n#if defined(NORMAL_MAP)\n#pragma include(normalMapParamsVert.glsl)\n#endif\n\n#pragma include(metalnessRoughnessMapParamsVert.glsl)\n#pragma include(ambientOcclusionMapParamsVert.glsl)\n#pragma include(emissiveMapParamsVert.glsl)\n\n#endif // end: if any possible map\n\n#pragma include(skinningParamsVert.glsl)\n\n// START\n// #pragma include(worldSpaceVaryingsParamsVert.glsl)\n// END\n\n#ifdef GLES_3\nout vec3 vNormal;\nout vec3 vViewPosition;\n#else\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#endif\n\n// START\n#pragma attribute(customPosition, vec3, INSTANCE_CUSTOM_1, 1);\n#pragma include(worldSpaceParamsVert.glsl)\n#pragma include(customColorParamsVert.glsl)\n#pragma include(ignoreRaycastParamsVert.glsl)\n// END\n\nvoid main() {\n    #pragma include(transformVert.glsl)\n\n    worldPosition = matrixWorld * objectPosition + vec4(customPosition, 0.0);\n\n    #pragma include(viewPositionVert.glsl)\n    #pragma include(clipPositionVert.glsl)\n    #pragma include(matrixWorldView.glsl)\n\n    #ifdef NORMAL_PACK\n    #pragma include(normalPackVert.glsl)\n    #else\n    #pragma include(normalVert.glsl)\n    #endif\n\n    vViewPosition = viewPosition.xyz;\n\n    #ifdef ALBEDO_MAP\n    vAlbedoMapUv = transformUv(albedoMapTransform, _albedoMapUv);\n    #endif\n\n    #ifdef NORMAL_MAP\n    vNormalMapUv = transformUv(normalMapTransform, _normalMapUv);\n    #endif\n\n    #ifdef METALNESS_ROUGHNESS_MAP\n    vMetalnessRoughnessMapUv = transformUv(metalnessRoughnessMapTransform, _metalnessRoughnessMapUv);\n    #endif\n\n    #ifdef AMBIENT_OCCLUSION_MAP\n    vAmbientOcclusionMapUv = transformUv(ambientOcclusionMapTransform, _ambientOcclusionMapUv);\n    #endif\n\n    #ifdef EMISSIVE_MAP\n    vEmissiveMapTransformUv = transformUv(emissiveMapTransform, _emissiveMapUv);\n    #endif\n\n    // START\n    // #pragma include(worldSpaceVaryingsVert.glsl)\n    #pragma include(worldSpaceVert.glsl)\n    #pragma include(customColorVert.glsl)\n    #pragma include(ignoreRaycastVert.glsl)\n    // END\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 235 */
/***/ (function(module, exports) {

module.exports = "#define CUSTOM_COLOR_OUTPUT_MASK 2097152\n\nuniform vec3 albedo;\nuniform float opacity;\nuniform float metalness;\nuniform float roughness;\nuniform float normalIncidenceFresnel;   // default value is for plastic high (0.05)\n\n#ifdef CLEAR_COAT\nuniform float clearCoatStrength;\nuniform float clearCoatRoughness;\n#endif\n\n#pragma include(materialPBR.glsl)\n\n#pragma include(toneMappingFragParams.glsl)\n\n#ifdef SRGB_OUTPUT\n#pragma include(rgbToSrgbFunc.glsl)\n#endif\n\nuniform vec3 emissiveFactor;\nuniform float emissiveLuminance;\n\n#if defined(ALBEDO_MAP)\n#ifdef GLES_3\nin vec2 vAlbedoMapUv;\n#else\nvarying vec2 vAlbedoMapUv;\n#endif\n#endif\n\n#if defined(NORMAL_MAP)\n#ifdef GLES_3\nin vec2 vNormalMapUv;\n#else\nvarying vec2 vNormalMapUv;\n#endif\n#pragma include(normalMapParamsFrag.glsl)\n#endif\n\n#if defined(METALNESS_ROUGHNESS_MAP)\n#ifdef GLES_3\nin vec2 vMetalnessRoughnessMapUv;\n#else\nvarying vec2 vMetalnessRoughnessMapUv;\n#endif\n#endif\n\n#pragma include(ambientOcclusionMapParamsFrag.glsl)\n\n#pragma include(emissiveMapParamsFrag.glsl)\n\n#pragma include(iblSH.glsl)\n#pragma include(diffuseIlluminanceMapParamsFrag.glsl)\n#pragma include(preFilteredEnvMapParamsFrag.glsl)\n\n#pragma include(worldSpaceFragContextParamsFrag.glsl)\n\n// START\n// #pragma include(worldSpaceVaryingsParamsFrag.glsl)\n// END\n\n#pragma include(lightsParamsFrag.glsl)\n#pragma include(attenuation.glsl)\n\n#ifdef GLES_3\nin vec3 vNormal;\nin vec3 vViewPosition;\n#else\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#ifdef GLES_3\nin vec3 vInstanceUniqueColor;\n#else\nvarying vec3 vInstanceUniqueColor;\n#endif // GLES_3\n#endif\n\n// START\n#pragma include(worldSpaceParamsFrag.glsl)\n#pragma include(sectionBoxParamsFrag.glsl)\n#pragma include(customColorParamsFrag.glsl)\n#pragma include(ignoreRaycastParamsFrag.glsl)\n// END\n\n#pragma fragOutputs\n\nvoid main() {\n    // START\n    #pragma include(sectionBoxFrag.glsl)\n    #pragma include(ignoreRaycastFrag.glsl)\n    #pragma include(customColorFrag.glsl)\n    // END\n\n    vec3 directLightDiffuse = vec3(0.0);\n    vec3 directLightSpecular = vec3(0.0);\n    vec3 indirectLightDiffuse = vec3(0.0);\n    vec3 indirectLightSpecular = vec3(0.0);\n    vec3 reflectedLight = vec3(0.0);\n    // TODO:: move gltf extension from map to material.\n    vec3 emittedLight = emissiveFactor;\n    vec3 indirectLight = vec3(0.0);\n\n    #pragma include(emissiveMapFrag.glsl)\n\n    DirectLightFragContext    directLightFragContext;\n    IndirectLightFragContext  indirectLightFragContext;\n\n    MaterialPBR material;\n\n    float alpha = opacity;\n\n    vec3 albedo_ = albedo;\n\n    #pragma include(albedoMapFrag.glsl)\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #pragma include(normalMapFrag.glsl)\n\n    #pragma include(worldSpaceFragContextFrag.glsl)\n\n    #pragma include(materialPBRFrag.glsl)\n\n    #pragma fragOutput(NORMALS, xyz, normal * 0.5 + 0.5)\n    #pragma fragOutput(VIEW_POSITION, xyz, vViewPosition)\n    #pragma fragOutput(HYPERBOLIC_DEPTH_RGBA, rgba, encodeNormalizedFloatRGBA(gl_FragCoord.z))\n    #pragma fragOutput(COLOR_0, rgba, vec4(albedo_, alpha))\n    #pragma fragOutput(COLOR_1, rgb, vec3(normalIncidenceFresnel, material.roughness, material.metalness))\n    #pragma fragOutput(EMISSIVE, rgba, vec4(emittedLight, alpha))\n\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n        #pragma fragOutput(INSTANCE_COLOR, rgba, vec4(vInstanceUniqueColor, 1.0))\n    #endif\n\n    #if (OUTPUT_MASK & DIRECT_LIGHT_OUTPUT_MASK)\n    vec3 view = -normalize(vViewPosition);\n\n    directLightFragContext.nv = clamp(dot(normal, view), EPSILON, 1.);\n\n    #if defined(DIRECT_SHADOW_CASTERS_COUNT) && DIRECT_SHADOW_CASTERS_COUNT > 0\n        float depth = hyperbolicDepthToLinearNormalized(gl_FragCoord.z * 2.0 - 1.0, cameraNearFar[0], cameraNearFar[1]);\n        int cascadeIndex = cascadeIndex(depth);\n    #endif\n\n    #if DIRECTIONAL_LIGHTS_COUNT > 0\n    {\n        DirectionalLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < DIRECTIONAL_LIGHTS_COUNT; ++lightIndex) {\n            light = directionalLight[lightIndex];\n\n            vec3 l = -light.viewSpaceDirection;\n\n            vec3 h = normalize(l + view);\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.luminance = light.luminance; // nt\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(directShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    #if POINT_LIGHTS_COUNT > 0\n    {\n        PointLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < POINT_LIGHTS_COUNT; ++lightIndex) {\n            light = pointLight[lightIndex];\n\n            float size = light.size;\n\n            float invSqAttenRadius = light.invAttenRadius;\n\n            vec3 lightToFrag = light.viewSpacePosition - vViewPosition;\n\n            float atten = distanceAttenuation(lightToFrag, size * size, invSqAttenRadius);\n\n            vec3 l = normalize(lightToFrag);\n\n            vec3 h = normalize(l + view);\n\n            directLightFragContext.luminance = light.luminousIntensity * saturate(atten); // lm / sr * 1 / m^2 === nt\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(omniShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    #if SPOT_LIGHTS_COUNT > 0\n    {\n        SpotLight light;\n\n        #pragma unroll\n        for (int lightIndex = 0; lightIndex < SPOT_LIGHTS_COUNT; lightIndex++) {\n            light = spotLight[lightIndex];\n\n            float size = light.size;\n\n            float invSqAttenRadius = light.invAttenRadius;\n\n            vec3 l = light.viewSpacePosition - vViewPosition;\n\n            float atten = distanceAttenuation(l, size * size, invSqAttenRadius);\n\n            l = normalize(l);\n\n            vec3 h = normalize(l + view);\n\n            atten *= angleAttenuation(l, -light.viewSpaceDirection, light.lightAngleScale, light.lightAngleOffset);\n\n            directLightFragContext.luminance = light.luminousIntensity * saturate(atten); // lm / sr * 1 / m^2 === nt\n\n            directLightFragContext.nl = saturate(dot(normal, l));\n            directLightFragContext.nh = saturate(dot(normal, h));\n            directLightFragContext.hl = saturate(dot(h, l));\n            directLightFragContext.hv = saturate(dot(h, view));\n\n            directLightFragContext.lighted = 1.0;\n\n            #pragma include(spotShadowCastersFrag.glsl)\n\n            directLightFunc(material, directLightFragContext);\n\n            directLightDiffuse += directLightFragContext.diffuse;\n            directLightSpecular += directLightFragContext.specular;\n        }\n    }\n    #endif\n\n    reflectedLight = directLightDiffuse + directLightSpecular;\n    #endif // (OUTPUT_MASK & DIRECT_LIGHT_OUTPUT_MASK)\n\n    #pragma fragOutput(DIRECT_DIFFUSE, rgba, vec4(directLightDiffuse, alpha))\n    #pragma fragOutput(DIRECT_SPECULAR, rgba, vec4(directLightSpecular, alpha))\n\n    #if (OUTPUT_MASK & INDIRECT_LIGHT_OUTPUT_MASK)\n    #ifdef WORLD_SPACE_FRAG_CONTEXT\n    indirectLightFragContext.viewWorld = viewWorld;\n    indirectLightFragContext.normalWorld = normalWorld;\n    #endif\n\n    #ifdef USE_AMBIENT_LIGHT\n    indirectLightFragContext.luminanceDiffuse = ambientLight.luminance;\n    #else\n        #if defined(DIFFUSE_ILLUMINANCE_MAP) && defined(WORLD_SPACE_FRAG_CONTEXT)\n        {\n            #ifdef GLES_3\n                vec3 luminance = texture(_illuminanceMap, normalWorld).rgb;\n            #else\n                vec3 luminance = LogLuv2RGB(textureCube(_illuminanceMap, normalWorld));\n            #endif\n\n            indirectLightFragContext.luminanceDiffuse = luminance;\n        }\n        #elif defined(SH_BAND_COUNT) && defined(WORLD_SPACE_FRAG_CONTEXT) && SH_BAND_COUNT > 0\n            indirectLightFragContext.luminanceDiffuse = illuminanceSH(normalWorld);\n        #else\n            indirectLightFragContext.luminanceDiffuse = vec3(1.0);\n        #endif\n\n        #if defined(PRE_FILTERED_ENV_MAP) && defined(WORLD_SPACE_FRAG_CONTEXT)\n        {\n            vec3 R = normalize(reflect(-viewWorld, normalWorld));\n\n            vec3 luminance = prefilteredEnvMapColor(R, material.roughness);\n\n            indirectLightFragContext.luminanceSpecular = luminance;\n\n            #ifdef CLEAR_COAT\n            indirectLightFragContext.luminanceClearCoat = prefilteredEnvMapColor(R, material.clearCoatRoughness);\n            #endif\n        }\n        #else\n            indirectLightFragContext.luminanceSpecular = vec3(1.0);\n        #endif\n    #endif\n\n    #pragma include(ambientOcclusionMapFrag.glsl)\n\n    indirectLightFunc(material, indirectLightFragContext);\n\n    indirectLightDiffuse = indirectLightFragContext.diffuse;\n    indirectLightSpecular = indirectLightFragContext.specular;\n    #endif // (OUTPUT_MASK & INDIRECT_LIGHT_OUTPUT_MASK)\n\n    #pragma fragOutput(INDIRECT_DIFFUSE, rgba, vec4(indirectLightDiffuse, alpha))\n    #pragma fragOutput(INDIRECT_SPECULAR, rgba, vec4(indirectLightSpecular, alpha))\n\n    #pragma fragOutput(DIFFUSE, rgba, vec4(indirectLightDiffuse + directLightDiffuse, alpha))\n    #pragma fragOutput(SPECULAR, rgba, vec4(indirectLightSpecular + directLightSpecular, alpha))\n\n    #pragma fragOutput(TM_DIFFUSE, rgba, vec4(toneMappingFunc(indirectLightDiffuse + directLightDiffuse), alpha))\n    #pragma fragOutput(TM_SPECULAR, rgba, vec4(toneMappingFunc(indirectLightSpecular + directLightSpecular), alpha))\n\n    reflectedLight += (indirectLightDiffuse + indirectLightSpecular);\n\n    vec3 outgoingLight = emittedLight + reflectedLight;\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 RGB_HDR = outgoingLight * alpha;\n        #else\n            vec3 RGB_HDR = outgoingLight;\n        #endif\n\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, vec4(RGB_HDR, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 XYZ = RGB2XYZ * outgoingLight * alpha;\n        #else\n            vec3 XYZ = RGB2XYZ * outgoingLight;\n        #endif\n\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec4 logLUV = RGB2LogLUV(outgoingLight) * alpha;\n        #else\n            vec4 logLUV = RGB2LogLUV(outgoingLight);\n        #endif\n\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, logLUV)\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n    outgoingLight = ACESToneMapping(outgoingLight * manualExposure);\n\n    #ifdef SRGB_OUTPUT\n    const float gammaOutput = 0.41666;\n\n    outgoingLight = rgbToSrgb(outgoingLight, gammaOutput);\n    #endif\n\n    #ifdef PREMULTIPLIED_ALPHA\n    outgoingLight *= alpha;\n    #endif\n\n    #pragma fragOutput(DEFAULT, rgba, vec4(outgoingLight, alpha))\n    #endif // DEFAULT_OUTPUT_MASK\n}\n"

/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports = "#define CUSTOM_COLOR_OUTPUT_MASK 2097152\n\nuniform vec3 color;\nuniform float opacity;\n\n#pragma include(math.glsl)\n\n#ifdef SRGB_OUTPUT\n    #pragma include(rgbToSrgbFunc.glsl)\n#endif\n\n#ifdef COLOR_MAP\n    #ifdef GLES_3\n        in vec2 vColorMapUv;\n    #else\n        varying vec2 vColorMapUv;\n    #endif\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #ifdef GLES_3\n        in vec3 vInstanceUniqueColor;\n    #else\n        varying vec3 vInstanceUniqueColor;\n    #endif // GLES_3\n#endif\n\n#pragma fragOutputs\n\n// START\n#pragma include(worldSpaceParamsFrag.glsl)\n#pragma include(sectionBoxParamsFrag.glsl)\n#pragma include(ignoreRaycastParamsFrag.glsl)\n#pragma include(customColorParamsFrag.glsl)\n// END\n\nvoid main() {\n    // START\n    #pragma include(sectionBoxFrag.glsl)\n    #pragma include(ignoreRaycastFrag.glsl)\n    #pragma include(customColorFrag.glsl)\n    // END\n\n    // TODO:: vertex color support\n    vec3 outColor = color;\n    float alpha = opacity;\n\n    #ifdef COLOR_MAP\n        vec4 texelColor = _colorMapReadFunc(vColorMapUv);\n\n        outColor *= texelColor.rgb;\n        alpha *= texelColor.a;\n\n        if (texelColor.a < 0.5) { discard; }\n    #endif\n\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n        #pragma fragOutput(INSTANCE_COLOR, rgba, vec4(vInstanceUniqueColor, 1.0))\n    #endif\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 RGB_HDR = outColor * alpha;\n        #else\n            vec3 RGB_HDR = outColor;\n        #endif\n\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, vec4(RGB_HDR, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        vec3 XYZ = RGB2XYZ * outColor;\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, RGB2LogLUV(outColor))\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n        #ifdef SRGB_OUTPUT\n            const float gammaOutput = 0.41666;\n\n            outColor = rgbToSrgb(outColor, gammaOutput);\n        #endif\n\n        #ifdef PREMULTIPLIED_ALPHA\n            outColor *= alpha;\n        #endif\n\n        #pragma fragOutput(DEFAULT, rgba, vec4(outColor, alpha))\n    #endif\n}"

/***/ }),
/* 237 */
/***/ (function(module, exports) {

module.exports = "#define CUSTOM_COLOR_OUTPUT_MASK 2097152\n\n#pragma attribute(position, vec3, POSITION, 0);\n// TODO:: vertex color support\n// #pragma attribute(color, vec{3, 4}, COLOR, 0);\n\n#pragma include(morphParamsVert.glsl)\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n\n#pragma include(transformAttributesVert.glsl)\n\n#ifdef COLOR_MAP\n#pragma include(colorMapParamsVert.glsl)\n#pragma include(transformUv.glsl)\n#endif\n\n//START\n#pragma attribute(customPosition, vec3, INSTANCE_CUSTOM_1, 1);\n#pragma include(worldSpaceParamsVert.glsl)\n#pragma include(ignoreRaycastParamsVert.glsl)\n#pragma include(customColorParamsVert.glsl)\n//END\n\nvoid main() {\n    #pragma include(transformVert.glsl)\n\n    worldPosition = matrixWorld * objectPosition + vec4(customPosition, 0.0);\n\n    #pragma include(clipPositionVert.glsl)\n\n    #ifdef COLOR_MAP\n    vColorMapUv = transformUv(colorMapTransform, _colorMapUv);\n    #endif\n\n    // START\n    #pragma include(worldSpaceVert.glsl)\n    #pragma include(ignoreRaycastVert.glsl)\n    #pragma include(customColorVert.glsl)\n    // END\n\n    gl_Position = clipPosition;\n}\n"

/***/ }),
/* 238 */
/***/ (function(module, exports) {

module.exports = "#ifdef GLES_3\n    in vec2 vUV;\n#else\n    varying vec2 vUV;\n#endif\n\n#ifdef GLES_3\n    out vec4 fragColor;\n#else\n    #define fragColor gl_FragColor\n#endif\n\n#ifndef GLES_3\n    vec4 texture(sampler2D colorMap, const in vec2 texCoord) {\n        return texture2D(colorMap, texCoord);\n    }\n#endif\n\nuniform vec2 resolution;\nuniform vec3 hoverIdColor;\nuniform float hoverAnimationProgress;\nuniform sampler2D _colorMap;\n\n#pragma include(rgbToSrgbFunc.glsl)\n\n#ifdef FXAA\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\nvec4 fxaa(sampler2D tex, vec2 uv) {\n    vec4 color;\n\n    vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n\n    vec3 rgbNW = texture(tex, uv + vec2(-1.0, -1.0) * inverseVP).xyz;\n    vec3 rgbNE = texture(tex, uv + vec2(1.0, -1.0) * inverseVP).xyz;\n    vec3 rgbSW = texture(tex, uv + vec2(-1.0, 1.0) * inverseVP).xyz;\n    vec3 rgbSE = texture(tex, uv + vec2(1.0, 1.0) * inverseVP).xyz;\n    vec4 texColor = texture(tex, uv);\n    vec3 rgbM  = texColor.xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec4 rgbA = 0.5 * (\n        texture(tex, uv + dir * (1.0 / 3.0 - 0.5)) +\n        texture(tex, uv + dir * (2.0 / 3.0 - 0.5)));\n    vec4 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, uv + dir * -0.5) +\n        texture(tex, uv + dir * 0.5));\n\n    float lumaB = dot(rgbB.xyz, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\n        color = rgbA;\n    } else {\n        color = rgbB;\n    }\n\n    return color;\n}\n#endif\n\n#ifdef SSAA\nvec4 ssaa(sampler2D tex, vec2 uv) {\n    vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec2 suv = uv - vec2((float(SSAA) - 1.0) * 0.5) * inverseVP;\n    vec4 color;\n\n    for (int i = 0; i < SSAA; i++) {\n        for (int j = 0; j < SSAA; j++) {\n            color += texture(tex, suv + vec2(i, j) * inverseVP);\n        }\n    }\n\n    return color / float(SSAA * SSAA);\n}\n#endif\n\nvoid main() {\n    #if defined(FXAA)\n        fragColor = fxaa(_colorMap, vUV);\n    #elif defined(SSAA)\n        fragColor = ssaa(_colorMap, vUV);\n    #else\n        fragColor = texture(_colorMap, vUV);\n    #endif\n}\n"

/***/ }),
/* 239 */
/***/ (function(module, exports) {

module.exports = "#ifdef GLES_3\nin vec2 vUV;\n#else\nvarying vec2 vUV;\n#endif\n\n#ifdef GLES_3\n    out vec4 fragColor;\n#else\n    #define fragColor gl_FragColor\n#endif\n\n#ifndef GLES_3\nvec4 texture(sampler2D colorMap, const in vec2 texCoord) {\n    return texture2D(colorMap, texCoord);\n}\n#endif\n\n/* MAX 8 textures */\nuniform sampler2D _colorMap0; // 1\nuniform sampler2D _colorMap1; // 2\nuniform sampler2D _colorMap2; // 3\n\nuniform sampler2D _coloredTextureVisible; // 4\nuniform sampler2D _coloredTextureHidden; // 5\n\nuniform sampler2D _pointsTextureVisible; // 6\nuniform sampler2D _pointsTextureHidden; // 7\n\nuniform sampler2D _idMap; // 8\n\nuniform vec3  hoverIdColor;\nuniform float hoverAnimationProgress;\n\n#ifdef DEBUG_LAYERS\n    uniform sampler2D _mainDepthTexture;\n#endif\n\n#pragma include(rgbToSrgbFunc.glsl)\n\n// ONE_MINUS_SRC_ALPHA\nvec4 blend(vec4 src, vec4 dst) {\n    return src + dst * (1. - src.a);\n}\n\nvec4 applyHover(vec4 color) {\n    vec4 result = color;\n    vec3 idColor = texture(_idMap, vUV).rgb;\n\n    if (hoverIdColor != vec3(1.0, 1.0, 1.0) && idColor == hoverIdColor) {\n        result.rgb += (0.15 * hoverAnimationProgress);\n    }\n\n    return result;\n}\n\nvec4 applyOverlay(vec4 color, vec4 vTexel, vec4 hTexel, float vAlpha, float hAlpha) {\n    vec4 result = color;\n\n    // hTexel.a != 0.0 ? hAlpha : 0.0\n    result = mix(result, hTexel, (1. - step(hTexel.a, 0.)) * hAlpha);\n\n    // vTexel.a != 0.0 ? vAlpha : 0.0\n    result = mix(result, vTexel, (1. - step(vTexel.a, 0.)) * vAlpha);\n\n    return result;\n}\n\nvoid main() {\n    vec2 uv = vUV;\n\n    #ifdef DEBUG_LAYERS\n        uv *= 2.0;\n        if (uv.x > 1.) { uv.x -= 1.; }\n        if (uv.y > 1.) { uv.y -= 1.; }\n    #endif\n\n    vec4 texelMain     = texture(_colorMap0, uv);\n    vec4 texelService  = texture(_colorMap1, uv);\n    vec4 texelNavCube  = texture(_colorMap2, uv);\n    vec4 texelColoredV = texture(_coloredTextureVisible, uv);\n    vec4 texelColoredH = texture(_coloredTextureHidden, uv);\n    vec4 texelPointsV  = texture(_pointsTextureVisible, uv);\n    vec4 texelPointsH  = texture(_pointsTextureHidden, uv);\n\n    texelMain = applyOverlay(texelMain, texelColoredV, texelColoredH, 0.5, 0.16);\n    texelMain = applyOverlay(texelMain, texelPointsV, texelPointsH, texelPointsV.a, texelPointsH.a * 0.16);\n    texelMain = applyHover(texelMain);\n\n    fragColor = blend(texelNavCube, blend(texelService, texelMain));\n\n    #ifdef DEBUG_LAYERS\n        if (vUV.x < 0.5 && vUV.y > 0.5) {\n            vec4 idMap = texture(_idMap, uv);\n            fragColor = vec4(idMap.rgb * 8., idMap.a);\n        } else if (vUV.x >= 0.5 && vUV.y > 0.5) {\n            fragColor = texelColoredH;\n        } else if (vUV.x < 0.5 && vUV.y < 0.5) {\n            vec4 depthMap = texture(_mainDepthTexture, uv);\n            fragColor = vec4(vec3(depthMap.r), 1.);\n        }\n    #endif\n\n    /* for debugging idMap */\n    // float f = 0.3;\n    // if (vUV.x < f && vUV.y < f) {\n    //     uv /= f;\n    //     if (uv.x > 1.) { uv.x -= 1.; }\n    //     if (uv.y > 1.) { uv.y -= 1.; }\n    //     vec4 idMap = texture(_idMap, uv);\n    //     fragColor = vec4(idMap.rgb * 8., idMap.a);\n    // }\n}\n"

/***/ }),
/* 240 */
/***/ (function(module, exports) {

module.exports = "uniform float relation;\nuniform float pointSize;\n\n#ifdef STATIC_SIZE\n    uniform vec2 viewportSize;\n    uniform bool isOrthoProjection;\n#endif\n\n#ifdef ORIGIN_3D\n    uniform vec3 origin;\n#else\n    uniform vec2 origin;\n#endif\n\n#pragma attribute(position, vec2, POSITION, 0)\n\n#define VIEW_TO_CLIP_POSITION\n\n#pragma include(matrixRoutines.glsl)\n#pragma include(clipPositionParams.glsl)\n#pragma include(transformAttributesVert.glsl)\n\n#ifdef COLOR_MAP\n#pragma include(colorMapParamsVert.glsl)\n#pragma include(transformUv.glsl)\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n#pragma include(math.glsl)\n#endif\n\n// START\n#pragma include(ignoreRaycastParamsVert.glsl)\n// END\n\n\n#ifdef GLES_3\n    out vec3 vPositionWorld;\n#else\n    varying vec3 vPositionWorld;\n#endif\n\nvec2 unpackVec2(vec2 values) {\n    return values * 2.0 - 1.0;\n}\n\nmat3 getLinearMatrix(mat4 matrix) {\n    return transpose(mat3(matrix));\n}\n\nvoid main() {\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    vInstanceUniqueColor = encodeFloatRGB(instanceIdentifiers.y);\n    #endif\n\n    #ifdef COLOR_MAP\n    vec2 uv = position * 0.5 + 0.5;\n    uv.y = 1.0 - uv.y;\n\n    vColorMapUv = transformUv(colorMapTransform, uv);\n    #endif\n\n    mat4 matrixWorld = transpose(mat4(transform1, transform2, transform3, transform4));\n    mat4 cameraMatrix = inverse(viewMatrix);\n\n    // Not a vertex's world position, but sprite's pivot\n    vPositionWorld = vec3(matrixWorld[3][0], matrixWorld[3][1], matrixWorld[3][2]);\n\n    float scaleX = pointSize * min(relation, 1.0);\n    float scaleY = pointSize / max(relation, 1.0);\n\n    #ifdef STATIC_SIZE\n        vec3 direction = (cameraMatrix[3].xyz - matrixWorld[3].xyz) * getLinearMatrix(viewMatrix);\n        vec3 viewAxisZ = vec3(0.0, 0.0, 1.0);\n\n        float factor = 1.0;\n        float pxFactor = 1.0 / viewportSize.y;\n\n        if (isOrthoProjection) {\n            factor = pxFactor * (1.0 / projectionMatrix[1].y);\n        } else {\n            float distanceFactor = length(direction);\n            float perspectiveFactor = dot(normalize(direction), viewAxisZ) * (1.0 / projectionMatrix[1].y);\n\n            factor = distanceFactor * perspectiveFactor * pxFactor;\n        }\n\n        scaleX *= factor;\n        scaleY *= factor;\n    #endif\n\n    #ifdef ORIGIN_3D\n        vec3 offsetVec = origin * max(scaleX, scaleY);\n    #else\n        vec2 offset = unpackVec2(origin);\n        vec3 offsetVec = vec3(-offset.x * scaleX, offset.y * scaleY, 0.0) * getLinearMatrix(cameraMatrix);\n    #endif\n\n    matrixWorld[3].xyz += offsetVec;\n\n    mat4 matrixWorldView = viewMatrix * matrixWorld;\n    vec4 viewPosition = matrixWorldView * vec4(0.0, 0.0, 0.0, 1.0);\n\n    mat3 spriteTransform = mat3(\n        vec3(scaleX, 0.0, 0.0),\n        vec3(0.0, scaleY, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n\n    vec3 spriteVertexPosition = spriteTransform * vec3(position, 1.0);\n\n    // START\n    #pragma include(ignoreRaycastVert.glsl)\n    // END\n\n    viewPosition.xy += spriteVertexPosition.xy;\n    gl_Position = projectionMatrix * viewPosition;\n}\n"

/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports = "\nuniform vec3 color;\nuniform float opacity;\n\n#pragma include(math.glsl)\n\n#ifdef SRGB_OUTPUT\n    #pragma include(rgbToSrgbFunc.glsl)\n#endif\n\n#ifdef COLOR_MAP\n    #ifdef GLES_3\n        in vec2 vColorMapUv;\n    #else\n        varying vec2 vColorMapUv;\n    #endif\n#endif\n\n#if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n    #ifdef GLES_3\n        in vec3 vInstanceUniqueColor;\n    #else\n        varying vec3 vInstanceUniqueColor;\n    #endif\n#endif\n\n#pragma fragOutputs\n\n// START\n#ifdef GLES_3\n    in vec3 vPositionWorld;\n#else\n    varying vec3 vPositionWorld;\n#endif\n\n#pragma include(ignoreRaycastParamsFrag.glsl)\n#pragma include(sectionBoxParamsFrag.glsl)\n// END\n\nvoid main() {\n    // START\n    #pragma include(sectionBoxFrag.glsl)\n    // END\n\n    // TODO:: vertex color support\n    vec3 outColor = vec3(1., 1., 1.);\n    float alpha = opacity;\n\n    // START\n    #pragma include(ignoreRaycastFrag.glsl)\n    // END\n\n    #ifdef COLOR_MAP\n        vec4 texelColor = _colorMapReadFunc(vColorMapUv);\n\n        outColor *= texelColor.rgb;\n        alpha *= texelColor.a;\n\n        #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n            if (texelColor.a < 0.99) { discard; }\n        #endif\n    #endif\n\n    #if defined(BLENDING_METHOD_ADD)\n        outColor += color;\n    #elif defined(BLENDING_METHOD_MULTIPLY)\n        outColor *= color;\n    #else\n        outColor += color * 0.00000000001; // Do nothing, but not allow to erase uniform\n    #endif\n\n    #if (OUTPUT_MASK & INSTANCE_COLOR_OUTPUT_MASK)\n        #pragma fragOutput(INSTANCE_COLOR, rgba, vec4(vInstanceUniqueColor, 1.0))\n    #endif\n\n    #pragma include(alphaTestFrag.glsl)\n\n    #if (OUTPUT_MASK & LINEAR_HDR_COLOR)\n        #ifdef PREMULTIPLIED_ALPHA\n            vec3 RGB_HDR = outColor * alpha;\n        #else\n            vec3 RGB_HDR = outColor;\n        #endif\n\n        #pragma fragOutput(LINEAR_HDR_COLOR, rgba, vec4(RGB_HDR, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_xyY_COLOR)\n        vec3 XYZ = RGB2XYZ * outColor;\n        vec3 xyY = XYZ2xyY(XYZ);\n\n        #pragma fragOutput(CIE_xyY_COLOR, rgba, vec4(xyY, alpha))\n    #endif\n\n    #if (OUTPUT_MASK & CIE_LUV_COLOR)\n        #pragma fragOutput(CIE_LUV_COLOR, rgba, RGB2LogLUV(outColor))\n    #endif\n\n    #if (OUTPUT_MASK & DEFAULT_OUTPUT_MASK)\n        #ifdef SRGB_OUTPUT\n            const float gammaOutput = 0.41666;\n\n            outColor = rgbToSrgb(outColor, gammaOutput);\n        #endif\n\n        #ifdef PREMULTIPLIED_ALPHA\n            outColor *= alpha;\n        #endif\n\n        #pragma fragOutput(DEFAULT, rgba, vec4(outColor, alpha))\n    #endif\n}\n"

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(255)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"calculateDistanceParts\", function() { return /* binding */ calculateDistanceParts; });\n\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/generate-function.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nclass FunctionGenerator {\n  constructor() {\n    this.doc = [];\n    this.ctx = {};\n    this.strict = true;\n    this.name = '';\n    this.params = [];\n    this._code = [];\n  }\n\n  emit(strings, ...values) {\n    const code = this._code;\n    code.push(strings[0]);\n\n    for (const _ref of values.entries()) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const i = _ref2[0];\n      const value = _ref2[1];\n      code.push(value, strings[i + 1]);\n    }\n\n    code.push('\\n');\n  }\n\n  _compile() {\n    const ctx = new Map(Object.entries(this.ctx));\n    const strict = this.strict;\n    const code = this._code;\n    code.unshift(`return function(${this.params}){\\n`);\n\n    if (strict) {\n      code.unshift('\\'use strict\\';');\n    }\n\n    ;\n    code.push('}\\n');\n\n    try {\n      // eslint-disable-next-line no-new-func\n      const fn = new Function(...ctx.keys(), code.join(''))(...ctx.values());\n      Object.defineProperty(fn, 'name', {\n        configurable: true,\n        value: this.name\n      });\n\n      if (false) {}\n\n      return fn;\n    } finally {\n      code.pop();\n\n      if (strict) {\n        code.shift();\n      }\n\n      code.shift();\n    }\n  }\n\n}\n\nfunction generateFunction(generate) {\n  const fg = new FunctionGenerator();\n  generate(fg);\n  return fg._compile();\n}\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/function-property-definer-makers.js\n\n\nfunction makeFunctionPropertyDefiner(type, name, object) {\n  return {\n    [name](generate) {\n      const fn = generateFunction(generate);\n      let descriptor = Object.getOwnPropertyDescriptor(object, fn.name);\n\n      if (descriptor === undefined) {\n        descriptor = {\n          configurable: true\n        };\n      }\n\n      if (type === 'value') {\n        descriptor.writable = true;\n      }\n\n      descriptor[type] = fn;\n      Object.defineProperty(object, fn.name, descriptor);\n    }\n\n  }[name];\n}\n\nfunction makeMethodDefiner(object) {\n  return makeFunctionPropertyDefiner('value', 'defineMethod', object);\n}\nfunction makeGetterDefiner(object) {\n  return makeFunctionPropertyDefiner('get', 'defineGetter', object);\n}\nfunction makeSetterDefiner(object) {\n  return makeFunctionPropertyDefiner('set', 'defineSetter', object);\n}\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/codegen/lib/make-property-aliaser.js\nfunction makePropertyAliaser(object) {\n  return function aliasProperty(name, alias) {\n    const descriptor = Object.getOwnPropertyDescriptor(object, name);\n\n    if (false) {}\n\n    Object.defineProperty(object, alias, descriptor);\n  };\n}\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/to-title-case.js\nfunction toTitleCase(s) {\n  return (s[0] || '').toUpperCase() + s.slice(1);\n}\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/functions.js\nconst functions_isNaN = Number.isNaN,\n      functions_isFinite = Number.isFinite,\n      isInteger = Number.isInteger,\n      isSafeInteger = Number.isSafeInteger;\n\nconst functions_abs = Math.abs,\n      sign = Math.sign,\n      floor = Math.floor,\n      ceil = Math.ceil,\n      trunc = Math.trunc,\n      round = Math.round,\n      fround = Math.fround,\n      max = Math.max,\n      min = Math.min,\n      hypot = Math.hypot,\n      sqrt = Math.sqrt,\n      cbrt = Math.cbrt,\n      pow = Math.pow,\n      exp = Math.exp,\n      expm1 = Math.expm1,\n      log = Math.log,\n      log1p = Math.log1p,\n      log2 = Math.log2,\n      log10 = Math.log10,\n      sin = Math.sin,\n      cos = Math.cos,\n      tan = Math.tan,\n      asin = Math.asin,\n      acos = Math.acos,\n      atan = Math.atan,\n      atan2 = Math.atan2,\n      sinh = Math.sinh,\n      cosh = Math.cosh,\n      tanh = Math.tanh,\n      asinh = Math.asinh,\n      acosh = Math.acosh,\n      atanh = Math.atanh,\n      imul = Math.imul,\n      clz32 = Math.clz32;\n/**\n * @function module:@wgetemp/math.clamp\n * @param {number} x Value.\n * @param {number} a Lower bound.\n * @param {number} b Upper bound.\n * @returns {number} Value clamped between `a` and `b`.\n *    Equivalent to `{@link module:@wgetemp/math.min}({@link module:@wgetemp/math.max}(x, a), b)`.\n */\n\n\nfunction clamp(x, a, b) {\n  return min(max(x, a), b);\n}\n/**\n * @function module:@wgetemp/math.rt\n * @param {number} d Root degree.\n * @param {number} y Value.\n * @returns {number} `d`-degree root of number `y`.\n *    Equivalent to `{@link module:@wgetemp/math.pow}(y, 1 / d)`.\n */\n\nfunction rt(d, y) {\n  return pow(y, 1 / d);\n}\n/**\n * @function module:@wgetemp/math.sq\n * @param {number} x Value.\n * @returns {number} Square of `x`. Equivalent to `x * x`.\n */\n\nfunction sq(x) {\n  return x * x;\n}\n/**\n * @function module:@wgetemp/math.cb\n * @param {number} x Value.\n * @returns {number} Cube of `x`. Equivalent to `x * x * x`.\n */\n\nfunction cb(x) {\n  return x * x * x;\n}\n/**\n * @function module:@wgetemp/math.exp2\n * @param {number} x Value.\n * @returns {number} Base-2 exponent of `x`.\n *    Equivalent to `{@link module:@wgetemp/math.pow}(2, x)`.\n */\n\nfunction exp2(x) {\n  return pow(2, x);\n}\n/**\n * @function module:@wgetemp/math.exp10\n * @param {number} x Value.\n * @returns {number} Base-10 exponent of `x`.\n *    Equivalent to `{@link module:@wgetemp/math.pow}(10, x)`.\n */\n\nfunction exp10(x) {\n  return pow(10, x);\n}\n/**\n * @function module:@wgetemp/math.isPow2\n * @param {number} x Value.\n * @returns {boolean} Whether `x` is a power of 2, including negative powers.\n *    Equivalent to `{@link module:@wgetemp/math.isInteger}({@link module:@wgetemp/math.log2}(x))`.\n */\n\nfunction isPow2(x) {\n  return isInteger(log2(x));\n}\n/**\n * @function module:@wgetemp/math.isPow10\n * @param {number} x Value.\n * @returns {boolean} Whether `x` is a power of 10, including negative powers.\n *    Equivalent to `{@link module:@wgetemp/math.isInteger}({@link module:@wgetemp/math.log10}(x))`.\n */\n\nfunction isPow10(x) {\n  return isInteger(log10(x));\n}\n/**\n * @function module:@wgetemp/math.floorPow2\n * @param {number} x Value.\n * @returns {number} Biggest power of 2 not greater than `x`.\n *    Equivalent to `{@link module:@wgetemp/math.exp2}({@link module:@wgetemp/math.floor}({@link module:@wgetemp/math.log2}(x)))`.\n */\n\nfunction floorPow2(x) {\n  return exp2(floor(log2(x)));\n}\n/**\n * @function module:@wgetemp/math.ceilPow2\n * @param {number} x Value.\n * @returns {number} Smallest power of 2 not less than `x`.\n *    Equivalent to `{@link module:@wgetemp/math.exp2}({@link module:@wgetemp/math.ceil}({@link module:@wgetemp/math.log2}(x)))`.\n */\n\nfunction ceilPow2(x) {\n  return exp2(ceil(log2(x)));\n}\n/**\n * @function module:@wgetemp/math.floorPow10\n * @param {number} x Value.\n * @returns {number} Biggest power of 10 not greater than `x`.\n *    Equivalent to `{@link module:@wgetemp/math.exp10}({@link module:@wgetemp/math.floor}({@link module:@wgetemp/math.log10}(x)))`.\n */\n\nfunction floorPow10(x) {\n  return exp10(floor(log10(x)));\n}\n/**\n * @function module:@wgetemp/math.ceilPow10\n * @param {number} x Value.\n * @returns {number} Smallest power of 10 not less than `x`.\n *    Equivalent to `{@link module:@wgetemp/math.exp10}({@link module:@wgetemp/math.ceil}({@link module:@wgetemp/math.log10}(x)))`.\n */\n\nfunction ceilPow10(x) {\n  return exp10(ceil(log10(x)));\n}\n/**\n * @function module:@wgetemp/math.ldexp\n * @summary Compose normalized fraction and base-2 exponent into a number.\n * @desc Attempts to behave identically to corresponding C function.\n * @param {number} x Normalized fraction.\n * @param {number} e Base-2 exponent.\n * @returns {number} Effectively `x * {@link module:@wgetemp/math.exp2}(e)`,\n *    but with careful handling of edge cases.\n */\n// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html\n\nfunction ldexp(x, e) {\n  if (x === 0 || !functions_isFinite(x)) {\n    return x;\n  }\n\n  const n = min(ceil(functions_abs(e) / 1023), 3);\n\n  for (let i = 0; i < n; ++i) {\n    x *= pow(2, floor((e + i) / n));\n  }\n\n  return x;\n}\n/**\n * @function module:@wgetemp/math.frexp\n * @summary Decompose number into normalized fraction and base-2 exponent.\n * @desc Attempts to behave identically to corresponding C function.\n * @param {number} x Value.\n * @param {Array} [results] Result array.\n * @param {number} [results.0] Normalized fraction.\n * @param {number} [results.1] Base-2 exponent.\n * @returns {number} Filled `results`.\n */\n// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html\n\nconst frexp = (() => {\n  const f64 = new Float64Array(1);\n  const hu32 = new Uint32Array(f64.buffer, (() => {\n    return new Uint8Array(Uint16Array.of(4).buffer)[0];\n  })(), 1);\n  return function frexp(x, results = [0, 0]) {\n    if (x === 0 || !functions_isFinite(x)) {\n      results[0] = x;\n      results[1] = 0;\n    } else {\n      f64[0] = x;\n      let be = hu32[0] >>> 20 & 0x7FF;\n\n      if (be === 0) {\n        f64[0] = x * 0x10000000000000000;\n        be = (hu32[0] >>> 20 & 0x7FF) - 64;\n      }\n\n      const e = be - 1022;\n      results[0] = ldexp(x, -e);\n      results[1] = e;\n    }\n\n    return results;\n  };\n})();\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/vectors.js\nfunction vectors_slicedToArray(arr, i) { return vectors_arrayWithHoles(arr) || vectors_iterableToArrayLimit(arr, i) || vectors_unsupportedIterableToArray(arr, i) || vectors_nonIterableRest(); }\n\nfunction vectors_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction vectors_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return vectors_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return vectors_arrayLikeToArray(o, minLen); }\n\nfunction vectors_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction vectors_iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction vectors_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nconst aas = [...'xyzw'];\n\nfunction makeClass(d) {\n  const as = aas.slice(0, d);\n  const Vector = generateFunction(fg => {\n    fg.name = `Vector${d}`;\n    fg.params = as;\n\n    for (const a of as) {\n      fg.emit`this.${a}=${a}===undefined?0:${a}`;\n    }\n\n    if (false) {}\n  });\n\n  if (false) {}\n\n  const defineMethod = makeMethodDefiner(Vector.prototype);\n  const defineGetter = makeGetterDefiner(Vector.prototype);\n  const defineSetter = makeSetterDefiner(Vector.prototype);\n  const aliasProperty = makePropertyAliaser(Vector.prototype);\n  defineMethod(fg => {\n    fg.name = 'set';\n    fg.params = as;\n\n    for (const a of as) {\n      fg.emit`this.${a}=${a}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'fromNumber';\n    fg.params = ['number'];\n\n    for (const a of as) {\n      fg.emit`this.${a}=number`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = `from${Vector.name}`;\n    fg.params = ['vector'];\n\n    for (const a of as) {\n      fg.emit`this.${a}=vector.${a}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty(`from${Vector.name}`, 'fromVector');\n  aliasProperty('fromVector', 'copy');\n\n  if (d === 2) {\n    defineMethod(fg => {\n      fg.name = `fromComplex`;\n      fg.params = ['complex'];\n      fg.emit`this.x=complex.re`;\n      fg.emit`this.y=complex.im`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = `fromArray`;\n    fg.params = ['array'];\n\n    for (const _ref of as.entries()) {\n      var _ref2 = vectors_slicedToArray(_ref, 2);\n\n      const i = _ref2[0];\n      const a = _ref2[1];\n      fg.emit`this.${a}=array[${i}]`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = `fromArrayAt`;\n    fg.params = ['offset', 'array'];\n\n    for (const _ref3 of as.entries()) {\n      var _ref4 = vectors_slicedToArray(_ref3, 2);\n\n      const i = _ref4[0];\n      const a = _ref4[1];\n      fg.emit`this.${a}=array[offset+${i}]`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = `toArray`;\n    fg.params = ['array'];\n\n    for (const _ref5 of as.entries()) {\n      var _ref6 = vectors_slicedToArray(_ref5, 2);\n\n      const i = _ref6[0];\n      const a = _ref6[1];\n      fg.emit`array[${i}]=this.${a}`;\n    }\n\n    fg.emit`return array`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = `toArrayAt`;\n    fg.params = ['offset', 'array'];\n\n    for (const _ref7 of as.entries()) {\n      var _ref8 = vectors_slicedToArray(_ref7, 2);\n\n      const i = _ref8[0];\n      const a = _ref8[1];\n      fg.emit`array[offset+${i}]=this.${a}`;\n    }\n\n    fg.emit`return array`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.ctx[Vector.name] = Vector;\n    fg.name = 'clone';\n    fg.emit`return new ${Vector.name}().copy(this)`;\n\n    if (false) {}\n  });\n\n  for (const fn of [functions_isNaN, isInteger, isSafeInteger, functions_isFinite, isPow2, isPow10]) {\n    const name = fn.name,\n          Name = toTitleCase(name);\n    defineGetter(fg => {\n      fg.ctx[name] = fn;\n      fg.name = `some${Name}`;\n      fg.emit`return ${as.map(a => `${name}(this.${a})`).join('||')}`;\n\n      if (false) {}\n    });\n    defineGetter(fg => {\n      fg.ctx[name] = fn;\n      fg.name = `every${Name}`;\n      fg.emit`return ${as.map(a => `${name}(this.${a})`).join('&&')}`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = 'equals';\n    fg.params = ['that'];\n    fg.emit`return ${as.map(a => `this.${a}===that.${a}`).join('&&')}`;\n\n    if (false) {}\n  });\n\n  function defineUnaryOperation(name, vector) {\n    defineMethod(fg => {\n      fg.name = name;\n      vector(fg);\n      fg.emit`return this`;\n    });\n  }\n\n  for (const _ref9 of [['negate', '-']]) {\n    var _ref10 = vectors_slicedToArray(_ref9, 2);\n\n    const name = _ref10[0];\n    const op = _ref10[1];\n    defineUnaryOperation(name, fg => {\n      for (const a of as) {\n        fg.emit`this.${a}=${op}this.${a}`;\n      }\n\n      if (false) {}\n    });\n  }\n\n  for (const fn of [sign, functions_abs, floor, ceil, trunc, round, fround, floorPow2, ceilPow2, floorPow10, ceilPow10]) {\n    const name = fn.name;\n    defineUnaryOperation(name, fg => {\n      fg.ctx[name] = fn;\n\n      for (const a of as) {\n        fg.emit`this.${a}=${name}(this.${a})`;\n      }\n\n      if (false) {}\n    });\n  }\n\n  function defineBinaryOperartion(name, commutative, {\n    vector,\n    number,\n    preNumber\n  }) {\n    const Name = toTitleCase(name);\n    defineMethod(fg => {\n      fg.name = `${name}Vector`;\n      fg.params = ['right'];\n      vector(fg, 'this', 'right');\n      fg.emit`return this`;\n    });\n    defineMethod(fg => {\n      fg.name = `${name}Number`;\n      fg.params = ['right'];\n      number(fg);\n      fg.emit`return this`;\n    });\n\n    if (!commutative) {\n      defineMethod(fg => {\n        fg.name = `pre${Name}Vector`;\n        fg.params = ['left'];\n        vector(fg, 'left', 'this');\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        fg.name = `pre${Name}Number`;\n        fg.params = ['left'];\n        preNumber(fg);\n        fg.emit`return this`;\n      });\n    }\n  }\n\n  for (const _ref11 of [['add', '+', 1], ['subtract', '-', 0], ['multiply', '*', 1], ['divide', '/', 0], ['modulo', '%', 0]]) {\n    var _ref12 = vectors_slicedToArray(_ref11, 3);\n\n    const name = _ref12[0];\n    const op = _ref12[1];\n    const commutative = _ref12[2];\n    const Name = toTitleCase(name);\n    defineBinaryOperartion(name, commutative, {\n      vector(fg, left, right) {\n        for (const a of as) {\n          fg.emit`this.${a}=${left}.${a}${op}${right}.${a}`;\n        }\n\n        if (false) {}\n      },\n\n      number(fg) {\n        if (['/', '%'].includes(op)) {\n          if (op === '%') {\n            Object.assign(fg.ctx, {\n              trunc: trunc\n            });\n\n            for (const a of as) {\n              fg.emit`var ${a}=this.${a}`;\n            }\n          }\n\n          fg.emit`var invRight=1/right`;\n        }\n\n        for (const a of as) {\n          if (op === '/') {\n            fg.emit`this.${a}=this.${a}*invRight`;\n          } else if (op === '%') {\n            fg.emit`this.${a}=${a}-trunc(${a}*invRight)*right`;\n          } else {\n            fg.emit`this.${a}=this.${a}${op}right`;\n          }\n        }\n\n        if (false) {}\n      },\n\n      preNumber(fg) {\n        for (const a of as) {\n          fg.emit`this.${a}=left${op}this.${a}`;\n        }\n\n        if (false) {}\n      }\n\n    });\n\n    if (['+', '-'].includes(op)) {\n      aliasProperty(`${name}Vector`, name);\n\n      if (!commutative) {\n        aliasProperty(`pre${Name}Vector`, `pre${Name}`);\n      }\n    }\n\n    if (['*', '/'].includes(op)) {\n      aliasProperty(`${name}Number`, name);\n    }\n  }\n\n  for (const _ref13 of [[min, 1], [max, 1]]) {\n    var _ref14 = vectors_slicedToArray(_ref13, 2);\n\n    const fn = _ref14[0];\n    const commutative = _ref14[1];\n    const name = fn.name,\n          Name = toTitleCase(name);\n    defineBinaryOperartion(name, commutative, {\n      vector(fg, left, right) {\n        fg.ctx[name] = fn;\n\n        for (const a of as) {\n          fg.emit`this.${a}=${name}(${left}.${a},${right}.${a})`;\n        }\n\n        if (false) {}\n      },\n\n      number(fg) {\n        fg.ctx[name] = fn;\n\n        for (const a of as) {\n          fg.emit`this.${a}=${name}(this.${a},right)`;\n        }\n\n        if (false) {}\n      },\n\n      preNumber(fg) {\n        fg.ctx[name] = fn;\n\n        for (const a of as) {\n          fg.emit`this.${a}=${name}(left,this.${a})`;\n        }\n\n        if (false) {}\n      }\n\n    });\n\n    if ([min, max].includes(fn)) {\n      aliasProperty(`${name}Vector`, name);\n    }\n  }\n\n  defineMethod(fg => {\n    Object.assign(fg.ctx, {\n      clamp: clamp\n    });\n    fg.name = `clampVectors`;\n    fg.params = ['low', 'high'];\n\n    for (const a of as) {\n      fg.emit`this.${a}=clamp(this.${a},low.${a},high.${a})`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty('clampVectors', 'clamp');\n  defineMethod(fg => {\n    Object.assign(fg.ctx, {\n      clamp: clamp\n    });\n    fg.name = `clampNumbers`;\n    fg.params = ['low', 'high'];\n\n    for (const a of as) {\n      fg.emit`this.${a}=clamp(this.${a},low,high)`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineGetter(fg => {\n    fg.name = 'sqLength';\n\n    for (const a of as) {\n      fg.emit`var ${a}=this.${a}`;\n    }\n\n    fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;\n\n    if (false) {}\n  });\n  defineSetter(fg => {\n    Object.assign(fg.ctx, {\n      sqrt: sqrt\n    });\n    fg.name = 'sqLength';\n    fg.params = ['newSqLength'];\n    fg.emit`this.multiply(sqrt(newSqLength/this.sqLength))`;\n  });\n  defineGetter(fg => {\n    Object.assign(fg.ctx, {\n      sqrt: sqrt\n    });\n    fg.name = 'length';\n    fg.emit`return sqrt(this.sqLength)`;\n\n    if (false) {}\n  });\n  defineSetter(fg => {\n    fg.name = 'length';\n    fg.params = ['newLength'];\n    fg.emit`this.multiply(newLength/this.length)`;\n  });\n  defineMethod(fg => {\n    fg.name = 'sqDistance';\n    fg.params = ['that'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=this.${a}-that.${a}`;\n    }\n\n    fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    Object.assign(fg.ctx, {\n      sqrt: sqrt\n    });\n    fg.name = 'distance';\n    fg.params = ['that'];\n    fg.emit`return sqrt(this.sqDistance(that))`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'normalize';\n    fg.emit`return this.divide(this.length)`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'dot';\n    fg.params = ['that'];\n    fg.emit`return ${as.map(a => `this.${a}*that.${a}`).join('+')}`;\n\n    if (false) {}\n  });\n\n  if (d === 2) {\n    defineMethod(fg => {\n      fg.name = 'cross';\n      fg.params = ['right'];\n      fg.emit`return this.x*right.y-this.y*right.x`;\n\n      if (false) {}\n    });\n  } else {\n    function cross(result, left, right) {\n      const ax = left.x,\n            ay = left.y,\n            az = left.z;\n      const bx = right.x,\n            by = right.y,\n            bz = right.z;\n      result.x = ay * bz - az * by;\n      result.y = az * bx - ax * bz;\n      result.z = ax * by - ay * bx;\n    }\n\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        cross\n      });\n      fg.name = 'cross';\n      fg.params = ['right'];\n      fg.emit`cross(this,this,right)`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        cross\n      });\n      fg.name = 'preCross';\n      fg.params = ['left'];\n      fg.emit`cross(this,left,this)`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  if (d === 2) {\n    defineMethod(fg => {\n      fg.name = 'orthogonalize';\n      fg.emit`var x=this.x`;\n      fg.emit`this.x=-this.y`;\n      fg.emit`this.y=x`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  } else {\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        abs: functions_abs\n      });\n      fg.name = 'orthogonalize';\n      fg.emit`var x=this.x,y=this.y,z=this.z`;\n      fg.emit`var ax=abs(x),ay=abs(y),az=abs(z)`;\n      fg.emit`if(ax<=ay&&ax<=az){`;\n      fg.emit`this.x=0`;\n      fg.emit`this.y=z`;\n      fg.emit`this.z=-y`;\n      fg.emit`}else if(ay<=az){`;\n      fg.emit`this.x=-z`;\n      fg.emit`this.y=0`;\n      fg.emit`this.z=x`;\n      fg.emit`}else{`;\n      fg.emit`this.x=y`;\n      fg.emit`this.y=-x`;\n      fg.emit`this.z=0`;\n      fg.emit`}`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  aliasProperty('add', 'translate');\n  aliasProperty(`multiplyVector`, 'scale');\n  aliasProperty(`multiply`, 'scaleUniform');\n  defineMethod(fg => {\n    fg.name = 'shear';\n    fg.params = ['shearing'];\n\n    if (d === 2) {\n      fg.emit`this.x+=this.y*shearing`;\n    } else {\n      fg.emit`var y=this.y,z=this.z`;\n      fg.emit`this.x+=y*shearing.z+z*shearing.y`;\n      fg.emit`this.y=y+z*shearing.x`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    Object.assign(fg.ctx, {\n      tmp: new Vector()\n    });\n    fg.name = 'reflect';\n    fg.params = ['normal'];\n    fg.emit`tmp.copy(normal).multiply(2*this.dot(normal))`;\n    fg.emit`return this.subtract(tmp)`;\n\n    if (false) {}\n  });\n\n  if (d === 2) {\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        sin: sin,\n        cos: cos\n      });\n      fg.name = 'rotate';\n      fg.params = ['angle'];\n      fg.emit`var x=this.x,y=this.y`;\n      fg.emit`var s=sin(angle),c=cos(angle)`;\n      fg.emit`this.x=x*c-y*s`;\n      fg.emit`this.y=x*s+y*c`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      fg.name = 'rotateBetween';\n      fg.params = ['from', 'to'];\n      fg.emit`var x=this.x,y=this.y`;\n      fg.emit`var s=from.cross(to),c=from.dot(to)`;\n      fg.emit`this.x=x*c-y*s`;\n      fg.emit`this.y=x*s+y*c`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      fg.name = 'applyComplex';\n      fg.params = ['complex'];\n      fg.emit`var x=this.x,y=this.y`;\n      fg.emit`var re=complex.re,im=complex.im`;\n      fg.emit`this.x=x*re-y*im`;\n      fg.emit`this.y=x*im+y*re`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  } else {\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        sin: sin,\n        cos: cos\n      });\n      fg.name = 'rotate';\n      fg.params = ['angle', 'axis'];\n      fg.emit`var x=this.x,y=this.y,z=this.z`;\n      fg.emit`var s=sin(angle),c=cos(angle)`;\n      fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;\n      fg.emit`var q=(ax*x+ay*y+az*z)*(1-c)`;\n      fg.emit`this.x=x*c+(ay*z-az*y)*s+ax*q`;\n      fg.emit`this.y=y*c+(az*x-ax*z)*s+ay*q`;\n      fg.emit`this.z=z*c+(ax*y-ay*x)*s+az*q`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        axis: new Vector()\n      });\n      fg.name = 'rotateBetween';\n      fg.params = ['from', 'to'];\n      fg.emit`axis.copy(from).cross(to)`;\n      fg.emit`var axs=axis.x,ays=axis.y,azs=axis.z`;\n      fg.emit`axis.normalize()`;\n      fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;\n      fg.emit`var c=from.dot(to),q=axis.dot(this)*(1-c),`;\n      fg.emit`x=this.x,y=this.y,z=this.z`;\n      fg.emit`this.x=x*c+(ays*z-azs*y)+axis.x*q`;\n      fg.emit`this.y=y*c+(azs*x-axs*z)+axis.y*q`;\n      fg.emit`this.z=z*c+(axs*y-ays*x)+axis.z*q`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        sqrt: sqrt\n      });\n      fg.name = 'applyComplex';\n      fg.params = ['complex', 'axis'];\n      fg.emit`var x=this.x,y=this.y,z=this.z`;\n      fg.emit`var re=complex.re,im=complex.im`;\n      fg.emit`var f=sqrt(re*re+im*im)`;\n      fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;\n      fg.emit`var q=(ax*x+ay*y+az*z)*(f-re)`;\n      fg.emit`this.x=x*re+(ay*z-az*y)*im+ax*q`;\n      fg.emit`this.y=y*re+(az*x-ax*z)*im+ay*q`;\n      fg.emit`this.z=z*re+(ax*y-ay*x)*im+az*q`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      fg.name = 'applyQuaternion';\n      fg.params = ['quaternion'];\n      fg.emit`var x=this.x,y=this.y,z=this.z,`;\n      fg.emit`re=quaternion.re,`;\n      fg.emit`imX=quaternion.imX,`;\n      fg.emit`imY=quaternion.imY,`;\n      fg.emit`imZ=quaternion.imZ,`;\n      fg.emit`tRe=imX*x+imY*y+imZ*z,`;\n      fg.emit`tImX=re*x+imZ*y-imY*z,`;\n      fg.emit`tImY=re*y+imX*z-imZ*x,`;\n      fg.emit`tImZ=re*z+imY*x-imX*y`;\n      fg.emit`this.x=tRe*imX+tImX*re+tImY*imZ-tImZ*imY`;\n      fg.emit`this.y=tRe*imY+tImY*re+tImZ*imX-tImX*imZ`;\n      fg.emit`this.z=tRe*imZ+tImZ*re+tImX*imY-tImY*imX`;\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = 'multiplyLinearMatrix';\n    fg.params = ['matrix'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=this.${a}`;\n    }\n\n    for (const _ref15 of as.entries()) {\n      var _ref16 = vectors_slicedToArray(_ref15, 2);\n\n      const j = _ref16[0];\n      const a = _ref16[1];\n      fg.emit`this.${a}=${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty('multiplyLinearMatrix', 'applyLinearMatrix');\n  defineMethod(fg => {\n    fg.name = 'multiplyAffineMatrix';\n    fg.params = ['matrix'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=this.${a}`;\n    }\n\n    for (const _ref17 of as.entries()) {\n      var _ref18 = vectors_slicedToArray(_ref17, 2);\n\n      const j = _ref18[0];\n      const a = _ref18[1];\n      fg.emit`this.${a}=${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}+matrix._${d}${j}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty('multiplyAffineMatrix', 'applyAffineMatrix');\n  defineMethod(fg => {\n    fg.name = 'multiplyHomogeneousMatrix';\n    fg.params = ['matrix'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=this.${a}`;\n    }\n\n    fg.emit`var invW=1/(${as.map((a, i) => `${a}*matrix._${i}${d}`).join('+')}+matrix._${d}${d})`;\n\n    for (const _ref19 of as.entries()) {\n      var _ref20 = vectors_slicedToArray(_ref19, 2);\n\n      const j = _ref20[0];\n      const a = _ref20[1];\n      fg.emit`this.${a}=(${as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')}+matrix._${d}${j})*invW`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty('multiplyHomogeneousMatrix', 'applyHomogeneousMatrix');\n  return Vector;\n}\n\nconst Vector2 = makeClass(2);\nconst Vector3 = makeClass(3);\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/complex.js\n\n\n\nconst complex_Complex = (() => {\n  /**\n   * @class module:@wgetemp/math.Complex\n   * @summary Complex number. Used for representing 2D rotations and uniform\n   *     scaling.\n   * @param {number} [re=1] Real component.\n   * @param {number} [im=0] Imaginary component.\n   */\n  class Complex {\n    constructor(re = 1, im = 0) {\n      /**\n       * @var module:@wgetemp/math.Complex#re\n       * @summary Real component.\n       * @type {number}\n       */\n      this.re = re;\n      /**\n       * @var module:@wgetemp/math.Complex#im\n       * @summary Imaginary component.\n       * @type {number}\n       */\n\n      this.im = im;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#set\n     * @summary Set complex components.\n     * @param {number} re Real component.\n     * @param {number} im Imaginary component.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    set(re, im) {\n      this.re = re;\n      this.im = im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromNumber\n     * @summary Set complex from real number.\n     * @desc ```\n     * this.re = re;\n     * this.im = 0;\n     * ```\n     * @param {number} re Real component.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromNumber(re) {\n      this.re = re;\n      this.im = 0;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromComplex\n     * @summary Set complex from another complex.\n     * @param {module:@wgetemp/math.Complex} complex Source complex.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromComplex(complex) {\n      this.re = complex.re;\n      this.im = complex.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromVector2\n     * @summary Set complex from 2D vector.\n     * @desc ```\n     * this.re = vector.x;\n     * this.im = vector.y;\n     * ```\n     * @param {module:@wgetemp/math.Vector2} complex Source vector.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromVector2(vector) {\n      this.re = vector.x;\n      this.im = vector.y;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromArray\n     * @summary Set complex from array.\n     * @desc ```\n     * this.re = array[0];\n     * this.im = array[1];\n     * ```\n     * @param {ArrayLike} array Source array. Must have at least two elements.\n     * First two elements must be numbers.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromArray(array) {\n      this.re = array[0];\n      this.im = array[1];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromArrayAt\n     * @summary Set complex from array at given offset.\n     * @desc ```\n     * this.re = array[offset    ];\n     * this.im = array[offset + 1];\n     * ```\n     * @param {number} offset Where in the array to take values from.\n     * @param {ArrayLike} array Source array. Must have at least (`offset` + 2) elements.\n     * Two elements starting at `offset` must be numbers.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromArrayAt(offset, array) {\n      this.re = array[offset];\n      this.im = array[offset + 1];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#toArray\n     * @summary Put complex elements into array.\n     * @desc ```\n     * array[0] = this.re;\n     * array[1] = this.im;\n     * ```\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toArray(array) {\n      array[0] = this.re;\n      array[1] = this.im;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#toArrayAt\n     * @summary Put complex elements into array at given offset.\n     * @desc ```\n     * array[offset    ] = this.re;\n     * array[offset + 1] = this.im;\n     * ```\n     * @param {number} offset Where in the array to put values to.\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toArrayAt(offset, array) {\n      array[offset] = this.re;\n      array[offset + 1] = this.im;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#clone\n     * @returns {module:@wgetemp/math.Complex}\n     */\n\n\n    clone() {\n      return new Complex().copy(this);\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#equals\n     * @param {module:@wgetemp/math.Complex} that Other complex.\n     * @returns {boolean} Whether `this` components are equal to `that`\n     * components.\n     */\n\n\n    equals(that) {\n      return this.re === that.re && this.im === that.im;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#negate\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    negate() {\n      this.re = -this.re;\n      this.im = -this.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#invert\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    invert() {\n      const re = this.re,\n            im = this.im;\n      const invSqAbs = 1 / this.sqAbs;\n      this.re *= invSqAbs;\n      this.im *= -invSqAbs;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#addComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} that Other operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    addComplex(that) {\n      this.re += that.re;\n      this.im += that.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#addNumber\n     * @desc Result is placed into `this`.\n     * @param {number} that Other operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    addNumber(that) {\n      this.re += that;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#subtractComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} right Right operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    subtractComplex(right) {\n      this.re -= right.re;\n      this.im -= right.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#preSubtractComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} left Left operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    preSubtractComplex(left) {\n      this.re = left.re - this.re;\n      this.im = left.im - this.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#subtractNumber\n     * @desc Result is placed into `this`.\n     * @param {number} right Right operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    subtractNumber(right) {\n      this.re -= right;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#preSubtractNumber\n     * @desc Result is placed into `this`.\n     * @param {number} left Left operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    preSubtractNumber(left) {\n      this.re = left - this.re;\n      this.im = -this.im;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#multiplyComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} that Other operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    multiplyComplex(that) {\n      const aRe = this.re,\n            aIm = this.im;\n      const bRe = that.re,\n            bIm = that.im;\n      this.re = aRe * bRe - aIm * bIm;\n      this.im = aRe * bIm + aIm * bRe;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#multiplyNumber\n     * @desc Result is placed into `this`.\n     * @param {number} that Other operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    multiplyNumber(that) {\n      this.re *= that;\n      this.im *= that;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#divideComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} right Right operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    divideComplex(right) {\n      return this.multiplyComplex(tmp.copy(right).invert());\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#preDivideComplex\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Complex} left Left operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    preDivideComplex(left) {\n      return this.invert().multiplyComplex(left);\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#divideNumber\n     * @desc Result is placed into `this`.\n     * @param {number} right Right operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    divideNumber(right) {\n      return this.multiplyNumber(1 / right);\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#preDivideNumber\n     * @desc Result is placed into `this`.\n     * @param {number} left Left operand.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    preDivideNumber(left) {\n      return this.invert().multiplyNumber(left);\n    }\n    /**\n     * @var module:@wgetemp/math.Complex#sqAbs\n     * @summary Squared absolute value (magnitude) of complex number.\n     * @type {number}\n     */\n\n\n    get sqAbs() {\n      const re = this.re,\n            im = this.im;\n      return re * re + im * im;\n    }\n\n    set sqAbs(newSqAbs) {\n      this.multiplyNumber(sqrt(newSqAbs / this.sqAbs));\n    }\n    /**\n     * @var module:@wgetemp/math.Complex#abs\n     * @summary Absolute value (magnitude) of complex number.\n     * @type {number}\n     */\n\n\n    get abs() {\n      return sqrt(this.sqAbs);\n    }\n\n    set abs(newAbs) {\n      this.multiplyNumber(newAbs / this.abs);\n    }\n    /**\n     * @var module:@wgetemp/math.Complex#arg\n     * @summary Argument (rotation angle in radians) of complex number.\n     * @type {number}\n     */\n\n\n    get arg() {\n      return atan2(this.im, this.re);\n    }\n\n    set arg(newArg) {\n      const abs = this.abs;\n      this.re = cos(newArg) * abs;\n      this.im = sin(newArg) * abs;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#normalize\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    normalize() {\n      return this.divideNumber(this.abs);\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromRotation\n     * @summary Initialize `this` with rotation transformation.\n     * @param {number} angle Rotation angle (in radians).\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromRotation(angle) {\n      this.re = cos(angle);\n      this.im = sin(angle);\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#rotate\n     * @summary Apply rotation transformation to `this`.\n     * @param {number} angle Rotation angle (in radians).\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    rotate(angle) {\n      const re = this.re,\n            im = this.im;\n      const s = sin(angle),\n            c = cos(angle);\n      this.re = re * c - im * s;\n      this.im = re * s + im * c;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#fromRotationBetween\n     * @summary Initialize `this` with rotation transformation required to\n     * align `from` with `to`.\n     * @param {module:@wgetemp/math.Vector2} from Initial direction.\n     * Must have unit length.\n     * @param {module:@wgetemp/math.Vector2} to Final direction.\n     * Must have unit length.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    fromRotationBetween(from, to) {\n      this.re = from.dot(to);\n      this.im = from.cross(to);\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Complex#rotateBetween\n     * @summary Apply rotation transformation required to align `from` with `to`.\n     * @param {module:@wgetemp/math.Vector2} from Initial direction.\n     * Must have unit length.\n     * @param {module:@wgetemp/math.Vector2} to Final direction.\n     * Must have unit length.\n     * @returns {module:@wgetemp/math.Complex} `this`\n     */\n\n\n    rotateBetween(from, to) {\n      const re = this.re,\n            im = this.im;\n      const s = from.dot(to),\n            c = from.cross(to);\n      this.re = re * c - im * s;\n      this.im = re * s + im * c;\n      return this;\n    }\n\n  }\n\n  const tmp = new Complex();\n  const aliasProperty = makePropertyAliaser(Complex.prototype);\n  aliasProperty('fromComplex', 'copy');\n  aliasProperty('fromVector2', 'fromVector');\n\n  for (const fn of [functions_isNaN, functions_isFinite]) {\n    const Name = toTitleCase(fn.name);\n    Object.defineProperties(Complex.prototype, {\n      [`some${Name}`]: {\n        configurable: true,\n\n        get() {\n          return fn(this.re) || fn(this.im);\n        }\n\n      },\n      [`every${Name}`]: {\n        configurable: true,\n\n        get() {\n          return fn(this.re) && fn(this.im);\n        }\n\n      }\n    });\n  }\n  /**\n   * @var module:@wgetemp/math.Complex#someIsNaN\n   * @summary Whether some component {@link module:@wgetemp/math.isNaN}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Complex#everyIsNaN\n   * @summary Whether every component {@link module:@wgetemp/math.isNaN}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Complex#someIsFinite\n   * @summary Whether some component {@link module:@wgetemp/math.isFinite}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Complex#everyIsFinite\n   * @summary Whether every component {@link module:@wgetemp/math.isFinite}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @function module:@wgetemp/math.Complex#add\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#addComplex}.\n   * @param {module:@wgetemp/math.Complex} that Other operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n\n  aliasProperty('addComplex', 'add');\n  /**\n   * @function module:@wgetemp/math.Complex#subtract\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#subtractComplex}.\n   * @param {module:@wgetemp/math.Complex} right Right operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('subtractComplex', 'subtract');\n  /**\n   * @function module:@wgetemp/math.Complex#preSubtract\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#preSubtractComplex}.\n   * @param {module:@wgetemp/math.Complex} left Left operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('preSubtractComplex', 'preSubtract');\n  /**\n   * @function module:@wgetemp/math.Complex#multiply\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#multiplyComplex}.\n   * @param {module:@wgetemp/math.Complex} that Other operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('multiplyComplex', 'multiply');\n  /**\n   * @function module:@wgetemp/math.Complex#applyComplex\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#multiplyComplex}.\n   * @param {module:@wgetemp/math.Complex} that Other operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('multiplyComplex', 'applyComplex');\n  /**\n   * @function module:@wgetemp/math.Complex#apply\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#multiply}.\n   * @param {module:@wgetemp/math.Complex} that Other operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('multiply', 'apply');\n  /**\n   * @function module:@wgetemp/math.Complex#divide\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#divideComplex}.\n   * @param {module:@wgetemp/math.Complex} right Right operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('divideComplex', 'divide');\n  /**\n   * @function module:@wgetemp/math.Complex#preDivide\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#preDivideComplex}.\n   * @param {module:@wgetemp/math.Complex} left Left operand.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('preDivideComplex', 'preDivide');\n  /**\n   * @function module:@wgetemp/math.Complex#fromUniformScaling\n   * @summary Initialize `this` with uniform scaling transformation.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#fromNumber}.\n   * @param {number} uniformScaling Uniform scaling factor.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('fromNumber', 'fromUniformScaling');\n  /**\n   * @function module:@wgetemp/math.Complex#scaleUniform\n   * @summary Apply uniform scaling transformation to `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Complex#multiplyNumber}.\n   * @param {number} uniformScaling Uniform scaling factor.\n   * @returns {module:@wgetemp/math.Complex} `this`\n   */\n\n  aliasProperty('multiplyNumber', 'scaleUniform');\n  /**\n   * @var module:@wgetemp/math.Complex#uniformScaling\n   * @summary Uniform scaling factor.\n   * @desc Alias for {@link module:@wgetemp/math.Complex#abs}.\n   * @type {number}\n   */\n\n  aliasProperty('abs', 'uniformScaling');\n  /**\n   * @var module:@wgetemp/math.Complex#rotationAngle\n   * @summary Rotation angle (in radians).\n   * @desc Alias for {@link module:@wgetemp/math.Complex#arg}.\n   * @type {number}\n   */\n\n  aliasProperty('arg', 'rotationAngle');\n  return Complex;\n})();\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/quaternion.js\n\n\n\n\nconst quaternion_Quaternion = (() => {\n  function multiply(result, left, right) {\n    const lRe = left.re,\n          lImX = left.imX,\n          lImY = left.imY,\n          lImZ = left.imZ;\n    const rRe = right.re,\n          rImX = right.imX,\n          rImY = right.imY,\n          rImZ = right.imZ;\n    result.re = lRe * rRe - lImX * rImX - lImY * rImY - lImZ * rImZ;\n    result.imX = lRe * rImX + lImX * rRe + lImY * rImZ - lImZ * rImY;\n    result.imY = lRe * rImY + lImY * rRe + lImZ * rImX - lImX * rImZ;\n    result.imZ = lRe * rImZ + lImZ * rRe + lImX * rImY - lImY * rImX;\n    return result;\n  }\n\n  const im = new Vector3();\n  /**\n   * @class module:@wgetemp/math.Quaternion\n   * @summary Used for representing 3D rotations and uniform scaling.\n   * @desc It is stored in conjugate form, so that multiplication composes transformations from\n   * left to right.\n   * @param {number} [re=1] Real component.\n   * @param {number} [imX=0] Imaginary X component.\n   * @param {number} [imY=0] Imaginary Y component.\n   * @param {number} [imZ=0] Imaginary Z component.\n   */\n\n  class Quaternion {\n    constructor(re = 1, imX = 0, imY = 0, imZ = 0) {\n      /**\n       * @var module:@wgetemp/math.Quaternion#re\n       * @summary Real component.\n       * @type {number}\n       */\n      this.re = re;\n      /**\n       * @var module:@wgetemp/math.Quaternion#imX\n       * @summary Imaginary X component.\n       * @type {number}\n       */\n\n      this.imX = imX;\n      /**\n       * @var module:@wgetemp/math.Quaternion#imY\n       * @summary Imaginary Y component.\n       * @type {number}\n       */\n\n      this.imY = imY;\n      /**\n       * @var module:@wgetemp/math.Quaternion#imZ\n       * @summary Imaginary Z component.\n       * @type {number}\n       */\n\n      this.imZ = imZ;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#set\n     * @summary Set quaternion components.\n     * @param {number} re Real component.\n     * @param {number} imX Imaginary X component.\n     * @param {number} imY Imaginary Y component.\n     * @param {number} imZ Imaginary Z component.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    set(re, imX, imY, imZ) {\n      this.re = re;\n      this.imX = imX;\n      this.imY = imY;\n      this.imZ = imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromNumber\n     * @summary Set quaternion from real number.\n     * @desc ```\n     * this.re = re;\n     * this.imX = 0;\n     * this.imY = 0;\n     * this.imZ = 0;\n     * ```\n     * @param {number} re Real component.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromNumber(re) {\n      this.re = re;\n      this.imX = 0;\n      this.imY = 0;\n      this.imZ = 0;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromQuaternion\n     * @summary Set quaternion from another quaternion.\n     * @param {module:@wgetemp/math.Quaternion} quaternion Source quaternion.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromQuaternion(quaternion) {\n      this.re = quaternion.re;\n      this.imX = quaternion.imX;\n      this.imY = quaternion.imY;\n      this.imZ = quaternion.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromArray\n     * @summary Set quaternion from array.\n     * @desc The array is expected to store the quaternion in more commonly used, non-conjugate\n     * form, with imaginary components preceding the real one:\n     * ```\n     * this.imX = -array[0];\n     * this.imY = -array[1];\n     * this.imZ = -array[2];\n     * this.re  =  array[3];\n     * ```\n     * @param {ArrayLike} array Source array. Must have at least four elements.\n     * First four elements must be numbers.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromArray(array) {\n      this.imX = -array[0];\n      this.imY = -array[1];\n      this.imZ = -array[2];\n      this.re = array[3];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromArrayAt\n     * @summary Set quaternion from array at given offset.\n     * @desc The array is expected to store the quaternion in more commonly used, non-conjugate\n     * form, with imaginary components preceding the real one:\n     * ```\n     * this.imX = -array[offset    ];\n     * this.imY = -array[offset + 1];\n     * this.imZ = -array[offset + 2];\n     * this.re  =  array[offset + 3];\n     * ```\n     * @param {number} offset Where in the array to take values from.\n     * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.\n     * Four elements starting at `offset` must be numbers.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromArrayAt(offset, array) {\n      this.imX = -array[offset];\n      this.imY = -array[offset + 1];\n      this.imZ = -array[offset + 2];\n      this.re = array[offset + 3];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#toArray\n     * @summary Put quaternion elements into array.\n     * @desc The array will store the quaternion in more commonly used, non-conjugate\n     * form, with imaginary components preceding the real one:\n     * ```\n     * array[0] = -this.imX;\n     * array[1] = -this.imY;\n     * array[2] = -this.imZ;\n     * array[3] =  this.re;\n     * ```\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toArray(array) {\n      array[0] = -this.imX;\n      array[1] = -this.imY;\n      array[2] = -this.imZ;\n      array[3] = this.re;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#toArrayAt\n     * @summary Put quaternion elements into array at given offset.\n     * @desc The array will store the quaternion in more commonly used, non-conjugate\n     * form, with imaginary components preceding the real one:\n     * ```\n     * array[offset    ] = -this.imX;\n     * array[offset + 1] = -this.imY;\n     * array[offset + 2] = -this.imZ;\n     * array[offset + 3] =  this.re;\n     * ```\n     * @param {number} offset Where in the array to put values to.\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toArrayAt(offset, array) {\n      array[offset] = -this.imX;\n      array[offset + 1] = -this.imY;\n      array[offset + 2] = -this.imZ;\n      array[offset + 3] = this.re;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromConjugateArray\n     * @summary Set quaternion from array.\n     * @desc The array is expected to store the quaternion in conjugate form, with imaginary\n     * components preceding the real one:\n     * ```\n     * this.imX = array[0];\n     * this.imY = array[1];\n     * this.imZ = array[2];\n     * this.re  = array[3];\n     * ```\n     * @param {ArrayLike} array Source array. Must have at least four elements.\n     * First four elements must be numbers.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromConjugateArray(array) {\n      this.imX = array[0];\n      this.imY = array[1];\n      this.imZ = array[2];\n      this.re = array[3];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromConjugateArrayAt\n     * @summary Set quaternion from array at given offset.\n     * @desc The array is expected to store the quaternion in conjugate form, with imaginary\n     * components preceding the real one:\n     * ```\n     * this.imX = array[offset    ];\n     * this.imY = array[offset + 1];\n     * this.imZ = array[offset + 2];\n     * this.re  = array[offset + 3];\n     * ```\n     * @param {number} offset Where in the array to take values from.\n     * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.\n     * Four elements starting at `offset` must be numbers.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromConjugateArrayAt(offset, array) {\n      this.imX = array[offset];\n      this.imY = array[offset + 1];\n      this.imZ = array[offset + 2];\n      this.re = array[offset + 3];\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#toConjugateArray\n     * @summary Put quaternion elements into array.\n     * @desc The array will store the quaternion in conjugate form, with imaginary components\n     * preceding the real one:\n     * ```\n     * array[0] = this.imX;\n     * array[1] = this.imY;\n     * array[2] = this.imZ;\n     * array[3] = this.re;\n     * ```\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toConjugateArray(array) {\n      array[0] = this.imX;\n      array[1] = this.imY;\n      array[2] = this.imZ;\n      array[3] = this.re;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#toConjugateArrayAt\n     * @summary Put quaternion elements into array at given offset.\n     * @desc The array will store the quaternion in conjugate form, with imaginary components\n     * preceding the real one:\n     * ```\n     * array[offset    ] = this.imX;\n     * array[offset + 1] = this.imY;\n     * array[offset + 2] = this.imZ;\n     * array[offset + 3] = this.re;\n     * ```\n     * @param {number} offset Where in the array to put values to.\n     * @param {ArrayLike} array Destination array.\n     * @returns {ArrayLike} `array`\n     */\n\n\n    toConjugateArrayAt(offset, array) {\n      array[offset] = this.imX;\n      array[offset + 1] = this.imY;\n      array[offset + 2] = this.imZ;\n      array[offset + 3] = this.re;\n      return array;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#clone\n     * @returns {module:@wgetemp/math.Quaternion}\n     */\n\n\n    clone() {\n      return new Quaternion().copy(this);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#equals\n     * @param {module:@wgetemp/math.Quaternion} that Other quaternion.\n     * @returns {boolean} Whether `this` components are equal to `that`\n     * components.\n     */\n\n\n    equals(that) {\n      return this.re === that.re && this.imX === that.imX && this.imY === that.imY && this.imZ === that.imZ;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#negate\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    negate() {\n      this.re = -this.re;\n      this.imX = -this.imX;\n      this.imY = -this.imY;\n      this.imZ = -this.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#conjugate\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    conjugate() {\n      this.imX = -this.imX;\n      this.imY = -this.imY;\n      this.imZ = -this.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#invert\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    invert() {\n      const invNegSqAbs = -1 / this.sqAbs;\n      this.re *= -invNegSqAbs;\n      this.imX *= invNegSqAbs;\n      this.imY *= invNegSqAbs;\n      this.imZ *= invNegSqAbs;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#addQuaternion\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Quaternion} that Other operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    addQuaternion(that) {\n      this.re += that.re;\n      this.imX += that.imX;\n      this.imY += that.imY;\n      this.imZ += that.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#addNumber\n     * @desc Result is placed into `this`.\n     * @param {number} that Other operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    addNumber(that) {\n      this.re += that;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#subtractQuaternion\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Quaternion} right Right operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    subtractQuaternion(right) {\n      this.re -= right.re;\n      this.imX -= right.imX;\n      this.imY -= right.imY;\n      this.imZ -= right.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#preSubtractQuaternion\n     * @desc Result is placed into `this`.\n     * @param {module:@wgetemp/math.Quaternion} left Left operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preSubtractQuaternion(left) {\n      this.re = left.re - this.re;\n      this.imX = left.imX - this.imX;\n      this.imY = left.imY - this.imY;\n      this.imZ = left.imZ - this.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#subtractNumber\n     * @desc Result is placed into `this`.\n     * @param {number} right Right operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    subtractNumber(right) {\n      this.re -= right;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#preSubtractNumber\n     * @desc Result is placed into `this`.\n     * @param {number} left Left operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preSubtractNumber(left) {\n      this.re = left - this.re;\n      this.imX = -this.imX;\n      this.imY = -this.imY;\n      this.imZ = -this.imZ;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#multiplyQuaternion\n     * @desc Composes transformations left to right. Result is placed into `this`.\n     * @param {module:@wgetemp/math.Quaternion} right Right operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    multiplyQuaternion(right) {\n      return multiply(this, this, right);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#preMultiplyQuaternion\n     * @desc Composes transformations left to right. Result is placed into `this`.\n     * @param {module:@wgetemp/math.Quaternion} left Left operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preMultiplyQuaternion(left) {\n      return multiply(this, left, this);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#multiplyNumber\n     * @desc Result is placed into `this`.\n     * @param {number} that Other operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    multiplyNumber(that) {\n      this.re *= that;\n      this.imX *= that;\n      this.imY *= that;\n      this.imZ *= that;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#divideNumber\n     * @desc Result is placed into `this`.\n     * @param {number} right Right operand.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    divideNumber(right) {\n      return this.multiplyNumber(1 / right);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#imPaste\n     * @summary Paste imaginary components into a vector.\n     * @param {module:@wgetemp/math.Vector3} im Destination vector.\n     * @returns {module:@wgetemp/math.Vector3} `im`\n     */\n\n\n    imPaste(im) {\n      im.x = this.imX;\n      im.y = this.imY;\n      im.z = this.imZ;\n      return im;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#imPaste\n     * @summary Sets imaginary components from vector.\n     * @desc Real component is not modified.\n     * @param {module:@wgetemp/math.Vector3} im Source vector.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    imCopy(im) {\n      this.imX = im.x;\n      this.imY = im.y;\n      this.imZ = im.z;\n      return this;\n    }\n    /**\n     * @var module:@wgetemp/math.Quaternion#sqAbs\n     * @summary Squared absolute value (magnitude) of quaternion.\n     * @type {number}\n     */\n\n\n    get sqAbs() {\n      const re = this.re,\n            imX = this.imX,\n            imY = this.imY,\n            imZ = this.imZ;\n      return re * re + imX * imX + imY * imY + imZ * imZ;\n    }\n\n    set sqAbs(newSqAbs) {\n      this.multiplyNumber(sqrt(newSqAbs / this.sqAbs));\n    }\n    /**\n     * @var module:@wgetemp/math.Quaternion#abs\n     * @summary Absolute value (magnitude aka norm) of quaternion.\n     * @type {number}\n     */\n\n\n    get abs() {\n      return sqrt(this.sqAbs);\n    }\n\n    set abs(newAbs) {\n      this.multiplyNumber(newAbs / this.abs);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#normalize\n     * @desc In place.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    normalize() {\n      return this.divideNumber(this.abs);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromUniformScaling\n     * @summary Initialize `this` with uniform scaling transformation.\n     * @param {number} factor Uniform scaling factor.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromUniformScaling(scaling) {\n      return this.fromNumber(sqrt(scaling));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#scaleUniform\n     * @summary Apply uniform scaling transformation to `this`.\n     * @param {number} factor Uniform scaling factor.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    scaleUniform(scaling) {\n      return this.multiplyNumber(sqrt(scaling));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromRotation\n     * @summary Initialize `this` with rotation transformation.\n     * @param {number} angle Rotation angle (in radians).\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromRotation(angle, axis) {\n      const halfAngle = angle * 0.5;\n      const minusSin = -sin(halfAngle);\n      this.re = cos(halfAngle);\n      this.imX = minusSin * axis.x;\n      this.imY = minusSin * axis.y;\n      this.imZ = minusSin * axis.z;\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#rotate\n     * @summary (Post-)apply rotation transformation to `this`.\n     * @param {number} angle Rotation angle (in radians).\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    rotate(angle, axis) {\n      return this.multiply(tmp.fromRotation(angle, axis));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#preRotate\n     * @summary Pre-apply rotation transformation to `this`.\n     * @param {number} angle Rotation angle (in radians).\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preRotate(angle, axis) {\n      return this.preMultiply(tmp.fromRotation(angle, axis));\n    }\n    /**\n     * @var module:@wgetemp/math.Quaternion#rotationAngle\n     * @summary Rotation angle (in radians).\n     * @type {number}\n     */\n\n\n    get rotationAngle() {\n      return 2 * acos(this.re / this.abs);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#rotationAxisPaste\n     * @summary Paste rotation axis into a vector.\n     * @param {module:@wgetemp/math.Vector3} axis Destination vector.\n     * @returns {module:@wgetemp/math.Vector3} `axis`\n     */\n\n\n    rotationAxisPaste(axis) {\n      return this.imPaste(axis).negate().normalize();\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromRotationBetween\n     * @summary Initialize `this` with rotation transformation required to\n     * align `from` with `to`.\n     * @param {module:@wgetemp/math.Vector3} from Initial direction.\n     * Must have unit length.\n     * @param {module:@wgetemp/math.Vector3} to Final direction.\n     * Must have unit length.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromRotationBetween(from, to) {\n      this.re = from.dot(to) + 1;\n      this.imCopy(im.copy(to).cross(from));\n      this.normalize();\n\n      if (!this.everyIsFinite) {\n        this.re = 0;\n        this.imCopy(im.copy(from).orthogonalize());\n      }\n\n      return this;\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#rotateBetween\n     * @summary (Post-)apply rotation transformation required to align `from` with `to`.\n     * @param {module:@wgetemp/math.Vector3} from Initial direction.\n     * Must have unit length.\n     * @param {module:@wgetemp/math.Vector3} to Final direction.\n     * Must have unit length.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    rotateBetween(from, to) {\n      return this.multiply(tmp.fromRotationBetween(from, to));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#preRotateBetween\n     * @summary Pre-apply rotation transformation required to align `from` with `to`.\n     * @param {module:@wgetemp/math.Vector3} from Initial direction.\n     * Must have unit length.\n     * @param {module:@wgetemp/math.Vector3} to Final direction.\n     * Must have unit length.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preRotateBetween(from, to) {\n      return this.preMultiply(tmp.fromRotationBetween(from, to));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#fromComplex\n     * @summary Initialize `this` with transformation encoded in\n     * {module:@wgetemp/math.Complex} about given axis.\n     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    fromComplex(complex, axis) {\n      return this.fromRotation(complex.rotationAngle, axis).scaleUniform(complex.uniformScaling);\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#applyComplex\n     * @summary (Post-)apply transformation encoded in\n     * {module:@wgetemp/math.Complex} about given axis.\n     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    applyComplex(complex, axis) {\n      return this.multiply(tmp.fromComplex(complex, axis));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#applyComplex\n     * @summary Pre-apply transformation encoded in\n     * {module:@wgetemp/math.Complex} about given axis.\n     * @param {module:@wgetemp/math.Complex} complex Rotation and/or uniform scaling.\n     * @param {module:@wgetemp/math.Vector3} axis Rotation axis.\n     * @returns {module:@wgetemp/math.Quaternion} `this`\n     */\n\n\n    preApplyComplex(complex, axis) {\n      return this.preMultiply(tmp.fromComplex(complex, axis));\n    }\n    /**\n     * @function module:@wgetemp/math.Quaternion#complexPaste\n     * @summary Paste transformation within the plane othrogonal to rotation axis.\n     * @param {module:@wgetemp/math.Complex} axis Destination complex.\n     * @returns {module:@wgetemp/math.Complex} `complex`\n     */\n\n\n    complexPaste(complex) {\n      const re = this.re,\n            imX = this.imX,\n            imY = this.imY,\n            imZ = this.imZ;\n      const sqIm = imX * imX + imY * imY + imZ * imZ;\n      complex.re = re * re - sqIm;\n      complex.im = 2 * re * sqrt(sqIm);\n      return complex;\n    }\n\n  }\n\n  const tmp = new Quaternion();\n  const aliasProperty = makePropertyAliaser(Quaternion.prototype);\n  /**\n   * @function module:@wgetemp/math.Quaternion#copy\n   * @summary Set quaternion from another quaternion.\n   * @desc Alias for {@link module:@wgetemp/math.Quaternion#fromQuaternion}.\n   * @param {module:@wgetemp/math.Quaternion} quaternion Source quaternion.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('fromQuaternion', 'copy');\n\n  for (const fn of [functions_isNaN, functions_isFinite]) {\n    const Name = toTitleCase(fn.name);\n    Object.defineProperties(Quaternion.prototype, {\n      [`some${Name}`]: {\n        configurable: true,\n\n        get() {\n          return fn(this.re) || fn(this.imX) || fn(this.imY) || fn(this.imZ);\n        }\n\n      },\n      [`every${Name}`]: {\n        configurable: true,\n\n        get() {\n          return fn(this.re) && fn(this.imX) && fn(this.imY) && fn(this.imZ);\n        }\n\n      }\n    });\n  }\n  /**\n   * @var module:@wgetemp/math.Quaternion#someIsNaN\n   * @summary Whether some component {@link module:@wgetemp/math.isNaN}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Quaternion#everyIsNaN\n   * @summary Whether every component {@link module:@wgetemp/math.isNaN}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Quaternion#someIsFinite\n   * @summary Whether some component {@link module:@wgetemp/math.isFinite}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @var module:@wgetemp/math.Quaternion#everyIsFinite\n   * @summary Whether every component {@link module:@wgetemp/math.isFinite}.\n   * @type {boolean}\n   * @readonly\n   */\n\n  /**\n   * @function module:@wgetemp/math.Quaternion#add\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#addQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} that Other operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n\n  aliasProperty('addQuaternion', 'add');\n  /**\n   * @function module:@wgetemp/math.Quaternion#subtract\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#subtractQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} right Right operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('subtractQuaternion', 'subtract');\n  /**\n   * @function module:@wgetemp/math.Quaternion#preSubtract\n   * @desc Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#preSubtractQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} left Left operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('preSubtractQuaternion', 'preSubtract');\n  /**\n   * @function module:@wgetemp/math.Quaternion#multiply\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#multiplyQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} right Right operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('multiplyQuaternion', 'multiply');\n  /**\n   * @function module:@wgetemp/math.Quaternion#applyQuaternion\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#multiplyQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} right Right operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('multiplyQuaternion', 'applyQuaternion');\n  /**\n   * @function module:@wgetemp/math.Quaternion#apply\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#multiply}\n   * @param {module:@wgetemp/math.Quaternion} right Right operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('multiply', 'apply');\n  /**\n   * @function module:@wgetemp/math.Quaternion#preMultiply\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiplyQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} left Left operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('preMultiplyQuaternion', 'preMultiply');\n  /**\n   * @function module:@wgetemp/math.Quaternion#preApplyQuaternion\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiplyQuaternion}\n   * @param {module:@wgetemp/math.Quaternion} left Left operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('preMultiplyQuaternion', 'preApplyQuaternion');\n  /**\n   * @function module:@wgetemp/math.Quaternion#preApply\n   * @desc Composes transformations left to right. Result is placed into `this`.\n   *\n   * Alias for {@link module:@wgetemp/math.Quaternion#preMultiply}\n   * @param {module:@wgetemp/math.Quaternion} left Left operand.\n   * @returns {module:@wgetemp/math.Quaternion} `this`\n   */\n\n  aliasProperty('preMultiply', 'preApply');\n  /**\n   * @var module:@wgetemp/math.Quaternion#uniformScaling\n   * @summary Uniform scaling factor.\n   * @desc Alias for {@link module:@wgetemp/math.Quaternion#sqAbs}\n   * @type {number}\n   */\n\n  aliasProperty('sqAbs', 'uniformScaling');\n  return Quaternion;\n})();\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/matrices.js\nfunction matrices_slicedToArray(arr, i) { return matrices_arrayWithHoles(arr) || matrices_iterableToArrayLimit(arr, i) || matrices_unsupportedIterableToArray(arr, i) || matrices_nonIterableRest(); }\n\nfunction matrices_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction matrices_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return matrices_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return matrices_arrayLikeToArray(o, minLen); }\n\nfunction matrices_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction matrices_iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction matrices_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nconst matrices_aas = [...'xyzw'];\nconst ais = [0, 1, 2, 3];\nconst KINDS = {\n  LINEAR: {\n    name: 'Linear',\n    rd: 0,\n    cd: 0\n  },\n  AFFINE: {\n    name: 'Affine',\n    rd: 1,\n    cd: 0\n  },\n  HOMOGENEOUS: {\n    name: 'Homogeneous',\n    rd: 1,\n    cd: 1\n  }\n};\n\nfunction matrices_makeClass(kind, d) {\n  const r = d + kind.rd;\n  const c = d + kind.cd;\n  const is = ais.slice(0, r);\n  const js = ais.slice(0, c);\n  const as = matrices_aas.slice(0, d);\n  const Matrix = generateFunction(fg => {\n    fg.name = `${kind.name}Matrix${d}`;\n\n    for (const i of is) for (const j of js) {\n      fg.params.push(`_${i}${j}`);\n    }\n\n    for (const j of js) for (const i of is) {\n      fg.emit`this._${i}${j}=${`_${i}${j}===undefined?${+(i === j)}:_${i}${j}`}`;\n    }\n\n    if (false) {}\n  });\n\n  for (const _ref of Object.entries({\n    kind: kind.name.toLowerCase(),\n    rowCount: r,\n    columnCount: c\n  })) {\n    var _ref2 = matrices_slicedToArray(_ref, 2);\n\n    const name = _ref2[0];\n    const value = _ref2[1];\n    Object.defineProperty(Matrix.prototype, name, {\n      configurable: true,\n      value\n    });\n\n    if (false) {}\n  }\n\n  if (false) {}\n\n  const defineMethod = makeMethodDefiner(Matrix.prototype);\n  const defineGetter = makeGetterDefiner(Matrix.prototype);\n  const defineSetter = makeSetterDefiner(Matrix.prototype);\n  const aliasProperty = makePropertyAliaser(Matrix.prototype);\n\n  for (const srcKind of Object.values(KINDS)) {\n    const srcR = d + srcKind.rd;\n    const srcC = d + srcKind.cd;\n\n    if (srcR > r || srcC > c) {\n      continue;\n    }\n\n    const srcIs = ais.slice(0, srcR);\n    const srcJs = ais.slice(0, srcC);\n    defineMethod(fg => {\n      fg.name = `set${srcKind.name}`;\n\n      for (const i of srcIs) for (const j of srcJs) {\n        fg.params.push(`_${i}${j}`);\n      }\n\n      for (const j of js) for (const i of is) {\n        fg.emit`this._${i}${j}=${(() => {\n          if (i < srcR && j < srcC) {\n            return `_${i}${j}`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  aliasProperty(`set${kind.name}`, 'set');\n  defineMethod(fg => {\n    fg.name = 'fromNumber';\n    fg.params = ['number'];\n\n    for (const j of js) for (const i of is) {\n      fg.emit`this._${i}${j}=${(() => {\n        if (i === j && i < d) {\n          return 'number';\n        }\n\n        return +(i === j);\n      })()}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n\n  for (const srcKind of Object.values(KINDS)) {\n    const srcR = d + srcKind.rd;\n    const srcC = d + srcKind.cd;\n\n    if (srcR > r || srcC > c) {\n      continue;\n    }\n\n    defineMethod(fg => {\n      fg.name = `from${srcKind.name}Matrix${d}`;\n      fg.params = ['matrix'];\n\n      for (const j of js) for (const i of is) {\n        fg.emit`this._${i}${j}=${(() => {\n          if (i < srcR && j < srcC) {\n            return `matrix._${i}${j}`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    aliasProperty(`from${srcKind.name}Matrix${d}`, `from${srcKind.name}Matrix`);\n    aliasProperty(`from${srcKind.name}Matrix${d}`, `from${srcKind.name}${d}`);\n    aliasProperty(`from${srcKind.name}Matrix`, `from${srcKind.name}`);\n\n    if (d > 2) {\n      defineMethod(fg => {\n        fg.name = `from${srcKind.name}Matrix2`;\n        fg.params = ['matrix'];\n\n        for (const j of js) for (const i of is) {\n          fg.emit`this._${i}${j}=${(() => {\n            if (i < d - 1 && j < d - 1) {\n              return `matrix._${i}${j}`;\n            }\n\n            if (i === d && srcKind.rd && j < d - 1 || j === d && srcKind.cd && i < d - 1 || i === d && srcKind.rd && j === d && srcKind.cd) {\n              return `matrix._${i - (i >= d)}${j - (j >= d)}`;\n            }\n\n            return +(i === j);\n          })()}`;\n        }\n\n        fg.emit`return this`;\n\n        if (false) {}\n      });\n      aliasProperty(`from${srcKind.name}Matrix2`, `from${srcKind.name}2`);\n    }\n  }\n\n  aliasProperty(`from${kind.name}`, 'copy');\n\n  for (const arrayKind of Object.values(KINDS)) {\n    const arrayR = d + arrayKind.rd;\n    const arrayC = d + arrayKind.cd;\n    const arrayIs = ais.slice(0, arrayR);\n    const arrayJs = ais.slice(0, arrayC);\n\n    for (const _ref3 of [['Row', (i, j) => i * arrayC + j], ['Column', (i, j) => j * arrayR + i]]) {\n      var _ref4 = matrices_slicedToArray(_ref3, 2);\n\n      const Layout = _ref4[0];\n      const getOffset = _ref4[1];\n\n      if (arrayR <= r && arrayC <= c) {\n        defineMethod(fg => {\n          fg.name = `from${arrayKind.name}${Layout}ArrayAt`;\n          fg.params = ['offset', 'array'];\n\n          for (const j of js) for (const i of is) {\n            fg.emit`this._${i}${j}=${(() => {\n              if (i < arrayR && j < arrayC) {\n                return `array[offset+${getOffset(i, j)}]`;\n              }\n\n              return +(i === j);\n            })()}`;\n          }\n\n          fg.emit`return this`;\n\n          if (false) {}\n        });\n        defineMethod(fg => {\n          fg.name = `from${arrayKind.name}${Layout}Array`;\n          fg.params = ['array'];\n          fg.emit`return this.from${arrayKind.name}${Layout}ArrayAt(${`0,array`})`;\n\n          if (false) {}\n        });\n\n        if (arrayKind === kind) {\n          aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`, `from${Layout}ArrayAt`);\n          aliasProperty(`from${arrayKind.name}${Layout}Array`, `from${Layout}Array`);\n        }\n\n        if (Layout === 'Row') {\n          aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`, `from${arrayKind.name}ArrayAt`);\n          aliasProperty(`from${arrayKind.name}${Layout}Array`, `from${arrayKind.name}Array`);\n\n          if (arrayKind === kind) {\n            aliasProperty(`from${Layout}ArrayAt`, 'fromArrayAt');\n            aliasProperty(`from${Layout}Array`, 'fromArray');\n          }\n        }\n      }\n\n      if (arrayR >= r && arrayC >= c) {\n        defineMethod(fg => {\n          fg.name = `to${arrayKind.name}${Layout}ArrayAt`;\n          fg.params = ['offset', 'array'];\n\n          for (const j of arrayJs) for (const i of arrayIs) {\n            fg.emit`array[offset+${getOffset(i, j)}]=${(() => {\n              if (i < r && j < c) {\n                return `this._${i}${j}`;\n              }\n\n              return +(i === j);\n            })()}`;\n          }\n\n          fg.emit`return array`;\n\n          if (false) {}\n        });\n        defineMethod(fg => {\n          fg.name = `to${arrayKind.name}${Layout}Array`;\n          fg.params = ['array'];\n          fg.emit`return this.to${arrayKind.name}${Layout}ArrayAt(${`0,array`})`;\n\n          if (false) {}\n        });\n\n        if (arrayKind === kind) {\n          aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`, `to${Layout}ArrayAt`);\n          aliasProperty(`to${arrayKind.name}${Layout}Array`, `to${Layout}Array`);\n        }\n\n        if (Layout === 'Row') {\n          aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`, `to${arrayKind.name}ArrayAt`);\n          aliasProperty(`to${arrayKind.name}${Layout}Array`, `to${arrayKind.name}Array`);\n\n          if (arrayKind === kind) {\n            aliasProperty(`to${Layout}ArrayAt`, 'toArrayAt');\n            aliasProperty(`to${Layout}Array`, 'toArray');\n          }\n        }\n      }\n    }\n  }\n\n  defineMethod(fg => {\n    fg.ctx[Matrix.name] = Matrix;\n    fg.name = 'clone';\n    fg.emit`return new ${Matrix.name}().copy(this)`;\n\n    if (false) {}\n  });\n\n  for (const fn of [functions_isNaN, functions_isFinite]) {\n    const name = fn.name,\n          Name = toTitleCase(name);\n    defineGetter(fg => {\n      fg.ctx[name] = fn;\n      fg.name = `some${Name}`;\n      fg.emit`return ${js.map(j => {\n        return is.map(i => `${name}(this._${i}${j})`).join('||');\n      }).join('||')}`;\n\n      if (false) {}\n    });\n    defineGetter(fg => {\n      fg.ctx[name] = fn;\n      fg.name = `every${Name}`;\n      fg.emit`return ${js.map(j => {\n        return is.map(i => `${name}(this._${i}${j})`).join('&&');\n      }).join('&&')}`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = 'equals';\n    fg.params = ['that'];\n    fg.emit`return ${js.map(j => {\n      return is.map(i => `this._${i}${j}===that._${i}${j}`).join('&&');\n    }).join('&&')}`;\n\n    if (false) {}\n  });\n\n  if (c === r) {\n    defineMethod(fg => {\n      fg.name = 'transpose';\n\n      for (const j of js) for (const i of is) {\n        if (i <= j) {\n          continue;\n        }\n\n        fg.emit`${['var '].slice(i !== 1)}t=this._${i}${j}`;\n        fg.emit`this._${i}${j}=this._${j}${i}`;\n        fg.emit`this._${j}${i}=t`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = 'invert';\n\n    for (const j of js) for (const i of is) {\n      fg.emit`var _${i}${j}=this._${i}${j}`;\n    }\n\n    if (r === 3 && c === 2) {\n      fg.emit`var c02=_10*_21-_20*_11,`;\n      fg.emit`c12=_00*_21-_20*_01`;\n    } else if (r === 3 && c === 3) {\n      fg.emit`var c00=_11*_22-_21*_12,`;\n      fg.emit`c01=_10*_22-_20*_12,`;\n      fg.emit`c02=_10*_21-_20*_11,`;\n      fg.emit`c10=_01*_22-_21*_02,`;\n      fg.emit`c11=_00*_22-_20*_02,`;\n      fg.emit`c12=_00*_21-_20*_01,`;\n      fg.emit`c20=_01*_12-_11*_02,`;\n      fg.emit`c21=_00*_12-_10*_02,`;\n      fg.emit`c22=_00*_11-_10*_01`;\n    } else if (r === 4 && c === 3) {\n      fg.emit`var c0103=_21*_32-_31*_22,`;\n      fg.emit`c0203=_11*_32-_31*_12,`;\n      fg.emit`c0303=_11*_22-_21*_12,`;\n      fg.emit`c1203=_01*_32-_31*_02,`;\n      fg.emit`c1303=_01*_22-_21*_02,`;\n      fg.emit`c2303=_01*_12-_11*_02,`;\n      fg.emit`c00=_11*_22-_21*_12,`;\n      fg.emit`c01=_10*_22-_20*_12,`;\n      fg.emit`c02=_10*_21-_20*_11,`;\n      fg.emit`c03=_10*c0103-_20*c0203+_30*c0303,`;\n      fg.emit`c10=_01*_22-_21*_02,`;\n      fg.emit`c11=_00*_22-_20*_02,`;\n      fg.emit`c12=_00*_21-_20*_01,`;\n      fg.emit`c13=_00*c0103-_20*c1203+_30*c1303,`;\n      fg.emit`c20=_01*_12-_11*_02,`;\n      fg.emit`c21=_00*_12-_10*_02,`;\n      fg.emit`c22=_00*_11-_10*_01,`;\n      fg.emit`c23=_00*c0203-_10*c1203+_30*c2303`;\n    } else if (r === 4 && c === 4) {\n      fg.emit`var c0101=_22*_33-_32*_23,`;\n      fg.emit`c0201=_12*_33-_32*_13,`;\n      fg.emit`c0301=_12*_23-_22*_13,`;\n      fg.emit`c0102=_21*_33-_31*_23,`;\n      fg.emit`c0202=_11*_33-_31*_13,`;\n      fg.emit`c0302=_11*_23-_21*_13,`;\n      fg.emit`c0103=_21*_32-_31*_22,`;\n      fg.emit`c0203=_11*_32-_31*_12,`;\n      fg.emit`c0303=_11*_22-_21*_12,`;\n      fg.emit`c1201=_02*_33-_32*_03,`;\n      fg.emit`c1301=_02*_23-_22*_03,`;\n      fg.emit`c1202=_01*_33-_31*_03,`;\n      fg.emit`c1302=_01*_23-_21*_03,`;\n      fg.emit`c1203=_01*_32-_31*_02,`;\n      fg.emit`c1303=_01*_22-_21*_02,`;\n      fg.emit`c2301=_02*_13-_12*_03,`;\n      fg.emit`c2302=_01*_13-_11*_03,`;\n      fg.emit`c2303=_01*_12-_11*_02,`;\n      fg.emit`c00=_11*c0101-_21*c0201+_31*c0301,`;\n      fg.emit`c01=_10*c0101-_20*c0201+_30*c0301,`;\n      fg.emit`c02=_10*c0102-_20*c0202+_30*c0302,`;\n      fg.emit`c03=_10*c0103-_20*c0203+_30*c0303,`;\n      fg.emit`c10=_01*c0101-_21*c1201+_31*c1301,`;\n      fg.emit`c11=_00*c0101-_20*c1201+_30*c1301,`;\n      fg.emit`c12=_00*c0102-_20*c1202+_30*c1302,`;\n      fg.emit`c13=_00*c0103-_20*c1203+_30*c1303,`;\n      fg.emit`c20=_01*c0201-_11*c1201+_31*c2301,`;\n      fg.emit`c21=_00*c0201-_10*c1201+_30*c2301,`;\n      fg.emit`c22=_00*c0202-_10*c1202+_30*c2302,`;\n      fg.emit`c23=_00*c0203-_10*c1203+_30*c2303,`;\n      fg.emit`c30=_01*c0301-_11*c1301+_21*c2301,`;\n      fg.emit`c31=_00*c0301-_10*c1301+_20*c2301,`;\n      fg.emit`c32=_00*c0302-_10*c1302+_20*c2302,`;\n      fg.emit`c33=_00*c0303-_10*c1303+_20*c2303`;\n    }\n\n    fg.emit`var invDet=1/(${(() => {\n      if (c === 2) {\n        return '_00*_11-_10*_01';\n      }\n\n      return js.map(i => {\n        return `${'+-'[i % 2].slice(i === 0)}_${i}0*c${i}0`;\n      }).join('');\n    })()}),invNegDet=-invDet`;\n\n    if (r === 2 && c === 2) {\n      fg.emit`this._00=_11*invDet`;\n      fg.emit`this._10=_10*invNegDet`;\n      fg.emit`this._01=_01*invNegDet`;\n      fg.emit`this._11=_00*invDet`;\n    } else if (r === 3 && c === 2) {\n      fg.emit`this._00=_11*invDet`;\n      fg.emit`this._10=_10*invNegDet`;\n      fg.emit`this._20=c02*invDet`;\n      fg.emit`this._01=_01*invNegDet`;\n      fg.emit`this._11=_00*invDet`;\n      fg.emit`this._21=c12*invNegDet`;\n    } else {\n      for (const j of js) for (const i of is) {\n        fg.emit`this._${i}${j}=${(() => {\n          if (i < r && j < c) {\n            return `c${j}${i}*inv${(i + j) % 2 ? 'Neg' : ''}Det`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n\n  for (const rightKind of Object.values(KINDS)) {\n    const rightR = d + rightKind.rd;\n    const rightC = d + rightKind.cd;\n\n    if (rightR > r || rightC > c) {\n      continue;\n    }\n\n    defineMethod(fg => {\n      fg.name = `multiply${rightKind.name}`;\n      fg.params = ['right'];\n\n      for (const j of ais.slice(0, min(c, rightR))) {\n        for (const i of is) {\n          fg.emit`var _${i}${j}=this._${i}${j}`;\n        }\n      }\n\n      for (const j of ais.slice(0, rightC)) {\n        for (const i of ais.slice(0, rightR)) {\n          fg.emit`var r${i}${j}=right._${i}${j}`;\n        }\n      }\n\n      for (const j of ais.slice(0, rightC)) for (const i of is) {\n        fg.emit`this._${i}${j}=${[...function* () {\n          for (let k = 0; k < max(c, rightR); ++k) {\n            const a = i < r && k < c ? `_${i}${k}` : +(i === k);\n            const b = k < rightR && j < rightC ? `r${k}${j}` : +(k === j);\n\n            if (a === 0 || b === 0) {// nop\n            } else if (a === 1) {\n              yield b;\n            } else if (b === 1) {\n              yield a;\n            } else {\n              yield `${a}*${b}`;\n            }\n          }\n        }()].join('+')}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    aliasProperty(`multiply${rightKind.name}`, `apply${rightKind.name}`);\n  }\n\n  aliasProperty(`multiply${kind.name}`, 'multiply');\n  aliasProperty(`multiply${kind.name}`, 'apply');\n\n  for (const leftKind of Object.values(KINDS)) {\n    const leftR = d + leftKind.rd;\n    const leftC = d + leftKind.cd;\n\n    if (leftR > r || leftC > c) {\n      continue;\n    }\n\n    defineMethod(fg => {\n      fg.name = `preMultiply${leftKind.name}`;\n      fg.params = ['left'];\n\n      for (const j of ais.slice(0, min(leftC, r))) {\n        for (const i of ais.slice(0, leftR)) {\n          fg.emit`var l${i}${j}=left._${i}${j}`;\n        }\n      }\n\n      for (const j of js) {\n        for (const i of is) {\n          fg.emit`var _${i}${j}=this._${i}${j}`;\n        }\n      }\n\n      for (const j of js) for (const i of ais.slice(0, leftR)) {\n        fg.emit`this._${i}${j}=${[...function* () {\n          for (let k = 0; k < max(leftC, r); ++k) {\n            const a = i < leftR && k < leftC ? `l${i}${k}` : +(i === k);\n            const b = k < r && j < c ? `_${k}${j}` : +(k === j);\n\n            if (a === 0 || b === 0) {// nop\n            } else if (a === 1) {\n              yield b;\n            } else if (b === 1) {\n              yield a;\n            } else {\n              yield `${a}*${b}`;\n            }\n          }\n        }()].join('+')}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    aliasProperty(`preMultiply${leftKind.name}`, `preApply${leftKind.name}`);\n  }\n\n  aliasProperty(`preMultiply${kind.name}`, 'preMultiply');\n  aliasProperty('preMultiply', 'preApply');\n  defineMethod(fg => {\n    fg.name = 'multiplyNumber';\n    fg.params = ['right'];\n\n    for (const j of js.slice(0, d)) for (const i of is) {\n      fg.emit`this._${i}${j}*=right`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'preMultiplyNumber';\n    fg.params = ['left'];\n\n    for (const j of js) for (const i of is.slice(0, d)) {\n      fg.emit`this._${i}${j}*=left`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineGetter(fg => {\n    fg.name = `determinant`;\n\n    if (c > 2) {\n      for (const j of js.slice(1)) for (const i of js) {\n        fg.emit`var _${i}${j}=this._${i}${j}`;\n      }\n    }\n\n    if (c === 3) {\n      fg.emit`var c00=_11*_22-_21*_12,`;\n      fg.emit`c10=_01*_22-_21*_02,`;\n      fg.emit`c20=_01*_12-_11*_02`;\n    } else if (c === 4) {\n      fg.emit`var c0101=_22*_33-_32*_23,`;\n      fg.emit`c0201=_12*_33-_32*_13,`;\n      fg.emit`c0301=_12*_23-_22*_13,`;\n      fg.emit`c1201=_02*_33-_32*_03,`;\n      fg.emit`c1301=_02*_23-_22*_03,`;\n      fg.emit`c2301=_02*_13-_12*_03,`;\n      fg.emit`c00=_11*c0101-_21*c0201+_31*c0301,`;\n      fg.emit`c10=_01*c0101-_21*c1201+_31*c1301,`;\n      fg.emit`c20=_01*c0201-_11*c1201+_31*c2301,`;\n      fg.emit`c30=_01*c0301-_11*c1301+_21*c2301`;\n    }\n\n    fg.emit`return ${(() => {\n      if (c === 2) {\n        return 'this._00*this._11-this._10*this._01';\n      }\n\n      return js.map(i => {\n        return `${'+-'[i % 2].slice(i === 0)}this._${i}0*c${i}0`;\n      }).join('');\n    })()}`;\n\n    if (false) {}\n  });\n\n  for (const _ref5 of [...as.map((a, i) => {\n    return [i, `axis${a.toUpperCase()}`];\n  }), [d, 'translation']]) {\n    var _ref6 = matrices_slicedToArray(_ref5, 2);\n\n    const i = _ref6[0];\n    const param = _ref6[1];\n    defineMethod(fg => {\n      fg.name = `${param}Paste`;\n      fg.params = [param];\n\n      for (const _ref7 of as.entries()) {\n        var _ref8 = matrices_slicedToArray(_ref7, 2);\n\n        const j = _ref8[0];\n        const a = _ref8[1];\n        fg.emit`${param}.${a}=${(() => {\n          if (i < d || kind !== KINDS.LINEAR) {\n            return `this._${i}${j}`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n\n      fg.emit`return ${param}`;\n\n      if (false) {}\n    });\n\n    if (i < d || kind !== KINDS.LINEAR) {\n      defineMethod(fg => {\n        fg.name = `${param}Copy`;\n        fg.params = [param];\n\n        for (const _ref9 of as.entries()) {\n          var _ref10 = matrices_slicedToArray(_ref9, 2);\n\n          const j = _ref10[0];\n          const a = _ref10[1];\n          fg.emit`this._${i}${j}=${param}.${a}`;\n        }\n\n        fg.emit`return this`;\n\n        if (false) {}\n      });\n    }\n  }\n\n  if (kind !== KINDS.LINEAR) {\n    defineMethod(fg => {\n      fg.name = 'fromTranslation';\n      fg.params = ['translation'];\n\n      for (const j of js) for (const i of is) {\n        fg.emit`this._${i}${j}=${(() => {\n          if (i === d && j < d) {\n            return `translation.${as[j]}`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      fg.name = 'translate';\n      fg.params = ['translation'];\n\n      if (kind === KINDS.AFFINE) {\n        for (const _ref11 of as.entries()) {\n          var _ref12 = matrices_slicedToArray(_ref11, 2);\n\n          const j = _ref12[0];\n          const a = _ref12[1];\n          fg.emit`this._${d}${j}+=translation.${a}`;\n        }\n      } else {\n        for (const i of is) {\n          fg.emit`var _${i}${d}=this._${i}${d}`;\n        }\n\n        for (const a of as) {\n          fg.emit`var ${a}=translation.${a}`;\n        }\n\n        for (const _ref13 of as.entries()) {\n          var _ref14 = matrices_slicedToArray(_ref13, 2);\n\n          const j = _ref14[0];\n          const a = _ref14[1];\n\n          for (const i of is) {\n            fg.emit`this._${i}${j}+=_${i}${d}*${a}`;\n          }\n        }\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      fg.name = 'preTranslate';\n      fg.params = ['translation'];\n\n      for (const a of as) {\n        fg.emit`var ${a}=translation.${a}`;\n      }\n\n      for (const j of js) {\n        fg.emit`this._${d}${j}+=${as.map((a, i) => {\n          return `${a}*this._${i}${j}`;\n        }).join('+')}`;\n      }\n\n      fg.emit`return this`;\n\n      if (false) {}\n    });\n  }\n\n  defineMethod(fg => {\n    fg.name = 'fromScaling';\n    fg.params = ['scaling'];\n\n    for (const j of js) for (const i of is) {\n      fg.emit`this._${i}${j}=${(() => {\n        if (i === j && i < d) {\n          return `scaling.${as[i]}`;\n        }\n\n        return +(i === j);\n      })()}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'scale';\n    fg.params = ['scaling'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=scaling.${a}`;\n    }\n\n    for (const _ref15 of as.entries()) {\n      var _ref16 = matrices_slicedToArray(_ref15, 2);\n\n      const j = _ref16[0];\n      const a = _ref16[1];\n\n      for (const i of is) {\n        fg.emit`this._${i}${j}*=${a}`;\n      }\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'preScale';\n    fg.params = ['scaling'];\n\n    for (const a of as) {\n      fg.emit`var ${a}=scaling.${a}`;\n    }\n\n    for (const j of js) for (const _ref17 of matrices_aas.slice(0, d).entries()) {\n      var _ref18 = matrices_slicedToArray(_ref17, 2);\n\n      const i = _ref18[0];\n      const a = _ref18[1];\n      fg.emit`this._${i}${j}*=${a}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  aliasProperty('fromNumber', 'fromUniformScaling');\n  aliasProperty('multiplyNumber', 'scaleUniform');\n  aliasProperty('preMultiplyNumber', 'preScaleUniform');\n  defineMethod(fg => {\n    fg.name = 'fromShearing';\n    fg.params = ['shearing'];\n\n    for (const j of js) for (const i of is) {\n      fg.emit`this._${i}${j}=${(() => {\n        if (d === 2) {\n          if (i === 1 && j === 0) {\n            return 'shearing';\n          }\n        } else {\n          if (i === 1 && j === 0) {\n            return 'shearing.z';\n          }\n\n          if (i === 2 && j === 0) {\n            return 'shearing.y';\n          }\n\n          if (i === 2 && j === 1) {\n            return 'shearing.x';\n          }\n        }\n\n        return +(i === j);\n      })()}`;\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'shear';\n    fg.params = ['shearing'];\n\n    if (d === 2) {\n      for (const i of is) {\n        fg.emit`this._${i}0+=this._${i}1*shearing`;\n      }\n    } else {\n      for (const i of is) {\n        fg.emit`var _${i}1=this._${i}1`;\n      }\n\n      for (const i of is) {\n        fg.emit`var _${i}2=this._${i}2`;\n      }\n\n      for (const a of as) {\n        fg.emit`var ${a}=shearing.${a}`;\n      }\n\n      for (const i of is) {\n        fg.emit`this._${i}0+=_${i}1*z+_${i}2*y`;\n      }\n\n      for (const i of is) {\n        fg.emit`this._${i}1=_${i}1+_${i}2*x`;\n      }\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n  defineMethod(fg => {\n    fg.name = 'preShear';\n    fg.params = ['shearing'];\n\n    if (d === 2) {\n      for (const j of js) {\n        fg.emit`this._1${j}+=shearing*this._0${j}`;\n      }\n    } else {\n      for (const a of as) {\n        fg.emit`var ${a}=shearing.${a}`;\n      }\n\n      for (const j of js) {\n        fg.emit`var _0${j}=this._0${j}`;\n        fg.emit`var _1${j}=this._1${j}`;\n      }\n\n      for (const j of js) {\n        fg.emit`this._1${j}=z*_0${j}+_1${j}`;\n        fg.emit`this._2${j}+=y*_0${j}+x*_1${j}`;\n      }\n    }\n\n    fg.emit`return this`;\n\n    if (false) {}\n  });\n\n  if (false) {}\n\n  if (d === 2) {\n    const tmp = new (kind === KINDS.LINEAR ? Matrix : LinearMatrix2)();\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        SQRT2: sqrt(2)\n      });\n      fg.name = 'fromReflection';\n      fg.params = ['normal'];\n      fg.emit`var x=normal.x*SQRT2,`;\n      fg.emit`y=normal.y*SQRT2`;\n      fg.emit`this._00=1-x*x`;\n      fg.emit`this._10=-y*x`;\n\n      if (kind.rd) {\n        fg.emit`this._20=0`;\n      }\n\n      fg.emit`this._01=this._10`;\n      fg.emit`this._11=1-y*y`;\n\n      if (kind.rd) {\n        fg.emit`this._21=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}2=${+(i === 2)}`;\n        }\n      }\n\n      fg.emit`return this`;\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        tmp\n      });\n      fg.name = 'reflect';\n      fg.params = ['normal'];\n      fg.emit`return this.multiplyLinear(${`tmp.fromReflection(${fg.params})`})`;\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, {\n        tmp\n      });\n      fg.name = 'preReflect';\n      fg.params = ['normal'];\n      fg.emit`return this.preMultiplyLinear(${`tmp.fromReflection(${fg.params})`})`;\n    });\n\n    const defineTransform = (fromName, name, prepare) => {\n      defineMethod(fg => {\n        fg.name = fromName;\n        prepare(fg);\n\n        for (const j of js) for (const i of is) {\n          fg.emit`this._${i}${j}=${(() => {\n            if (i < d && j < d) {\n              if (i === j) {\n                return 're';\n              }\n\n              return '-im'.slice(i < j);\n            }\n\n            return +(i === j);\n          })()}`;\n        }\n\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        fg.name = name;\n\n        for (const j of as.keys()) for (const i of is) {\n          fg.emit`var _${i}${j}=this._${i}${j}`;\n        }\n\n        prepare(fg);\n\n        for (const i of is) {\n          fg.emit`this._${i}0=_${i}0*re-_${i}1*im`;\n        }\n\n        for (const i of is) {\n          fg.emit`this._${i}1=_${i}0*im+_${i}1*re`;\n        }\n\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        fg.name = `pre${toTitleCase(name)}`;\n        prepare(fg);\n\n        for (const j of js) for (const i of as.keys()) {\n          fg.emit`var _${i}${j}=this._${i}${j}`;\n        }\n\n        for (const j of js) {\n          fg.emit`this._0${j}=re*_0${j}+im*_1${j}`;\n          fg.emit`this._1${j}=re*_1${j}-im*_0${j}`;\n        }\n\n        fg.emit`return this`;\n      });\n    };\n\n    defineTransform('fromRotation', 'rotate', fg => {\n      Object.assign(fg.ctx, {\n        sin: sin,\n        cos: cos\n      });\n      fg.params = ['angle'];\n      fg.emit`var re=cos(angle),im=sin(angle)`;\n    });\n    defineTransform('fromRotationBetween', 'rotateBetween', fg => {\n      fg.params = ['from', 'to'];\n      fg.emit`var re=from.dot(to),im=from.cross(to)`;\n    });\n    defineTransform('fromComplex', 'applyComplex', fg => {\n      fg.params = ['complex'];\n      fg.emit`var re=complex.re,im=complex.im`;\n    });\n\n    if (false) {}\n  } else {\n    const tmp = new (kind === KINDS.LINEAR ? Matrix : LinearMatrix3)();\n\n    const defineTransform = (prepare, name) => {\n      let fromName, params;\n      defineMethod(fg => {\n        prepare(fg);\n        fromName = fg.name;\n        params = [...fg.params];\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = name;\n        fg.params = params;\n        fg.emit`return this.multiplyLinear(${`tmp.${fromName}(${params})`})`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = `pre${toTitleCase(name)}`;\n        fg.params = params;\n        fg.emit`return this.preMultiplyLinear(${`tmp.${fromName}(${params})`})`;\n      });\n    };\n\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        SQRT2: sqrt(2)\n      });\n      fg.name = 'fromReflection';\n      fg.params = ['normal'];\n      fg.emit`var x=normal.x*SQRT2,`;\n      fg.emit`y=normal.y*SQRT2,`;\n      fg.emit`z=normal.z*SQRT2`;\n      fg.emit`this._00=1-x*x`;\n      fg.emit`this._10=-y*x`;\n      fg.emit`this._20=-z*x`;\n\n      if (kind.rd) {\n        fg.emit`this._30=0`;\n      }\n\n      fg.emit`this._01=this._10`;\n      fg.emit`this._11=1-y*y`;\n      fg.emit`this._21=-z*y`;\n\n      if (kind.rd) {\n        fg.emit`this._31=0`;\n      }\n\n      fg.emit`this._02=this._20`;\n      fg.emit`this._12=this._21`;\n      fg.emit`this._22=1-z*z`;\n\n      if (kind.rd) {\n        fg.emit`this._32=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'reflect');\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        sin: sin,\n        cos: cos\n      });\n      fg.name = 'fromRotation';\n      fg.params = ['angle', 'axis'];\n      fg.emit`var s=sin(angle),c=cos(angle),t=1-c,`;\n      fg.emit`x=axis.x,y=axis.y,z=axis.z,`;\n      fg.emit`xs=x*s,ys=y*s,zs=z*s,`;\n      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;\n      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;\n      fg.emit`this._00=c+x*xt`;\n      fg.emit`this._10=xyt-zs`;\n      fg.emit`this._20=xzt+ys`;\n\n      if (kind.rd) {\n        fg.emit`this._30=0`;\n      }\n\n      fg.emit`this._01=xyt+zs`;\n      fg.emit`this._11=c+y*yt`;\n      fg.emit`this._21=yzt-xs`;\n\n      if (kind.rd) {\n        fg.emit`this._31=0`;\n      }\n\n      fg.emit`this._02=xzt-ys`;\n      fg.emit`this._12=yzt+xs`;\n      fg.emit`this._22=c+z*zt`;\n\n      if (kind.rd) {\n        fg.emit`this._32=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'rotate');\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        axis: new Vector3()\n      });\n      fg.name = 'fromRotationBetween';\n      fg.params = ['from', 'to'];\n      fg.emit`axis.copy(from).cross(to)`;\n      fg.emit`var xs=axis.x,ys=axis.y,zs=axis.z`;\n      fg.emit`axis.normalize()`;\n      fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;\n      fg.emit`var x=axis.x,y=axis.y,z=axis.z,`;\n      fg.emit`c=from.dot(to),t=1-c,`;\n      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;\n      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;\n      fg.emit`this._00=c+x*xt`;\n      fg.emit`this._10=xyt-zs`;\n      fg.emit`this._20=xzt+ys`;\n\n      if (kind.rd) {\n        fg.emit`this._30=0`;\n      }\n\n      fg.emit`this._01=xyt+zs`;\n      fg.emit`this._11=c+y*yt`;\n      fg.emit`this._21=yzt-xs`;\n\n      if (kind.rd) {\n        fg.emit`this._31=0`;\n      }\n\n      fg.emit`this._02=xzt-ys`;\n      fg.emit`this._12=yzt+xs`;\n      fg.emit`this._22=c+z*zt`;\n\n      if (kind.rd) {\n        fg.emit`this._32=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'rotateBetween');\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        sqrt: sqrt\n      });\n      fg.name = 'fromComplex';\n      fg.params = ['complex', 'axis'];\n      fg.emit`var re=complex.re,im=complex.im,`;\n      fg.emit`scaling=sqrt(re*re+im*im),t=scaling-re,`;\n      fg.emit`x=axis.x,y=axis.y,z=axis.z,`;\n      fg.emit`xIm=x*im,yIm=y*im,zIm=z*im,`;\n      fg.emit`xt=x*t,yt=y*t,zt=z*t,`;\n      fg.emit`xyt=x*yt,xzt=z*xt,yzt=y*zt`;\n      fg.emit`this._00=re+x*xt`;\n      fg.emit`this._10=xyt-zIm`;\n      fg.emit`this._20=xzt+yIm`;\n\n      if (kind.rd) {\n        fg.emit`this._30=0`;\n      }\n\n      fg.emit`this._01=xyt+zIm`;\n      fg.emit`this._11=re+y*yt`;\n      fg.emit`this._21=yzt-xIm`;\n\n      if (kind.rd) {\n        fg.emit`this._31=0`;\n      }\n\n      fg.emit`this._02=xzt-yIm`;\n      fg.emit`this._12=yzt+xIm`;\n      fg.emit`this._22=re+z*zt`;\n\n      if (kind.rd) {\n        fg.emit`this._32=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'applyComplex');\n\n    if (false) {}\n\n    defineTransform(fg => {\n      fg.name = 'fromQuaternion';\n      fg.params = ['quaternion'];\n      fg.emit`var re=quaternion.re,`;\n      fg.emit`imX=quaternion.imX,`;\n      fg.emit`imY=quaternion.imY,`;\n      fg.emit`imZ=quaternion.imZ,`;\n      fg.emit`scaling=re*re+imX*imX+imY*imY+imZ*imZ,`;\n      fg.emit`re2=re*2,imX2=imX*2,imY2=imY*2,imZ2=imZ*2,`;\n      fg.emit`imXImX2=imX*imX2,imYImY2=imY*imY2,imZImZ2=imZ*imZ2,`;\n      fg.emit`reImX2=re*imX2,reImY2=re*imY2,reImZ2=re*imZ2,`;\n      fg.emit`imXImY2=imX*imY2,imXImZ2=imX*imZ2,imYImZ2=imY*imZ2`;\n      fg.emit`this._00=scaling-(imYImY2+imZImZ2),`;\n      fg.emit`this._10=imXImY2+reImZ2,`;\n      fg.emit`this._20=imXImZ2-reImY2,`;\n\n      if (kind.rd) {\n        fg.emit`this._30=0`;\n      }\n\n      fg.emit`this._01=imXImY2-reImZ2,`;\n      fg.emit`this._11=scaling-(imXImX2+imZImZ2),`;\n      fg.emit`this._21=imYImZ2+reImX2,`;\n\n      if (kind.rd) {\n        fg.emit`this._31=0`;\n      }\n\n      fg.emit`this._02=imXImZ2+reImY2,`;\n      fg.emit`this._12=imYImZ2-reImX2,`;\n      fg.emit`this._22=scaling-(imXImX2+imYImY2)`;\n\n      if (kind.rd) {\n        fg.emit`this._32=0`;\n      }\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'applyQuaternion');\n\n    if (false) {}\n\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        x: new Vector3(),\n        y: new Vector3(),\n        z: new Vector3()\n      });\n      fg.name = 'fromLookDirection';\n      fg.params = ['direction', 'up'];\n      fg.emit`z.copy(direction).normalize()`;\n      fg.emit`if(!z.everyIsFinite){`;\n      fg.emit`z.copy(up).orthogonalize().normalize()`;\n      fg.emit`}else{`;\n      fg.emit`z.negate()`;\n      fg.emit`}`;\n      fg.emit`x.copy(up).cross(z)`;\n      fg.emit`if(!x.everyIsFinite){`;\n      fg.emit`x.copy(z).orthogonalize()`;\n      fg.emit`}`;\n      fg.emit`x.normalize()`;\n      fg.emit`y.copy(z).cross(x)`;\n\n      for (const j of js) for (const i of is) {\n        fg.emit`this._${i}${j}=${(() => {\n          if (i < 3 && j < 3) {\n            return `${as[i]}.${as[j]}`;\n          }\n\n          return +(i === j);\n        })()}`;\n      }\n    }, 'lookIn');\n\n    if (false) {}\n  }\n\n  if (kind !== KINDS.LINEAR && d === 3) {\n    const tmp = new (kind === KINDS.AFFINE ? Matrix : AffineMatrix3)();\n\n    const defineTransform = (prepare, name) => {\n      let fromName, params;\n      defineMethod(fg => {\n        prepare(fg);\n        fromName = fg.name;\n        params = [...fg.params];\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = name;\n        fg.params = params;\n        fg.emit`return this.multiplyAffine(${`tmp.${fromName}(${params})`})`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = `pre${toTitleCase(name)}`;\n        fg.params = params;\n        fg.emit`return this.preMultiplyAffine(${`tmp.${fromName}(${params})`})`;\n      });\n    };\n\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        direction: new Vector3()\n      });\n      fg.name = 'fromLookTarget';\n      fg.params = ['origin', 'target', 'up'];\n      fg.emit`direction.copy(target).subtract(origin)`;\n      fg.emit`this.fromLookDirection(direction,up).translate(origin)`;\n    }, 'lookAt');\n\n    if (false) {}\n\n    defineTransform(fg => {\n      fg.name = 'fromWebGLOrthographicAsymmetricProjection';\n      fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];\n      fg.emit`var invNegWidth=1/(left-right),`;\n      fg.emit`invNegHeight=1/(bottom-top),`;\n      fg.emit`invNegDepth=1/(near-far)`;\n      fg.emit`this._00=-2*invNegWidth`;\n      fg.emit`this._10=0`;\n      fg.emit`this._20=0`;\n      fg.emit`this._30=(left+right)*invNegWidth`;\n      fg.emit`this._01=0`;\n      fg.emit`this._11=-2*invNegHeight`;\n      fg.emit`this._21=0`;\n      fg.emit`this._31=(bottom+top)*invNegHeight`;\n      fg.emit`this._02=0`;\n      fg.emit`this._12=0`;\n      fg.emit`this._22=2*invNegDepth,`;\n      fg.emit`this._32=(near+far)*invNegDepth`;\n\n      if (kind.cd) {\n        for (const i of is) {\n          fg.emit`this._${i}3=${+(i === 3)}`;\n        }\n      }\n    }, 'projectWebGLOrthographicAsymmetric');\n\n    if (false) {}\n\n    defineTransform(fg => {\n      fg.name = 'fromWebGLOrthographicProjection';\n      fg.params = ['width', 'height', 'near', 'far'];\n      fg.emit`var top=height*.5,right=width*.5`;\n      fg.emit`this.fromWebGLOrthographicAsymmetricProjection(${'-right,right,-top,top,near,far'})`;\n    }, 'projectWebGLOrthographic');\n\n    if (false) {}\n  }\n\n  if (kind === KINDS.HOMOGENEOUS && d === 3) {\n    const tmp = new Matrix();\n\n    const defineTransform = (prepare, name) => {\n      let fromName, params;\n      defineMethod(fg => {\n        prepare(fg);\n        fromName = fg.name;\n        params = [...fg.params];\n        fg.emit`return this`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = name;\n        fg.params = params;\n        fg.emit`return this.multiply(tmp.${fromName}(${params}))`;\n      });\n      defineMethod(fg => {\n        Object.assign(fg.ctx, {\n          tmp\n        });\n        fg.name = `pre${toTitleCase(name)}`;\n        fg.params = params;\n        fg.emit`return this.preMultiply(tmp.${fromName}(${params}))`;\n      });\n    };\n\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        isFinite: functions_isFinite\n      });\n      fg.name = 'fromWebGLAsymmetricPerspectiveProjection';\n      fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];\n      fg.emit`var near2=near*2,`;\n      fg.emit`invWidth=1/(right-left),`;\n      fg.emit`invHeight=1/(top-bottom)`;\n      fg.emit`this._00=near2*invWidth,`;\n      fg.emit`this._10=0`;\n      fg.emit`this._20=(left+right)*invWidth`;\n      fg.emit`this._30=0`;\n      fg.emit`this._01=0`;\n      fg.emit`this._11=near2*invHeight`;\n      fg.emit`this._21=(bottom+top)*invHeight`;\n      fg.emit`this._31=0`;\n      fg.emit`this._02=0`;\n      fg.emit`this._12=0`;\n      fg.emit`if(isFinite(far)){`;\n      fg.emit`var invNegDepth=1/(near-far)`;\n      fg.emit`this._22=(near+far)*invNegDepth`;\n      fg.emit`this._32=near2*far*invNegDepth`;\n      fg.emit`}else{`;\n      fg.emit`this._22=-1`;\n      fg.emit`this._32=-near2`;\n      fg.emit`}`;\n      fg.emit`this._03=0`;\n      fg.emit`this._13=0`;\n      fg.emit`this._23=-1`;\n      fg.emit`this._33=0`;\n    }, 'projectWebGLPerspectiveAsymmetric');\n\n    if (false) {}\n\n    defineTransform(fg => {\n      Object.assign(fg.ctx, {\n        tan: tan\n      });\n      fg.name = 'fromWebGLPerspectiveProjection';\n      fg.params = ['aspectRatio', 'verticalFieldOfView', 'near', 'far'];\n      fg.emit`var top=near*tan(verticalFieldOfView*.5),`;\n      fg.emit`right=top*aspectRatio`;\n      fg.emit`this.fromWebGLAsymmetricPerspectiveProjection(${'-right,right,-top,top,near,far'})`;\n    }, 'projectWebGLPerspective');\n\n    if (false) {}\n  }\n\n  for (const splitKind of [KINDS.LINEAR, KINDS.AFFINE]) {\n    if (splitKind.rd > kind.rd) {\n      continue;\n    }\n\n    defineMethod(fg => {\n      fg.name = `from${splitKind.name}SplitTransform`;\n      fg.params = ['transform'];\n      fg.emit`return this.fromScaling(transform.scaling)`;\n      fg.emit`.shear(transform.shearing)`;\n\n      if (d === 2) {\n        fg.emit`.applyComplex(transform.complex)`;\n      } else {\n        fg.emit`.applyQuaternion(transform.quaternion)`;\n      }\n\n      if (splitKind !== KINDS.LINEAR) {\n        fg.emit`.translate(transform.translation)`;\n      }\n\n      if (false) {}\n    });\n    defineMethod(fg => {\n      Object.assign(fg.ctx, d === 2 ? {\n        tmpVector: new Vector2(),\n        tmpComplex: new complex_Complex()\n      } : {\n        tmpVector: new Vector3(),\n        tmpQuaternion: new quaternion_Quaternion()\n      });\n      fg.name = `fromInverted${splitKind.name}SplitTransform`;\n      fg.params = ['transform'];\n\n      if (d === 3) {\n        fg.emit`var shearing=transform.shearing`;\n      }\n\n      if (splitKind !== KINDS.LINEAR) {\n        fg.emit`return this.fromTranslation(${'tmpVector.copy(transform.translation).negate()'})`;\n\n        if (d === 2) {\n          fg.emit`.applyComplex(${'tmpComplex.copy(transform.complex).invert()'})`;\n        } else {\n          fg.emit`.applyQuaternion(${'tmpQuaternion.copy(transform.quaternion).invert()'})`;\n        }\n      } else {\n        if (d === 2) {\n          fg.emit`return this.fromComplex(${'tmpComplex.copy(transform.complex).invert()'})`;\n        } else {\n          fg.emit`return this.fromQuaternion(${'tmpQuaternion.copy(transform.quaternion).invert()'})`;\n        }\n      }\n\n      if (d === 2) {\n        fg.emit`.shear(-transform.shearing)`;\n      } else {\n        fg.emit`.shear(tmpVector.set(${['-shearing.x', 'shearing.x*shearing.z-shearing.y', '-shearing.z']}))`;\n      }\n\n      fg.emit`.scale(${'tmpVector.copy(transform.scaling).preDivideNumber(1)'})`;\n\n      if (false) {}\n    });\n\n    if (splitKind === kind) {\n      aliasProperty(`from${splitKind.name}SplitTransform`, 'fromSplitTransform');\n      aliasProperty(`fromInverted${splitKind.name}SplitTransform`, 'fromInvertedSplitTransform');\n    }\n  }\n\n  return Matrix;\n}\n\nconst LinearMatrix2 = matrices_makeClass(KINDS.LINEAR, 2);\nconst AffineMatrix2 = matrices_makeClass(KINDS.AFFINE, 2);\nconst HomogeneousMatrix2 = matrices_makeClass(KINDS.HOMOGENEOUS, 2);\nconst LinearMatrix3 = matrices_makeClass(KINDS.LINEAR, 3);\nconst AffineMatrix3 = matrices_makeClass(KINDS.AFFINE, 3);\nconst HomogeneousMatrix3 = matrices_makeClass(KINDS.HOMOGENEOUS, 3);\n// CONCATENATED MODULE: ./src/features/distance-calculator/distance-module/utils.ts\n\n\nconst EPS = 0.0000001;\nconst plVec1 = new Vector3();\nconst plVec2 = new Vector3();\nfunction pointToLine(result, point, start, end) {\n  plVec1.copy(end).subtract(start);\n  plVec2.copy(point).subtract(start);\n  let t = plVec2.dot(plVec1) / plVec1.dot(plVec1);\n  t = Math.min(Math.max(t, 0), 1);\n  const distance = plVec1.multiplyNumber(t).add(start).distance(point);\n\n  if (distance > result.distance) {\n    return;\n  }\n\n  result.distance = distance;\n  result.start.copy(point);\n  result.end.copy(plVec1);\n}\nconst ptVec1 = new Vector3();\nconst ptVec2 = new Vector3();\nconst ptVec3 = new Vector3();\nconst ptVec4 = new Vector3();\nfunction pointToTriangle(result, point, vert0, vec0, vec1, normal, matrix) {\n  ptVec3.copy(point).subtract(vert0);\n  const t = normal.dot(ptVec3);\n  ptVec4.copy(normal).multiplyNumber(t);\n  ptVec3.subtract(ptVec4);\n  ptVec4.copy(ptVec3).add(vert0);\n  ptVec3.applyLinearMatrix(matrix);\n  ptVec1.copy(vert0).add(vec0);\n  ptVec2.copy(vert0).add(vec1);\n\n  if (ptVec3.x < 0) {\n    // calc edge v0-v1\n    pointToLine(result, point, vert0, ptVec2);\n  } else if (ptVec3.y < 0) {\n    // calc edge v0-v2\n    pointToLine(result, point, vert0, ptVec1);\n  } else if (ptVec3.x + ptVec3.y > 1) {\n    // calc edge v1-v2\n    pointToLine(result, point, ptVec1, ptVec2);\n  } else {\n    // calc in triangle\n    const distance = ptVec4.distance(point);\n\n    if (distance > result.distance) {\n      return;\n    }\n\n    result.distance = distance;\n    result.start.copy(point);\n    result.end.copy(ptVec4);\n  }\n}\nconst uVec = new Vector3();\nconst vVec = new Vector3();\nconst wVec = new Vector3();\nfunction edgeToEdge(result, start0, end0, start1, end1) {\n  uVec.copy(end0).subtract(start0);\n  vVec.copy(end1).subtract(start1);\n  const c = uVec.dot(uVec);\n  const d = vVec.dot(vVec);\n  const e = uVec.dot(vVec);\n  const factor = e * e - c * d;\n\n  if (Math.abs(factor) < EPS) {\n    // Parallel lines\n    const lengthFactor = 1 / uVec.dot(uVec);\n    let distance = 0;\n    vVec.copy(start1).subtract(start0);\n    const start = uVec.dot(vVec) * lengthFactor;\n\n    if (start >= 0 && start <= 1) {\n      distance = uVec.multiplyNumber(start).add(start0).distance(start1);\n\n      if (distance > result.distance) {\n        return;\n      }\n\n      result.distance = distance;\n      result.start.copy(uVec);\n      result.end.copy(start1);\n      return;\n    }\n\n    vVec.copy(end1).subtract(start0);\n    const end = uVec.dot(vVec) * lengthFactor;\n\n    if (end >= 0 && end <= 1) {\n      distance = uVec.multiplyNumber(end).add(start0).distance(end1);\n\n      if (distance > result.distance) {\n        return;\n      }\n\n      result.distance = distance;\n      result.start.copy(uVec);\n      result.end.copy(end1);\n      return;\n    }\n\n    const length = uVec.length;\n    const tStart = start > 0 ? start - length : Math.abs(start);\n    const tEnd = end > 0 ? end - length : Math.abs(end);\n\n    if (tStart > tEnd) {\n      if (end > 0) {\n        uVec.copy(end0);\n      } else {\n        uVec.copy(start0);\n      }\n\n      vVec.copy(end1);\n    } else {\n      if (start > 0) {\n        uVec.copy(end0);\n      } else {\n        uVec.copy(start0);\n      }\n\n      vVec.copy(start1);\n    }\n\n    distance = uVec.distance(vVec);\n\n    if (distance > result.distance) {\n      return;\n    }\n\n    result.distance = distance;\n    result.start.copy(uVec);\n    result.end.copy(vVec);\n  } else {\n    // Skew lines\n    wVec.copy(start0).subtract(start1);\n    const a = wVec.dot(uVec);\n    const b = wVec.dot(vVec);\n    const t = Math.min(Math.max((a * d - b * e) / factor, 0), 1);\n    const s = Math.min(Math.max((a * e - b * c) / factor, 0), 1);\n    uVec.multiplyNumber(t).add(start0);\n    vVec.multiplyNumber(s).add(start1);\n    const distance = uVec.distance(vVec);\n\n    if (distance > result.distance) {\n      return;\n    }\n\n    result.distance = distance;\n    result.start.copy(uVec);\n    result.end.copy(vVec);\n  }\n}\nconst etVec1 = new Vector3();\nconst etVec2 = new Vector3();\nfunction edgeToTriangle(result, start, end, vert0, vec0, vec1, normal, matrix) {\n  // intersection point\n  const startDist = etVec1.copy(start).subtract(vert0).dot(normal);\n  const endDist = etVec1.copy(end).subtract(vert0).dot(normal);\n\n  if (Math.abs(startDist) + Math.abs(endDist) > EPS) {\n    if (startDist * endDist < 0) {\n      etVec1.copy(end).subtract(start).multiplyNumber(startDist / (startDist - endDist)).add(start);\n      pointToTriangle(result, etVec1, vert0, vec0, vec1, normal, matrix);\n    }\n  } // edge to triangle edges\n\n\n  etVec1.copy(vert0).add(vec0);\n  etVec2.copy(vert0).add(vec1);\n  edgeToEdge(result, start, end, vert0, etVec1);\n  edgeToEdge(result, start, end, etVec1, etVec2);\n  edgeToEdge(result, start, end, etVec2, vert0);\n}\nconst ttVec1 = new Vector3();\nconst ttVec2 = new Vector3();\nconst ttNormal = new Vector3();\nconst ttLinMatrix = new LinearMatrix3();\nfunction triangleToTriangle(result, vert0, vert1, vert2, vert3, vert4, vert5) {\n  // quick check\n  const dist = vert0.distance(vert3) - Math.max(vert0.distance(vert1), vert0.distance(vert2), vert1.distance(vert2)) - Math.max(vert3.distance(vert4), vert3.distance(vert5), vert4.distance(vert5));\n\n  if (dist > result.distance) {\n    return;\n  } // Edges first triangle with second triangle\n\n\n  ttVec1.copy(vert4).subtract(vert3);\n  ttVec2.copy(vert5).subtract(vert3);\n  ttNormal.copy(ttVec1).cross(ttVec2);\n\n  if (ttNormal.length < EPS) {\n    return;\n  }\n\n  ttNormal.normalize();\n  ttLinMatrix.axisXCopy(ttVec1).axisYCopy(ttVec2).axisZCopy(ttNormal).invert(); // points\n\n  pointToTriangle(result, vert0, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  pointToTriangle(result, vert1, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  pointToTriangle(result, vert2, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix); // edges\n\n  edgeToTriangle(result, vert0, vert1, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  edgeToTriangle(result, vert1, vert2, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  edgeToTriangle(result, vert2, vert0, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix); // Edges second triangle with first triangle\n\n  ttVec1.copy(vert1).subtract(vert0);\n  ttVec2.copy(vert2).subtract(vert0);\n  ttNormal.copy(ttVec1).cross(ttVec2);\n\n  if (ttNormal.length < EPS) {\n    return;\n  }\n\n  ttNormal.normalize();\n  ttLinMatrix.axisXCopy(ttVec1).axisYCopy(ttVec2).axisZCopy(ttNormal).invert(); // points\n\n  pointToTriangle(result, vert3, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  pointToTriangle(result, vert4, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  pointToTriangle(result, vert5, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix); // edges\n\n  edgeToTriangle(result, vert3, vert4, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  edgeToTriangle(result, vert4, vert5, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n  edgeToTriangle(result, vert5, vert3, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);\n}\n// CONCATENATED MODULE: ./src/global-helpers/worker.ts\n/* eslint-disable no-restricted-globals */\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nfunction exposeFromWorker(fn) {\n  const handleMessage = async event => {\n    let message;\n\n    try {\n      const result = await fn(...event.data);\n      message = {\n        state: 'success',\n        result,\n        error: null\n      };\n    } catch (error) {\n      message = {\n        state: 'error',\n        result: null,\n        error\n      };\n    }\n\n    self.postMessage(message);\n  }; // Could be only one expose per worker with this implementation\n\n\n  if (self.__handleMessage) {\n    self.removeEventListener('message', self.__handleMessage);\n  }\n\n  self.__handleMessage = handleMessage;\n  self.addEventListener('message', handleMessage);\n}\nfunction createWorker(LoaderWorker) {\n  const run = async (...args) => {\n    const worker = new LoaderWorker();\n    const result = await new Promise((resolve, reject) => {\n      worker.onmessage = event => {\n        const message = event.data;\n\n        if (message.state === 'error') {\n          reject(message.error);\n          return;\n        }\n\n        resolve(message.result);\n      };\n\n      worker.onerror = event => {\n        reject(event);\n      };\n\n      worker.postMessage(args);\n    });\n    worker.terminate();\n    return result;\n  };\n\n  return run;\n}\n// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/babel-loader/lib??ref--6!./src/features/distance-calculator/distance-module/calculate-parts.worker.ts\n\n\n\nconst tmpVec0 = new Vector3();\nconst tmpVec1 = new Vector3();\nconst tmpVec2 = new Vector3();\nconst tmpVec3 = new Vector3();\nconst tmpVec4 = new Vector3();\nconst tmpVec5 = new Vector3();\nconst calculateDistanceParts = (part, parts, result, pos0, idx0, mat0, pos1, idx1, mat1) => {\n  // Need to recreate Vector3 after transfer to the worker\n  result.start = new Vector3().copy(result.start);\n  result.end = new Vector3().copy(result.end);\n  const length = Math.ceil(idx0.length / 3 / parts);\n\n  for (let i = length * part * 3; i < Math.min(length * (part + 1) * 3, idx0.length); i += 3) {\n    for (let j = 0; j < idx1.length; j += 3) {\n      tmpVec0.set(pos0[idx0[i + 0] * 3], pos0[idx0[i + 0] * 3 + 1], pos0[idx0[i + 0] * 3 + 2]).applyAffineMatrix(mat0);\n      tmpVec1.set(pos0[idx0[i + 1] * 3], pos0[idx0[i + 1] * 3 + 1], pos0[idx0[i + 1] * 3 + 2]).applyAffineMatrix(mat0);\n      tmpVec2.set(pos0[idx0[i + 2] * 3], pos0[idx0[i + 2] * 3 + 1], pos0[idx0[i + 2] * 3 + 2]).applyAffineMatrix(mat0);\n      tmpVec3.set(pos1[idx1[j + 0] * 3], pos1[idx1[j + 0] * 3 + 1], pos1[idx1[j + 0] * 3 + 2]).applyAffineMatrix(mat1);\n      tmpVec4.set(pos1[idx1[j + 1] * 3], pos1[idx1[j + 1] * 3 + 1], pos1[idx1[j + 1] * 3 + 2]).applyAffineMatrix(mat1);\n      tmpVec5.set(pos1[idx1[j + 2] * 3], pos1[idx1[j + 2] * 3 + 1], pos1[idx1[j + 2] * 3 + 2]).applyAffineMatrix(mat1);\n      triangleToTriangle(result, tmpVec0, tmpVec1, tmpVec2, tmpVec3, tmpVec4, tmpVec5);\n    }\n  }\n\n  return result;\n};\nexposeFromWorker(calculateDistanceParts);\n\n/***/ })\n/******/ ]);", null);
};

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PublicEventEmitter; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO Fix public events
class PublicEventEmitter {
  // eslint-disable-next-line @typescript-eslint/ban-types
  constructor() {
    _defineProperty(this, "_events", void 0);

    this._events = new Map();
  }

  addEventListener(eventName, cb) {
    if (!this._events.has(eventName)) {
      this._events.set(eventName, new Set());
    }

    const callbacksSet = this._events.get(eventName);

    if (!callbacksSet) {
      return;
    }

    callbacksSet.add(cb);
  } // eslint-disable-next-line @typescript-eslint/ban-types


  removeEventListener(eventName, cb) {
    const callbacksSet = this._events.get(eventName);

    if (!callbacksSet) {
      return;
    }

    callbacksSet.delete(cb);
  }

  fireEvent(eventName, event) {
    const callbacksSet = this._events.get(eventName);

    if (!callbacksSet) {
      return;
    }

    for (const cb of callbacksSet) {
      cb(event);
    }
  }

}

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return decorateWithIframeAPI; });
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types */
const source = 'industrial-viewer';

function serializeReplacer(key, value) {
  if (typeof value === 'function') {
    return '[Function]';
  }

  return value;
}

function serialize(input) {
  if (typeof input === 'boolean' || typeof input === 'number' || typeof input === 'string' || input === null || input === undefined) {
    return input;
  }

  return JSON.parse(JSON.stringify(input, serializeReplacer));
}

function postMethodComplete(methodName, args, result) {
  window.parent.postMessage({
    type: 'apiMethodFulfilled',
    apiCall: methodName,
    args: serialize(args),
    result: serialize(result),
    source
  }, '*');
}

function postEventCallback(callbackName, event) {
  window.parent.postMessage({
    type: 'apiCallback',
    apiCall: callbackName,
    // TODO DEPRECATED
    event: serialize(event),
    args: serialize([event]),
    // TODO DEPRECATED
    source
  }, '*');
}

function postError(error) {
  window.parent.postMessage({
    type: 'apiMethodError',
    message: error.message,
    stack: error.stack || null,
    source
  }, '*');
}

function getPropertyByPath(ctx, path) {
  let context = ctx;
  let property;
  let propName;

  if (!path.length) {
    postError(new Error('Wrong message - invalid method path'));
    return null;
  }

  for (let i = 0; i < path.length; i++) {
    context = i ? property : ctx;
    propName = path[i];

    if (!(propName in context)) {
      postError(new Error(`Wrong message - property "${propName}" doesn't exist`));
      return null;
    } // check above guarantee that propName is keyof context


    property = context[propName];
  }

  return {
    value: property,
    context
  };
}

function addApiCallListeners(apiInstance) {
  if (window === window.parent) {
    return;
  }

  window.addEventListener('message', event => {
    if (event.source === window) {
      return;
    }

    if (!event.data || typeof event.data !== 'object' || !event.data.apiCall) {
      return;
    }

    const propertyPath = event.data.apiCall.split('.');
    const property = getPropertyByPath(apiInstance, propertyPath);

    if (!property) {
      return;
    }

    if (typeof property.value === 'function') {
      property.value.apply(property.context, event.data.args);
    } else {
      postError(new Error('Wrong message format or method doesn\'t exist'));
    }
  }, false);
}

function decorateObject(sourceObject, path = []) {
  const proto = Object.getPrototypeOf(sourceObject);
  const propertyNames = [...Object.getOwnPropertyNames(sourceObject), ...Object.getOwnPropertyNames(proto)].filter(propertyName => {
    return !propertyName.startsWith('_') && propertyName !== 'constructor';
  }); // necessary cause getOwnPropertyNames returns string[]

  propertyNames.forEach(propertyName => {
    const propertyValue = sourceObject[propertyName];

    if (propertyValue && typeof propertyValue === 'object') {
      decorateObject(propertyValue, [...path, propertyName]);
      return;
    }

    const methodName = propertyName;
    const fullPathName = [...path, methodName].join('.'); // TODO DEPRECATED Remove

    if (String(propertyName).startsWith('on')) {
      // Descriptor
      if (typeof propertyValue !== 'function') {
        const descriptor = Object.getOwnPropertyDescriptor(sourceObject, propertyName);

        if (!descriptor || typeof descriptor.get !== 'function') {
          return;
        }

        const originalCallbackGetter = descriptor.get;

        descriptor.get = function () {
          const originalCallback = originalCallbackGetter.apply(this);
          return function (event) {
            originalCallback(event);
            postEventCallback(fullPathName, event);
          };
        };

        Object.defineProperty(sourceObject, propertyName, descriptor);
        return;
      }

      setTimeout(() => {
        // now all properties are functions
        // @ts-ignore - impossible to describe this case
        sourceObject[propertyName](event => {
          postEventCallback(fullPathName, event);
        });
      });
    }

    if (typeof propertyValue !== 'function') {
      return;
    }

    const originalMethod = propertyValue; // @ts-ignore - impossible to describe this case

    sourceObject[propertyName] = function (...args) {
      let result;

      try {
        result = originalMethod.apply(this, args);
      } catch (error) {
        postError(error);
        throw error;
      } // If async. Don't need messages for sync functions


      if (result && typeof result === 'object' && typeof result.then === 'function') {
        return result.then(methodResult => {
          postMethodComplete(fullPathName, args, methodResult);
          return methodResult;
        }).catch(error => {
          postError(error);
          throw error;
        });
      }

      postMethodComplete(fullPathName, args, result);
      return result;
    };
  });
}

function decorateWithIframeAPI(api, eventEmitter) {
  decorateObject(api);
  decorateObject(Object.getPrototypeOf(api));
  addApiCallListeners(api);
  const originalFireEvent = eventEmitter.fireEvent;

  eventEmitter.fireEvent = function (callbackName, event) {
    originalFireEvent.call(eventEmitter, callbackName, event);
    postEventCallback(callbackName, event);
  };
}

/***/ }),
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ app_App; });

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wge/core/lib/index.js + 126 modules
var lib = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/mobx/lib/mobx.module.js
var mobx_module = __webpack_require__(3);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/index.js + 11 modules
var math_lib = __webpack_require__(1);

// CONCATENATED MODULE: ./src/core/gl/time.ts
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Time {
  constructor() {
    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_deltaTime", void 0);

    _defineProperty(this, "_elapsedTime", void 0);

    _defineProperty(this, "_timeScale", void 0);

    this._time = performance.now();
    this._deltaTime = 0;
    this._elapsedTime = 0;
    this._timeScale = 1;
  }

  get elapsedTime() {
    return this._elapsedTime;
  }

  get deltaTime() {
    return this._deltaTime;
  }

  get timeScale() {
    return this._timeScale;
  }

  set timeScale(scale) {
    if (typeof scale !== 'number') {
      return;
    }

    this._timeScale = scale;
  }

  reset() {
    this._time = performance.now();
    this._elapsedTime = 0;
    this._deltaTime = 0;
    this._timeScale = 1;
  }

  update() {
    const now = performance.now();
    this._deltaTime = (now - this._time) * this._timeScale * 0.001;
    this._elapsedTime += this._deltaTime;
    this._time = now;
  }

}
// EXTERNAL MODULE: ./src/global-helpers/event.ts
var global_helpers_event = __webpack_require__(42);

// CONCATENATED MODULE: ./src/core/gl/index.ts
function gl_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // import { debugGl } from './utils';

const systemsByName = {
  DrawSystem: lib["r" /* DrawSystem */],
  MeshSystem: lib["G" /* MeshSystem */],
  TimeSystem: lib["ib" /* TimeSystem */],
  InputSystem: lib["u" /* InputSystem */],
  LightSystem: lib["x" /* LightSystem */],
  OrbitSystem: lib["K" /* OrbitSystem */],
  CameraSystem: lib["g" /* CameraSystem */],
  ScreenSystem: lib["Z" /* ScreenSystem */],
  SpriteSystem: lib["eb" /* SpriteSystem */],
  AnimationSystem: lib["c" /* AnimationSystem */],
  TransformSystem: lib["kb" /* TransformSystem */],
  CubeCameraSystem: lib["l" /* CubeCameraSystem */],
  VisibilitySystem: lib["rb" /* VisibilitySystem */],
  LineSystem: lib["A" /* LineSystem */]
};

const logStaging = ({
  element,
  vertex
}) => {
  const totalSize = element + vertex; // eslint-disable-next-line no-console

  console.log(`Staging memory size: ${totalSize} (${Math.round(totalSize / 2 ** 20)} MB)`);
};

class gl_GL {
  constructor({
    container,
    store
  }) {
    gl_defineProperty(this, "onResize", new global_helpers_event["a" /* Event */]());

    gl_defineProperty(this, "onStagingsRecreated", new global_helpers_event["a" /* Event */]());

    gl_defineProperty(this, "renderer", void 0);

    gl_defineProperty(this, "canvas", void 0);

    gl_defineProperty(this, "customAttributes", void 0);

    gl_defineProperty(this, "_container", void 0);

    gl_defineProperty(this, "_store", void 0);

    gl_defineProperty(this, "time", void 0);

    this._container = container;
    this._store = store;
    this._store.window.pixelRatio = Math.min(window.devicePixelRatio, 2);
    this.renderer = new lib["W" /* Renderer */]({
      preserveDrawingBuffer: true,
      premultipliedAlpha: true,
      vertexStaging: new lib["ob" /* VertexBuffer */]({
        byteLength: 2 ** 20
      }),
      elementStaging: new lib["ob" /* VertexBuffer */]({
        byteLength: 2 ** 20
      }),
      antialias: false,
      alpha: true
    });
    this.renderer.context.clearColor(0, 0, 0, 0);
    this.canvas = this.renderer.canvas;
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.canvas.className = 'industrial-viewer-canvas3d';
    container.style.outline = 'none'; // debugGl(this.renderer);

    this.time = new Time();
    this.customAttributes = [{
      semantic: lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_0,
      // COLOR
      countComponents: 3
    }, {
      semantic: lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_1,
      // POSITION
      countComponents: 3
    }, {
      semantic: lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_2,
      // IGNORE_COLOR_RAYCASTING
      countComponents: 1
    }];

    this._addListeners();
  }

  _addListeners() {
    const resizeObserver = new ResizeObserver(([entry]) => {
      const {
        width,
        height
      } = entry.contentRect; // No need to resize if container is invisible
      // See more at src/api/utils/getImageFromCanvas()

      if (!width || !height) {
        return;
      }

      this._store.window.resize(entry.contentRect.width, entry.contentRect.height);
    });
    resizeObserver.observe(this._container);
    this.canvas.addEventListener('webglcontextlost', () => {
      const ctx = this.renderer.context;
      const error = `0x${ctx.getError().toString(16)}`;
      throw new Error(`WebGL context lost. GL Error: ${error}`);
    }, false);
  }

  updateStaging({
    vertex,
    element
  }) {
    const byteLength = this._store.renderer.byteLength;
    const serviceSceneReserve = 0.5 * 2 ** 20;

    const edgeIndexReserve = size => size * 2; // Worse case x2 indexes for edges


    const vertexSize = Math.ceil(Math.max(vertex * 1.05 + serviceSceneReserve, byteLength.vertex));
    const elementSize = Math.ceil(Math.max(edgeIndexReserve(element) + serviceSceneReserve, byteLength.element));
    let isStagingsUpdated = false;

    if (this.renderer.vertexStaging.buffer.byteLength < vertexSize) {
      isStagingsUpdated = true;
      this.renderer.vertexStaging = new lib["ob" /* VertexBuffer */]({
        byteLength: vertexSize
      });
    }

    if (this.renderer.elementStaging.buffer.byteLength < elementSize) {
      isStagingsUpdated = true;
      this.renderer.elementStaging = new lib["ob" /* VertexBuffer */]({
        byteLength: elementSize
      });
    }

    if (isStagingsUpdated) {
      this.onStagingsRecreated.emit({
        vertexStaging: this.renderer.vertexStaging,
        elementStaging: this.renderer.elementStaging
      });
      logStaging({
        vertex: this.renderer.vertexStaging.buffer.byteLength,
        element: this.renderer.elementStaging.buffer.byteLength
      });
    }
  }

  updateBrowserSize(width, height) {
    this.renderer.resize(width, height, false);
    this.onResize.emit();
  }

  clear(renderTarget, clear) {
    const {
      frameBuffers,
      context: gl
    } = this.renderer;
    const {
      webGLFramebuffer
    } = frameBuffers.getWebGLFramebuffer(renderTarget); // Don't use gl.clearColor directly, it will confuse WebGLState.

    this.renderer.state.clearColor = clear;
    gl.bindFramebuffer(gl.FRAMEBUFFER, webGLFramebuffer);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  validateAntialiasing(options = this._store.renderer.antialiasing) {
    const {
      pixelRatio
    } = options;
    const ctx = this.renderer.context;
    const glMaxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
    const maxDeviceSize = Math.max(ctx.drawingBufferWidth, ctx.drawingBufferHeight);
    return maxDeviceSize * pixelRatio <= glMaxTextureSize;
  }

}

gl_defineProperty(gl_GL, "systemsByName", systemsByName);
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/enum/index.js
/**
 * @module module:@webgears-app/enum
 */

/**
 * @interface module:@webgears-app/enum.Enum
 * @summary Enum with iteration and lookup convenience utilities.
 * @example
 * const Fruit = makeEnum([
 *     'APPLE'
 *     'ORANGE'
 *     'BANANA',
 *     'KIWI',
 * ]);
 *
 * // Access element value.
 * Fruit.ORANGE
 * // => 1
 * 
 * // Is iterable.
 * [...Fruit] // same as Fruit.values()
 * // => [0, 1, 2, 3]
 * 
 * // Get iterator over names.
 * [...Fruit.names()] // same as Fruit.keys()
 * // => ['APPLE', 'ORANGE', 'BANANA', 'KIWI']
 * 
 * // Get iterator over entries.
 * [...Fruit.entries()]
 * // => [['APPLE', 0], ['ORANGE', 1], ['BANANA', 2], ['KIWI', 3]]
 * 
 * // Get first name for a given value or undefined if none exists.
 * Fruit.firstNameOf(2)
 * // => 'BANANA'
 * 
 * // It is also possible to specify some or all values explicitly:
 * [...makeEnum([
 *     'APPLE',
 *     ['ORANGE', 'foo'],
 *     ['BANANA'],
 *     ['KIWI', 42],
 * ])]
 * // => [0, 'foo', 1, 42]
 */

/**
 * @function module:@webgears-app/enum.Enum#firstNameOf
 * @summary Get name of first entry with given value.
 * @param {any} value Entry value.
 * @returns {(string|undefined)} Name of first entry with given value or
 *     undefined if none such.
 */

/**
 * @function module:@webgears-app/enum.Enum#names
 * @summary Get iterator over entry names.
 * @returns {Iterator.<string>} Names.
 */

/**
 * @function module:@webgears-app/enum.Enum#keys
 * @desc Alias for {@link module:@webgears-app/enum.Enum#names}.
 * @summary Get iterator over entry names.
 * @returns {Iterator.<any>} Names.
 */

/**
 * @function module:@webgears-app/enum.Enum#values
 * @summary Get iterator over entry value.
 * @returns {Iterator.<any>} Values.
 */

/**
 * @typedef {Array} module:@webgears-app/enum.Enum.Entry
 * @summary Tuple of name and value.
 * @property {string} 0 Name.
 * @property {any} 1 Value.
 */

/**
 * @function module:@webgears-app/enum.Enum#entries
 * @summary Get iterator over entries.
 * @desc Also accessible as [Symbol.iterator].
 * @returns {Iterator.<module:@webgears-app/enum.Enum.Entry>} Entries.
 */

function parseEntry(entry) {
    if (typeof entry === 'string' || entry instanceof String) {
        entry = [entry];
    }

    entry = Array.from(entry);
    console.assert(entry.length > 0);
    console.assert(entry.length <= 2);

    console.assert(typeof entry[0] === 'string' || entry[0] instanceof String);

    if (entry.length === 1) { entry.push(undefined); }

    return entry;
}

function fillEntryValues(entries) {
    let nextValue = 0;
    for (const entry of entries) {
        if (entry[1] === undefined) {
            entry[1] = nextValue++;
        } else if (typeof entry[1] === 'number' ||
                   entry[1] instanceof Number)
        {
            nextValue = entry[1] + 1;
        }
    }
}

/**
 * @typedef {(string|Array)} module:@webgears-app/enum.Enum.EntryDescriptor
 * @summary Either entry name string or 1-tuple of name, or 2-tuple of name and value.
 * @property {string} 0 Name.
 * @property {any} [1] Value.
 */

/**
 * @summary Create new enum with given entries. 
 * @desc Any value that can be a key in a Map is allowed as entry value. When
 *     value is not specified for an entry, it defaults to value of the nearest
 *     preceding entry with a number value plus one; or zero for the first entry,
 *     same as C enums. 
 * @param {Iterable.<module:@webgears-app/enum.Enum.EntryDescriptor>} entries Entry descriptors.
 * @returns {module:@webgears-app/enum.Enum}
 */
function makeEnum(entries) {
    entries = Array.from(entries, parseEntry);
    fillEntryValues(entries);

    const Enum = {};

    const names = [];
    const values = [];
    const firstNames = new Map();
    for (const [name, value] of entries) {
        Enum[name] = value;
        names.push(name);
        values.push(value);
        if (!firstNames.has(name)) { firstNames.set(value, name); }
    }
    const entryCount = entries;

    const props = Object.getOwnPropertyDescriptors({
        firstNameOf(value) {
            return firstNames.get(value);
        },

        names() {
            return names.values();
        },

        keys() {
            return names.values();
        },

        values() {
            return values.values();
        },

        [Symbol.iterator]() {
            return values.values();
        },

        *entries() {
            for (let i = 0; i < entryCount; ++i) {
                yield [names[i], values[i]];
            }
        },
    });
    for (const key of Reflect.ownKeys(props)) {
        props[key].enumerable = false;
    }
    Object.defineProperties(Enum, props);

    // XXX: angular.js polyfills Object.defineProperties with a broken version
    // that ignores symbols. The following is a workaround for this.
    if (!Enum.hasOwnProperty(Symbol.iterator)) {
        Enum[Symbol.iterator] = props[Symbol.iterator].value;
    }

    return Enum;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/event/index.js
/**
 * @module @webgears-app/event
 */

/**
 * @example
 * const event = new Event();
 * 
 * const handler = (...args) => {
 *     console.log(`event happened with args: ${args.join(', ')}`);
 * };
 * event.subscribe(handler)
 * 
 * event.emit(1, 2, 3);
 * // => event happened with args: 1, 2, 3
 * 
 * event.unsubscribe(handler);
 */
class Event {
    constructor() {
        this._handlers = new Map();
    }

    /**
     * @summary Subscribe handler function to event.
     * @param {function} handler Handler function.
     * @param {object} [opts={}] Options.
     * @param {boolean} [opts.once=false] Automatically unsubscribe after first emission.
     */
    subscribe(handler, { once = false } = {}) {
        this._handlers.set(handler, once);
    }

    /**
     * @summary Unsubscribe handler function from event.
     * @param {function} handler Handler function.
     */
    unsubscribe(handler) {
        this._handlers.delete(handler);
    }

    /**
     * @summary Unsubscribe all handler functions from event.
     */
    unsubscribeAll() {
        this._handlers.clear();
    }

    /**
     * @summary Emit event with given arguments.
     * @desc Arguments are shared between subscribed handlers. Exceptions
     *     thrown by handlers are caught, logged to console, and discarded.
     * @param {...any} args Arguments.
     * @returns {boolean} Whether the event has been received by some handler.
     */
    emit(...args) {
        const handlers = this._handlers;
        const isReceived = handlers.size > 0;
        for (const [handler, once] of handlers) {
            if (once) { handlers.delete(handler); }
            try {
                handler(...args);
            } catch (error) {
                console.error(error);
            }
        }
        return isReceived;
    }
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/keyboard.js



const keyboard_Keyboard = (() => {
    // https://www.w3.org/TR/DOM-Level-3-Events-code/#keyboard-key-codes
    const domCodes = [
        'Unidentified',

        // Writing system
        'Backquote',
        'Backslash',
        'Backspace',
        'BracketLeft',
        'BracketRight',
        'Comma',
        ...(function*() {
            for (let i = 0; i <= 9; ++i) {
                yield `Digit${i}`;
            }
        })(),
        'Equal',
        'IntlBackslash',
        'IntlRo',
        'IntlYen',
        ...(function*() {
            for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); ++i) {
                yield `Key${String.fromCharCode(i)}`;
            }
        })(),
        'Minus',
        'Period',
        'Quote',
        'Semicolon',
        'Slash',

        // Functional
        'AltLeft',
        'AltRight',
        'CapsLock',
        'ContextMenu',
        'ControlLeft',
        'ControlRight',
        'Enter',
        'MetaLeft',
        'MetaRight',
        'ShiftLeft',
        'ShiftRight',
        'Space',
        'Tab',
        'Convert',
        'KanaMode',
        ...(function*() {
            for (let i = 1; i <= 5; ++i) {
                yield `Lang${i}`;
            }
        })(),
        'NonConvert',

        // Control pad
        'Delete',
        'End',
        'Help',
        'Home',
        'Insert',
        'PageDown',
        'PageUp',

        // Arrow pad
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight',
        'ArrowUp',

        // Numpad
        'NumLock',
        ...(function*() {
            for (let i = 0; i <= 9; ++i) {
                yield `Numpad${i}`;
            }
        })(),
        'NumpadAdd',
        'NumpadBackspace',
        'NumpadClear',
        'NumpadClearEntry',
        'NumpadComma',
        'NumpadDecimal',
        'NumpadDivide',
        'NumpadEnter',
        'NumpadEqual',
        'NumpadHash',
        'NumpadMemoryAdd',
        'NumpadMemoryClear',
        'NumpadMemoryRecall',
        'NumpadMemoryStore',
        'NumpadMemorySubtract',
        'NumpadMultiply',
        'NumpadParentLeft',
        'NumpadParentRight',
        'NumpadStar',
        'NumpadSubtract',

        // Function
        'Escape',
        ...(function*() {
            for (let i = 1; i <= 12; ++i) {
                yield `F${i}`;
            }
        })(),
        'Fn',
        'FnLock',
        'PrintScreen',
        'ScrollLock',
        'Pause',
    ];

    /**
     * @namespace module:@webgears-app/input.Keyboard.Keys
     * @summary Keyboard keys.
     * @desc Contains [DOM Key Codes for Standard keyboards]{@link https://www.w3.org/TR/DOM-Level-3-Events-code/#keyboard-key-codes},
     *     except for name casing. E.g. "KeyA" DOM Key Code corresponds to 
     *     {@link module:@webgears-app/input.Keyboard.Keys}.KEY_A.
     * @implements {module:@webgears-app/enum.Enum}
     */
    const Keys = makeEnum(domCodes.map(key => {
        return key.replace(/[a-z][A-Z0-9]/g, (chars) => {
            return [...chars].join('_');
        }).toUpperCase();
    }));

    const inverseDOMCodes = new Map([...domCodes.entries()].map(entry => {
        entry.reverse();
        return entry;
    }));

    Object.defineProperties(Keys, {
        domCodeOf: {
            /**
             * @function module:@webgears-app/input.Keyboard.Keys.domCodeOf
             * @summary Get [DOM Key Code]{@link https://www.w3.org/TR/DOM-Level-3-Events-code/#keyboard-key-codes} of key.
             * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
             * @returns {string} DOM Key Code.
             */
            value(key) {
                return domeCodes[key];
            },
        },
        fromDOMCode: {
            /**
             * @function module:@webgears-app/input.Keyboard.Keys.fromDOMCode
             * @summary Convert key to 
             *     [DOM Key Code]{@link https://www.w3.org/TR/DOM-Level-3-Events-code/#keyboard-key-codes}.
             * @param {string} domCode [DOM Key Code]{@link https://www.w3.org/TR/DOM-Level-3-Events-code/#keyboard-key-codes}.
             * @returns {module:@webgears-app/input.Keyboard.Keys} Key.
             */
            value(domCode) {
                return inverseDOMCodes.get(domCode) || 0;
            },
        },
    });

    const ON_KEY_PRESSES = Symbol('Keyboard.ON_KEY_PRESSES');
    const ON_KEY_RELEASES = Symbol('Keyboard.ON_KEY_RELEASES');

    /**
     * @class module:@webgears-app/input.Keyboard
     * @summary Keyboard-like input device.
     * @abstract
     * @example
     * keyboard.onKeyPress(Keyboard.Keys.SPACE).subscribe(() => {
     *     console.log(`spacebar pressed`);
     * });
     */
    class Keyboard {
        constructor() {
            this[ON_KEY_PRESSES] = new Map();
            this[ON_KEY_RELEASES] = new Map();
        }

        /**
         * @function module:@webgears-app/input.Keyboard#isKeyPressed
         * @summary Whether key is currently pressed.
         * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
         * @returns {boolean}
         * @abstract
         */
        isKeyPressed(key) {
            console.assert(false, 'not implemented');
            return false;
        }

        /**
         * @callback module:@webgears-app/input.Keyboard.KeyPressEventSignature
         */
        /**
         * @function module:@webgears-app/input.Keyboard#onKeyPress
         * @summary Get event emitted when key is pressed.
         * @desc Must be emitted by implementation.
         * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
         * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Keyboard.KeyPressEventSignature>} Key press. 
         */
        onKeyPress(key) {
            const onPresses = this[ON_KEY_PRESSES];
            let onPress = onPresses.get(key);
            if (onPress === undefined) {
                onPresses.set(key, (onPress = new Event()));
            }
            return onPress;
        }

        /**
         * @callback module:@webgears-app/input.Keyboard.KeyReleaseEventSignature
         */
        /**
         * @function module:@webgears-app/input.Keyboard#onKeyRelease
         * @summary Get event emitted when key is released.
         * @desc Must be emitted by implementation.
         * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
         * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Keyboard.KeyReleaseEventSignature>} Key release. 
         */
        onKeyRelease(key) {
            const onReleases = this[ON_KEY_RELEASES];
            let onRelease = onReleases.get(key);
            if (onRelease === undefined) {
                onReleases.set(key, (onRelease = new Event()));
            }
            return onRelease;
        }
    }

    Object.defineProperties(Keyboard, {
        Keys: { value: Keys },
    });

    return Keyboard;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/dom-keyboard.js


/**
 * @class module:@webgears-app/input.DOMKeyboard
 * @summary Wrapper for DOM Keyboard API.
 * @extends module:@webgears-app/input.Keyboard
 * @param {?(Element|Document)} [target=null] Target element or document. See
 *     {@link module:@webgears-app/input.DOMKeyboard#target}.
 */
class dom_keyboard_DOMKeyboard extends keyboard_Keyboard {
    constructor(target = null) {
        super();

        this._target = null;
        this._keyStates = new Map();

        this.target = target;
    }

    /**
     * @var module:@webgears-app/input.DOMKeyboard#target
     * @summary Current target element or document.
     * @desc If set to an {@link Element} that has no `tabIndex` attribute,
     *     sets this attribute to -1.
     * @type {?(Element|Document)}
     */
    get target() {
        return this._target;
    }

    set target(target) {
        console.assert(target === null ||
                       target instanceof Element ||
                       target instanceof Document);

        if (target === this._target) { return; }

        if (this._target !== null) {
            this._unsubscribe();
        }
        this._target = target;
        if (target === null) {
            this._keyStates.clear();
            this._unsubscribe = undefined;
            return;
        }

        if (target instanceof Element &&
            target.getAttribute('tabIndex') === null)
        { target.tabIndex = -1; }

        this._keyStates.clear();
        const onKeyDown = (event) => {
            const key = keyboard_Keyboard.Keys.fromDOMCode(event.code);
            this._keyStates.set(key, true);
            if (this.onKeyPress(key).emit()) {
                event.preventDefault();
            }
        };
        target.addEventListener('keydown', onKeyDown);
        const onKeyUp = (event) => {
            const key = keyboard_Keyboard.Keys.fromDOMCode(event.code);
            this._keyStates.set(key, false);
            if (this.onKeyRelease(key).emit()) {
                event.preventDefault();
            }
        };
        target.addEventListener('keyup', onKeyUp);

        this._unsubscribe = () => {
            target.removeEventListener('keydown', onKeyDown);
            target.removeEventListener('keyup', onKeyUp);
        };
    }

    /**
     * @function module:@webgears-app/input.DOMKeyboard#isKeyPressed
     * @summary Whether key is pressed.
     * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
     * @returns {boolean}
     */
    isKeyPressed(key) {
        return this._target !== null && (this._keyStates.get(key) || false);
    }
}

/**
 * @function module:@webgears-app/input.DOMKeyboard#onKeyPress
 * @summary Get event emitted when key is pressed.
 * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
 * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Keyboard.KeyPressEventSignature>} Key pressed.
 */

/**
 * @function module:@webgears-app/input.DOMKeyboard#onKeyRelease
 * @summary Get event emitted when key is released.
 * @param {module:@webgears-app/input.Keyboard.Keys} key Key.
 * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Keyboard.KeyReleaseEventSignature>} Key release.
 */

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/constants.js
const {
    /**
     * @constant module:@webgears-app/math.MIN_POSITIVE_NUMBER
     * @summary Alias for {@link Number.MIN_VALUE}.
     * @type {number}
     */
    MIN_VALUE: MIN_POSITIVE_NUMBER,
    
    /**
     * @constant module:@webgears-app/math.MAX_FINITE_NUMBER
     * @summary Alias for {@link Number.MAX_VALUE}.
     * @type {number}
     */
    MAX_VALUE: MAX_FINITE_NUMBER,

    /**
     * @constant module:@webgears-app/math.MIN_SAFE_INTEGER
     * @summary Alias for {@link Number.MIN_SAFE_INTEGER}.
     * @type {number}
     */
    MIN_SAFE_INTEGER,
    
    /**
     * @constant module:@webgears-app/math.MAX_SAFE_INTEGER
     * @summary Alias for {@link Number.MAX_SAFE_INTEGER}.
     * @type {number}
     */
    MAX_SAFE_INTEGER,
} = Number;

const {
    /**
     * @constant module:@webgears-app/math.PI
     * @summary Alias for {@link Math.PI}.
     * @type {number}
     */
    PI,

    /**
     * @constant module:@webgears-app/math.E
     * @summary Alias for {@link Math.E}.
     * @type {number}
     */
    E,
} = Math;

/**
 * @constant module:@webgears-app/math.TAU
 * @summary 2
 * @type {number}
 */
const TAU = PI * 2;

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/functions.js
const {
    /**
     * @function module:@webgears-app/math.isNaN
     * @summary Alias for {@link Number.isNaN}.
     * @param {number} value
     * @returns {boolean}
     */
    isNaN: functions_isNaN,

    /**
     * @function module:@webgears-app/math.isFinite
     * @summary Alias for {@link Number.isFinite}.
     * @param {number} value
     * @returns {boolean}
     */
    isFinite: functions_isFinite,

    /**
     * @function module:@webgears-app/math.isInteger
     * @summary Alias for {@link Number.isInteger}.
     * @param {number} value
     * @returns {boolean}
     */
    isInteger,

    /**
     * @function module:@webgears-app/math.isSafeInteger
     * @summary Alias for {@link Number.isSafeInteger}.
     * @param {number} value
     * @returns {boolean}
     */
    isSafeInteger,
} = Number;

const {
    /**
     * @function module:@webgears-app/math.abs
     * @summary Alias for {@link Math.abs}.
     * @param {number} value
     * @returns {number}
     */
    abs: functions_abs,
    
    /**
     * @function module:@webgears-app/math.sign
     * @summary Alias for {@link Math.sign}.
     * @param {number} value
     * @returns {number}
     */
    sign,

    /**
     * @function module:@webgears-app/math.floor
     * @summary Alias for {@link Math.floor}.
     * @param {number} value
     * @returns {number}
     */
    floor,
    
    /**
     * @function module:@webgears-app/math.ceil
     * @summary Alias for {@link Math.ceil}.
     * @param {number} value
     * @returns {number}
     */
    ceil,
    
    /**
     * @function module:@webgears-app/math.trunc
     * @summary Alias for {@link Math.trunc}.
     * @param {number} value
     * @returns {number}
     */
    trunc,
    
    /**
     * @function module:@webgears-app/math.round
     * @summary Alias for {@link Math.round}.
     * @param {number} value
     * @returns {number}
     */
    round,
    
    /**
     * @function module:@webgears-app/math.fround
     * @summary Alias for {@link Math.fround}.
     * @param {number} value
     * @returns {number}
     */
    fround,

    /**
     * @function module:@webgears-app/math.max
     * @summary Alias for {@link Math.max}.
     * @param {...number} values
     * @returns {number}
     */
    max: functions_max,
    
    /**
     * @function module:@webgears-app/math.min
     * @summary Alias for {@link Math.min}.
     * @param {...number} values
     * @returns {number}
     */
    min: functions_min,
    
    /**
     * @function module:@webgears-app/math.hypot
     * @summary Alias for {@link Math.hypot}.
     * @param {...number} values
     * @returns {number}
     */
    hypot,

    /**
     * @function module:@webgears-app/math.sqrt
     * @summary Alias for {@link Math.sqrt}.
     * @param {number} value
     * @returns {number}
     */
    sqrt,

    /**
     * @function module:@webgears-app/math.cbrt
     * @summary Alias for {@link Math.cbrt}.
     * @param {number} value
     * @returns {number}
     */
    cbrt,

    /**
     * @function module:@webgears-app/math.pow
     * @summary Alias for {@link Math.pow}.
     * @param {number} base
     * @param {number} power
     * @returns {number}
     */
    pow,

    /**
     * @function module:@webgears-app/math.exp
     * @summary Alias for {@link Math.exp}.
     * @param {number} value
     * @returns {number}
     */
    exp,

    /**
     * @function module:@webgears-app/math.expm1
     * @summary Alias for {@link Math.expm1}.
     * @param {number} value
     * @returns {number}
     */
    expm1,

    /**
     * @function module:@webgears-app/math.log
     * @summary Alias for {@link Math.log}.
     * @param {number} value
     * @returns {number}
     */
    log,

    /**
     * @function module:@webgears-app/math.log1p
     * @summary Alias for {@link Math.log1p}.
     * @param {number} value
     * @returns {number}
     */
    log1p,

    /**
     * @function module:@webgears-app/math.log2
     * @summary Alias for {@link Math.log2}.
     * @param {number} value
     * @returns {number}
     */
    log2,

    /**
     * @function module:@webgears-app/math.log10
     * @summary Alias for {@link Math.log10}.
     * @param {number} value
     * @returns {number}
     */
    log10,

    /**
     * @function module:@webgears-app/math.sin
     * @summary Alias for {@link Math.sin}.
     * @param {number} value
     * @returns {number}
     */
    sin,

    /**
     * @function module:@webgears-app/math.cos
     * @summary Alias for {@link Math.cos}.
     * @param {number} value
     * @returns {number}
     */
    cos,

    /**
     * @function module:@webgears-app/math.tan
     * @summary Alias for {@link Math.tan}.
     * @param {number} value
     * @returns {number}
     */
    tan,

    /**
     * @function module:@webgears-app/math.asin
     * @summary Alias for {@link Math.asin}.
     * @param {number} value
     * @returns {number}
     */
    asin,

    /**
     * @function module:@webgears-app/math.acos
     * @summary Alias for {@link Math.acos}.
     * @param {number} value
     * @returns {number}
     */
    acos,

    /**
     * @function module:@webgears-app/math.atan
     * @summary Alias for {@link Math.atan}.
     * @param {number} value
     * @returns {number}
     */
    atan,

    /**
     * @function module:@webgears-app/math.atan2
     * @summary Alias for {@link Math.atan2}.
     * @param {number} y
     * @param {number} x
     * @returns {number}
     */
    atan2,

    /**
     * @function module:@webgears-app/math.sinh
     * @summary Alias for {@link Math.sinh}.
     * @param {number} value
     * @returns {number}
     */
    sinh,

    /**
     * @function module:@webgears-app/math.cosh
     * @summary Alias for {@link Math.cosh}.
     * @param {number} value
     * @returns {number}
     */
    cosh,

    /**
     * @function module:@webgears-app/math.tanh
     * @summary Alias for {@link Math.tanh}.
     * @param {number} value
     * @returns {number}
     */
    tanh,

    /**
     * @function module:@webgears-app/math.asinh
     * @summary Alias for {@link Math.asinh}.
     * @param {number} value
     * @returns {number}
     */
    asinh,

    /**
     * @function module:@webgears-app/math.acosh
     * @summary Alias for {@link Math.acosh}.
     * @param {number} value
     * @returns {number}
     */
    acosh,

    /**
     * @function module:@webgears-app/math.atanh
     * @summary Alias for {@link Math.atanh}.
     * @param {number} value
     * @returns {number}
     */
    atanh,

    /**
     * @function module:@webgears-app/math.imul
     * @summary Alias for {@link Math.imul}.
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    imul,

    /**
     * @function module:@webgears-app/math.clz32
     * @summary Alias for {@link Math.clz32}.
     * @param {number} value
     * @returns {number}
     */
    clz32,
} = Math;

/**
 * @function module:@webgears-app/math.clamp
 * @param {number} x Value.
 * @param {number} a Lower bound.
 * @param {number} b Upper bound.
 * @returns {number} Value clamped between `a` and `b`.
 *    Equivalent to `{@link module:@webgears-app/math.min}({@link module:@webgears-app/math.max}(x, a), b)`.
 */
function clamp(x, a, b) {
    return functions_min(functions_max(x, a), b);
}

/**
 * @function module:@webgears-app/math.rt
 * @param {number} d Root degree.
 * @param {number} y Value.
 * @returns {number} `d`-degree root of number `y`.
 *    Equivalent to `{@link module:@webgears-app/math.pow}(y, 1 / d)`.
 */
function rt(d, y) {
    return pow(y, 1 / d);
}

/**
 * @function module:@webgears-app/math.sq
 * @param {number} x Value.
 * @returns {number} Square of `x`. Equivalent to `x * x`.
 */
function sq(x) {
    return x * x;
}

/**
 * @function module:@webgears-app/math.cb
 * @param {number} x Value.
 * @returns {number} Cube of `x`. Equivalent to `x * x * x`.
 */
function cb(x) {
    return x * x * x;
}

/**
 * @function module:@webgears-app/math.exp2
 * @param {number} x Value.
 * @returns {number} Base-2 exponent of `x`.
 *    Equivalent to `{@link module:@webgears-app/math.pow}(2, x)`.
 */
function exp2(x) {
    return pow(2, x);
}

/**
 * @function module:@webgears-app/math.exp10
 * @param {number} x Value.
 * @returns {number} Base-10 exponent of `x`.
 *    Equivalent to `{@link module:@webgears-app/math.pow}(10, x)`.
 */
function exp10(x) {
    return pow(10, x);
}

/**
 * @function module:@webgears-app/math.isPow2
 * @param {number} x Value.
 * @returns {boolean} Whether `x` is a power of 2, including negative powers.
 *    Equivalent to `{@link module:@webgears-app/math.isInteger}({@link module:@webgears-app/math.log2}(x))`.
 */
function isPow2(x) {
    return isInteger(log2(x));
}

/**
 * @function module:@webgears-app/math.isPow10
 * @param {number} x Value.
 * @returns {boolean} Whether `x` is a power of 10, including negative powers.
 *    Equivalent to `{@link module:@webgears-app/math.isInteger}({@link module:@webgears-app/math.log10}(x))`.
 */
function isPow10(x) {
    return isInteger(log10(x));
}

/**
 * @function module:@webgears-app/math.floorPow2
 * @param {number} x Value.
 * @returns {number} Biggest power of 2 not greater than `x`.
 *    Equivalent to `{@link module:@webgears-app/math.exp2}({@link module:@webgears-app/math.floor}({@link module:@webgears-app/math.log2}(x)))`.
 */
function floorPow2(x) {
    return exp2(floor(log2(x)));
}

/**
 * @function module:@webgears-app/math.ceilPow2
 * @param {number} x Value.
 * @returns {number} Smallest power of 2 not less than `x`.
 *    Equivalent to `{@link module:@webgears-app/math.exp2}({@link module:@webgears-app/math.ceil}({@link module:@webgears-app/math.log2}(x)))`.
 */
function ceilPow2(x) {
    return exp2(ceil(log2(x)));
}

/**
 * @function module:@webgears-app/math.floorPow10
 * @param {number} x Value.
 * @returns {number} Biggest power of 10 not greater than `x`.
 *    Equivalent to `{@link module:@webgears-app/math.exp10}({@link module:@webgears-app/math.floor}({@link module:@webgears-app/math.log10}(x)))`.
 */
function floorPow10(x) {
    return exp10(floor(log10(x)));
}

/**
 * @function module:@webgears-app/math.ceilPow10
 * @param {number} x Value.
 * @returns {number} Smallest power of 10 not less than `x`.
 *    Equivalent to `{@link module:@webgears-app/math.exp10}({@link module:@webgears-app/math.ceil}({@link module:@webgears-app/math.log10}(x)))`.
 */
function ceilPow10(x) {
    return exp10(ceil(log10(x)));
}

/**
 * @function module:@webgears-app/math.ldexp
 * @summary Compose normalized fraction and base-2 exponent into a number.
 * @desc Attempts to behave identically to corresponding C function.
 * @param {number} x Normalized fraction.
 * @param {number} e Base-2 exponent.
 * @returns {number} Effectively `x * {@link module:@webgears-app/math.exp2}(e)`,
 *    but with careful handling of edge cases.
 */
// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html
function ldexp(x, e) {
    if (x === 0 || !functions_isFinite(x)) { return x; }
    const n = functions_min(ceil(functions_abs(e) / 1023), 3);
    for (let i = 0; i < n; ++i) { x *= pow(2, floor((e + i) / n)); }
    return x;
}

/**
 * @function module:@webgears-app/math.frexp
 * @summary Decompose number into normalized fraction and base-2 exponent.
 * @desc Attempts to behave identically to corresponding C function.
 * @param {number} x Value.
 * @param {Array} [results] Result array.
 * @param {number} [results.0] Normalized fraction.
 * @param {number} [results.1] Base-2 exponent.
 * @returns {number} Filled `results`.
 */
// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html
const frexp = (() => {
    const f64 = new Float64Array(1);
    const hu32 = new Uint32Array(f64.buffer, (() => {
        return new Uint8Array(Uint16Array.of(4).buffer)[0];
    })(), 1);
    return function frexp(x, results = [0, 0]) {
        if (x === 0 || !functions_isFinite(x)) {
            results[0] = x;
            results[1] = 0;
        } else {
            f64[0] = x;
            let be = (hu32[0] >>> 20) & 0x7FF;
            if (be === 0) {
                f64[0] = x * 0x10000000000000000;
                be = ((hu32[0] >>> 20) & 0x7FF) - 64;
            }
            const e = be - 1022;
            results[0] = ldexp(x, -e);
            results[1] = e;
        }
        return results;
    };
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/codegen/lib/generate-function.js
class FunctionGenerator {
    constructor() {
        this.doc = [];
        this.ctx = {};
        this.strict = true;
        this.name = '';
        this.params = [];
        this._code = [];
    }

    emit(strings, ...values) {
        const code = this._code;
        code.push(strings[0]);
        for (const [i, value] of values.entries()) {
            code.push(value, strings[i + 1]);
        }
        code.push('\n');
    }

    _compile() {
        const ctx = new Map(Object.entries(this.ctx));
        const { strict } = this;
        const code = this._code;
        code.unshift(`return function(${this.params}){\n`);
        if (strict) { code.unshift('\'use strict\';'); };
        code.push('}\n');
        try {
            // eslint-disable-next-line no-new-func
            const fn = new Function(...ctx.keys(),
                                    code.join(''))(...ctx.values());
            Object.defineProperty(fn, 'name', {
                configurable: true,
                value: this.name,
            });
            if (false) {}
            return fn;
        } finally {
            code.pop();
            if (strict) { code.shift(); }
            code.shift();
        }
    }
}

function generateFunction(generate) {
    const fg = new FunctionGenerator();
    generate(fg);
    return fg._compile();
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/codegen/lib/function-property-definer-makers.js


function makeFunctionPropertyDefiner(type, name, object) {
    return {
        [name](generate) {
            const fn = generateFunction(generate);
            let descriptor = Object.getOwnPropertyDescriptor(object, fn.name);
            if (descriptor === undefined) {
                descriptor = { configurable: true };
            }
            if (type === 'value') { descriptor.writable = true; }
            descriptor[type] = fn;
            Object.defineProperty(object, fn.name, descriptor);
        }
    }[name];
}

function makeMethodDefiner(object) {
    return makeFunctionPropertyDefiner('value', 'defineMethod', object);
}

function makeGetterDefiner(object) {
    return makeFunctionPropertyDefiner('get', 'defineGetter', object);
}

function makeSetterDefiner(object) {
    return makeFunctionPropertyDefiner('set', 'defineSetter', object);
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/codegen/lib/make-property-aliaser.js
function makePropertyAliaser(object) {
    return function aliasProperty(name, alias) {
        const descriptor = Object.getOwnPropertyDescriptor(object, name);
        if (false) {}
        Object.defineProperty(object, alias, descriptor);
    };
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/to-title-case.js
function toTitleCase(s) {
    return (s[0] || '').toUpperCase() + s.slice(1);
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/vectors.js




const aas = [...'xyzw'];

function makeClass(d) {
    const as = aas.slice(0, d);

    const Vector = generateFunction(fg => {
        fg.name = `Vector${d}`;
        fg.params = as;
        for (const a of as) {
            fg.emit`this.${a}=${a}===undefined?0:${a}`;
        }

        if (false) {}
    });
    
    if (false) {}

    const defineMethod = makeMethodDefiner(Vector.prototype);
    const defineGetter = makeGetterDefiner(Vector.prototype);
    const defineSetter = makeSetterDefiner(Vector.prototype);
    const aliasProperty = makePropertyAliaser(Vector.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = as;
        for (const a of as) {
            fg.emit`this.${a}=${a}`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.name = 'fromNumber';
        fg.params = ['number'];
        for (const a of as) {
            fg.emit`this.${a}=number`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.name = `from${Vector.name}`;
        fg.params = ['vector'];
        for (const a of as) {
            fg.emit`this.${a}=vector.${a}`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    aliasProperty(`from${Vector.name}`, 'fromVector');
    aliasProperty('fromVector', 'copy');

    if (d === 2) {
        defineMethod(fg => {
            fg.name = `fromComplex`;
            fg.params = ['complex'];
            fg.emit`this.x=complex.re`;
            fg.emit`this.y=complex.im`;
            fg.emit`return this`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = `fromArray`;
        fg.params = ['array'];
        for (const [i, a] of as.entries()) {
            fg.emit`this.${a}=array[${i}]`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = `fromArrayAt`;
        fg.params = ['offset', 'array'];
        for (const [i, a] of as.entries()) {
            fg.emit`this.${a}=array[offset+${i}]`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.name = `toArray`;
        fg.params = ['array'];
        for (const [i, a] of as.entries()) {
            fg.emit`array[${i}]=this.${a}`;
        }
        fg.emit`return array`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = `toArrayAt`;
        fg.params = ['offset', 'array'];
        for (const [i, a] of as.entries()) {
            fg.emit`array[offset+${i}]=this.${a}`;
        }
        fg.emit`return array`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.ctx[Vector.name] = Vector;
        fg.name = 'clone';
        fg.emit`return new ${Vector.name}().copy(this)`;

        if (false) {}
    });

    for (const fn of [
        functions_isNaN,
        isInteger,
        isSafeInteger,
        functions_isFinite,
        isPow2,
        isPow10,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        defineGetter(fg => {
            fg.ctx[name] = fn;
            fg.name = `some${Name}`;
            fg.emit`return ${as.map(a => `${name}(this.${a})`).join('||')}`;

            if (false) {}
        });
        defineGetter(fg => {
            fg.ctx[name] = fn;
            fg.name = `every${Name}`;
            fg.emit`return ${as.map(a => `${name}(this.${a})`).join('&&')}`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return ${as.map(a => `this.${a}===that.${a}`).join('&&')}`;

        if (false) {}
    });

    function defineUnaryOperation(name, vector) {
        defineMethod(fg => {
            fg.name = name;
            vector(fg);
            fg.emit`return this`;
        });
    }
    for (const [name, op] of [
        ['negate', '-'],
    ]) {
        defineUnaryOperation(name, fg => {
            for (const a of as) {
                fg.emit`this.${a}=${op}this.${a}`;
            }

            if (false) {}
        });
    }
    for (const fn of [
        sign,
        functions_abs,
        floor,
        ceil,
        trunc,
        round,
        fround,
        floorPow2,
        ceilPow2,
        floorPow10,
        ceilPow10,
    ]) {
        const { name } = fn;
        defineUnaryOperation(name, fg => {
            fg.ctx[name] = fn;
            for (const a of as) {
                fg.emit`this.${a}=${name}(this.${a})`;
            }

            if (false) {}
        });
    }

    function defineBinaryOperartion(name, commutative, {
        vector, number, preNumber,
    }) {
        const Name = toTitleCase(name);

        defineMethod(fg => {
            fg.name = `${name}Vector`;
            fg.params = ['right'];
            vector(fg, 'this', 'right');
            fg.emit`return this`;
        });
        defineMethod(fg => {
            fg.name = `${name}Number`;
            fg.params = ['right'];
            number(fg);
            fg.emit`return this`;
        });

        if (!commutative) {
            defineMethod(fg => {
                fg.name = `pre${Name}Vector`;
                fg.params = ['left'];
                vector(fg, 'left', 'this');
                fg.emit`return this`;
            });

            defineMethod(fg => {
                fg.name = `pre${Name}Number`;
                fg.params = ['left'];
                preNumber(fg);
                fg.emit`return this`;
            });
        }
    }
    for (const [name, op, commutative] of [
        ['add'     , '+', 1],
        ['subtract', '-', 0],
        ['multiply', '*', 1],
        ['divide'  , '/', 0],
        ['modulo'  , '%', 0],
    ]) {
        const Name = toTitleCase(name);
        defineBinaryOperartion(name, commutative, {
            vector(fg, left, right) {
                for (const a of as) {
                    fg.emit`this.${a}=${left}.${a}${op}${right}.${a}`;
                }

                if (false) {}
            },
            number(fg) {
                if (['/', '%'].includes(op)) {
                    if (op === '%') {
                        Object.assign(fg.ctx, { trunc: trunc });
                        for (const a of as) {
                            fg.emit`var ${a}=this.${a}`;
                        }
                    }
                    fg.emit`var invRight=1/right`;
                }
                for (const a of as) {
                    if (op === '/') {
                        fg.emit`this.${a}=this.${a}*invRight`;
                    } else if (op === '%') {
                        fg.emit`this.${a}=${a}-trunc(${a}*invRight)*right`;
                    } else {
                        fg.emit`this.${a}=this.${a}${op}right`;
                    }
                }

                if (false) {}
            },
            preNumber(fg) {
                for (const a of as) {
                    fg.emit`this.${a}=left${op}this.${a}`;
                }

                if (false) {}
            },
        });
        if (['+', '-'].includes(op)) {
            aliasProperty(`${name}Vector`, name);
            if (!commutative) {
                aliasProperty(`pre${Name}Vector`, `pre${Name}`);
            }
        }
        if (['*', '/'].includes(op)) {
            aliasProperty(`${name}Number`, name);
        }
    }
    for (const [fn, commutative] of [
        [functions_min, 1],
        [functions_max, 1],
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        defineBinaryOperartion(name, commutative, {
            vector(fg, left, right) {
                fg.ctx[name] = fn;
                for (const a of as) {
                    fg.emit`this.${a}=${name}(${left}.${a},${right}.${a})`;
                }

                if (false) {}
            },
            number(fg) {
                fg.ctx[name] = fn;
                for (const a of as) {
                    fg.emit`this.${a}=${name}(this.${a},right)`;
                }

                if (false) {}
            },
            preNumber(fg) {
                fg.ctx[name] = fn;
                for (const a of as) {
                    fg.emit`this.${a}=${name}(left,this.${a})`;
                }

                if (false) {}
            },
        });
        if ([functions_min, functions_max].includes(fn)) {
            aliasProperty(`${name}Vector`, name);
        }
    }

    defineMethod(fg => {
        Object.assign(fg.ctx, { clamp: clamp });
        fg.name = `clampVectors`;
        fg.params = ['low', 'high'];
        for (const a of as) {
            fg.emit`this.${a}=clamp(this.${a},low.${a},high.${a})`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    aliasProperty('clampVectors', 'clamp');
    defineMethod(fg => {
        Object.assign(fg.ctx, { clamp: clamp });
        fg.name = `clampNumbers`;
        fg.params = ['low', 'high'];
        for (const a of as) {
            fg.emit`this.${a}=clamp(this.${a},low,high)`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineGetter(fg => {
        fg.name = 'sqLength';
        for (const a of as) {
            fg.emit`var ${a}=this.${a}`;
        }
        fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;

        if (false) {}
    });
    defineSetter(fg => {
        Object.assign(fg.ctx, { sqrt: sqrt });
        fg.name = 'sqLength';
        fg.params = ['newSqLength'];
        fg.emit`this.multiply(sqrt(newSqLength/this.sqLength))`;
    });

    defineGetter(fg => {
        Object.assign(fg.ctx, { sqrt: sqrt });
        fg.name = 'length';
        fg.emit`return sqrt(this.sqLength)`;

        if (false) {}
    });
    defineSetter(fg => {
        fg.name = 'length';
        fg.params = ['newLength'];
        fg.emit`this.multiply(newLength/this.length)`;
    });

    defineMethod(fg => {
        fg.name = 'sqDistance';
        fg.params = ['that'];
        for (const a of as) {
            fg.emit`var ${a}=this.${a}-that.${a}`;
        }
        fg.emit`return ${as.map(a => `${a}*${a}`).join('+')}`;

        if (false) {}
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { sqrt: sqrt });
        fg.name = 'distance';
        fg.params = ['that'];
        fg.emit`return sqrt(this.sqDistance(that))`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.name = 'normalize';
        fg.emit`return this.divide(this.length)`;

        if (false) {}
    });

    defineMethod(fg => {
        fg.name = 'dot';
        fg.params = ['that'];
        fg.emit`return ${as.map(a => `this.${a}*that.${a}`).join('+')}`;

        if (false) {}
    });

    if (d === 2) {
        defineMethod(fg => {
            fg.name = 'cross';
            fg.params = ['right'];
            fg.emit`return this.x*right.y-this.y*right.x`;

            if (false) {}
        });
    } else {
        function cross(result, left, right) {
            const { x: ax, y: ay, z: az } = left;
            const { x: bx, y: by, z: bz } = right;
            result.x = ay * bz - az * by;
            result.y = az * bx - ax * bz;
            result.z = ax * by - ay * bx;
        }
        defineMethod(fg => {
            Object.assign(fg.ctx, { cross });
            fg.name = 'cross';
            fg.params = ['right'];
            fg.emit`cross(this,this,right)`;
            fg.emit`return this`;

            if (false) {}
        });
        defineMethod(fg => {
            Object.assign(fg.ctx, { cross });
            fg.name = 'preCross';
            fg.params = ['left'];
            fg.emit`cross(this,left,this)`;
            fg.emit`return this`;

            if (false) {}
        });
    }

    if (d === 2) {
        defineMethod(fg => {
            fg.name = 'orthogonalize';
            fg.emit`var x=this.x`;
            fg.emit`this.x=-this.y`;
            fg.emit`this.y=x`;
            fg.emit`return this`;

            if (false) {}
        });
    } else {
        defineMethod(fg => {
            Object.assign(fg.ctx, { abs: functions_abs });
            fg.name = 'orthogonalize';
            fg.emit`var x=this.x,y=this.y,z=this.z`;
            fg.emit`var ax=abs(x),ay=abs(y),az=abs(z)`;
            fg.emit`if(ax<=ay&&ax<=az){`;
            fg.emit    `this.x=0`;
            fg.emit    `this.y=z`;
            fg.emit    `this.z=-y`;
            fg.emit`}else if(ay<=az){`;
            fg.emit    `this.x=-z`;
            fg.emit    `this.y=0`;
            fg.emit    `this.z=x`;
            fg.emit`}else{`;
            fg.emit    `this.x=y`;
            fg.emit    `this.y=-x`;
            fg.emit    `this.z=0`;
            fg.emit`}`;
            fg.emit`return this`;

            if (false) {}
        });
    }

    aliasProperty('add', 'translate');

    aliasProperty(`multiplyVector`, 'scale');
    aliasProperty(`multiply`, 'scaleUniform');

    defineMethod(fg => {
        fg.name = 'shear';
        fg.params = ['shearing'];
        if (d === 2) {
            fg.emit`this.x+=this.y*shearing`;
        } else {
            fg.emit`var y=this.y,z=this.z`;
            fg.emit`this.x+=y*shearing.z+z*shearing.y`;
            fg.emit`this.y=y+z*shearing.x`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { tmp: new Vector() });
        fg.name = 'reflect';
        fg.params = ['normal'];
        fg.emit`tmp.copy(normal).multiply(2*this.dot(normal))`;
        fg.emit`return this.subtract(tmp)`;

        if (false) {}
    });

    if (d === 2) {
        defineMethod(fg => {
            Object.assign(fg.ctx, { sin: sin, cos: cos });
            fg.name = 'rotate';
            fg.params = ['angle'];
            fg.emit`var x=this.x,y=this.y`;
            fg.emit`var s=sin(angle),c=cos(angle)`;
            fg.emit`this.x=x*c-y*s`;
            fg.emit`this.y=x*s+y*c`;
            fg.emit`return this`;

            if (false) {}
        });

        defineMethod(fg => {
            fg.name = 'rotateBetween';
            fg.params = ['from', 'to'];
            fg.emit`var x=this.x,y=this.y`;
            fg.emit`var s=from.cross(to),c=from.dot(to)`;
            fg.emit`this.x=x*c-y*s`;
            fg.emit`this.y=x*s+y*c`;
            fg.emit`return this`;

            if (false) {}
        });

        defineMethod(fg => {
            fg.name = 'applyComplex';
            fg.params = ['complex'];
            fg.emit`var x=this.x,y=this.y`;
            fg.emit`var re=complex.re,im=complex.im`;
            fg.emit`this.x=x*re-y*im`;
            fg.emit`this.y=x*im+y*re`;
            fg.emit`return this`;

            if (false) {}
        });
    } else {
        defineMethod(fg => {
            Object.assign(fg.ctx, { sin: sin, cos: cos });
            fg.name = 'rotate';
            fg.params = ['angle', 'axis'];
            fg.emit`var x=this.x,y=this.y,z=this.z`;
            fg.emit`var s=sin(angle),c=cos(angle)`;
            fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;
            fg.emit`var q=(ax*x+ay*y+az*z)*(1-c)`;
            fg.emit`this.x=x*c+(ay*z-az*y)*s+ax*q`;
            fg.emit`this.y=y*c+(az*x-ax*z)*s+ay*q`;
            fg.emit`this.z=z*c+(ax*y-ay*x)*s+az*q`;
            fg.emit`return this`;

            if (false) {}
        });

        defineMethod(fg => {
            Object.assign(fg.ctx, {
                axis: new Vector(),
            });
            fg.name = 'rotateBetween';
            fg.params = ['from', 'to'];
            fg.emit`axis.copy(from).cross(to)`;
            fg.emit`var axs=axis.x,ays=axis.y,azs=axis.z`;
            fg.emit`axis.normalize()`;
            fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;
            fg.emit`var c=from.dot(to),q=axis.dot(this)*(1-c),`;
            fg.emit    `x=this.x,y=this.y,z=this.z`;
            fg.emit`this.x=x*c+(ays*z-azs*y)+axis.x*q`;
            fg.emit`this.y=y*c+(azs*x-axs*z)+axis.y*q`;
            fg.emit`this.z=z*c+(axs*y-ays*x)+axis.z*q`;
            fg.emit`return this`;

            if (false) {}
        });

        defineMethod(fg => {
            Object.assign(fg.ctx, { sqrt: sqrt });
            fg.name = 'applyComplex';
            fg.params = ['complex', 'axis'];
            fg.emit`var x=this.x,y=this.y,z=this.z`;
            fg.emit`var re=complex.re,im=complex.im`;
            fg.emit`var f=sqrt(re*re+im*im)`;
            fg.emit`var ax=axis.x,ay=axis.y,az=axis.z`;
            fg.emit`var q=(ax*x+ay*y+az*z)*(f-re)`;
            fg.emit`this.x=x*re+(ay*z-az*y)*im+ax*q`;
            fg.emit`this.y=y*re+(az*x-ax*z)*im+ay*q`;
            fg.emit`this.z=z*re+(ax*y-ay*x)*im+az*q`;
            fg.emit`return this`;

            if (false) {}
        });

        defineMethod(fg => {
            fg.name = 'applyQuaternion';
            fg.params = ['quaternion'];
            fg.emit`var x=this.x,y=this.y,z=this.z,`;
            fg.emit    `re=quaternion.re,`;
            fg.emit    `imX=quaternion.imX,`;
            fg.emit    `imY=quaternion.imY,`;
            fg.emit    `imZ=quaternion.imZ,`;
            fg.emit    `tRe=imX*x+imY*y+imZ*z,`;
            fg.emit    `tImX=re*x+imZ*y-imY*z,`;
            fg.emit    `tImY=re*y+imX*z-imZ*x,`;
            fg.emit    `tImZ=re*z+imY*x-imX*y`;
            fg.emit`this.x=tRe*imX+tImX*re+tImY*imZ-tImZ*imY`;
            fg.emit`this.y=tRe*imY+tImY*re+tImZ*imX-tImX*imZ`;
            fg.emit`this.z=tRe*imZ+tImZ*re+tImX*imY-tImY*imX`;
            fg.emit`return this`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = 'multiplyLinearMatrix';
        fg.params = ['matrix'];
        for (const a of as) {
            fg.emit`var ${a}=this.${a}`;
        }
        for (const [j, a] of as.entries()) {
            fg.emit`this.${a}=${
                as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')
            }`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    aliasProperty('multiplyLinearMatrix', 'applyLinearMatrix');

    defineMethod(fg => {
        fg.name = 'multiplyAffineMatrix';
        fg.params = ['matrix'];
        for (const a of as) {
            fg.emit`var ${a}=this.${a}`;
        }
        for (const [j, a] of as.entries()) {
            fg.emit`this.${a}=${
                as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')
            }+matrix._${d}${j}`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    aliasProperty('multiplyAffineMatrix', 'applyAffineMatrix');

    defineMethod(fg => {
        fg.name = 'multiplyHomogeneousMatrix';
        fg.params = ['matrix'];
        for (const a of as) {
            fg.emit`var ${a}=this.${a}`;
        }
        fg.emit`var invW=1/(${
            as.map((a, i) => `${a}*matrix._${i}${d}`).join('+')
        }+matrix._${d}${d})`;
        for (const [j, a] of as.entries()) {
            fg.emit`this.${a}=(${
                as.map((a, i) => `${a}*matrix._${i}${j}`).join('+')
            }+matrix._${d}${j})*invW`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    aliasProperty('multiplyHomogeneousMatrix', 'applyHomogeneousMatrix');

    return Vector;
}

const Vector2 = makeClass(2);
const Vector3 = makeClass(3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/complex.js




const complex_Complex = (() => {
    /**
     * @class module:@webgears-app/math.Complex
     * @summary Complex number. Used for representing 2D rotations and uniform
     *     scaling.
     * @param {number} [re=1] Real component.
     * @param {number} [im=0] Imaginary component.
     */
    class Complex {
        constructor(re = 1, im = 0) {
            /**
             * @var module:@webgears-app/math.Complex#re
             * @summary Real component.
             * @type {number}
             */
            this.re = re;

            /**
             * @var module:@webgears-app/math.Complex#im
             * @summary Imaginary component.
             * @type {number}
             */
            this.im = im;
        }

        /**
         * @function module:@webgears-app/math.Complex#set
         * @summary Set complex components.
         * @param {number} re Real component.
         * @param {number} im Imaginary component.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        set(re, im) {
            this.re = re;
            this.im = im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#fromNumber
         * @summary Set complex from real number.
         * @desc ```
         * this.re = re;
         * this.im = 0;
         * ```
         * @param {number} re Real component.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromNumber(re) {
            this.re = re;
            this.im = 0;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#fromComplex
         * @summary Set complex from another complex.
         * @param {module:@webgears-app/math.Complex} complex Source complex.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromComplex(complex) {
            this.re = complex.re;
            this.im = complex.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#fromVector2
         * @summary Set complex from 2D vector.
         * @desc ```
         * this.re = vector.x;
         * this.im = vector.y;
         * ```
         * @param {module:@webgears-app/math.Vector2} complex Source vector.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromVector2(vector) {
            this.re = vector.x;
            this.im = vector.y;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#fromArray
         * @summary Set complex from array.
         * @desc ```
         * this.re = array[0];
         * this.im = array[1];
         * ```
         * @param {ArrayLike} array Source array. Must have at least two elements.
         * First two elements must be numbers.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromArray(array) {
            this.re = array[0];
            this.im = array[1];
            return this
        }

        /**
         * @function module:@webgears-app/math.Complex#fromArrayAt
         * @summary Set complex from array at given offset.
         * @desc ```
         * this.re = array[offset    ];
         * this.im = array[offset + 1];
         * ```
         * @param {number} offset Where in the array to take values from.
         * @param {ArrayLike} array Source array. Must have at least (`offset` + 2) elements.
         * Two elements starting at `offset` must be numbers.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromArrayAt(offset, array) {
            this.re = array[offset    ];
            this.im = array[offset + 1];
            return this
        }

        /**
         * @function module:@webgears-app/math.Complex#toArray
         * @summary Put complex elements into array.
         * @desc ```
         * array[0] = this.re;
         * array[1] = this.im;
         * ```
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toArray(array) {
            array[0] = this.re;
            array[1] = this.im;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Complex#toArrayAt
         * @summary Put complex elements into array at given offset.
         * @desc ```
         * array[offset    ] = this.re;
         * array[offset + 1] = this.im;
         * ```
         * @param {number} offset Where in the array to put values to.
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toArrayAt(offset, array) {
            array[offset    ] = this.re;
            array[offset + 1] = this.im;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Complex#clone
         * @returns {module:@webgears-app/math.Complex}
         */
        clone() {
            return new Complex().copy(this);
        }

        /**
         * @function module:@webgears-app/math.Complex#equals
         * @param {module:@webgears-app/math.Complex} that Other complex.
         * @returns {boolean} Whether `this` components are equal to `that`
         * components.
         */
        equals(that) {
            return this.re === that.re && this.im === that.im;
        }

        /**
         * @function module:@webgears-app/math.Complex#negate
         * @desc In place.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        negate() {
            this.re = -this.re;
            this.im = -this.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#invert
         * @desc In place.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        invert() {
            const { re, im } = this;
            const invSqAbs = 1 / this.sqAbs;
            this.re *= invSqAbs;
            this.im *= -invSqAbs;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#addComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} that Other operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        addComplex(that) {
            this.re += that.re;
            this.im += that.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#addNumber
         * @desc Result is placed into `this`.
         * @param {number} that Other operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        addNumber(that) {
            this.re += that;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#subtractComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} right Right operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        subtractComplex(right) {
            this.re -= right.re;
            this.im -= right.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#preSubtractComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} left Left operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        preSubtractComplex(left) {
            this.re = left.re - this.re;
            this.im = left.im - this.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#subtractNumber
         * @desc Result is placed into `this`.
         * @param {number} right Right operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        subtractNumber(right) {
            this.re -= right;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#preSubtractNumber
         * @desc Result is placed into `this`.
         * @param {number} left Left operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        preSubtractNumber(left) {
            this.re = left - this.re;
            this.im = -this.im;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#multiplyComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} that Other operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        multiplyComplex(that) {
            const { re: aRe, im: aIm } = this;
            const { re: bRe, im: bIm } = that;
            this.re = aRe * bRe - aIm * bIm;
            this.im = aRe * bIm + aIm * bRe;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#multiplyNumber
         * @desc Result is placed into `this`.
         * @param {number} that Other operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        multiplyNumber(that) {
            this.re *= that;
            this.im *= that;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#divideComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} right Right operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        divideComplex(right) {
            return this.multiplyComplex(tmp.copy(right).invert());
        }

        /**
         * @function module:@webgears-app/math.Complex#preDivideComplex
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Complex} left Left operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        preDivideComplex(left) {
            return this.invert().multiplyComplex(left);
        }

        /**
         * @function module:@webgears-app/math.Complex#divideNumber
         * @desc Result is placed into `this`.
         * @param {number} right Right operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        divideNumber(right) {
            return this.multiplyNumber(1 / right);
        }

        /**
         * @function module:@webgears-app/math.Complex#preDivideNumber
         * @desc Result is placed into `this`.
         * @param {number} left Left operand.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        preDivideNumber(left) {
            return this.invert().multiplyNumber(left);
        }

        /**
         * @var module:@webgears-app/math.Complex#sqAbs
         * @summary Squared absolute value (magnitude) of complex number.
         * @type {number}
         */
        get sqAbs() {
            const { re, im } = this;
            return re * re + im * im;
        }
        set sqAbs(newSqAbs) {
            this.multiplyNumber(sqrt(newSqAbs / this.sqAbs));
        }

        /**
         * @var module:@webgears-app/math.Complex#abs
         * @summary Absolute value (magnitude) of complex number.
         * @type {number}
         */
        get abs() {
            return sqrt(this.sqAbs);
        }
        set abs(newAbs) {
            this.multiplyNumber(newAbs / this.abs);
        }

        /**
         * @var module:@webgears-app/math.Complex#arg
         * @summary Argument (rotation angle in radians) of complex number.
         * @type {number}
         */
        get arg() {
            return atan2(this.im, this.re);
        }
        set arg(newArg) {
            const { abs } = this;
            this.re = cos(newArg) * abs;
            this.im = sin(newArg) * abs;
        }

        /**
         * @function module:@webgears-app/math.Complex#normalize
         * @desc In place.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        normalize() {
            return this.divideNumber(this.abs);
        }

        /**
         * @function module:@webgears-app/math.Complex#fromRotation
         * @summary Initialize `this` with rotation transformation.
         * @param {number} angle Rotation angle (in radians).
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromRotation(angle) {
            this.re = cos(angle);
            this.im = sin(angle);
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#rotate
         * @summary Apply rotation transformation to `this`.
         * @param {number} angle Rotation angle (in radians).
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        rotate(angle) {
            const { re, im } = this;
            const s = sin(angle), c = cos(angle);
            this.re = re * c - im * s;
            this.im = re * s + im * c;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#fromRotationBetween
         * @summary Initialize `this` with rotation transformation required to
         * align `from` with `to`.
         * @param {module:@webgears-app/math.Vector2} from Initial direction.
         * Must have unit length.
         * @param {module:@webgears-app/math.Vector2} to Final direction.
         * Must have unit length.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        fromRotationBetween(from, to) {
            this.re = from.dot(to);
            this.im = from.cross(to);
            return this;
        }

        /**
         * @function module:@webgears-app/math.Complex#rotateBetween
         * @summary Apply rotation transformation required to align `from` with `to`.
         * @param {module:@webgears-app/math.Vector2} from Initial direction.
         * Must have unit length.
         * @param {module:@webgears-app/math.Vector2} to Final direction.
         * Must have unit length.
         * @returns {module:@webgears-app/math.Complex} `this`
         */
        rotateBetween(from, to) {
            const { re, im } = this;
            const s = from.dot(to), c = from.cross(to);
            this.re = re * c - im * s;
            this.im = re * s + im * c;
            return this;
        }
    }

    const tmp = new Complex();

    const aliasProperty = makePropertyAliaser(Complex.prototype);

    aliasProperty('fromComplex', 'copy');
    aliasProperty('fromVector2', 'fromVector');

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const Name = toTitleCase(fn.name);
        Object.defineProperties(Complex.prototype, {
            [`some${Name}`]: {
                configurable: true,
                get() { return fn(this.re) || fn(this.im); },
            },
            [`every${Name}`]: {
                configurable: true,
                get() { return fn(this.re) && fn(this.im); },
            },
        });
    }
    /**
     * @var module:@webgears-app/math.Complex#someIsNaN
     * @summary Whether some component {@link module:@webgears-app/math.isNaN}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Complex#everyIsNaN
     * @summary Whether every component {@link module:@webgears-app/math.isNaN}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Complex#someIsFinite
     * @summary Whether some component {@link module:@webgears-app/math.isFinite}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Complex#everyIsFinite
     * @summary Whether every component {@link module:@webgears-app/math.isFinite}.
     * @type {boolean}
     * @readonly
     */

    /**
     * @function module:@webgears-app/math.Complex#add
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#addComplex}.
     * @param {module:@webgears-app/math.Complex} that Other operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('addComplex', 'add');

    /**
     * @function module:@webgears-app/math.Complex#subtract
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#subtractComplex}.
     * @param {module:@webgears-app/math.Complex} right Right operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('subtractComplex', 'subtract');

    /**
     * @function module:@webgears-app/math.Complex#preSubtract
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#preSubtractComplex}.
     * @param {module:@webgears-app/math.Complex} left Left operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('preSubtractComplex', 'preSubtract');

    /**
     * @function module:@webgears-app/math.Complex#multiply
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#multiplyComplex}.
     * @param {module:@webgears-app/math.Complex} that Other operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('multiplyComplex', 'multiply');

    /**
     * @function module:@webgears-app/math.Complex#applyComplex
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#multiplyComplex}.
     * @param {module:@webgears-app/math.Complex} that Other operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('multiplyComplex', 'applyComplex');
    /**
     * @function module:@webgears-app/math.Complex#apply
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#multiply}.
     * @param {module:@webgears-app/math.Complex} that Other operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('multiply', 'apply');

    /**
     * @function module:@webgears-app/math.Complex#divide
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#divideComplex}.
     * @param {module:@webgears-app/math.Complex} right Right operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('divideComplex', 'divide');

    /**
     * @function module:@webgears-app/math.Complex#preDivide
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#preDivideComplex}.
     * @param {module:@webgears-app/math.Complex} left Left operand.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('preDivideComplex', 'preDivide');

    /**
     * @function module:@webgears-app/math.Complex#fromUniformScaling
     * @summary Initialize `this` with uniform scaling transformation.
     *
     * Alias for {@link module:@webgears-app/math.Complex#fromNumber}.
     * @param {number} uniformScaling Uniform scaling factor.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('fromNumber', 'fromUniformScaling');

    /**
     * @function module:@webgears-app/math.Complex#scaleUniform
     * @summary Apply uniform scaling transformation to `this`.
     *
     * Alias for {@link module:@webgears-app/math.Complex#multiplyNumber}.
     * @param {number} uniformScaling Uniform scaling factor.
     * @returns {module:@webgears-app/math.Complex} `this`
     */
    aliasProperty('multiplyNumber', 'scaleUniform');

    /**
     * @var module:@webgears-app/math.Complex#uniformScaling
     * @summary Uniform scaling factor.
     * @desc Alias for {@link module:@webgears-app/math.Complex#abs}.
     * @type {number}
     */
    aliasProperty('abs', 'uniformScaling');

    /**
     * @var module:@webgears-app/math.Complex#rotationAngle
     * @summary Rotation angle (in radians).
     * @desc Alias for {@link module:@webgears-app/math.Complex#arg}.
     * @type {number}
     */
    aliasProperty('arg', 'rotationAngle');

    return Complex;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/quaternion.js






const quaternion_Quaternion = (() => {
    function multiply(result, left, right) {
        const { re: lRe, imX: lImX, imY: lImY, imZ: lImZ } = left;
        const { re: rRe, imX: rImX, imY: rImY, imZ: rImZ } = right;
        result.re = lRe * rRe - lImX * rImX - lImY * rImY - lImZ * rImZ;
        result.imX = lRe * rImX + lImX * rRe + lImY * rImZ - lImZ * rImY;
        result.imY = lRe * rImY + lImY * rRe + lImZ * rImX - lImX * rImZ;
        result.imZ = lRe * rImZ + lImZ * rRe + lImX * rImY - lImY * rImX;
        return result;
    }

    const im = new Vector3();

    /**
     * @class module:@webgears-app/math.Quaternion
     * @summary Used for representing 3D rotations and uniform scaling.
     * @desc It is stored in conjugate form, so that multiplication composes transformations from
     * left to right.
     * @param {number} [re=1] Real component.
     * @param {number} [imX=0] Imaginary X component.
     * @param {number} [imY=0] Imaginary Y component.
     * @param {number} [imZ=0] Imaginary Z component.
     */
    class Quaternion {
        constructor(re = 1, imX = 0, imY = 0, imZ = 0) {
            /**
             * @var module:@webgears-app/math.Quaternion#re
             * @summary Real component.
             * @type {number}
             */
            this.re = re;

            /**
             * @var module:@webgears-app/math.Quaternion#imX
             * @summary Imaginary X component.
             * @type {number}
             */
            this.imX = imX;

            /**
             * @var module:@webgears-app/math.Quaternion#imY
             * @summary Imaginary Y component.
             * @type {number}
             */
            this.imY = imY;

            /**
             * @var module:@webgears-app/math.Quaternion#imZ
             * @summary Imaginary Z component.
             * @type {number}
             */
            this.imZ = imZ;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#set
         * @summary Set quaternion components.
         * @param {number} re Real component.
         * @param {number} imX Imaginary X component.
         * @param {number} imY Imaginary Y component.
         * @param {number} imZ Imaginary Z component.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        set(re, imX, imY, imZ) {
            this.re = re;
            this.imX = imX;
            this.imY = imY;
            this.imZ = imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromNumber
         * @summary Set quaternion from real number.
         * @desc ```
         * this.re = re;
         * this.imX = 0;
         * this.imY = 0;
         * this.imZ = 0;
         * ```
         * @param {number} re Real component.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromNumber(re) {
            this.re = re;
            this.imX = 0;
            this.imY = 0;
            this.imZ = 0;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromQuaternion
         * @summary Set quaternion from another quaternion.
         * @param {module:@webgears-app/math.Quaternion} quaternion Source quaternion.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromQuaternion(quaternion) {
            this.re = quaternion.re;
            this.imX = quaternion.imX;
            this.imY = quaternion.imY;
            this.imZ = quaternion.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromArray
         * @summary Set quaternion from array.
         * @desc The array is expected to store the quaternion in more commonly used, non-conjugate
         * form, with imaginary components preceding the real one:
         * ```
         * this.imX = -array[0];
         * this.imY = -array[1];
         * this.imZ = -array[2];
         * this.re  =  array[3];
         * ```
         * @param {ArrayLike} array Source array. Must have at least four elements.
         * First four elements must be numbers.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromArray(array) {
            this.imX = -array[0];
            this.imY = -array[1];
            this.imZ = -array[2];
            this.re = array[3];
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromArrayAt
         * @summary Set quaternion from array at given offset.
         * @desc The array is expected to store the quaternion in more commonly used, non-conjugate
         * form, with imaginary components preceding the real one:
         * ```
         * this.imX = -array[offset    ];
         * this.imY = -array[offset + 1];
         * this.imZ = -array[offset + 2];
         * this.re  =  array[offset + 3];
         * ```
         * @param {number} offset Where in the array to take values from.
         * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.
         * Four elements starting at `offset` must be numbers.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromArrayAt(offset, array) {
            this.imX = -array[offset];
            this.imY = -array[offset + 1];
            this.imZ = -array[offset + 2];
            this.re = array[offset + 3];
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#toArray
         * @summary Put quaternion elements into array.
         * @desc The array will store the quaternion in more commonly used, non-conjugate
         * form, with imaginary components preceding the real one:
         * ```
         * array[0] = -this.imX;
         * array[1] = -this.imY;
         * array[2] = -this.imZ;
         * array[3] =  this.re;
         * ```
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toArray(array) {
            array[0] = -this.imX;
            array[1] = -this.imY;
            array[2] = -this.imZ;
            array[3] = this.re;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#toArrayAt
         * @summary Put quaternion elements into array at given offset.
         * @desc The array will store the quaternion in more commonly used, non-conjugate
         * form, with imaginary components preceding the real one:
         * ```
         * array[offset    ] = -this.imX;
         * array[offset + 1] = -this.imY;
         * array[offset + 2] = -this.imZ;
         * array[offset + 3] =  this.re;
         * ```
         * @param {number} offset Where in the array to put values to.
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toArrayAt(offset, array) {
            array[offset] = -this.imX;
            array[offset + 1] = -this.imY;
            array[offset + 2] = -this.imZ;
            array[offset + 3] = this.re;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromConjugateArray
         * @summary Set quaternion from array.
         * @desc The array is expected to store the quaternion in conjugate form, with imaginary
         * components preceding the real one:
         * ```
         * this.imX = array[0];
         * this.imY = array[1];
         * this.imZ = array[2];
         * this.re  = array[3];
         * ```
         * @param {ArrayLike} array Source array. Must have at least four elements.
         * First four elements must be numbers.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromConjugateArray(array) {
            this.imX = array[0];
            this.imY = array[1];
            this.imZ = array[2];
            this.re = array[3];
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromConjugateArrayAt
         * @summary Set quaternion from array at given offset.
         * @desc The array is expected to store the quaternion in conjugate form, with imaginary
         * components preceding the real one:
         * ```
         * this.imX = array[offset    ];
         * this.imY = array[offset + 1];
         * this.imZ = array[offset + 2];
         * this.re  = array[offset + 3];
         * ```
         * @param {number} offset Where in the array to take values from.
         * @param {ArrayLike} array Source array. Must have at least (`offset` + 4) elements.
         * Four elements starting at `offset` must be numbers.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromConjugateArrayAt(offset, array) {
            this.imX = array[offset];
            this.imY = array[offset + 1];
            this.imZ = array[offset + 2];
            this.re = array[offset + 3];
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#toConjugateArray
         * @summary Put quaternion elements into array.
         * @desc The array will store the quaternion in conjugate form, with imaginary components
         * preceding the real one:
         * ```
         * array[0] = this.imX;
         * array[1] = this.imY;
         * array[2] = this.imZ;
         * array[3] = this.re;
         * ```
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toConjugateArray(array) {
            array[0] = this.imX;
            array[1] = this.imY;
            array[2] = this.imZ;
            array[3] = this.re;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#toConjugateArrayAt
         * @summary Put quaternion elements into array at given offset.
         * @desc The array will store the quaternion in conjugate form, with imaginary components
         * preceding the real one:
         * ```
         * array[offset    ] = this.imX;
         * array[offset + 1] = this.imY;
         * array[offset + 2] = this.imZ;
         * array[offset + 3] = this.re;
         * ```
         * @param {number} offset Where in the array to put values to.
         * @param {ArrayLike} array Destination array.
         * @returns {ArrayLike} `array`
         */
        toConjugateArrayAt(offset, array) {
            array[offset] = this.imX;
            array[offset + 1] = this.imY;
            array[offset + 2] = this.imZ;
            array[offset + 3] = this.re;
            return array;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#clone
         * @returns {module:@webgears-app/math.Quaternion}
         */
        clone() {
            return new Quaternion().copy(this);
        }
        
        /**
         * @function module:@webgears-app/math.Quaternion#equals
         * @param {module:@webgears-app/math.Quaternion} that Other quaternion.
         * @returns {boolean} Whether `this` components are equal to `that`
         * components.
         */
        equals(that) {
            return this.re === that.re &&
                   this.imX === that.imX &&
                   this.imY === that.imY &&
                   this.imZ === that.imZ;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#negate
         * @desc In place.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        negate() {
            this.re = -this.re;
            this.imX = -this.imX;
            this.imY = -this.imY;
            this.imZ = -this.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#conjugate
         * @desc In place.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        conjugate() {
            this.imX = -this.imX;
            this.imY = -this.imY;
            this.imZ = -this.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#invert
         * @desc In place.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        invert() {
            const invNegSqAbs = -1 / this.sqAbs;
            this.re *= -invNegSqAbs;
            this.imX *= invNegSqAbs;
            this.imY *= invNegSqAbs;
            this.imZ *= invNegSqAbs;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#addQuaternion
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Quaternion} that Other operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        addQuaternion(that) {
            this.re += that.re;
            this.imX += that.imX;
            this.imY += that.imY;
            this.imZ += that.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#addNumber
         * @desc Result is placed into `this`.
         * @param {number} that Other operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        addNumber(that) {
            this.re += that;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#subtractQuaternion
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Quaternion} right Right operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        subtractQuaternion(right) {
            this.re -= right.re;
            this.imX -= right.imX;
            this.imY -= right.imY;
            this.imZ -= right.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#preSubtractQuaternion
         * @desc Result is placed into `this`.
         * @param {module:@webgears-app/math.Quaternion} left Left operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preSubtractQuaternion(left) {
            this.re = left.re - this.re;
            this.imX = left.imX - this.imX;
            this.imY = left.imY - this.imY;
            this.imZ = left.imZ - this.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#subtractNumber
         * @desc Result is placed into `this`.
         * @param {number} right Right operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        subtractNumber(right) {
            this.re -= right;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#preSubtractNumber
         * @desc Result is placed into `this`.
         * @param {number} left Left operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preSubtractNumber(left) {
            this.re = left - this.re;
            this.imX = -this.imX;
            this.imY = -this.imY;
            this.imZ = -this.imZ;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#multiplyQuaternion
         * @desc Composes transformations left to right. Result is placed into `this`.
         * @param {module:@webgears-app/math.Quaternion} right Right operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        multiplyQuaternion(right) {
            return multiply(this, this, right);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#preMultiplyQuaternion
         * @desc Composes transformations left to right. Result is placed into `this`.
         * @param {module:@webgears-app/math.Quaternion} left Left operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preMultiplyQuaternion(left) {
            return multiply(this, left, this);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#multiplyNumber
         * @desc Result is placed into `this`.
         * @param {number} that Other operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        multiplyNumber(that) {
            this.re *= that;
            this.imX *= that;
            this.imY *= that;
            this.imZ *= that;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#divideNumber
         * @desc Result is placed into `this`.
         * @param {number} right Right operand.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        divideNumber(right) {
            return this.multiplyNumber(1 / right);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#imPaste
         * @summary Paste imaginary components into a vector.
         * @param {module:@webgears-app/math.Vector3} im Destination vector.
         * @returns {module:@webgears-app/math.Vector3} `im`
         */
        imPaste(im) {
            im.x = this.imX;
            im.y = this.imY;
            im.z = this.imZ;
            return im;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#imPaste
         * @summary Sets imaginary components from vector.
         * @desc Real component is not modified.
         * @param {module:@webgears-app/math.Vector3} im Source vector.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        imCopy(im) {
            this.imX = im.x;
            this.imY = im.y;
            this.imZ = im.z;
            return this;
        }

        /**
         * @var module:@webgears-app/math.Quaternion#sqAbs
         * @summary Squared absolute value (magnitude) of quaternion.
         * @type {number}
         */
        get sqAbs() {
            const { re, imX, imY, imZ } = this;
            return re * re + imX * imX + imY * imY + imZ * imZ;
        }
        set sqAbs(newSqAbs) {
            this.multiplyNumber(sqrt(newSqAbs / this.sqAbs));
        }

        /**
         * @var module:@webgears-app/math.Quaternion#abs
         * @summary Absolute value (magnitude aka norm) of quaternion.
         * @type {number}
         */
        get abs() {
            return sqrt(this.sqAbs);
        }
        set abs(newAbs) {
            this.multiplyNumber(newAbs / this.abs);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#normalize
         * @desc In place.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        normalize() {
            return this.divideNumber(this.abs);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromUniformScaling
         * @summary Initialize `this` with uniform scaling transformation.
         * @param {number} factor Uniform scaling factor.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromUniformScaling(scaling) {
            return this.fromNumber(sqrt(scaling));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#scaleUniform
         * @summary Apply uniform scaling transformation to `this`.
         * @param {number} factor Uniform scaling factor.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        scaleUniform(scaling) {
            return this.multiplyNumber(sqrt(scaling));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromRotation
         * @summary Initialize `this` with rotation transformation.
         * @param {number} angle Rotation angle (in radians).
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromRotation(angle, axis) {
            const halfAngle = angle * 0.5;
            const minusSin = -sin(halfAngle);
            this.re = cos(halfAngle);
            this.imX = minusSin * axis.x;
            this.imY = minusSin * axis.y;
            this.imZ = minusSin * axis.z;
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#rotate
         * @summary (Post-)apply rotation transformation to `this`.
         * @param {number} angle Rotation angle (in radians).
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        rotate(angle, axis) {
            return this.multiply(tmp.fromRotation(angle, axis));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#preRotate
         * @summary Pre-apply rotation transformation to `this`.
         * @param {number} angle Rotation angle (in radians).
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preRotate(angle, axis) {
            return this.preMultiply(tmp.fromRotation(angle, axis));
        }

        /**
         * @var module:@webgears-app/math.Quaternion#rotationAngle
         * @summary Rotation angle (in radians).
         * @type {number}
         */
        get rotationAngle() {
            return 2 * acos(this.re / this.abs);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#rotationAxisPaste
         * @summary Paste rotation axis into a vector.
         * @param {module:@webgears-app/math.Vector3} axis Destination vector.
         * @returns {module:@webgears-app/math.Vector3} `axis`
         */
        rotationAxisPaste(axis) {
            return this.imPaste(axis).negate().normalize();
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromRotationBetween
         * @summary Initialize `this` with rotation transformation required to
         * align `from` with `to`.
         * @param {module:@webgears-app/math.Vector3} from Initial direction.
         * Must have unit length.
         * @param {module:@webgears-app/math.Vector3} to Final direction.
         * Must have unit length.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromRotationBetween(from, to) {
            this.re = from.dot(to) + 1;
            this.imCopy(im.copy(to).cross(from));
            this.normalize();
            if (!this.everyIsFinite) {
                this.re = 0;
                this.imCopy(im.copy(from).orthogonalize());
            }
            return this;
        }

        /**
         * @function module:@webgears-app/math.Quaternion#rotateBetween
         * @summary (Post-)apply rotation transformation required to align `from` with `to`.
         * @param {module:@webgears-app/math.Vector3} from Initial direction.
         * Must have unit length.
         * @param {module:@webgears-app/math.Vector3} to Final direction.
         * Must have unit length.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        rotateBetween(from, to) {
            return this.multiply(tmp.fromRotationBetween(from, to));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#preRotateBetween
         * @summary Pre-apply rotation transformation required to align `from` with `to`.
         * @param {module:@webgears-app/math.Vector3} from Initial direction.
         * Must have unit length.
         * @param {module:@webgears-app/math.Vector3} to Final direction.
         * Must have unit length.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preRotateBetween(from, to) {
            return this.preMultiply(tmp.fromRotationBetween(from, to));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#fromComplex
         * @summary Initialize `this` with transformation encoded in
         * {module:@webgears-app/math.Complex} about given axis.
         * @param {module:@webgears-app/math.Complex} complex Rotation and/or uniform scaling.
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        fromComplex(complex, axis) {
            return this.fromRotation(complex.rotationAngle, axis)
                       .scaleUniform(complex.uniformScaling);
        }

        /**
         * @function module:@webgears-app/math.Quaternion#applyComplex
         * @summary (Post-)apply transformation encoded in
         * {module:@webgears-app/math.Complex} about given axis.
         * @param {module:@webgears-app/math.Complex} complex Rotation and/or uniform scaling.
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        applyComplex(complex, axis) {
            return this.multiply(tmp.fromComplex(complex, axis));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#applyComplex
         * @summary Pre-apply transformation encoded in
         * {module:@webgears-app/math.Complex} about given axis.
         * @param {module:@webgears-app/math.Complex} complex Rotation and/or uniform scaling.
         * @param {module:@webgears-app/math.Vector3} axis Rotation axis.
         * @returns {module:@webgears-app/math.Quaternion} `this`
         */
        preApplyComplex(complex, axis) {
            return this.preMultiply(tmp.fromComplex(complex, axis));
        }

        /**
         * @function module:@webgears-app/math.Quaternion#complexPaste
         * @summary Paste transformation within the plane othrogonal to rotation axis.
         * @param {module:@webgears-app/math.Complex} axis Destination complex.
         * @returns {module:@webgears-app/math.Complex} `complex`
         */
        complexPaste(complex) {
            const { re, imX, imY, imZ } = this;
            const sqIm = imX * imX + imY * imY + imZ * imZ;
            complex.re = re * re - sqIm; 
            complex.im = 2 * re * sqrt(sqIm); 
            return complex
        }
    }

    const tmp = new Quaternion();

    const aliasProperty = makePropertyAliaser(Quaternion.prototype);

    /**
     * @function module:@webgears-app/math.Quaternion#copy
     * @summary Set quaternion from another quaternion.
     * @desc Alias for {@link module:@webgears-app/math.Quaternion#fromQuaternion}.
     * @param {module:@webgears-app/math.Quaternion} quaternion Source quaternion.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('fromQuaternion', 'copy');

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const Name = toTitleCase(fn.name);
        Object.defineProperties(Quaternion.prototype, {
            [`some${Name}`]: {
                configurable: true,
                get() {
                    return fn(this.re) ||
                           fn(this.imX) ||
                           fn(this.imY) ||
                           fn(this.imZ);
                },
            },
            [`every${Name}`]: {
                configurable: true,
                get() {
                    return fn(this.re) &&
                           fn(this.imX) &&
                           fn(this.imY) &&
                           fn(this.imZ);
                },
            },
        });
    }
    /**
     * @var module:@webgears-app/math.Quaternion#someIsNaN
     * @summary Whether some component {@link module:@webgears-app/math.isNaN}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Quaternion#everyIsNaN
     * @summary Whether every component {@link module:@webgears-app/math.isNaN}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Quaternion#someIsFinite
     * @summary Whether some component {@link module:@webgears-app/math.isFinite}.
     * @type {boolean}
     * @readonly
     */
    /**
     * @var module:@webgears-app/math.Quaternion#everyIsFinite
     * @summary Whether every component {@link module:@webgears-app/math.isFinite}.
     * @type {boolean}
     * @readonly
     */

    /**
     * @function module:@webgears-app/math.Quaternion#add
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#addQuaternion}
     * @param {module:@webgears-app/math.Quaternion} that Other operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('addQuaternion', 'add');

    /**
     * @function module:@webgears-app/math.Quaternion#subtract
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#subtractQuaternion}
     * @param {module:@webgears-app/math.Quaternion} right Right operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('subtractQuaternion', 'subtract');

    /**
     * @function module:@webgears-app/math.Quaternion#preSubtract
     * @desc Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#preSubtractQuaternion}
     * @param {module:@webgears-app/math.Quaternion} left Left operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('preSubtractQuaternion', 'preSubtract');

    /**
     * @function module:@webgears-app/math.Quaternion#multiply
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#multiplyQuaternion}
     * @param {module:@webgears-app/math.Quaternion} right Right operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('multiplyQuaternion', 'multiply');

    /**
     * @function module:@webgears-app/math.Quaternion#applyQuaternion
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#multiplyQuaternion}
     * @param {module:@webgears-app/math.Quaternion} right Right operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('multiplyQuaternion', 'applyQuaternion');

    /**
     * @function module:@webgears-app/math.Quaternion#apply
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#multiply}
     * @param {module:@webgears-app/math.Quaternion} right Right operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('multiply', 'apply');

    /**
     * @function module:@webgears-app/math.Quaternion#preMultiply
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#preMultiplyQuaternion}
     * @param {module:@webgears-app/math.Quaternion} left Left operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('preMultiplyQuaternion', 'preMultiply');

    /**
     * @function module:@webgears-app/math.Quaternion#preApplyQuaternion
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#preMultiplyQuaternion}
     * @param {module:@webgears-app/math.Quaternion} left Left operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('preMultiplyQuaternion', 'preApplyQuaternion');

    /**
     * @function module:@webgears-app/math.Quaternion#preApply
     * @desc Composes transformations left to right. Result is placed into `this`.
     *
     * Alias for {@link module:@webgears-app/math.Quaternion#preMultiply}
     * @param {module:@webgears-app/math.Quaternion} left Left operand.
     * @returns {module:@webgears-app/math.Quaternion} `this`
     */
    aliasProperty('preMultiply', 'preApply');

    /**
     * @var module:@webgears-app/math.Quaternion#uniformScaling
     * @summary Uniform scaling factor.
     * @desc Alias for {@link module:@webgears-app/math.Quaternion#sqAbs}
     * @type {number}
     */
    aliasProperty('sqAbs', 'uniformScaling');

    return Quaternion;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/matrices.js







const matrices_aas = [...'xyzw'];
const ais = [0, 1, 2, 3];

const KINDS = {
    LINEAR: {
        name: 'Linear',
        rd: 0, cd: 0,
    },
    AFFINE: {
        name: 'Affine',
        rd: 1, cd: 0,
    },
    HOMOGENEOUS: {
        name: 'Homogeneous',
        rd: 1, cd: 1,
    },
};

function matrices_makeClass(kind, d) {
    const r = d + kind.rd;
    const c = d + kind.cd;

    const is = ais.slice(0, r);
    const js = ais.slice(0, c);
    const as = matrices_aas.slice(0, d);

    const Matrix = generateFunction(fg => {
        fg.name = `${kind.name}Matrix${d}`;
        for (const i of is) for (const j of js) {
            fg.params.push(`_${i}${j}`);
        }
        for (const j of js) for (const i of is) {
            fg.emit`this._${i}${j}=${
                `_${i}${j}===undefined?${+(i === j)}:_${i}${j}`
            }`;
        }

        if (false) {}
    });

    for (const [name, value] of Object.entries({
        kind: kind.name.toLowerCase(),
        rowCount: r,
        columnCount: c,
    })) {
        Object.defineProperty(Matrix.prototype, name, {
            configurable: true,
            value,
        });

        if (false) {}
    }

    if (false) {}

    const defineMethod = makeMethodDefiner(Matrix.prototype);
    const defineGetter = makeGetterDefiner(Matrix.prototype);
    const defineSetter = makeSetterDefiner(Matrix.prototype);
    const aliasProperty = makePropertyAliaser(Matrix.prototype);

    for (const srcKind of Object.values(KINDS)) {
        const srcR = d + srcKind.rd;
        const srcC = d + srcKind.cd;

        if (srcR > r || srcC > c) { continue; }

        const srcIs = ais.slice(0, srcR);
        const srcJs = ais.slice(0, srcC);

        defineMethod(fg => {
            fg.name = `set${srcKind.name}`;
            for (const i of srcIs) for (const j of srcJs) {
                fg.params.push(`_${i}${j}`);
            }
            for (const j of js) for (const i of is) {
                fg.emit`this._${i}${j}=${(() => {
                    if (i < srcR && j < srcC) { return `_${i}${j}`; }
                    return +(i === j);
                })()}`;
            }
            fg.emit`return this`;

            if (false) {}
        });
    }
    aliasProperty(`set${kind.name}`, 'set');

    defineMethod(fg => {
        fg.name = 'fromNumber';
        fg.params = ['number'];
        for (const j of js) for (const i of is) {
            fg.emit`this._${i}${j}=${(() => {
                if (i === j && i < d) { return 'number'; }
                return +(i === j);
            })()}`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    for (const srcKind of Object.values(KINDS)) {
        const srcR = d + srcKind.rd;
        const srcC = d + srcKind.cd;

        if (srcR > r || srcC > c) { continue; }

        defineMethod(fg => {
            fg.name = `from${srcKind.name}Matrix${d}`;
            fg.params = ['matrix'];
            for (const j of js) for (const i of is) {
                fg.emit`this._${i}${j}=${(() => {
                    if (i < srcR && j < srcC) { return `matrix._${i}${j}`; }
                    return +(i === j);
                })()}`;
            }
            fg.emit`return this`;

            if (false) {}
        });
        aliasProperty(`from${srcKind.name}Matrix${d}`,
                      `from${srcKind.name}Matrix`);
        aliasProperty(`from${srcKind.name}Matrix${d}`, `from${srcKind.name}${d}`);
        aliasProperty(`from${srcKind.name}Matrix`, `from${srcKind.name}`);

        if (d > 2) {
            defineMethod(fg => {
                fg.name = `from${srcKind.name}Matrix2`;
                fg.params = ['matrix'];
                for (const j of js) for (const i of is) {
                    fg.emit`this._${i}${j}=${(() => {
                        if (i < d - 1 && j < d - 1) {
                            return `matrix._${i}${j}`;
                        }
                        if (i === d && srcKind.rd && j < d - 1 ||
                            j === d && srcKind.cd && i < d - 1 ||
                            i === d && srcKind.rd && j === d && srcKind.cd)
                        { return `matrix._${i - (i >= d)}${j - (j >= d)}`; }
                        return +(i === j);
                    })()}`;
                }
                fg.emit`return this`;

                if (false) {}
            });
            aliasProperty(`from${srcKind.name}Matrix2`,
                          `from${srcKind.name}2`);
        }
    }
    aliasProperty(`from${kind.name}`, 'copy');

    for (const arrayKind of Object.values(KINDS)) {
        const arrayR = d + arrayKind.rd;
        const arrayC = d + arrayKind.cd;

        const arrayIs = ais.slice(0, arrayR);
        const arrayJs = ais.slice(0, arrayC);

        for (const [Layout, getOffset] of [
            ['Row'   , (i, j) => i * arrayC + j],
            ['Column', (i, j) => j * arrayR + i],
        ]) {
            if (arrayR <= r && arrayC <= c) {
                defineMethod(fg => {
                    fg.name = `from${arrayKind.name}${Layout}ArrayAt`;
                    fg.params = ['offset', 'array'];
                    for (const j of js) for (const i of is) {
                        fg.emit`this._${i}${j}=${(() => {
                            if (i < arrayR && j < arrayC) {
                                return `array[offset+${getOffset(i, j)}]`;
                            }
                            return +(i === j);
                        })()}`;
                    }
                    fg.emit`return this`;

                    if (false) {}
                });
                defineMethod(fg => {
                    fg.name = `from${arrayKind.name}${Layout}Array`;
                    fg.params = ['array'];
                    fg.emit`return this.from${arrayKind.name}${Layout}ArrayAt(${
                        `0,array`
                    })`;

                    if (false) {}
                });
                if (arrayKind === kind) {
                    aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`,
                                  `from${Layout}ArrayAt`);
                    aliasProperty(`from${arrayKind.name}${Layout}Array`,
                                  `from${Layout}Array`);
                }
                if (Layout === 'Row') {
                    aliasProperty(`from${arrayKind.name}${Layout}ArrayAt`,
                                  `from${arrayKind.name}ArrayAt`);
                    aliasProperty(`from${arrayKind.name}${Layout}Array`,
                                  `from${arrayKind.name}Array`);
                    if (arrayKind === kind) {
                        aliasProperty(`from${Layout}ArrayAt`, 'fromArrayAt');
                        aliasProperty(`from${Layout}Array`, 'fromArray');
                    }
                }
            }
            if (arrayR >= r && arrayC >= c) {
                defineMethod(fg => {
                    fg.name = `to${arrayKind.name}${Layout}ArrayAt`;
                    fg.params = ['offset', 'array'];
                    for (const j of arrayJs) for (const i of arrayIs) {
                        fg.emit`array[offset+${getOffset(i, j)}]=${(() => {
                            if (i < r && j < c) {
                                return `this._${i}${j}`;
                            }
                            return +(i === j);
                        })()}`;
                    }
                    fg.emit`return array`;

                    if (false) {}
                });
                defineMethod(fg => {
                    fg.name = `to${arrayKind.name}${Layout}Array`;
                    fg.params = ['array'];
                    fg.emit`return this.to${arrayKind.name}${Layout}ArrayAt(${
                        `0,array`
                    })`;

                    if (false) {}
                });
                if (arrayKind === kind) {
                    aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`,
                                  `to${Layout}ArrayAt`);
                    aliasProperty(`to${arrayKind.name}${Layout}Array`,
                                  `to${Layout}Array`);
                }
                if (Layout === 'Row') {
                    aliasProperty(`to${arrayKind.name}${Layout}ArrayAt`,
                                  `to${arrayKind.name}ArrayAt`);
                    aliasProperty(`to${arrayKind.name}${Layout}Array`,
                                  `to${arrayKind.name}Array`);
                    if (arrayKind === kind) {
                        aliasProperty(`to${Layout}ArrayAt`, 'toArrayAt');
                        aliasProperty(`to${Layout}Array`, 'toArray');
                    }
                }
            }
        }
    }

    defineMethod(fg => {
        fg.ctx[Matrix.name] = Matrix;
        fg.name = 'clone';
        fg.emit`return new ${Matrix.name}().copy(this)`;

        if (false) {}
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        defineGetter(fg => {
            fg.ctx[name] = fn;
            fg.name = `some${Name}`;
            fg.emit`return ${js.map(j => {
                return is.map(i => `${name}(this._${i}${j})`).join('||')
            }).join('||')}`;

            if (false) {}
        });
        defineGetter(fg => {
            fg.ctx[name] = fn;
            fg.name = `every${Name}`;
            fg.emit`return ${js.map(j => {
                return is.map(i => `${name}(this._${i}${j})`).join('&&')
            }).join('&&')}`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return ${js.map(j => {
            return is.map(i => `this._${i}${j}===that._${i}${j}`).join('&&')
        }).join('&&')}`;

        if (false) {}
    });

    if (c === r) {
        defineMethod(fg => {
            fg.name = 'transpose';
            for (const j of js) for (const i of is) {
                if (i <= j) { continue; }
                fg.emit`${['var '].slice(i !== 1)}t=this._${i}${j}`;
                fg.emit`this._${i}${j}=this._${j}${i}`;
                fg.emit`this._${j}${i}=t`;
            }
            fg.emit`return this`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = 'invert';

        for (const j of js) for (const i of is) {
            fg.emit`var _${i}${j}=this._${i}${j}`;
        }

        if (r === 3 && c === 2) {
            fg.emit`var c02=_10*_21-_20*_11,`;
            fg.emit    `c12=_00*_21-_20*_01`;
        } else if (r === 3 && c === 3) {
            fg.emit`var c00=_11*_22-_21*_12,`;
            fg.emit    `c01=_10*_22-_20*_12,`;
            fg.emit    `c02=_10*_21-_20*_11,`;
            fg.emit    `c10=_01*_22-_21*_02,`;
            fg.emit    `c11=_00*_22-_20*_02,`;
            fg.emit    `c12=_00*_21-_20*_01,`;
            fg.emit    `c20=_01*_12-_11*_02,`;
            fg.emit    `c21=_00*_12-_10*_02,`;
            fg.emit    `c22=_00*_11-_10*_01`;
        } else if (r === 4 && c === 3) {
            fg.emit`var c0103=_21*_32-_31*_22,`;
            fg.emit    `c0203=_11*_32-_31*_12,`;
            fg.emit    `c0303=_11*_22-_21*_12,`;
            fg.emit    `c1203=_01*_32-_31*_02,`;
            fg.emit    `c1303=_01*_22-_21*_02,`;
            fg.emit    `c2303=_01*_12-_11*_02,`;
            fg.emit    `c00=_11*_22-_21*_12,`;
            fg.emit    `c01=_10*_22-_20*_12,`;
            fg.emit    `c02=_10*_21-_20*_11,`;
            fg.emit    `c03=_10*c0103-_20*c0203+_30*c0303,`;
            fg.emit    `c10=_01*_22-_21*_02,`;
            fg.emit    `c11=_00*_22-_20*_02,`;
            fg.emit    `c12=_00*_21-_20*_01,`;
            fg.emit    `c13=_00*c0103-_20*c1203+_30*c1303,`;
            fg.emit    `c20=_01*_12-_11*_02,`;
            fg.emit    `c21=_00*_12-_10*_02,`;
            fg.emit    `c22=_00*_11-_10*_01,`;
            fg.emit    `c23=_00*c0203-_10*c1203+_30*c2303`;
        } else if (r === 4 && c === 4) {
            fg.emit`var c0101=_22*_33-_32*_23,`;
            fg.emit    `c0201=_12*_33-_32*_13,`;
            fg.emit    `c0301=_12*_23-_22*_13,`;
            fg.emit    `c0102=_21*_33-_31*_23,`;
            fg.emit    `c0202=_11*_33-_31*_13,`;
            fg.emit    `c0302=_11*_23-_21*_13,`;
            fg.emit    `c0103=_21*_32-_31*_22,`;
            fg.emit    `c0203=_11*_32-_31*_12,`;
            fg.emit    `c0303=_11*_22-_21*_12,`;
            fg.emit    `c1201=_02*_33-_32*_03,`;
            fg.emit    `c1301=_02*_23-_22*_03,`;
            fg.emit    `c1202=_01*_33-_31*_03,`;
            fg.emit    `c1302=_01*_23-_21*_03,`;
            fg.emit    `c1203=_01*_32-_31*_02,`;
            fg.emit    `c1303=_01*_22-_21*_02,`;
            fg.emit    `c2301=_02*_13-_12*_03,`;
            fg.emit    `c2302=_01*_13-_11*_03,`;
            fg.emit    `c2303=_01*_12-_11*_02,`;
            fg.emit    `c00=_11*c0101-_21*c0201+_31*c0301,`;
            fg.emit    `c01=_10*c0101-_20*c0201+_30*c0301,`;
            fg.emit    `c02=_10*c0102-_20*c0202+_30*c0302,`;
            fg.emit    `c03=_10*c0103-_20*c0203+_30*c0303,`;
            fg.emit    `c10=_01*c0101-_21*c1201+_31*c1301,`;
            fg.emit    `c11=_00*c0101-_20*c1201+_30*c1301,`;
            fg.emit    `c12=_00*c0102-_20*c1202+_30*c1302,`;
            fg.emit    `c13=_00*c0103-_20*c1203+_30*c1303,`;
            fg.emit    `c20=_01*c0201-_11*c1201+_31*c2301,`;
            fg.emit    `c21=_00*c0201-_10*c1201+_30*c2301,`;
            fg.emit    `c22=_00*c0202-_10*c1202+_30*c2302,`;
            fg.emit    `c23=_00*c0203-_10*c1203+_30*c2303,`;
            fg.emit    `c30=_01*c0301-_11*c1301+_21*c2301,`;
            fg.emit    `c31=_00*c0301-_10*c1301+_20*c2301,`;
            fg.emit    `c32=_00*c0302-_10*c1302+_20*c2302,`;
            fg.emit    `c33=_00*c0303-_10*c1303+_20*c2303`;
        }

        fg.emit`var invDet=1/(${(() => {
            if (c === 2) { return '_00*_11-_10*_01'; }
            return js.map(i => {
                return `${'+-'[i % 2].slice(i === 0)}_${i}0*c${i}0`;
            }).join('');
        })()}),invNegDet=-invDet`;

        if (r === 2 && c === 2) {
            fg.emit`this._00=_11*invDet`;
            fg.emit`this._10=_10*invNegDet`;
            fg.emit`this._01=_01*invNegDet`;
            fg.emit`this._11=_00*invDet`;
        } else if (r === 3 && c === 2) {
            fg.emit`this._00=_11*invDet`;
            fg.emit`this._10=_10*invNegDet`;
            fg.emit`this._20=c02*invDet`;
            fg.emit`this._01=_01*invNegDet`;
            fg.emit`this._11=_00*invDet`;
            fg.emit`this._21=c12*invNegDet`;
        } else {
            for (const j of js) for (const i of is) {
                fg.emit`this._${i}${j}=${(() => {
                    if (i < r && j < c) {
                        return `c${j}${i}*inv${((i + j) % 2) ? 'Neg' : ''}Det`;
                    }
                    return +(i === j);
                })()}`;
            }
        }

        fg.emit`return this`;

        if (false) {}
    });

    for (const rightKind of Object.values(KINDS)) {
        const rightR = d + rightKind.rd;
        const rightC = d + rightKind.cd;

        if (rightR > r || rightC > c) { continue; }

        defineMethod(fg => {
            fg.name = `multiply${rightKind.name}`;
            fg.params = ['right'];

            for (const j of ais.slice(0, functions_min(c, rightR))) {
                for (const i of is) {
                    fg.emit`var _${i}${j}=this._${i}${j}`;
                }
            }
            for (const j of ais.slice(0, rightC)) {
                for (const i of ais.slice(0, rightR)) {
                    fg.emit`var r${i}${j}=right._${i}${j}`;
                }
            }

            for (const j of ais.slice(0, rightC)) for (const i of is) {
                fg.emit`this._${i}${j}=${[...(function*() {
                    for (let k = 0; k < functions_max(c, rightR); ++k) {
                        const a = (i < r && k < c) ? `_${i}${k}` : +(i === k);
                        const b = (k < rightR && j < rightC) ? `r${k}${j}`
                                                             : +(k === j);
                        if (a === 0 || b === 0) {
                            // nop
                        } else if (a === 1) {
                            yield b;
                        } else if (b === 1) {
                            yield a;
                        } else {
                            yield `${a}*${b}`;
                        }
                    }
                })()].join('+')}`;
            }

            fg.emit`return this`;

            if (false) {}
        });
        aliasProperty(`multiply${rightKind.name}`, `apply${rightKind.name}`);
    }
    aliasProperty(`multiply${kind.name}`, 'multiply');
    aliasProperty(`multiply${kind.name}`, 'apply');

    for (const leftKind of Object.values(KINDS)) {
        const leftR = d + leftKind.rd;
        const leftC = d + leftKind.cd;

        if (leftR > r || leftC > c) { continue; }

        defineMethod(fg => {
            fg.name = `preMultiply${leftKind.name}`;
            fg.params = ['left'];

            for (const j of ais.slice(0, functions_min(leftC, r))) {
                for (const i of ais.slice(0, leftR)) {
                    fg.emit`var l${i}${j}=left._${i}${j}`;
                }
            }
            for (const j of js) {
                for (const i of is) {
                    fg.emit`var _${i}${j}=this._${i}${j}`;
                }
            }

            for (const j of js) for (const i of ais.slice(0, leftR)) {
                fg.emit`this._${i}${j}=${[...(function*() {
                    for (let k = 0; k < functions_max(leftC, r); ++k) {
                        const a = (i < leftR && k < leftC) ? `l${i}${k}`
                                                           : +(i === k);
                        const b = (k < r && j < c) ? `_${k}${j}` : +(k === j);
                        if (a === 0 || b === 0) {
                            // nop
                        } else if (a === 1) {
                            yield b;
                        } else if (b === 1) {
                            yield a;
                        } else {
                            yield `${a}*${b}`;
                        }
                    }
                })()].join('+')}`;
            }

            fg.emit`return this`;

            if (false) {}
        });
        aliasProperty(`preMultiply${leftKind.name}`,
                      `preApply${leftKind.name}`);
    }
    aliasProperty(`preMultiply${kind.name}`, 'preMultiply');
    aliasProperty('preMultiply', 'preApply');

    defineMethod(fg => {
        fg.name = 'multiplyNumber';
        fg.params = ['right'];
        for (const j of js.slice(0, d)) for (const i of is) {
            fg.emit`this._${i}${j}*=right`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = 'preMultiplyNumber';
        fg.params = ['left'];
        for (const j of js) for (const i of is.slice(0, d)) {
            fg.emit`this._${i}${j}*=left`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    defineGetter(fg => {
        fg.name = `determinant`;

        if (c > 2) {
            for (const j of js.slice(1)) for (const i of js) {
                fg.emit`var _${i}${j}=this._${i}${j}`;
            }
        }

        if (c === 3) {
            fg.emit`var c00=_11*_22-_21*_12,`;
            fg.emit    `c10=_01*_22-_21*_02,`;
            fg.emit    `c20=_01*_12-_11*_02`;
        } else if (c === 4) {
            fg.emit`var c0101=_22*_33-_32*_23,`;
            fg.emit    `c0201=_12*_33-_32*_13,`;
            fg.emit    `c0301=_12*_23-_22*_13,`;
            fg.emit    `c1201=_02*_33-_32*_03,`;
            fg.emit    `c1301=_02*_23-_22*_03,`;
            fg.emit    `c2301=_02*_13-_12*_03,`;
            fg.emit    `c00=_11*c0101-_21*c0201+_31*c0301,`;
            fg.emit    `c10=_01*c0101-_21*c1201+_31*c1301,`;
            fg.emit    `c20=_01*c0201-_11*c1201+_31*c2301,`;
            fg.emit    `c30=_01*c0301-_11*c1301+_21*c2301`;
        }

        fg.emit`return ${(() => {
            if (c === 2) { return 'this._00*this._11-this._10*this._01'; }
            return js.map(i => {
                return `${'+-'[i % 2].slice(i === 0)}this._${i}0*c${i}0`;
            }).join('');
        })()}`;

        if (false) {}
    });

    for (const [i, param] of [...as.map((a, i) => {
        return [i, `axis${a.toUpperCase()}`];
    }), [d, 'translation']]) {
        defineMethod(fg => {
            fg.name = `${param}Paste`;
            fg.params = [param];
            for (const [j, a] of as.entries()) {
                fg.emit`${param}.${a}=${(() => {
                    if (i < d || kind !== KINDS.LINEAR) {
                        return `this._${i}${j}`;
                    }
                    return +(i === j);
                })()}`;
            }
            fg.emit`return ${param}`;

            if (false) {}
        });
        if (i < d || kind !== KINDS.LINEAR) {
            defineMethod(fg => {
                fg.name = `${param}Copy`;
                fg.params = [param];
                for (const [j, a] of as.entries()) {
                    fg.emit`this._${i}${j}=${param}.${a}`;
                }
                fg.emit`return this`;

                if (false) {}
            });
        }
    }

    if (kind !== KINDS.LINEAR) {
        defineMethod(fg => {
            fg.name = 'fromTranslation';
            fg.params = ['translation'];
            for (const j of js) for (const i of is) {
                fg.emit`this._${i}${j}=${(() => {
                    if (i === d && j < d) { return `translation.${as[j]}`; }
                    return +(i === j);
                })()}`;
            }
            fg.emit`return this`;

            if (false) {}
        });
        defineMethod(fg => {
            fg.name = 'translate';
            fg.params = ['translation'];
            if (kind === KINDS.AFFINE) {
                for (const [j, a] of as.entries()) {
                    fg.emit`this._${d}${j}+=translation.${a}`;
                }
            } else {
                for (const i of is) {
                    fg.emit`var _${i}${d}=this._${i}${d}`;
                }
                for (const a of as) {
                    fg.emit`var ${a}=translation.${a}`;
                }
                for (const [j, a] of as.entries()) {
                    for (const i of is) {
                        fg.emit`this._${i}${j}+=_${i}${d}*${a}`;
                    }
                }
            }
            fg.emit`return this`;

            if (false) {}
        });
        defineMethod(fg => {
            fg.name = 'preTranslate';
            fg.params = ['translation'];
            for (const a of as) {
                fg.emit`var ${a}=translation.${a}`;
            }
            for (const j of js) {
                fg.emit`this._${d}${j}+=${as.map((a, i) => {
                    return `${a}*this._${i}${j}`;
                }).join('+')}`;
            }
            fg.emit`return this`;

            if (false) {}
        });
    }

    defineMethod(fg => {
        fg.name = 'fromScaling';
        fg.params = ['scaling'];
        for (const j of js) for (const i of is) {
            fg.emit`this._${i}${j}=${(() => {
                if (i === j && i < d) { return `scaling.${as[i]}`; }
                return +(i === j);
            })()}`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = 'scale';
        fg.params = ['scaling'];
        for (const a of as) {
            fg.emit`var ${a}=scaling.${a}`;
        }
        for (const [j, a] of as.entries()) for (const i of is) {
            fg.emit`this._${i}${j}*=${a}`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = 'preScale';
        fg.params = ['scaling'];
        for (const a of as) {
            fg.emit`var ${a}=scaling.${a}`;
        }
        for (const j of js) for (const [i, a] of matrices_aas.slice(0, d).entries()) {
            fg.emit`this._${i}${j}*=${a}`;
        }
        fg.emit`return this`;

        if (false) {}
    });

    aliasProperty('fromNumber', 'fromUniformScaling');
    aliasProperty('multiplyNumber', 'scaleUniform');
    aliasProperty('preMultiplyNumber', 'preScaleUniform');

    defineMethod(fg => {
        fg.name = 'fromShearing';
        fg.params = ['shearing'];
        for (const j of js) for (const i of is) {
            fg.emit`this._${i}${j}=${(() => {
                if (d === 2) {
                    if (i === 1 && j === 0) { return 'shearing'; }
                } else {
                    if (i === 1 && j === 0) { return 'shearing.z'; }
                    if (i === 2 && j === 0) { return 'shearing.y'; }
                    if (i === 2 && j === 1) { return 'shearing.x'; }
                }
                return +(i === j);
            })()}`;
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = 'shear';
        fg.params = ['shearing'];
        if (d === 2) {
            for (const i of is) {
                fg.emit`this._${i}0+=this._${i}1*shearing`;
            }
        } else {
            for (const i of is) {
                fg.emit`var _${i}1=this._${i}1`;
            }
            for (const i of is) {
                fg.emit`var _${i}2=this._${i}2`;
            }
            for (const a of as) {
                fg.emit`var ${a}=shearing.${a}`;
            }
            for (const i of is) {
                fg.emit`this._${i}0+=_${i}1*z+_${i}2*y`;
            }
            for (const i of is) {
                fg.emit`this._${i}1=_${i}1+_${i}2*x`;
            }
        }
        fg.emit`return this`;

        if (false) {}
    });
    defineMethod(fg => {
        fg.name = 'preShear';
        fg.params = ['shearing'];
        if (d === 2) {
            for (const j of js) {
                fg.emit`this._1${j}+=shearing*this._0${j}`;
            }
        } else {
            for (const a of as) {
                fg.emit`var ${a}=shearing.${a}`;
            }
            for (const j of js) {
                fg.emit`var _0${j}=this._0${j}`;
                fg.emit`var _1${j}=this._1${j}`;
            }
            for (const j of js) {
                fg.emit`this._1${j}=z*_0${j}+_1${j}`;
                fg.emit`this._2${j}+=y*_0${j}+x*_1${j}`;
            }
        }
        fg.emit`return this`;

        if (false) {}
    });

    if (false) {}
    if (d === 2) {
        const tmp = new ((kind === KINDS.LINEAR) ? Matrix : LinearMatrix2)();
        defineMethod(fg => {
            Object.assign(fg.ctx, { SQRT2: sqrt(2) });
            fg.name = 'fromReflection';
            fg.params = ['normal'];

            fg.emit`var x=normal.x*SQRT2,`;
            fg.emit    `y=normal.y*SQRT2`;

            fg.emit`this._00=1-x*x`;
            fg.emit`this._10=-y*x`;
            if (kind.rd) { fg.emit`this._20=0`; }

            fg.emit`this._01=this._10`;
            fg.emit`this._11=1-y*y`;
            if (kind.rd) { fg.emit`this._21=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}2=${+(i === 2)}`;
                }
            }
            fg.emit`return this`;
        }); 
        defineMethod(fg => {
            Object.assign(fg.ctx, { tmp });
            fg.name = 'reflect';
            fg.params = ['normal'];
            fg.emit`return this.multiplyLinear(${
                `tmp.fromReflection(${fg.params})`
            })`;
        });
        defineMethod(fg => {
            Object.assign(fg.ctx, { tmp });
            fg.name = 'preReflect';
            fg.params = ['normal'];
            fg.emit`return this.preMultiplyLinear(${
                `tmp.fromReflection(${fg.params})`
            })`;
        });

        const defineTransform = (fromName, name, prepare) => {
            defineMethod(fg => {
                fg.name = fromName;
                prepare(fg);
                for (const j of js) for (const i of is) {
                    fg.emit`this._${i}${j}=${(() => {
                        if (i < d && j < d) {
                            if (i === j) { return 're'; }
                            return '-im'.slice(i < j);
                        }
                        return +(i === j);
                    })()}`;
                }
                fg.emit`return this`;
            });
            defineMethod(fg => {
                fg.name = name;
                for (const j of as.keys()) for (const i of is) {
                    fg.emit`var _${i}${j}=this._${i}${j}`;
                }
                prepare(fg);
                for (const i of is) {
                    fg.emit`this._${i}0=_${i}0*re-_${i}1*im`;
                }
                for (const i of is) {
                    fg.emit`this._${i}1=_${i}0*im+_${i}1*re`;
                }
                fg.emit`return this`;
            });
            defineMethod(fg => {
                fg.name = `pre${toTitleCase(name)}`;
                prepare(fg);
                for (const j of js) for (const i of as.keys()) {
                    fg.emit`var _${i}${j}=this._${i}${j}`;
                }
                for (const j of js) {
                    fg.emit`this._0${j}=re*_0${j}+im*_1${j}`;
                    fg.emit`this._1${j}=re*_1${j}-im*_0${j}`;
                }
                fg.emit`return this`;
            });
        }

        defineTransform('fromRotation', 'rotate', fg => {
            Object.assign(fg.ctx, { sin: sin, cos: cos });
            fg.params = ['angle'];
            fg.emit`var re=cos(angle),im=sin(angle)`;
        });

        defineTransform('fromRotationBetween', 'rotateBetween', fg => {
            fg.params = ['from', 'to'];
            fg.emit`var re=from.dot(to),im=from.cross(to)`;
        });

        defineTransform('fromComplex', 'applyComplex', fg => {
            fg.params = ['complex'];
            fg.emit`var re=complex.re,im=complex.im`;
        });
        if (false) {}
    } else {
        const tmp = new ((kind === KINDS.LINEAR) ? Matrix : LinearMatrix3)();
        const defineTransform = (prepare, name) => {
            let fromName, params;
            defineMethod(fg => {
                prepare(fg);
                fromName = fg.name;
                params = [...fg.params];
                fg.emit`return this`;
            }); 
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = name;
                fg.params = params;
                fg.emit`return this.multiplyLinear(${
                    `tmp.${fromName}(${params})`
                })`;
            });
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = `pre${toTitleCase(name)}`;
                fg.params = params;
                fg.emit`return this.preMultiplyLinear(${
                    `tmp.${fromName}(${params})`
                })`;
            });
        }

        defineTransform(fg => {
            Object.assign(fg.ctx, { SQRT2: sqrt(2) });
            fg.name = 'fromReflection';
            fg.params = ['normal'];

            fg.emit`var x=normal.x*SQRT2,`;
            fg.emit    `y=normal.y*SQRT2,`;
            fg.emit    `z=normal.z*SQRT2`;

            fg.emit`this._00=1-x*x`;
            fg.emit`this._10=-y*x`;
            fg.emit`this._20=-z*x`;
            if (kind.rd) { fg.emit`this._30=0`; }

            fg.emit`this._01=this._10`;
            fg.emit`this._11=1-y*y`;
            fg.emit`this._21=-z*y`;
            if (kind.rd) { fg.emit`this._31=0`; }

            fg.emit`this._02=this._20`;
            fg.emit`this._12=this._21`;
            fg.emit`this._22=1-z*z`;
            if (kind.rd) { fg.emit`this._32=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'reflect');

        defineTransform(fg => {
            Object.assign(fg.ctx, { sin: sin, cos: cos });
            fg.name = 'fromRotation';
            fg.params = ['angle', 'axis'];

            fg.emit`var s=sin(angle),c=cos(angle),t=1-c,`;
            fg.emit    `x=axis.x,y=axis.y,z=axis.z,`;
            fg.emit    `xs=x*s,ys=y*s,zs=z*s,`;
            fg.emit    `xt=x*t,yt=y*t,zt=z*t,`;
            fg.emit    `xyt=x*yt,xzt=z*xt,yzt=y*zt`;

            fg.emit`this._00=c+x*xt`;
            fg.emit`this._10=xyt-zs`;
            fg.emit`this._20=xzt+ys`;
            if (kind.rd) { fg.emit`this._30=0`; }

            fg.emit`this._01=xyt+zs`;
            fg.emit`this._11=c+y*yt`;
            fg.emit`this._21=yzt-xs`;
            if (kind.rd) { fg.emit`this._31=0`; }

            fg.emit`this._02=xzt-ys`;
            fg.emit`this._12=yzt+xs`;
            fg.emit`this._22=c+z*zt`;
            if (kind.rd) { fg.emit`this._32=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'rotate');

        defineTransform(fg => {
            Object.assign(fg.ctx, {
                axis: new Vector3(),
            });
            fg.name = 'fromRotationBetween';
            fg.params = ['from', 'to'];

            fg.emit`axis.copy(from).cross(to)`;
            fg.emit`var xs=axis.x,ys=axis.y,zs=axis.z`;
            fg.emit`axis.normalize()`;
            fg.emit`if(!axis.everyIsFinite){axis.copy(from).orthogonalize()}`;
            fg.emit`var x=axis.x,y=axis.y,z=axis.z,`;
            fg.emit    `c=from.dot(to),t=1-c,`;
            fg.emit    `xt=x*t,yt=y*t,zt=z*t,`;
            fg.emit    `xyt=x*yt,xzt=z*xt,yzt=y*zt`;

            fg.emit`this._00=c+x*xt`;
            fg.emit`this._10=xyt-zs`;
            fg.emit`this._20=xzt+ys`;
            if (kind.rd) { fg.emit`this._30=0`; }

            fg.emit`this._01=xyt+zs`;
            fg.emit`this._11=c+y*yt`;
            fg.emit`this._21=yzt-xs`;
            if (kind.rd) { fg.emit`this._31=0`; }

            fg.emit`this._02=xzt-ys`;
            fg.emit`this._12=yzt+xs`;
            fg.emit`this._22=c+z*zt`;
            if (kind.rd) { fg.emit`this._32=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'rotateBetween');

        defineTransform(fg => {
            Object.assign(fg.ctx, { sqrt: sqrt });
            fg.name = 'fromComplex';
            fg.params = ['complex', 'axis'];

            fg.emit`var re=complex.re,im=complex.im,`;
            fg.emit    `scaling=sqrt(re*re+im*im),t=scaling-re,`;
            fg.emit    `x=axis.x,y=axis.y,z=axis.z,`;
            fg.emit    `xIm=x*im,yIm=y*im,zIm=z*im,`;
            fg.emit    `xt=x*t,yt=y*t,zt=z*t,`;
            fg.emit    `xyt=x*yt,xzt=z*xt,yzt=y*zt`;

            fg.emit`this._00=re+x*xt`;
            fg.emit`this._10=xyt-zIm`;
            fg.emit`this._20=xzt+yIm`;
            if (kind.rd) { fg.emit`this._30=0`; }

            fg.emit`this._01=xyt+zIm`;
            fg.emit`this._11=re+y*yt`;
            fg.emit`this._21=yzt-xIm`;
            if (kind.rd) { fg.emit`this._31=0`; }

            fg.emit`this._02=xzt-yIm`;
            fg.emit`this._12=yzt+xIm`;
            fg.emit`this._22=re+z*zt`;
            if (kind.rd) { fg.emit`this._32=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'applyComplex');
        if (false) {}

        defineTransform(fg => {
            fg.name = 'fromQuaternion';
            fg.params = ['quaternion'];

            fg.emit`var re=quaternion.re,`;
            fg.emit    `imX=quaternion.imX,`;
            fg.emit    `imY=quaternion.imY,`;
            fg.emit    `imZ=quaternion.imZ,`;
            fg.emit    `scaling=re*re+imX*imX+imY*imY+imZ*imZ,`;
            fg.emit    `re2=re*2,imX2=imX*2,imY2=imY*2,imZ2=imZ*2,`;
            fg.emit    `imXImX2=imX*imX2,imYImY2=imY*imY2,imZImZ2=imZ*imZ2,`;
            fg.emit    `reImX2=re*imX2,reImY2=re*imY2,reImZ2=re*imZ2,`;
            fg.emit    `imXImY2=imX*imY2,imXImZ2=imX*imZ2,imYImZ2=imY*imZ2`;

            fg.emit`this._00=scaling-(imYImY2+imZImZ2),`;
            fg.emit`this._10=imXImY2+reImZ2,`;
            fg.emit`this._20=imXImZ2-reImY2,`;
            if (kind.rd) { fg.emit`this._30=0`; }

            fg.emit`this._01=imXImY2-reImZ2,`;
            fg.emit`this._11=scaling-(imXImX2+imZImZ2),`;
            fg.emit`this._21=imYImZ2+reImX2,`;
            if (kind.rd) { fg.emit`this._31=0`; }

            fg.emit`this._02=imXImZ2+reImY2,`;
            fg.emit`this._12=imYImZ2-reImX2,`;
            fg.emit`this._22=scaling-(imXImX2+imYImY2)`;
            if (kind.rd) { fg.emit`this._32=0`; }

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'applyQuaternion');
        if (false) {}

        defineTransform(fg => {
            Object.assign(fg.ctx, {
                x: new Vector3(),
                y: new Vector3(),
                z: new Vector3(),
            });
            fg.name = 'fromLookDirection'
            fg.params = ['direction', 'up'];

            fg.emit`z.copy(direction).normalize()`;
            fg.emit`if(!z.everyIsFinite){`;
                fg.emit`z.copy(up).orthogonalize().normalize()`;
            fg.emit`}else{`;
                fg.emit`z.negate()`;
            fg.emit`}`;

            fg.emit`x.copy(up).cross(z)`;
            fg.emit`if(!x.everyIsFinite){`;
                fg.emit`x.copy(z).orthogonalize()`;
            fg.emit`}`;
            fg.emit`x.normalize()`;

            fg.emit`y.copy(z).cross(x)`;

            for (const j of js) for (const i of is) {
                fg.emit`this._${i}${j}=${(() => {
                    if (i < 3 && j < 3) {
                        return `${as[i]}.${as[j]}`;
                    }
                    return +(i === j);
                })()}`;
            }
        }, 'lookIn');
        if (false) {}
    }

    if (kind !== KINDS.LINEAR && d === 3) {
        const tmp = new ((kind === KINDS.AFFINE) ? Matrix : AffineMatrix3)();
        const defineTransform = (prepare, name) => {
            let fromName, params;
            defineMethod(fg => {
                prepare(fg);
                fromName = fg.name;
                params = [...fg.params];
                fg.emit`return this`;
            }); 
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = name;
                fg.params = params;
                fg.emit`return this.multiplyAffine(${
                    `tmp.${fromName}(${params})`
                })`;
            });
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = `pre${toTitleCase(name)}`;
                fg.params = params;
                fg.emit`return this.preMultiplyAffine(${
                    `tmp.${fromName}(${params})`
                })`;
            });
        }

        defineTransform(fg => {
            Object.assign(fg.ctx, {
                direction: new Vector3(),
            });
            fg.name = 'fromLookTarget'
            fg.params = ['origin', 'target', 'up'];

            fg.emit`direction.copy(target).subtract(origin)`;
            fg.emit`this.fromLookDirection(direction,up).translate(origin)`;
        }, 'lookAt');
        if (false) {}

        defineTransform(fg => {
            fg.name = 'fromWebGLOrthographicAsymmetricProjection';
            fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];

            fg.emit`var invNegWidth=1/(left-right),`;
            fg.emit    `invNegHeight=1/(bottom-top),`;
            fg.emit    `invNegDepth=1/(near-far)`;
                
            fg.emit`this._00=-2*invNegWidth`;
            fg.emit`this._10=0`;
            fg.emit`this._20=0`;
            fg.emit`this._30=(left+right)*invNegWidth`;

            fg.emit`this._01=0`;
            fg.emit`this._11=-2*invNegHeight`;
            fg.emit`this._21=0`;
            fg.emit`this._31=(bottom+top)*invNegHeight`;

            fg.emit`this._02=0`;
            fg.emit`this._12=0`;
            fg.emit`this._22=2*invNegDepth,`;
            fg.emit`this._32=(near+far)*invNegDepth`;

            if (kind.cd) {
                for (const i of is) {
                    fg.emit`this._${i}3=${+(i === 3)}`;
                }
            }
        }, 'projectWebGLOrthographicAsymmetric');
        if (false) {}

        defineTransform(fg => {
            fg.name = 'fromWebGLOrthographicProjection';
            fg.params = ['width', 'height', 'near', 'far'];
            fg.emit`var top=height*.5,right=width*.5`;
            fg.emit`this.fromWebGLOrthographicAsymmetricProjection(${
                '-right,right,-top,top,near,far'
            })`;
        }, 'projectWebGLOrthographic');
        if (false) {}
    }
    if (kind === KINDS.HOMOGENEOUS && d === 3) {
        const tmp = new Matrix();
        const defineTransform = (prepare, name) => {
            let fromName, params;
            defineMethod(fg => {
                prepare(fg);
                fromName = fg.name;
                params = [...fg.params];
                fg.emit`return this`;
            }); 
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = name;
                fg.params = params;
                fg.emit`return this.multiply(tmp.${fromName}(${params}))`;
            });
            defineMethod(fg => {
                Object.assign(fg.ctx, { tmp });
                fg.name = `pre${toTitleCase(name)}`;
                fg.params = params;
                fg.emit`return this.preMultiply(tmp.${fromName}(${params}))`;
            });
        }

        defineTransform(fg => {
            Object.assign(fg.ctx, { isFinite: functions_isFinite });
            fg.name = 'fromWebGLAsymmetricPerspectiveProjection';
            fg.params = ['left', 'right', 'bottom', 'top', 'near', 'far'];

            fg.emit`var near2=near*2,`;
            fg.emit    `invWidth=1/(right-left),`;
            fg.emit    `invHeight=1/(top-bottom)`;
                
            fg.emit`this._00=near2*invWidth,`;
            fg.emit`this._10=0`;
            fg.emit`this._20=(left+right)*invWidth`;
            fg.emit`this._30=0`;

            fg.emit`this._01=0`;
            fg.emit`this._11=near2*invHeight`;
            fg.emit`this._21=(bottom+top)*invHeight`;
            fg.emit`this._31=0`;

            fg.emit`this._02=0`;
            fg.emit`this._12=0`;
            fg.emit`if(isFinite(far)){`;
            fg.emit    `var invNegDepth=1/(near-far)`;
            fg.emit    `this._22=(near+far)*invNegDepth`;
            fg.emit    `this._32=near2*far*invNegDepth`;
            fg.emit`}else{`;
            fg.emit    `this._22=-1`;
            fg.emit    `this._32=-near2`;
            fg.emit`}`;

            fg.emit`this._03=0`;
            fg.emit`this._13=0`;
            fg.emit`this._23=-1`;
            fg.emit`this._33=0`;
        }, 'projectWebGLPerspectiveAsymmetric');
        if (false) {}

        defineTransform(fg => {
            Object.assign(fg.ctx, { tan: tan });
            fg.name = 'fromWebGLPerspectiveProjection';
            fg.params = ['aspectRatio', 'verticalFieldOfView', 'near', 'far'];

            fg.emit`var top=near*tan(verticalFieldOfView*.5),`;
            fg.emit    `right=top*aspectRatio`;

            fg.emit`this.fromWebGLAsymmetricPerspectiveProjection(${
                '-right,right,-top,top,near,far'
            })`;
        }, 'projectWebGLPerspective');
        if (false) {}
    }

    for (const splitKind of [KINDS.LINEAR, KINDS.AFFINE]) {
        if (splitKind.rd > kind.rd) { continue; }

        defineMethod(fg => {
            fg.name = `from${splitKind.name}SplitTransform`;
            fg.params = ['transform'];
            fg.emit`return this.fromScaling(transform.scaling)`;
            fg.emit           `.shear(transform.shearing)`;
            if (d === 2) {
                fg.emit`.applyComplex(transform.complex)`;
            } else {
                fg.emit`.applyQuaternion(transform.quaternion)`;
            }
            if (splitKind !== KINDS.LINEAR) {
                fg.emit`.translate(transform.translation)`;
            }

            if (false) {}
        });
        defineMethod(fg => {
            Object.assign(fg.ctx, (d === 2) ? {
                tmpVector: new Vector2(),
                tmpComplex: new complex_Complex(),
            } : {
                tmpVector: new Vector3(),
                tmpQuaternion: new quaternion_Quaternion(),
            });
            fg.name = `fromInverted${splitKind.name}SplitTransform`;
            fg.params = ['transform'];
            if (d === 3) {
                fg.emit`var shearing=transform.shearing`;
            }
            if (splitKind !== KINDS.LINEAR) {
                fg.emit`return this.fromTranslation(${
                    'tmpVector.copy(transform.translation).negate()'
                })`;
                if (d === 2) {
                    fg.emit`.applyComplex(${
                        'tmpComplex.copy(transform.complex).invert()'
                    })`;
                } else {
                    fg.emit`.applyQuaternion(${
                        'tmpQuaternion.copy(transform.quaternion).invert()'
                    })`;
                }
            } else {
                if (d === 2) {
                    fg.emit`return this.fromComplex(${
                        'tmpComplex.copy(transform.complex).invert()'
                    })`;
                } else {
                    fg.emit`return this.fromQuaternion(${
                        'tmpQuaternion.copy(transform.quaternion).invert()'
                    })`;
                }
            }
            if (d === 2) {
                fg.emit`.shear(-transform.shearing)`;
            } else {
                fg.emit`.shear(tmpVector.set(${[
                    '-shearing.x',
                    'shearing.x*shearing.z-shearing.y',
                    '-shearing.z',
                ]}))`;
            }
            fg.emit`.scale(${
                'tmpVector.copy(transform.scaling).preDivideNumber(1)'
            })`;

            if (false) {}
        });
        if (splitKind === kind) {
            aliasProperty(`from${splitKind.name}SplitTransform`,
                          'fromSplitTransform');
            aliasProperty(`fromInverted${splitKind.name}SplitTransform`,
                          'fromInvertedSplitTransform');
        }
    }

    return Matrix;
}

const LinearMatrix2 = matrices_makeClass(KINDS.LINEAR, 2);
const AffineMatrix2 = matrices_makeClass(KINDS.AFFINE, 2);
const HomogeneousMatrix2 = matrices_makeClass(KINDS.HOMOGENEOUS, 2);

const LinearMatrix3 = matrices_makeClass(KINDS.LINEAR, 3);
const AffineMatrix3 = matrices_makeClass(KINDS.AFFINE, 3);
const HomogeneousMatrix3 = matrices_makeClass(KINDS.HOMOGENEOUS, 3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/split-transforms.js







const split_transforms_KINDS = {
    LINEAR: {
        name: 'Linear',
        order: 0
    },
    AFFINE: {
        name: 'Affine',
        order: 1,
    },
};

function split_transforms_makeClass(kind, d) {
    const as = [...'xyz'].slice(0, d);

    function defineSet(fg) {
        Object.assign(fg.ctx, (d === 2) ? { Vector2: Vector2, Complex: complex_Complex }
                                        : { Vector3: Vector3, Quaternion: quaternion_Quaternion });

        fg.emit`var scaling=components.scaling`;
        fg.emit`this.scaling=scaling===undefined?${
            `new Vector${d}().fromNumber(1):scaling.clone()`
        }`;
        fg.emit`var shearing=components.shearing`;
        fg.emit`this.shearing=shearing===undefined?${
            (d === 2) ? '0:shearing' : 'new Vector3():shearing.clone()'
        }`;
        if (d === 2) {
            fg.emit`var complex=components.complex`;
            fg.emit`this.complex=complex===undefined?${
                'new Complex():complex.clone()'
            }`;
        } else {
            fg.emit`var quaternion=components.quaternion`;
            fg.emit`this.quaternion=quaternion===undefined?${
                'new Quaternion():quaternion.clone()'
            }`;
        }
        if (kind !== split_transforms_KINDS.LINEAR) {
            fg.emit`var translation=components.translation`;
            fg.emit`this.translation=translation===undefined?${
                `new Vector${d}():translation.clone()`
            }`;
        }
    }
    const Transform = generateFunction(fg => {
        fg.ctx.none = {};
        fg.name = `${kind.name}SplitTransform${d}`;
        fg.params = ['components'];
        fg.emit`if(components===undefined){components=none}`;
        defineSet(fg);
    });

    const defineMethod = makeMethodDefiner(Transform.prototype);
    const defineGetter = makeGetterDefiner(Transform.prototype);
    const aliasProperty = makePropertyAliaser(Transform.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = ['components'];
        defineSet(fg);
        fg.emit`return this`;
    });

    defineMethod(fg => {
        if (d === 2) {
            fg.name = 'fromComplex';
            fg.params = ['complex'];
            fg.emit`var scaling=complex.uniformScaling`;
            fg.emit`this.scaling.fromNumber(scaling)`;
            fg.emit`this.shearing=0`;
            fg.emit`this.complex.copy(complex).divideNumber(scaling)`;
        } else {
            Object.assign(fg.ctx, { sqrt: sqrt });
            fg.name = 'fromQuaternion';
            fg.params = ['quaternion'];
            fg.emit`var scaling=quaternion.uniformScaling`;
            fg.emit`this.scaling.fromNumber(scaling)`;
            fg.emit`this.shearing.fromNumber(0)`;
            fg.emit`this.quaternion.copy(quaternion).divideNumber(${
                'sqrt(scaling)'
            })`;
        }
        if (kind !== split_transforms_KINDS.LINEAR) {
            fg.emit`this.translation.fromNumber(0)`;
        }
        fg.emit`return this`;
    });

    for (const matrixKind of Object.values(split_transforms_KINDS)) {
        if (matrixKind.order > kind.order) { continue; }

        defineMethod(fg => {
            if (d === 2) {
                Object.assign(fg.ctx, {
                    max: functions_max, abs: functions_abs,
                    x: new Vector2(),
                    y: new Vector2(),
                    tmp: new Vector2(),
                });
            } else {
                Object.assign(fg.ctx, {
                    max: functions_max, abs: functions_abs, sqrt: sqrt,
                    x: new Vector3(),
                    y: new Vector3(),
                    z: new Vector3(),
                    tmp: new Vector3(),
                });
            }
            fg.name = `from${matrixKind.name}Matrix`;
            fg.params = ['matrix'];

            for (const a of as) {
                fg.emit`matrix.axis${a.toUpperCase()}Paste(${a})`;
            }

            fg.emit`var maxAbs=max(${as.map(ra => as.map(ca => {
                return `abs(${ra}.${ca})`
            }))}),invMaxAbs=1/maxAbs`;

            for (const a of as) {
                fg.emit`${a}.multiply(invMaxAbs)`;
            }

            fg.emit`var scaling=this.scaling`;

            fg.emit`scaling.x=x.length`;
            fg.emit`x.divide(scaling.x)`;

            if (d === 2) {
                fg.emit`var shearing=x.dot(y)`;
                fg.emit`y.subtract(tmp.copy(x).multiply(shearing))`;

                fg.emit`scaling.y=y.length`;
                fg.emit`var invScalingY=1/scaling.y`;
                fg.emit`y.multiply(invScalingY)`;
                fg.emit`shearing*=invScalingY`;

                fg.emit`scaling.multiply(maxAbs)`;

                fg.emit`if(x.cross(y)<0){`;
                fg.emit    `scaling.y=-scaling.y`;
                fg.emit    `shearing=-shearing`;
                fg.emit`}`;

                fg.emit`this.shearing=shearing`;
                fg.emit`this.complex.fromVector(x)`;
            } else {
                fg.emit`var shearing=this.shearing`;

                fg.emit`shearing.z=x.dot(y)`;
                fg.emit`y.subtract(tmp.copy(x).multiply(shearing.z))`;

                fg.emit`scaling.y=y.length`;
                fg.emit`var invScalingY=1/scaling.y`;
                fg.emit`y.multiply(invScalingY)`;
                fg.emit`shearing.z*=invScalingY`;

                fg.emit`shearing.y=x.dot(z)`;
                fg.emit`z.subtract(tmp.copy(x).multiply(shearing.y))`;
                fg.emit`shearing.x=y.dot(z)`;
                fg.emit`z.subtract(tmp.copy(y).multiply(shearing.x))`;

                fg.emit`scaling.z=z.length`;
                fg.emit`var invScalingZ=1/scaling.z`;
                fg.emit`z.multiply(invScalingZ)`;
                fg.emit`shearing.y*=invScalingZ`;
                fg.emit`shearing.x*=invScalingZ`;

                fg.emit`scaling.multiply(maxAbs)`;

                fg.emit`if(x.dot(tmp.copy(y).cross(z))<0){`;
                fg.emit    `x.negate()`;
                fg.emit    `y.negate()`;
                fg.emit    `z.negate()`;
                fg.emit    `scaling.negate()`;
                fg.emit`}`;

                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
                fg.emit`var trace=x.x+y.y+z.z`;
                fg.emit`if(trace>=0){`;
                fg.emit    `var a=sqrt(1+trace)`;
                fg.emit        `b=0.5/a`;
                fg.emit    `this.quaternion.set(a*0.5,`;
                fg.emit                        `(z.y-y.z)*b,`;
                fg.emit                        `(x.z-z.x)*b,`;
                fg.emit                        `(y.x-x.y)*b)`;
                fg.emit`}else if(x.x>y.y&&x.x>z.z){`;
                fg.emit    `var a=sqrt(1+x.x-y.y-z.z)`;
                fg.emit        `b=0.5/a`;
                fg.emit    `this.quaternion.set((z.y-y.z)*b,`;
                fg.emit                        `a*0.5,`;
                fg.emit                        `(x.y+y.x)*b,`;
                fg.emit                        `(x.z+z.x)*b)`;
                fg.emit`}else if(y.y>z.z){`;
                fg.emit    `var a=sqrt(1-x.x+y.y-z.z)`;
                fg.emit        `b=0.5/a`;
                fg.emit    `this.quaternion.set((x.z-z.x)*b,`;
                fg.emit                        `(x.y+y.x)*b,`;
                fg.emit                        `a*0.5,`;
                fg.emit                        `(y.z+z.y)*b)`;
                fg.emit`}else{`;
                fg.emit    `var a=sqrt(1-x.x-y.y+z.z),`;
                fg.emit        `b=0.5/a;`;
                fg.emit    `this.quaternion.set((y.x-x.y)*b,`;
                fg.emit                        `(x.z+z.x)*b,`;
                fg.emit                        `(y.z+z.y)*b,`;
                fg.emit                        `a*0.5)`;
                fg.emit`}`;
            }

            if (kind !== split_transforms_KINDS.LINEAR) {
                if (matrixKind === split_transforms_KINDS.LINEAR) {
                    fg.emit`this.translation.fromNumber(0)`;
                } else {
                    fg.emit`matrix.translationPaste(this.translation)`;
                }
            }

            fg.emit`return this`;
        });
        if (matrixKind === kind) {
            aliasProperty(`from${matrixKind.name}Matrix`, 'fromMatrix');
        }
    }

    for (const srcKind of Object.values(split_transforms_KINDS)) {
        if (srcKind.order > kind.order) { continue; }

        defineMethod(fg => {
            fg.name = `from${srcKind.name}SplitTransform`;
            fg.params = ['transform'];
            fg.emit`this.scaling.copy(transform.scaling)`;
            if (d === 2) {
                fg.emit`this.shearing=transform.shearing`;
                fg.emit`this.complex.copy(transform.complex)`;
            } else {
                fg.emit`this.shearing.copy(transform.shearing)`;
                fg.emit`this.quaternion.copy(transform.quaternion)`;
            }
            if (kind !== split_transforms_KINDS.LINEAR) {
                if (srcKind === split_transforms_KINDS.LINEAR) {
                    fg.emit`this.translation.fromNumber(0)`;
                } else {
                    fg.emit`this.translation.copy(transform.translation)`;
                }
            }
            fg.emit`return this`;
        });
        aliasProperty(`from${srcKind.name}SplitTransform`,
                      `from${srcKind.name}`);
    }
    aliasProperty(`from${kind.name}SplitTransform`, 'copy');

    defineMethod(fg => {
        fg.ctx[Transform.name] = Transform;
        fg.name = 'clone';
        fg.emit`return new ${Transform.name}().copy(this)`;
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        for (const [joiner, joinOp] of [
            ['some' , '||'],
            ['every', '&&'],
        ]) {
            const tests = [`this.scaling.${joiner}${Name}`];
            if (d === 2) {
                tests.push(`${name}(this.shearing)`);
                tests.push(`this.complex.${joiner}${Name}`);
            } else {
                tests.push(`this.shearing.${joiner}${Name}`);
                tests.push(`this.quaternion.${joiner}${Name}`);
            }
            if (kind !== split_transforms_KINDS.LINEAR) {
                tests.push(`this.translation.${joiner}${Name}`);
            }
            defineGetter(fg => {
                fg.ctx[name] = fn;
                fg.name = `${joiner}${Name}`;
                fg.emit`return ${tests.join(joinOp)}`;
            });
        }
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return this.scaling.equals(that.scaling)`;
        if (d === 2) {
            fg.emit`&&this.shearing===that.shearing`;
            fg.emit`&&this.complex.equals(that.complex)`;
        } else {
            fg.emit`&&this.shearing.equals(that.shearing)`;
            fg.emit`&&this.quaternion.equals(that.quaternion)`;
        }
        if (kind !== split_transforms_KINDS.LINEAR) {
            fg.emit`&&this.translation.equals(that.translation)`;
        }
    });

    return Transform;
}

const LinearSplitTransform2 = split_transforms_makeClass(split_transforms_KINDS.LINEAR, 2);
const AffineSplitTransform2 = split_transforms_makeClass(split_transforms_KINDS.AFFINE, 2);

const LinearSplitTransform3 = split_transforms_makeClass(split_transforms_KINDS.LINEAR, 3);
const AffineSplitTransform3 = split_transforms_makeClass(split_transforms_KINDS.AFFINE, 3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/rectangle-and-box.js





function rectangle_and_box_makeClass(d) {
    const name = (d === 2) ? 'rectangle' : 'box',
          Name = toTitleCase(name);
    const as = [...'xyz'].slice(0, d);

    const sphereName = (d === 2) ? 'circle' : 'sphere',
          SphereName = toTitleCase(sphereName);

    const tmp0 = new ((d === 2) ? Vector2 : Vector3)();
    const tmp1 = new ((d === 2) ? Vector2 : Vector3)();
    const tmp2 = new ((d === 2) ? Vector2 : Vector3)();

    const Box = generateFunction(fg => {
        Object.assign(fg.ctx, (d === 2) ? { Vector2: Vector2 } : { Vector3: Vector3 });
        fg.name = Name;
        fg.params = ['min', 'max'];
        for (const p of fg.params) {
            fg.emit`this.${p}=new Vector${d}()`;
            fg.emit`if(${p}===undefined){`;
            fg.emit    `this.${p}.fromNumber(${'-'.slice(p !== 'min')}0.5)`;
            fg.emit`}else{`;
            fg.emit    `this.${p}.copy(${p})`;
            fg.emit`}`;
        }
    });

    const defineMethod = makeMethodDefiner(Box.prototype);
    const defineGetter = makeGetterDefiner(Box.prototype);
    const defineSetter = makeSetterDefiner(Box.prototype);
    const aliasProperty = makePropertyAliaser(Box.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = ['min', 'max'];
        fg.emit`this.min.copy(min)`;
        fg.emit`this.max.copy(max)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = `from${Name}`;
        fg.params = [name];
        fg.emit`return this.set(${name}.min,${name}.max)`;
    });
    aliasProperty(`from${Name}`, 'copy');

    defineMethod(fg => {
        fg.name = 'fromCenterAndSize';
        fg.params = ['center', 'size'];
        fg.emit`this.min.copy(size).multiply(-0.5).add(center)`;
        fg.emit`this.max.copy(size).multiply(0.5).add(center)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'fromCenterAndUniformSize';
        fg.params = ['center', 'size'];
        fg.emit`this.min.copy(center).addNumber(-0.5*size)`;
        fg.emit`this.max.copy(center).addNumber(0.5*size)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = `fromSupporting${SphereName}`;
        fg.params = [sphereName];
        fg.emit`return this.fromCenterAndUniformSize(${
            `${sphereName}.center,${sphereName}.radius*2`
        })`;
    });

    defineMethod(fg => {
        fg.ctx[Name] = Box;
        fg.name = 'clone';
        fg.emit`return new ${Name}().copy(this)`;
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        for (const [joiner, joinOp] of [
            ['some' , '||'],
            ['every', '&&'],
        ]) {
            defineGetter(fg => {
                fg.ctx[name] = fn;
                fg.name = `${joiner}${Name}`;
                fg.emit`return ${[
                    `this.min.${joiner}${Name}`,
                    `this.max.${joiner}${Name}`,
                ].join(joinOp)}`;
            });
        }
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return this.min.equals(that.min)&&this.max.equals(that.max)`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            min: functions_min, max: functions_max,
            minDistances: tmp0,
            maxDistances: tmp1,
        });
        fg.name = 'pointDistance';
        fg.params = ['point'];
        fg.emit`minDistances.copy(this.min).subtract(point)`;
        fg.emit`maxDistances.copy(point).subtract(this.max)`;
        fg.emit`var distances = minDistances.max(maxDistances)`;
        fg.emit`return min(max(${
            as.map(a => `distances.${a}`)
        }),0)+distances.maxNumber(0).length`;
    });

    defineMethod(fg => {
        fg.name = 'centerPaste';
        fg.params = ['center'];
        fg.emit`return center.copy(this.min).add(this.max).multiply(0.5)`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { size: tmp0 });
        fg.name = 'centerCopy';
        fg.params = ['center'];
        fg.emit`return this.fromCenterAndSize(center,this.sizePaste(size))`;
    });
    defineMethod(fg => {
        fg.name = 'sizePaste';
        fg.params = ['size'];
        fg.emit`return size.copy(this.max).subtract(this.min)`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { center: tmp0 });
        fg.name = 'sizeCopy';
        fg.params = ['size'];
        fg.emit`return this.fromCenterAndSize(this.centerPaste(center),size)`;
    });
    defineSetter(fg => {
        Object.assign(fg.ctx, { center: tmp0 });
        fg.name = 'uniformSize';
        fg.params = ['size'];
        fg.emit`return this.fromCenterAndUniformSize(${
            `this.centerPaste(center),size`
        })`;
    });

    defineMethod(fg => {
        fg.name = 'consumePoint';
        fg.params = ['point'];
        fg.emit`this.min.min(point)`;
        fg.emit`this.max.max(point)`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        fg.name = `consume${Name}`;
        fg.params = [name];
        fg.emit`this.min.min(${name}.min)`;
        fg.emit`this.max.max(${name}.max)`;
        fg.emit`return this`;
    });
    aliasProperty(`consume${Name}`, 'consume');
    defineMethod(fg => {
        Object.assign(fg.ctx, { corner: tmp0 });
        fg.name = `consume${SphereName}`;
        fg.params = [sphereName];
        fg.emit`this.min.min(${sphereName}.minPaste(corner))`;
        fg.emit`this.max.max(${sphereName}.maxPaste(corner))`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'containsPoint';
        fg.params = ['point'];
        fg.emit`var min=this.min,max=this.max`;
        fg.emit`return ${as.map(a => {
            return `min.${a}<=point.${a}&&point.${a}<=max.${a}`;
        }).join('&&')}`;
    });
    defineMethod(fg => {
        fg.name = `contains${Name}`;
        fg.params = [name];
        fg.emit`return ${[
            `this.containsPoint(${name}.min)`,
            `this.containsPoint(${name}.max)`,
        ].join('&&')}`;
    });
    aliasProperty(`contains${Name}`, 'contains');
    defineMethod(fg => {
        Object.assign(fg.ctx, { corner: tmp0 });
        fg.name = `contains${SphereName}`;
        fg.params = [sphereName];
        fg.emit`return ${[
            `this.containsPoint(${sphereName}.minPaste(corner))`,
            `this.containsPoint(${sphereName}.maxPaste(corner))`,
        ].join('&&')}`;
    });

    aliasProperty('containsPoint', 'intersectsPoint');
    defineMethod(fg => {
        fg.name = `intersects${Name}`;
        fg.params = [name];
        fg.emit`var minA=this.min,maxA=this.max`;
        fg.emit`var minB=${name}.min,maxB=${name}.max`;
        fg.emit`return ${as.map(a => {
            return `minA.${a}<=maxB.${a}&&maxA.${a}>=minB.${a}`;
        }).join('&&')}`;
    });
    aliasProperty(`intersects${Name}`, 'intersects');
    defineMethod(fg => {
        Object.assign(fg.ctx, { sq: sq });
        fg.name = `intersects${SphereName}`;
        fg.params = [sphereName];
        fg.emit`var min=this.min,max=this.max,`;
        fg.emit    `center=${sphereName}.center,`;
        fg.emit    `negSqDistance=sq(${sphereName}.radius)`;
        for (const a of as) {
            fg.emit`if(center.${a}<min.${a}){`;
            fg.emit    `negSqDistance-=sq(min.${a}-center.${a})`;
            fg.emit`}else if(max.${a}<center.${a}){`;
            fg.emit    `negSqDistance-=sq(center.${a}-max.${a})`;
            fg.emit`}`;
        }
        fg.emit`return negSqDistance>=0`;
    });
    defineMethod(fg => {
        fg.name = `intersectsHalfSpace`;
        fg.params = ['halfSpace'];
        fg.emit`return halfSpace.intersects${Name}(this)`;
    });

    defineMethod(fg => {
        fg.name = 'translate';
        fg.params = ['translation'];
        fg.emit`this.min.translate(translation)`;
        fg.emit`this.max.translate(translation)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'scale';
        fg.params = ['scaling'];
        fg.emit`var min=this.min,max=this.max`;
        fg.emit`min.scale(scaling)`;
        fg.emit`max.scale(scaling)`;
        for (const a of as) {
            fg.emit`if(scaling.${a}<0){`;
            fg.emit    `var t=min.${a}`;
            fg.emit    `min.${a}=max.${a}`;
            fg.emit    `max.${a}=t`;
            fg.emit`}`;
        }
        fg.emit`return this`;
    });
    defineMethod(fg => {
        fg.name = 'scaleUniform';
        fg.params = ['scaling'];
        fg.emit`var min=this.min,max=this.max`;
        fg.emit`min.scaleUniform(scaling)`;
        fg.emit`max.scaleUniform(scaling)`;
        fg.emit`if(scaling<0){`;
        for (const a of as) {
            fg.emit`${['var '].slice(a !== 'x')}t=min.${a}`;
            fg.emit`min.${a}=max.${a}`;
            fg.emit`max.${a}=t`;
        }
        fg.emit`}`;
        fg.emit`return this`;
    });

    for (const [name, ...params] of (function*() {
        yield ['shear'        , 'shearing'];
        yield ['reflect'      , 'normal'];
        yield ['rotateBetween', 'from', 'to'];
        if (d === 2) {
            yield ['rotate'      , 'angle'  ];
            yield ['applyComplex', 'complex'];
        } else {
            yield ['rotate'         , 'angle'  , 'axis'];
            yield ['applyComplex'   , 'complex', 'axis'];
            yield ['applyQuaternion', 'quaternion'     ];
        }
        yield ['applyLinearMatrix', 'matrix'];
        yield ['applyAffineMatrix', 'matrix'];
    })()) {
        defineMethod(fg => {
            Object.assign(fg.ctx, {
                center: tmp0,
                corner: tmp1,
                halfSize: tmp2,
            });
            fg.name = name;
            fg.params = params;
            fg.emit`var min=this.min,max=this.max`;
            fg.emit`this.centerPaste(center).${name}(${params})`;
            fg.emit`corner.copy(max).${name}(${params}).subtract(center)`;
            fg.emit`halfSize.fromNumber(0).max(corner.abs())`;
            for (let i = 0; i < 2 ** (d - 1) - 1; ++i) {
                fg.emit`corner.set(${as.map((a, j) => {
                    return `m${['in', 'ax'][+(j === i)]}.${a}`;
                })}).${name}(${params}).subtract(center)`;
                fg.emit`halfSize.max(corner.abs())`;
            }
            fg.emit`min.copy(center).subtract(halfSize)`;
            fg.emit`max.copy(center).add(halfSize)`;
            fg.emit`return this`;
        });
    }

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            oldMin: tmp0,
            oldMax: tmp1,
            corner: tmp2,
        });
        fg.name = 'applyHomogeneousMatrix';
        fg.params = ['matrix'];
        fg.emit`var min=this.min,max=this.max`;
        fg.emit`oldMin.copy(min)`;
        fg.emit`oldMax.copy(max)`;
        fg.emit`min.${fg.name}(${fg.params})`;
        fg.emit`max.copy(min)`;
        for (let i = 1; i < 2 ** d - 1; ++i) {
            fg.emit`corner.set(${as.map((a, j) => {
                return `oldM${['in', 'ax'][(i >>> j) & 1]}.${a}`;
            })}).${fg.name}(${fg.params})`;
            fg.emit`min.min(corner)`;
            fg.emit`max.max(corner)`;
        }
        fg.emit`corner.copy(oldMax).${fg.name}(${fg.params})`;
        fg.emit`min.min(corner)`;
        fg.emit`max.max(corner)`;

        fg.emit`return this`;
    });

    return Box;
}

const Rectangle = rectangle_and_box_makeClass(2);
const rectangle_and_box_Box = rectangle_and_box_makeClass(3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/circle-and-sphere.js





function circle_and_sphere_makeClass(d) {
    const name = (d === 2) ? 'circle' : 'sphere',
          Name = toTitleCase(name);
    const as = [...'xyz'].slice(0, d);

    const boxName = (d === 2) ? 'rectangle' : 'box',
          BoxName = toTitleCase(boxName);

    const tmp0 = new ((d === 2) ? Vector2 : Vector3)();
    const tmp1 = new ((d === 2) ? Vector2 : Vector3)();
    const tmp2 = new ((d === 2) ? Vector2 : Vector3)();

    const Sphere = generateFunction(fg => {
        Object.assign(fg.ctx, (d === 2) ? { Vector2: Vector2 } : { Vector3: Vector3 });
        fg.name = Name;
        fg.params = ['center', 'radius'];
        fg.emit`this.center=new Vector${d}()`;
        fg.emit`if(center!==undefined){this.center.copy(center)}`;
        fg.emit`if(radius===undefined){`;
        fg.emit    `this.radius=1`;
        fg.emit`}else{`;
        fg.emit    `this.radius=radius`;
        fg.emit`}`;
    });

    const defineMethod = makeMethodDefiner(Sphere.prototype);
    const defineGetter = makeGetterDefiner(Sphere.prototype);
    const defineSetter = makeSetterDefiner(Sphere.prototype);
    const aliasProperty = makePropertyAliaser(Sphere.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = ['center', 'radius'];
        fg.emit`this.center.copy(center)`;
        fg.emit`this.radius=radius`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = `from${Name}`;
        fg.params = [name];
        fg.emit`return this.set(${name}.center,${name}.radius)`;
    });
    aliasProperty(`from${Name}`, 'copy');

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            center: tmp0,
            size: tmp1,
        });
        fg.name = `fromSupporting${BoxName}`;
        fg.params = [boxName];
        fg.emit`return this.set(${[
            `${boxName}.centerPaste(center)`,
            `${boxName}.sizePaste(size).length*0.5`,
        ]})`;
    });

    defineMethod(fg => {
        fg.ctx[Name] = Sphere;
        fg.name = 'clone';
        fg.emit`return new ${Name}().copy(this)`;
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        for (const [joiner, joinOp] of [
            ['some' , '||'],
            ['every', '&&'],
        ]) {
            defineGetter(fg => {
                fg.ctx[name] = fn;
                fg.name = `${joiner}${Name}`;
                fg.emit`return ${[
                    `this.center.${joiner}${Name}`,
                    `${name}(this.radius)`,
                ].join(joinOp)}`;
            });
        }
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return ${[
            `this.center.equals(that.center)`,
            `this.radius===that.radius`,
        ].join('&&')}`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            minDistances: tmp0,
            maxDistances: tmp1,
        });
        fg.name = 'pointDistance';
        fg.params = ['point'];
        fg.emit`return this.center.distance(point)-this.radius`;
    });

    defineMethod(fg => {
        fg.name = 'minPaste';
        fg.params = ['min'];
        fg.emit`return min.copy(this.center).subtractNumber(this.radius)`;
    });
    defineMethod(fg => {
        fg.name = 'maxPaste';
        fg.params = ['max'];
        fg.emit`return max.copy(this.center).addNumber(this.radius)`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            sqrt: sqrt,
            direction: tmp0,
        });
        fg.name = 'consumePoint';
        fg.params = ['point'];
        fg.emit`var center=this.center,radius=this.radius`;
        fg.emit`direction.copy(point).subtract(center)`;
        fg.emit`var sqDistance=direction.sqLength`;
        fg.emit`if(sqDistance>radius*radius){`;
        fg.emit    `var distance=sqrt(distance)`;
        fg.emit    `direction.multiply(0.5*(distance-radius)/distance)`;
        fg.emit    `center.add(direction)`;
        fg.emit    `this.radius=0.5*(distance+radius)`;
        fg.emit`}`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, {
            sq: sq, sqrt: sqrt,
            direction: tmp0,
        });
        fg.name = `consume${Name}`;
        fg.params = [name];
        fg.emit`var centerA=this.center,radiusA=this.radius,`;
        fg.emit    `centerB=${name}.center,radiusB=${name}.radius`;
        fg.emit`direction.copy(centerB).subtract(centerA)`;
        fg.emit`var sqDistance=direction.sqLength`;
        fg.emit`if(sqDistance>sq(radiusB-radiusA)){`;
        fg.emit    `var distance=sqrt(distance),t=distance+radiusB`;
        fg.emit    `direction.multiply(0.5*(t-radiusA)/distance)`;
        fg.emit    `centerA.add(direction)`;
        fg.emit    `this.radius=0.5*(t+radiusA)`;
        fg.emit`}else if(radiusB>radiusA){`;
        fg.emit    `centerA.copy(centerB)`;
        fg.emit    `this.radius=radiusB`;
        fg.emit`}`;
        fg.emit`return this`;
    });
    aliasProperty(`consume${Name}`, 'consume');
    defineMethod(fg => {
        Object.assign(fg.ctx, {
            sq: sq, sqrt: sqrt,
            [name]: new Sphere(),
        });
        fg.name = `consume${BoxName}`;
        fg.params = [boxName];
        fg.emit`return this.consume(${
            `${name}.fromSupporting${BoxName}(${boxName})`
        })`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { sq: sq });
        fg.name = 'containsPoint';
        fg.params = ['point'];
        fg.emit`return this.center.sqDistance(point)<=sq(this.radius)`;
    });
    defineMethod(fg => {
        fg.name = `contains${Name}`;
        fg.params = [name];
        fg.emit`var radiusDifference=this.radius-${name}.radius`;
        fg.emit`return ${[
            `radiusDifference>=0`,
            `this.center.sqDistance(${name}.center)<=sq(radiusDifference)`,
        ].join('&&')}`;
    });
    aliasProperty(`contains${Name}`, 'contains');
    defineMethod(fg => {
        Object.assign(fg.ctx, {
            direction: tmp0,
            farCorner: tmp1,
        });
        fg.name = `contains${BoxName}`;
        fg.params = [boxName];
        fg.emit`var min=${boxName}.min,max=${boxName}.max`;
        fg.emit`${boxName}.centerPaste(direction).subtract(this.center)`;
        for (const a of as) {
            fg.emit`farCorner.${a}=direction.${a}<0?min.${a}:max.${a}`;
        }
        fg.emit`return this.containsPoint(farCorner)`;
    });

    aliasProperty('containsPoint', 'intersectsPoint');
    defineMethod(fg => {
        Object.assign(fg.ctx, { sq: sq });
        fg.name = `intersects${Name}`;
        fg.params = [name];
        fg.emit`return this.center.sqDistance(${name}.center)<=`
        fg.emit       `sq(this.radius+${name}.radius)`;
    });
    aliasProperty(`intersects${Name}`, 'intersects');
    defineMethod(fg => {
        Object.assign(fg.ctx, { sq: sq });
        fg.name = `intersects${BoxName}`;
        fg.params = [boxName];
        fg.emit`return ${boxName}.intersects${Name}(this)`;
    });
    defineMethod(fg => {
        fg.name = `intersectsHalfSpace`;
        fg.params = ['halfSpace'];
        fg.emit`return halfSpace.intersects${Name}(this)`;
    });

    defineMethod(fg => {
        fg.name = 'translate';
        fg.params = ['translation'];
        fg.emit`this.center.translate(translation)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { max: functions_max });
        fg.name = 'scale';
        fg.params = ['scaling'];
        fg.emit`this.center.scale(scaling)`;
        fg.emit`this.radius*=max(${as.map(a => `scaling.${a}`)})`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { max: functions_max });
        fg.name = 'scaleUniform';
        fg.params = ['scaling'];
        fg.emit`this.center.scaleUniform(scaling)`;
        fg.emit`this.radius*=scaling`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'reflect';
        fg.params = ['normal'];
        fg.emit`this.center.reflect(${fg.params})`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'rotate';
        fg.params = ['angle'];
        if (d === 3) { fg.params.push('axis'); }
        fg.emit`this.center.rotate(${fg.params})`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        fg.name = 'rotateBetween';
        fg.params = ['from', 'to'];
        fg.emit`this.center.rotateBetween(${fg.params})`;
        fg.emit`return this`;
    });

    for (const [name, ...params] of (function*() {
        if (d === 2) {
            yield ['applyComplex'   , 'complex'];
        } else {
            yield ['applyComplex'   , 'complex', 'axis'];
            yield ['applyQuaternion', 'quaternion'     ];
        }
    })()) {
        defineMethod(fg => {
            fg.name = name;
            fg.params = params;
            fg.emit`this.center.${name}(${params})`;
            fg.emit`this.radius*=${params[0]}.uniformScaling`;
            fg.emit`return this`;
        });
    }

    for (const [name, ...params] of (function*() {
        yield ['shear'            , 'shearing'];
        yield ['applyLinearMatrix', 'matrix'  ];
        yield ['applyAffineMatrix', 'matrix'  ];
    })()) {
        defineMethod(fg => {
            Object.assign(fg.ctx, {
                max: functions_max, sqrt: sqrt,
                lo: tmp0,
                hi: tmp1,
                corner: tmp2,
            });
            fg.name = name;
            fg.params = params;
            fg.emit`this.minPaste(lo)`;
            fg.emit`this.maxPaste(hi)`;
            fg.emit`var center=this.center`;
            fg.emit`center.${name}(${params})`;
            fg.emit`corner.copy(hi).${name}(${params}).subtract(center)`;
            fg.emit`var sqRadius=corner.sqLength`;
            for (let i = 0; i < 2 ** (d - 1) - 1; ++i) {
                fg.emit`corner.set(${as.map((a, j) => {
                    return `${['lo', 'hi'][+(j === i)]}.${a}`;
                })}).${name}(${params}).subtract(center)`;
                fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
            }
            fg.emit`this.radius=sqrt(sqRadius)`;
            fg.emit`return this`;
        });
    }

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            max: functions_max, sqrt: sqrt,
            lo: tmp0,
            hi: tmp1,
            corner: tmp2,
        });
        fg.name = 'applyHomogeneousMatrix';
        fg.params = ['matrix'];
        fg.emit`this.minPaste(lo)`;
        fg.emit`this.maxPaste(hi)`;
        fg.emit`var center=this.center`;
        fg.emit`center.${fg.name}(${fg.params})`;
        fg.emit`corner.copy(lo).${fg.name}(${fg.params}).subtract(center)`;
        fg.emit`var sqRadius=corner.sqLength`;
        for (let i = 1; i < 2 ** d - 1; ++i) {
            fg.emit`corner.set(${as.map((a, j) => {
                return `${['lo', 'hi'][(i >>> j) & 1]}.${a}`;
            })}).${fg.name}(${fg.params}).subtract(center)`;
            fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
        }
        fg.emit`corner.copy(hi).${fg.name}(${fg.params}).subtract(center)`;
        fg.emit`sqRadius=max(sqRadius,corner.sqLength)`;
        fg.emit`this.radius=sqrt(sqRadius)`;
        fg.emit`return this`;
    });

    return Sphere;
}

const Circle = circle_and_sphere_makeClass(2);
const circle_and_sphere_Sphere = circle_and_sphere_makeClass(3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/half-spaces.js





function half_spaces_makeClass(d) {
    const as = [...'xyz'].slice(0, d);

    const boxName = (d === 2) ? 'rectangle' : 'box',
          BoxName = toTitleCase(boxName);
    const sphereName = (d === 2) ? 'circle' : 'sphere',
          SphereName = toTitleCase(sphereName);

    const tmp = new ((d === 2) ? Vector2 : Vector3)();

    const HalfSpace = generateFunction(fg => {
        Object.assign(fg.ctx, (d === 2) ? { Vector2: Vector2 } : { Vector3: Vector3 });
        fg.name = `HalfSpace${d}`;
        fg.params = ['normal', 'offset'];
        fg.emit`if(normal===undefined){`;
        fg.emit    `this.normal=new Vector${d}(${
                        as.map((a, i) => +(i === d - 1))
                   })`;
        fg.emit`}else{`;
        fg.emit    `this.normal=normal.clone()`;
        fg.emit`}`;
        fg.emit`if(offset===undefined){`;
        fg.emit    `this.offset=0`;
        fg.emit`}else{`;
        fg.emit    `this.offset=offset`;
        fg.emit`}`;
    });

    const defineMethod = makeMethodDefiner(HalfSpace.prototype);
    const defineGetter = makeGetterDefiner(HalfSpace.prototype);
    const defineSetter = makeSetterDefiner(HalfSpace.prototype);
    const aliasProperty = makePropertyAliaser(HalfSpace.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = ['normal', 'offset'];
        fg.emit`this.normal.copy(normal)`;
        fg.emit`this.offset=offset`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'fromHalfSpace';
        fg.params = ['halfSpace'];
        fg.emit`return this.set(halfSpace.normal, halfSpace.offset)`;
    });
    aliasProperty('fromHalfSpace', 'copy');

    defineMethod(fg => {
        fg.name = 'fromNormalAndPoint';
        fg.params = ['normal', 'point'];
        fg.emit`this.normal.copy(normal)`;
        fg.emit`this.offset=normal.dot(point)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'fromBoundaryPoints';
        fg.params = [as.map((a, i) => `point${i}`)];
        fg.emit`var normal=this.normal`;
        if (d === 2) {
            fg.emit`normal.copy(point1).subtract(point0).orthogonalize()`;
        } else {
            Object.assign(fg.ctx, { edge12: tmp });
            fg.emit`edge12.copy(point2).subtract(point1)`;
            fg.emit`normal.copy(point1).subtract(point0).cross(edge12)`;
        }
        fg.emit`this.offset=normal.dot(point0)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { [HalfSpace.name]: HalfSpace });
        fg.name = 'clone';
        fg.emit`return new ${HalfSpace.name}().copy(this)`;
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        for (const [joiner, joinOp] of [
            ['some' , '||'],
            ['every', '&&'],
        ]) {
            defineGetter(fg => {
                fg.ctx[name] = fn;
                fg.name = `${joiner}${Name}`;
                fg.emit`return ${[
                    `this.normal.${joiner}${Name}`,
                    `${name}(this.offset)`,
                ].join(joinOp)}`;
            });
        }
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return ${[
            `this.normal.equals(that.normal)`,
            `this.offset===that.offset`,
        ].join('&&')}`;
    });

    defineMethod(fg => {
        fg.name = 'flip';
        fg.emit`this.normal.negate()`;
        fg.emit`this.offset=-this.offset`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'normalize';
        fg.emit`var normal=this.normal,invNormalLength=1/normal.length`;
        fg.emit`normal.multiply(invNormalLength)`;
        fg.emit`this.offset*=invNormalLength`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'pointDistance';
        fg.params = ['point'];
        fg.emit`return this.normal.dot(point)-this.offset`;
    });

    defineMethod(fg => {
        fg.name = 'centerPaste';
        fg.params = ['center'];
        fg.emit`var normal=this.normal`;
        fg.emit`center.copy(normal).multiply(this.offset/normal.dot(normal))`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'consumePoint';
        fg.params = ['point'];
        fg.emit`var offset=this.normal.dot(point)`;
        fg.emit`if(offset>this.offset){this.offset=offset}`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { farCorner: tmp })
        fg.name = `consume${BoxName}`;
        fg.params = [boxName];
        fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;
        for (const a of as) {
            fg.emit`farCorner.${a}=normal.${a}<0?min.${a}:max.${a}`;
        }
        fg.emit`return this.consumePoint(farCorner)`;
    });
    defineMethod(fg => {
        fg.name = `consume${SphereName}`;
        fg.params = [sphereName];
        fg.emit`var normal=this.normal,`;
        fg.emit    `offset=normal.dot(${sphereName}.center)`;
        fg.emit`offset+=${sphereName}.radius*normal.length`;
        fg.emit`if(offset>this.offset){this.offset=offset}`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'containsPoint';
        fg.params = ['point'];
        fg.emit`return this.normal.dot(point)<=this.offset`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { farCorner: tmp })
        fg.name = `contains${BoxName}`;
        fg.params = [boxName];
        fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;
        for (const a of as) {
            fg.emit`farCorner.${a}=normal.${a}<0?min.${a}:max.${a}`;
        }
        fg.emit`return this.containsPoint(farCorner)`;
    });
    defineMethod(fg => {
        fg.name = `contains${SphereName}`;
        fg.params = [sphereName];
        fg.emit`var normal=this.normal,`;
        fg.emit    `offset=normal.dot(${sphereName}.center)`;
        fg.emit`offset+=${sphereName}.radius*normal.length`;
        fg.emit`return offset<=this.offset`;
    });

    aliasProperty('containsPoint', 'intersectsPoint');
    defineMethod(fg => {
        Object.assign(fg.ctx, { nearCorner: tmp })
        fg.name = `intersects${BoxName}`;
        fg.params = [boxName];
        fg.emit`var normal=this.normal,min=${boxName}.min,max=${boxName}.max`;
        for (const a of as) {
            fg.emit`nearCorner.${a}=normal.${a}>0?min.${a}:max.${a}`;
        }
        fg.emit`return this.intersectsPoint(nearCorner)`;
    });
    defineMethod(fg => {
        fg.name = `intersects${SphereName}`;
        fg.params = [sphereName];
        fg.emit`var normal=this.normal,`;
        fg.emit    `offset=normal.dot(${sphereName}.center)`;
        fg.emit`offset-=${sphereName}.radius*normal.length`;
        fg.emit`return offset<=this.offset`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { center: tmp });
        fg.name = 'translate';
        fg.params = ['translation'];
        fg.emit`this.centerPaste(center).translate(translation)`;
        fg.emit`this.offset=this.normal.dot(center)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'scale';
        fg.params = ['scaling'];
        fg.emit`this.normal.divideVector(scaling)`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        fg.name = 'scaleUniform';
        fg.params = ['scaling'];
        fg.emit`this.normal.divide(scaling)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'reflect';
        fg.params = ['normal'];
        fg.emit`this.normal.reflect(${fg.params})`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'rotate';
        fg.params = ['angle'];
        if (d === 3) { fg.params.push('axis'); }
        fg.emit`this.normal.rotate(${fg.params})`;
        fg.emit`return this`;
    });
    defineMethod(fg => {
        fg.name = 'rotateBetween';
        fg.params = ['from', 'to'];
        fg.emit`this.normal.rotateBetween(${fg.params})`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'applyComplex';
        fg.params = ['complex'];
        if (d === 3) { fg.params.push('axis'); }
        fg.emit`this.normal.applyComplex(${fg.params}).divide(complex.sqAbs)`;
        fg.emit`return this`;
    });

    if (d === 3) {
        defineMethod(fg => {
            Object.assign(fg.ctx, { sq: sq });
            fg.name = 'applyQuaternion';
            fg.params = ['quaternion'];
            fg.emit`this.normal.applyQuaternion(quaternion).divide(${
                'sq(quaternion.uniformScaling)'
            })`;
            fg.emit`return this`;
        });
    }

    for (const [name, param] of [
        ['shear'                 , 'shearing'],
        ['applyLinearMatrix'     , 'matrix'  ],
        ['applyAffineMatrix'     , 'matrix'  ],
        ['applyHomogeneousMatrix', 'matrix'  ],
    ]) {
        defineMethod(fg => {
            Object.assign(fg.ctx, { center: tmp });
            fg.name = name;
            fg.params = [param];
            fg.emit`var normal=this.normal`;
            fg.emit`this.centerPaste(center)`;
            fg.emit`normal.add(center)`;
            fg.emit      `.${name}(${param})`;
            fg.emit      `.subtract(center.${name}(${param}))`;
            fg.emit`this.offset=normal.dot(center)`;
            fg.emit`return this`;
        });
    }

    return HalfSpace;
}

const HalfSpace2 = half_spaces_makeClass(2);
const HalfSpace3 = half_spaces_makeClass(3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/rays.js





function rays_makeClass(d) {
    const as = [...'xyz'].slice(0, d);

    const boxName = (d === 2) ? 'rectangle' : 'box',
          BoxName = toTitleCase(boxName);
    const sphereName = (d === 2) ? 'circle' : 'sphere',
          SphereName = toTitleCase(sphereName);

    const tmp = new ((d === 2) ? Vector2 : Vector3)();

    const Ray = generateFunction(fg => {
        Object.assign(fg.ctx, (d === 2) ? { Vector2: Vector2 } : { Vector3: Vector3 });
        fg.name = `Ray${d}`;
        fg.params = ['origin', 'direction'];
        fg.emit`if(origin===undefined){`;
        fg.emit    `this.origin=new Vector${d}()`;
        fg.emit`}else{`;
        fg.emit    `this.origin=origin.clone()`;
        fg.emit`}`;
        fg.emit`if(direction===undefined){`;
        fg.emit    `this.direction=new Vector${d}(${
                        as.map((a, i) => -(i === d - 1))
                   })`;
        fg.emit`}else{`;
        fg.emit    `this.direction=direction.clone()`;
        fg.emit`}`;
    });

    const defineMethod = makeMethodDefiner(Ray.prototype);
    const defineGetter = makeGetterDefiner(Ray.prototype);
    const defineSetter = makeSetterDefiner(Ray.prototype);
    const aliasProperty = makePropertyAliaser(Ray.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = ['origin', 'direction'];
        fg.emit`this.origin.copy(origin)`;
        fg.emit`this.direction.copy(direction)`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'fromRay';
        fg.params = ['ray'];
        fg.emit`return this.set(ray.origin, ray.direction)`;
    });
    aliasProperty('fromRay', 'copy');

    defineMethod(fg => {
        fg.name = 'fromOriginAndTarget';
        fg.params = ['origin', 'target'];
        fg.emit`this.origin.copy(origin)`;
        fg.emit`this.direction.copy(target).subtract(origin).normalize()`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { [Ray.name]: Ray });
        fg.name = 'clone';
        fg.emit`return new ${Ray.name}().copy(this)`;
    });

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        for (const [joiner, joinOp] of [
            ['some' , '||'],
            ['every', '&&'],
        ]) {
            defineGetter(fg => {
                fg.ctx[name] = fn;
                fg.name = `${joiner}${Name}`;
                fg.emit`return ${[
                    `this.origin.${joiner}${Name}`,
                    `this.direction.${joiner}${Name}`,
                ].join(joinOp)}`;
            });
        }
    }

    defineMethod(fg => {
        fg.name = 'equals';
        fg.params = ['that'];
        fg.emit`return ${[
            `this.origin.equals(that.origin)`,
            `this.direction.equals(that.direction)`,
        ].join('&&')}`;
    });

    defineMethod(fg => {
        fg.name = 'flip';
        fg.emit`this.direction.negate()`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = 'normalize';
        fg.emit`this.direction.normalize()`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, {
            isNaN: functions_isNaN, min: functions_min, max: functions_max,
        });
        fg.name = `intersects${BoxName}`;
        fg.params = [boxName];
        fg.emit`var origin=this.origin,direction=this.direction,`;
        fg.emit    `lo=${boxName}.min,hi=${boxName}.max`;
        for (const a of as) {
            const A = a.toUpperCase();
            fg.emit`var invDirection${A}=1/direction.${a},`;
            fg.emit    `tMin${A}=(lo.${a}-origin.${a})*invDirection${A},`;
            fg.emit    `tMax${A}=(hi.${a}-origin.${a})*invDirection${A}`;
            fg.emit`if(isNaN(tMin${A})){`;
            fg.emit    `tMin${A}=0`;
            fg.emit`}`;
            fg.emit`if(isNaN(tMax${A})){`;
            fg.emit    `tMax${A}=0`;
            fg.emit`}`;
            fg.emit`if(tMin${A}>tMax${A}){`;
            fg.emit    `var t=tMin${A}`;
            fg.emit    `tMin${A}=tMax${A}`;
            fg.emit    `tMax${A}=t`;
            fg.emit`}`;
        }
        fg.emit`return max(${
            as.map(a => `tMin${a.toUpperCase()}`)
        },0)<=min(${
            as.map(a => `tMax${a.toUpperCase()}`)
        })`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, {
            sq: sq,
            difference: tmp,
        });
        fg.name = `intersects${SphereName}`;
        fg.params = [sphereName];
        fg.emit`var origin=this.origin,direction=this.direction`;
        fg.emit`difference.copy(${sphereName}.center).subtract(origin)`;
        fg.emit`if(difference.dot(direction)<=0){`;
        fg.emit    `return difference.sqLength<=sq(${sphereName}.radius)`;
        fg.emit`}`;
        fg.emit`return ${[
            'difference.cross(direction).sqLength',
            `sq(${sphereName}.radius)*direction.sqLength`,
        ].join('<=')}`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, {
            sq: sq,
            difference: tmp,
        });
        fg.name = `intersectsHalfSpace`;
        fg.params = ['halfSpace'];
        fg.emit`if(halfSpace.containsPoint(this.origin)){return true}`
        fg.emit`return halfSpace.normal.dot(this.direction)<0`
    });

    defineMethod(fg => {
        fg.name = 'translate';
        fg.params = ['translation'];
        fg.emit`this.origin.translate(translation)`;
        fg.emit`return this`;
    });

    for (const [name, ...params] of (function *() {
        yield ['scale', 'scaling'];
        yield ['scaleUniform', 'scaling'];
        yield ['shear', 'shearing'];
        yield ['reflect', 'normal'];
        yield ['rotateBetween', 'from', 'to'];
        if (d === 2) {
            yield ['rotate', 'angle'];
            yield ['applyComplex', 'complex'];
        } else {
            yield ['rotate', 'angle', 'axis'];
            yield ['applyComplex', 'complex', 'axis'];
            yield ['applyQuaternion', 'quaternion'];
        }
        yield ['applyLinearMatrix', 'matrix'];
    })()) {
        defineMethod(fg => {
            fg.name = name;
            fg.params = params;
            fg.emit`this.origin.${name}(${params})`;
            fg.emit`this.direction.${name}(${params})`;
            fg.emit`return this`;
        });
    }

    defineMethod(fg => {
        fg.name = 'applyAffineMatrix';
        fg.params = ['matrix'];
        fg.emit`this.origin.${fg.name}(${fg.params})`;
        fg.emit`this.direction.applyLinearMatrix(${fg.params})`;
        fg.emit`return this`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { center: tmp });
        fg.name = 'applyHomogeneousMatrix';
        fg.params = ['matrix'];
        fg.emit`var origin=this.origin`;
        fg.emit`this.direction.add(origin)`;
        fg.emit              `.${fg.name}(${fg.params})`;
        fg.emit              `.subtract(origin.${fg.name}(${fg.params}))`;
        fg.emit`return this`;
    });

    return Ray;
}

const Ray2 = rays_makeClass(2);
const Ray3 = rays_makeClass(3);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/spherical-coords.js




const spherical_coords_SphericalCoords = (() => {
    class SphericalCoords {
        constructor(radius = 0, longitude = 0, colatitude = 0) {
            this.radius = radius;
            this.longitude = longitude;
            this.colatitude = colatitude;
        }

        set(radius, longitude, colatitude) {
            this.radius = radius;
            this.longitude = longitude;
            this.colatitude = colatitude;
            return this;
        }

        fromSphericalCoords(sphericalCoords) {
            return this.set(sphericalCoords.radius,
                            sphericalCoords.longitude,
                            sphericalCoords.colatitude);
        }

        fromVector(vector) {
            this.radius = vector.length;
            this.longitude = atan2(vector.x, vector.z);
            this.colatitude = acos(vector.y / this.radius);
            if (functions_isNaN(this.colatitude)) { this.colatitude = 0; }
            return this;
        }
        toVector(vector) {
            const { radius, longitude, colatitude } = this;
            const radiusSinColatitude = radius * sin(colatitude);
            vector.x = radiusSinColatitude * sin(longitude);
            vector.y = radius * cos(colatitude);
            vector.z = radiusSinColatitude * cos(longitude);
            return vector;
        }

        clone() {
            return new SphericalCoords().copy(this);
        }

        equals(that) {
            return this.radius === that.radius &&
                   this.longitude === that.longitude &&
                   this.colatitude === that.colatitude;
        }
    }

    const aliasProperty =
        makePropertyAliaser(SphericalCoords.prototype);

    aliasProperty('fromSphericalCoords', 'copy');

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const Name = toTitleCase(fn.name);
        Object.defineProperties(SphericalCoords.prototype, {
            [`some${Name}`]: {
                configurable: true,
                get() {
                    return fn(this.radius) ||
                           fn(this.longitude) ||
                           fn(this.colatitude);
                },
            },
            [`every${Name}`]: {
                configurable: true,
                get() {
                    return fn(this.radius) &&
                           fn(this.longitude) &&
                           fn(this.colatitude);
                },
            },
        });
    }

    return SphericalCoords;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/rgb-color.js




const rgb_color_RGBColor = (() => {
    class RGBColor {
        constructor(r = 0, g = 0, b = 0) {
            this.r = r;
            this.g = g;
            this.b = b;
        }

        set(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        }

        fromNumber(number) {
            return this.set(number, number, number);
        }

        toGrayscale() {
            return this.r * 0.2126 + this.g * 0.7152 + this.b * 0.0722;
        }

        fromVector(vector) {
            this.r = vector.x;
            this.g = vector.y;
            this.b = vector.z;
            return this;
        }
        toVector(vector) {
            vector.x = this.r;
            vector.y = this.g;
            vector.z = this.b;
            return vector;
        }

        fromPackedInteger(value) {
            // 0.00392156862745098 == 1 / 255
            return this.set((value >> 16 & 0xFF) * 0.00392156862745098,
                            (value >>  8 & 0xFF) * 0.00392156862745098,
                            (value       & 0xFF) * 0.00392156862745098);
        }
        toPackedInteger() {
            return round(this.r * 255) << 16 |
                   round(this.g * 255) <<  8 |
                   round(this.b * 255);
        }

        fromRGBColor(rgbColor) {
            return this.set(rgbColor.r, rgbColor.g, rgbColor.b);
        }

        fromArray(array) {
            this.r = array[0];
            this.g = array[1];
            this.b = array[2];
            return this
        }
        fromArrayAt(offset, array) {
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this
        }
        toArray(array) {
            array[0] = this.r;
            array[1] = this.g;
            array[2] = this.b;
            return array;
        }
        toArrayAt(offset, array) {
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        }

        clone() {
            return new RGBColor().copy(this);
        }

        equals(that) {
            return this.r === that.r && this.g === that.g && this.b === that.b;
        }
    }

    const cs = [...'rgb'];

    const defineMethod = makeMethodDefiner(RGBColor.prototype);
    const aliasProperty = makePropertyAliaser(RGBColor.prototype);

    aliasProperty('fromNumber', 'fromGrayscale');
    aliasProperty('fromRGBColor', 'copy');

    for (const fn of [
        functions_isNaN,
        functions_isFinite,
    ]) {
        const Name = toTitleCase(fn.name);
        Object.defineProperties(RGBColor.prototype, {
            [`some${Name}`]: {
                configurable: true,
                get() { return fn(this.r) || fn(this.g) || fn(this.b); },
            },
            [`every${Name}`]: {
                configurable: true,
                get() { return fn(this.r) || fn(this.g) || fn(this.b); },
            },
        });
    }

    function defineUnaryOperation(name, rgb) {
        defineMethod(fg => {
            fg.name = name;
            rgb(fg);
            fg.emit`return this`;
        });
    }
    for (const [name, op] of [
        ['negate', '-'],
    ]) {
        defineUnaryOperation(name, fg => {
            for (const c of cs) {
                fg.emit`this.${c}=${op}this.${c}`;
            }
        });
    }
    for (const fn of [
        exp,
        expm1,
        exp2,
        exp10,
        log,
        log1p,
        log2,
        log10,
    ]) {
        const { name } = fn;
        defineUnaryOperation(name, fg => {
            fg.ctx[name] = fn;
            for (const c of cs) {
                fg.emit`this.${c}=${name}(this.${c})`;
            }
        });
    }

    function defineBinaryOperartion(name, commutative, {
        rgb, number, preNumber,
    }) {
        const Name = toTitleCase(name);

        defineMethod(fg => {
            fg.name = `${name}RGBColor`;
            fg.params = ['right'];
            rgb(fg, 'this', 'right');
            fg.emit`return this`;
        });
        defineMethod(fg => {
            fg.name = `${name}Number`;
            fg.params = ['right'];
            number(fg);
            fg.emit`return this`;
        });

        if (!commutative) {
            defineMethod(fg => {
                fg.name = `pre${Name}RGBColor`;
                fg.params = ['left'];
                rgb(fg, 'left', 'this');
                fg.emit`return this`;
            });

            defineMethod(fg => {
                fg.name = `pre${Name}Number`;
                fg.params = ['left'];
                preNumber(fg);
                fg.emit`return this`;
            });
        }
    }
    for (const [name, op, commutative] of [
        ['add'     , '+', 1],
        ['subtract', '-', 0],
        ['multiply', '*', 1],
        ['divide'  , '/', 0],
    ]) {
        const Name = toTitleCase(name);
        defineBinaryOperartion(name, commutative, {
            rgb(fg, left, right) {
                for (const c of cs) {
                    fg.emit`this.${c}=${left}.${c}${op}${right}.${c}`;
                }
            },
            number(fg) {
                if (op === '/') {
                    fg.emit`var invRight=1/right`;
                }
                for (const c of cs) {
                    if (op === '/') {
                        fg.emit`this.${c}=this.${c}*invRight`;
                    } else {
                        fg.emit`this.${c}=this.${c}${op}right`;
                    }
                }
            },
            preNumber(fg) {
                for (const c of cs) {
                    fg.emit`this.${c}=left${op}this.${c}`;
                }
            },
        });
        if (['+', '-'].includes(op)) {
            aliasProperty(`${name}RGBColor`, name);
            aliasProperty(`${name}Number`, `${name}Grayscale`);
            if (!commutative) {
                aliasProperty(`pre${Name}RGBColor`, `pre${Name}`);
                aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
            }
        }
        if (['*', '/'].includes(op)) {
            aliasProperty(`${name}Number`, `${name}Grayscale`);
            if (!commutative) {
                aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
            }
        }
    }
    for (const [fn, commutative] of [
        [pow, 0],
        [functions_min, 1],
        [functions_max, 1],
    ]) {
        const { name } = fn, Name = toTitleCase(name);
        defineBinaryOperartion(name, commutative, {
            rgb(fg, left, right) {
                fg.ctx[name] = fn;
                for (const c of cs) {
                    fg.emit`this.${c}=${name}(${left}.${c},${right}.${c})`;
                }
            },
            number(fg) {
                fg.ctx[name] = fn;
                for (const c of cs) {
                    fg.emit`this.${c}=${name}(this.${c},right)`;
                }
            },
            preNumber(fg) {
                fg.ctx[name] = fn;
                for (const c of cs) {
                    fg.emit`this.${c}=${name}(left,this.${c})`;
                }
            },
        });
        if (fn === pow) {
            aliasProperty(`${name}Number`, name);
            aliasProperty(`${name}Number`, `${name}Grayscale`);
            aliasProperty(`pre${Name}Number`, `pre${Name}Grayscale`);
        }
        if ([functions_min, functions_max].includes(fn)) {
            aliasProperty(`${name}Number`, name);
            aliasProperty(`${name}Number`, `${name}Grayscale`);
        }
    }

    defineMethod(fg => {
        Object.assign(fg.ctx, { clamp: clamp });
        fg.name = `clampRGBColors`;
        fg.params = ['low', 'high'];
        for (const c of cs) {
            fg.emit`this.${c}=clamp(this.${c},low.${c},high.${c})`;
        }
        fg.emit`return this`;
    });
    defineMethod(fg => {
        Object.assign(fg.ctx, { clamp: clamp });
        fg.name = `clampNumbers`;
        fg.params = ['low', 'high'];
        for (const c of cs) {
            fg.emit`this.${c}=clamp(this.${c},low,high)`;
        }
        fg.emit`return this`;
    });
    aliasProperty('clampNumbers', 'clamp');
    aliasProperty('clampNumbers', 'clampGrayscales');

    return RGBColor;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/cubic-hermite-interpolators.js






const cubic_hermite_interpolators_NumberCubicHermiteInterpolator = (() => {
    class NumberCubicHermiteInterpolator {
        constructor(start = 0, startTangent = 0, end = 0, endTangent = 0) {
            this.start = start;
            this.startTangent = startTangent;
            this.end = end;
            this.endTangent = endTangent;
        }

        set(start, startTangent, end, endTangent) {
            this.start = start;
            this.startTangent = startTangent;
            this.end = end;
            this.endTangent = endTangent;
            return this;
        }

        fromNumberCubicHermiteInterpolator(interpolator) {
            return this.set(interpolator.start,
                            interpolator.startTangent,
                            interpolator.end,
                            interpolator.endTangent);
        }

        fromBezierValues(p0, p1, p2, p3) {
            return this.set(p0, (p1 - p0) * 3, (p3 - p2) * 3, p3);
        }

        clone() {
            return new NumberCubicHermiteInterpolator().copy(this);
        }

        evaluate(alpha) {
            const alpha2 = alpha * alpha,
                  alpha3 = alpha * alpha2;
            const c = 3 * alpha2 - 2 * alpha3,
                  a = 1 - c,
                  b = alpha3 - 2 * alpha2 + alpha,
                  d = alpha3 - alpha2;
            return a * this.start +
                   b * this.startTangent +
                   c * this.end +
                   d * this.endTangent;
        }
    }

    const aliasProperty =
        makePropertyAliaser(NumberCubicHermiteInterpolator.prototype);

    aliasProperty('fromNumberCubicHermiteInterpolator', 'copy');

    return NumberCubicHermiteInterpolator;
})();

function makeCubicHermiteInterpolator(Value, {
    create = (fg, a) => {
        fg.emit`${a}=new ${Value.name}()`;
    },

    initialize = (fg) => {},

    copy = (fg, a, b) => {
        fg.emit`${a}.copy(${b})`;
    },

    multiplyNumber = (fg, a, b) => {
        fg.emit`${a}.multiplyNumber(${b})`;
    },

    add = (fg, a, b) => {
        fg.emit`${a}.add(${b})`;
    },

    subtract = (fg, a, b) => {
        fg.emit`${a}.subtract(${b})`;
    },
} = {}) {
    const params = ['start', 'startTangent', 'end', 'endTangent'];

    const tmp = new Value();

    const Interpolator = generateFunction(fg => {
        Object.assign(fg.ctx, { [Value.name]: Value });
        fg.name = `${Value.name}CubicHermiteInterpolator`;
        fg.params = params;
        for (const p of params) {
            create(fg, `this.${p}`);
            fg.emit`if(${p}===undefined){`;
            initialize(fg, `this.${p}`);
            fg.emit`}else{`;
            copy(fg, `this.${p}`, p);
            fg.emit`}`;
        }
    });

    const defineMethod = makeMethodDefiner(Interpolator.prototype);
    const aliasProperty = makePropertyAliaser(Interpolator.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = params;
        for (const p of params) {
            copy(fg, `this.${p}`, p);
        }
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = `from${Interpolator.name}`;
        fg.params = ['interpolator'];
        fg.emit`return this.set(${params.map(p => `interpolator.${p}`)})`;
    });
    aliasProperty(`from${Interpolator.name}`,
                  `from${Interpolator.name.slice(Value.name.length)}`);
    aliasProperty(`from${Interpolator.name}`, 'copy');

    defineMethod(fg => {
        fg.name = `fromBezierValues`;
        fg.params = ['p0', 'p1', 'p2', 'p3'];

        copy(fg, 'this.start', 'p0');
        copy(fg, 'this.startTangent', 'p1');
        subtract(fg, 'this.startTangent', 'p0');
        multiplyNumber(fg, 'this.startTangent', 3);

        copy(fg, 'this.end', 'p3');
        copy(fg, 'this.endTangent', 'p3');
        subtract(fg, 'this.endTangent', 'p2');
        multiplyNumber(fg, 'this.endTangent', 3);

        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.ctx[Interpolator.name] = Interpolator;
        fg.name = 'clone';
        fg.emit`return new ${Interpolator.name}().copy(this)`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { tmp });
        fg.name = 'evaluate';
        fg.params = ['alpha', 'result'];
        fg.emit`var alpha2=alpha*alpha,alpha3=alpha2*alpha,`;
        fg.emit    `c=3*alpha2-2*alpha3,`;
        fg.emit    `a=1-c,`;
        fg.emit    `b=alpha3-2*alpha2+alpha,`;
        fg.emit    `d=alpha3-alpha2`;

        copy(fg, 'result', 'this.start');
        multiplyNumber(fg, 'result', 'a');

        copy(fg, 'tmp', 'this.startTangent');
        multiplyNumber(fg, 'tmp', 'b');
        add(fg, 'result', 'tmp');

        copy(fg, 'tmp', 'this.end');
        multiplyNumber(fg, 'tmp', 'c');
        add(fg, 'result', 'tmp');

        copy(fg, 'tmp', 'this.endTangent');
        multiplyNumber(fg, 'tmp', 'd');
        add(fg, 'result', 'tmp');

        fg.emit`return result`;
    });

    return Interpolator;
}

const Vector2CubicHermiteInterpolator =
    makeCubicHermiteInterpolator(Vector2);
const Vector3CubicHermiteInterpolator =
    makeCubicHermiteInterpolator(Vector3);
const ComplexCubicHermiteInterpolator =
    makeCubicHermiteInterpolator(complex_Complex);
const QuaternionCubicHermiteInterpolator =
    makeCubicHermiteInterpolator(quaternion_Quaternion);
const RGBColorCubicHermiteInterpolator =
    makeCubicHermiteInterpolator(rgb_color_RGBColor);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/quaternion-slerper.js




const quaternion_slerper_QuaternionSlerper = (() => {
    const VALID = 0x01;
    const CLOSE = 0x02;

    function dot(a, b) {
        return a.re * b.re + a.imX * b.imX + a.imY * b.imY + a.imZ * b.imZ;
    }

    class QuaternionSlerper {
        constructor(start, end) {
            this._start = (start === undefined) ? new quaternion_Quaternion()
                                                : start.clone();
            this._end = (start === undefined) ? new quaternion_Quaternion()
                                              : end.clone();

            this._startFactor = 1;
            this._endFactor = 1;
            
            this._flags = 0;
            this._angle = 0;
        }

        set(start, end) {
            this._start.copy(start);
            this._end.copy(end);
            this._startFactor = 1;
            this._endFactor = 1;
            this._flags = 0;
            this._angle = 0;
            return this;
        }

        fromQuaternionSlerper(slerper) {
            this._start.copy(slerper._start)
            this._end.copy(slerper._end)
            this._startFactor = slerper._startFactor;
            this._endFactor = slerper._endFactor;
            this._flags = slerper._flags
            this._angle = slerper._angle
            return this;
        }

        clone() {
            return new QuaternionSlerper().copy(this);
        }

        startPaste(start) {
            return start.copy(this._start).multiply(this._startFactor);
        }
        startCopy(start) {
            this._start.copy(start);
            this._startFactor = 1;
            this._flags &= ~VALID;
            return this;
        }

        endPaste(end) {
            return end.copy(this._end).multiply(this._endFactor);
        }
        endCopy(end) {
            this._end.copy(end);
            this._endFactor = 1;
            this._flags &= ~VALID;
            return this;
        }

        _precompute() {
            const start = this._start;
            const end = this._end;

            let c = dot(start, end) / sqrt(start.sqAbs * end.sqAbs);
            if (c < 0) {
                c = -c;
                end.negate();
                this._endFactor = -this._endFactor;
            }
            if (c > 0.999999) {
                this._flags |= CLOSE;
            } else {
                this._flags &= ~CLOSE;
                this._angle = acos(c);
                const s = sqrt(1 - c * c);
                const invSin = 1 / s;
                start.multiplyNumber(invSin);
                end.multiplyNumber(invSin);
                this._startFactor *= s;
                this._endFactor *= s;
            }
        }

        evaluate(alpha, quaternion) {
            let flags = this._flags;
            if (!(flags & VALID)) {
                this._precompute();
                flags = (this._flags |= VALID);
            }

            const start = this._start;
            const end = this._end;

            let a, b;
            if (flags & CLOSE) {
                a = 1 - alpha;
                b = alpha;
            } else {
                const angle = this._angle;
                a = sin((1 - alpha) * angle);
                b = sin(alpha * angle);
            }

            quaternion.re = start.re * a + end.re * b;
            quaternion.imX = start.imX * a + end.imX * b;
            quaternion.imY = start.imY * a + end.imY * b;
            quaternion.imZ = start.imZ * a + end.imZ * b;

            return quaternion;
        }
    }

    const aliasProperty =
        makePropertyAliaser(QuaternionSlerper.prototype);

    aliasProperty('fromQuaternionSlerper', 'copy');

    return QuaternionSlerper;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/lerpers.js






const lerpers_NumberLerper = (() => {
    class NumberLerper {
        constructor(start = 0, end = 0) {
            this.start = start;
            this.end = end;
        }

        set(start, end) {
            this.start = start;
            this.end = end;
            return this;
        }

        fromNumberLerper(lerper) {
            return this.set(lerper.start, lerper.end);
        }

        clone() {
            return new NumberLerper().copy(this);
        }

        evaluate(alpha) {
            return this.start * (1 - alpha) + this.end * alpha;
        }
    }

    const aliasProperty = makePropertyAliaser(NumberLerper.prototype);

    aliasProperty('fromNumberLerper', 'copy');

    return NumberLerper;
})();

function makeLerper(Value, {
    create = (fg, a) => {
        fg.emit`${a}=new ${Value.name}()`;
    },

    initialize = (fg) => {},

    copy = (fg, a, b) => {
        fg.emit`${a}.copy(${b})`;
    },

    multiplyNumber = (fg, a, b) => {
        fg.emit`${a}.multiplyNumber(${b})`;
    },

    add = (fg, a, b) => {
        fg.emit`${a}.add(${b})`;
    },
} = {}) {
    const params = ['start', 'end'];

    const tmp = new Value();

    const Lerper = generateFunction(fg => {
        Object.assign(fg.ctx, { [Value.name]: Value });
        fg.name = `${Value.name}Lerper`;
        fg.params = params;
        for (const p of params) {
            create(fg, `this.${p}`);
            fg.emit`if(${p}===undefined){`;
            initialize(fg, `this.${p}`);
            fg.emit`}else{`;
            copy(fg, `this.${p}`, p);
            fg.emit`}`;
        }
    });

    const defineMethod = makeMethodDefiner(Lerper.prototype);
    const aliasProperty = makePropertyAliaser(Lerper.prototype);

    defineMethod(fg => {
        fg.name = 'set';
        fg.params = params;
        for (const p of params) {
            copy(fg, `this.${p}`, p);
        }
        fg.emit`return this`;
    });

    defineMethod(fg => {
        fg.name = `from${Lerper.name}`;
        fg.params = ['lerper'];
        fg.emit`return this.set(${params.map(p => `lerper.${p}`)})`;
    });
    aliasProperty(`from${Lerper.name}`,
                  `from${Lerper.name.slice(Value.name.length)}`);
    aliasProperty(`from${Lerper.name}`, 'copy');

    defineMethod(fg => {
        fg.ctx[Lerper.name] = Lerper;
        fg.name = 'clone';
        fg.emit`return new ${Lerper.name}().copy(this)`;
    });

    defineMethod(fg => {
        Object.assign(fg.ctx, { tmp });
        fg.name = 'evaluate';
        fg.params = ['alpha', 'result'];

        copy(fg, 'result', 'this.start');
        multiplyNumber(fg, 'result', '(1-alpha)');
        copy(fg, 'tmp', 'this.end');
        multiplyNumber(fg, 'tmp', 'alpha');
        add(fg, 'result', 'tmp');

        fg.emit`return result`;
    });

    return Lerper;
}

const Vector2Lerper = makeLerper(Vector2);
const Vector3Lerper = makeLerper(Vector3);
const ComplexLerper = makeLerper(complex_Complex);
const QuaternionLerper = makeLerper(quaternion_Quaternion);
const RGBColorLerper = makeLerper(rgb_color_RGBColor);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/math/lib/index.js
/**
 * @module @webgears-app/math
 */

















// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/mouse.js




const mouse_Mouse = (() => {
    /**
     * @namespace module:@webgears-app/input.Mouse.Buttons
     * @summary Mouse buttons.
     * @desc Other buttons are possible, but have no named entries.
     * @implements {module:@webgears-app/enum.Enum}
     * @property {number} LEFT Left button.
     * @property {number} MIDDLE Middle button.
     * @property {number} RIGHT Right button.
     */
    const Buttons = makeEnum([
        'LEFT',
        'MIDDLE',
        'RIGHT',
    ]);

    const ON_BUTTON_PRESSES = Symbol('Mouse.ON_BUTTON_PRESSES');
    const ON_BUTTON_RELEASES = Symbol('Mouse.ON_BUTTON_RELEASES');

    /**
     * @class module:@webgears-app/input.Mouse
     * @summary Mouse-like input device.
     * @abstract
     * @example
     * mouse.onMove.subscribe((delta) => {
     *     console.log(`mouse pointer moved to ${mouse.position} by ${delta}`);
     * });
     * mouse.onButtonPress(Mouse.Buttons.LEFT).subscribe(() => {
     *     console.log(`left mouse button pressed at ${mouse.position}`);
     * });
     */
    class Mouse {
        constructor() {
            Object.defineProperties(this, {
                /**
                 * @callback module:@webgears-app/input.Mouse.EnterEventSignature
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onEnter
                 * @summary Pointer entered underlying surface.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.EnterEventSignature>}
                 * @readonly
                 */
                onEnter: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Mouse.MoveEventSignature
                 * @param {module:@webgears-app/math.Vector2} delta Pointer position displacement.
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onMove
                 * @summary Pointer moved.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.MoveEventSignature>}
                 * @readonly
                 */
                onMove: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Mouse.LeaveEventSignature
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onLeave
                 * @summary Pointer left underlying surface.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.LeaveEventSignature>}
                 * @readonly
                 */
                onLeave: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Mouse.LockEventSignature
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onLock
                 * @summary Pointer locked.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.LockEventSignature>}
                 * @readonly
                 */
                onLock: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Mouse.UnlockEventSignature
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onUnlock
                 * @summary Pointer unlocked.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.UnlockEventSignature>}
                 * @readonly
                 */
                onUnlock: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Mouse.ScrollEventSignature
                 * @param {module:@webgears-app/math.Vector2} amount Scroll mount.
                 */
                /**
                 * @var module:@webgears-app/input.Mouse#onScroll
                 * @summary Wheel scrolled.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ScrollEventSignature>}
                 * @readonly
                 */
                onScroll: { value: new Event() },
            });

            this[ON_BUTTON_PRESSES] = new Map();
            this[ON_BUTTON_RELEASES] = new Map();
        }

        /**
         * @var module:@webgears-app/input.Mouse#surfaceSize
         * @summary Current size of underlying surface.
         * @type {module:@webgears-app/math.Vector2}
         * @abstract
         * @readonly
         */
        get surfaceSize() {
            console.assert(false, 'not implemented');
            return new Vector2();
        }

        /**
         * @var module:@webgears-app/input.Mouse#position
         * @summary Current pointer position.
         * @type {?module:@webgears-app/math.Vector2}
         * @readonly
         * @abstract
         */
        get position() {
            console.assert(false, 'not implemented');
            return new Vector2();
        }

        /**
         * @var module:@webgears-app/input.Mouse#isLocked
         * @summary Whether pointer is currently locked.
         * @type {boolean}
         * @readonly
         * @abstract
         */
        get isLocked() {
            console.assert(false, 'not implemented');
            return false;
        }

        /**
         * @function module:@webgears-app/input.Mouse#lock
         * @summary Lock pointer.
         * @returns {boolean} Whether pointer was locked successfully.
         * @async
         * @abstract
         */
        async lock() {
            console.assert(false, 'not implemented');
            return false;
        }

        /**
         * @function module:@webgears-app/input.Mouse#unlock
         * @summary Unlock pointer.
         * @returns {boolean} Whether pointer was unlocked successfully.
         * @async
         * @abstract
         */
        async unlock() {
            console.assert(false, 'not implemented');
            return false;
        }

        /**
         * @function module:@webgears-app/input.Mouse#isButtonPressed
         * @summary Whether button is currently pressed.
         * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
         * @returns {boolean}
         * @abstract
         */
        isButtonPressed(button) {
            console.assert(false, 'not implemented');
            return false;
        }

        /**
         * @callback module:@webgears-app/input.Mouse.ButtonPressEventSignature
         */
        /**
         * @summary Get event emitted when button is pressed.
         * @desc Must be emitted by implementation.
         * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
         * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ButtonPressEventSignature>} Button press. 
         */
        onButtonPress(button) {
            const onPresses = this[ON_BUTTON_PRESSES];
            let onPress = onPresses.get(button);
            if (onPress === undefined) {
                onPresses.set(button, (onPress = new Event()));
            }
            return onPress;
        }

        /**
         * @callback module:@webgears-app/input.Mouse.ButtonReleaseEventSignature
         */
        /**
         * @summary Get event emitted when button is relesed.
         * @desc Must be emitted by implementation.
         * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
         * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ButtonReleaseEventSignature>} Button release. 
         */
        onButtonRelease(button) {
            const onReleases = this[ON_BUTTON_RELEASES];
            let onRelease = onReleases.get(button);
            if (onRelease === undefined) {
                onReleases.set(button, (onRelease = new Event()));
            }
            return onRelease;
        }
    }

    Object.defineProperties(Mouse, {
        Buttons: { value: Buttons },
    });

    return Mouse;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/dom-mouse.js



/**
 * @class module:@webgears-app/input.DOMMouse
 * @summary Wrapper for DOM Mouse API.
 * @extends module:@webgears-app/input.Mouse
 * @param {?Document} [target=null] Target element.
 *     See {@link module:@webgears-app/input.Mouse#target}.
 */
class dom_mouse_DOMMouse extends mouse_Mouse {
    constructor(target = null) {
        super();

        this._target = null;
        this._surfaceSize = new Vector2();
        this._position = null;
        this._buttonStates = new Map();

        this.target = target;
    }

    _updatePosition(event) {
        const rect = this._target.getBoundingClientRect();
        if (this._position === null) {
            this._position = new Vector2(event.clientX - rect.left,
                                         event.clientY - rect.top);
            this.onEnter.emit();
        } else {
            this._position.set(event.clientX - rect.left,
                               event.clientY - rect.top);
        }
    }

    /**
     * @var module:@webgears-app/input.Mouse#target
     * @summary Current target element.
     * @type {?Element}
     */
    get target() {
        return this._target;
    }

    set target(target) {
        console.assert(target === null || target instanceof Element);

        if (target === this._target) { return; }

        if (this._target !== null) {
            this._unsubscribe();
            this.unlock().catch(console.error);
        }
        this._target = target;
        if (target === null) {
            this._unsubscribe = undefined;
            return;
        }
        const { ownerDocument } = target;

        const onMouseEnter = (event) => {
            this._updatePosition(event);
        };
        target.addEventListener('mouseenter', onMouseEnter);

        const onMouseMove = (event) => {
            this._updatePosition(event);
            const delta = new Vector2(event.movementX, event.movementY);
            this.onMove.emit(Object.freeze(delta));
        };
        target.addEventListener('mousemove', onMouseMove);

        const onMouseLeave = (event) => {
            this._position = null;
            for (const [button, isPressed] of this._buttonStates) {
                if (!isPressed) { continue; }
                this._buttonStates.set(button, false);
                this.onButtonRelease(button).emit();
            }
            this.onLeave.emit();
        };
        target.addEventListener('mouseleave', onMouseLeave);

        const onPointerLockChange = () => {
            (this.isLocked ? this.onLock : this.onUnlock).emit();
        }
        ownerDocument.addEventListener('pointerlockchange', onPointerLockChange);

        this._buttonStates.clear();
        const onMouseDown = (event) => {
            if (this._buttonStates.get(event.button)) { return; }
            this._buttonStates.set(event.button, true);
            this._updatePosition(event);
            if (this.onButtonPress(event.button).emit() && event.button === mouse_Mouse.Buttons.RIGHT) {
                const onContextMenu = (event) => {
                    target.removeEventListener('contextmenu', onContextMenu);
                    event.preventDefault();
                };
                target.addEventListener('contextmenu', onContextMenu);
            }
        };
        target.addEventListener('mousedown', onMouseDown);

        const onMouseUp = (event) => {
            const { button } = event;
            if (!this._buttonStates.get(button)) { return; }
            this._buttonStates.set(button, false);
            this._updatePosition(event);
            this.onButtonRelease(button).emit();
        };
        target.addEventListener('mouseup', onMouseUp);

        const onWheel = (event) => {
            this._updatePosition(event);
            const delta = new Vector2(event.deltaX, event.deltaY);
            if (this.onScroll.emit(Object.freeze(delta))) {
                event.preventDefault();
            }
        };
        target.addEventListener('wheel', onWheel);

        this._unsubscribe = () => {
            target.removeEventListener('mouseenter', onMouseEnter);
            target.removeEventListener('mousemove', onMouseMove);
            target.removeEventListener('mouseleave', onMouseLeave);
            ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);
            target.removeEventListener('mousedown', onMouseDown);
            target.removeEventListener('mouseup', onMouseUp);
            target.removeEventListener('wheel', onWheel);
        };
    }

    /**
     * @var module:@webgears-app/input.DOMMouse#surfaceSize
     * @summary Current size of underlying surface.
     * @desc Client size of element or (1, 1) for null target.
     * @type {Vector2}
     * @readonly
     */
    get surfaceSize() {
        const target = this._target;
        const surfaceSize = this._surfaceSize;
        if (target === null) { return surfaceSize.set(1, 1); }
        return surfaceSize.set(target.clientWidth, target.clientHeight);
    }

    /**
     * @var module:@webgears-app/input.DOMMouse#position
     * @summary Current pointer position.
     * @type {?module:@webgears-app/math.Vector2}
     * @readonly
     */
    get position() {
        return this._position;
    }

    /**
     * @var module:@webgears-app/input.DOMMouse#isLocked
     * @summary Whether pointer is currently locked.
     * @type {boolean}
     * @readonly
     */
    get isLocked() {
        const target = this._target;
        if (target === null) { return false; }
        return target.ownerDocument.pointerLockElement === target;
    }

    /**
     * @function module:@webgears-app/input.DOMMouse#lock
     * @summary Lock pointer.
     * @returns {boolean} Whether pointer was locked successfully.
     * @async
     */
    lock() {
        return new Promise((resolve) => {
            if (this.isLocked) { return resolve(true); }

            const target = this._target;
            if (target === null) { return false; }
            const { ownerDocument } = target;

            if (target.requestPointerLock === undefined) { return resolve(false); }

            const onChange = () => {
                unsubscribe();
                resolve(this.isLocked);
            };
            ownerDocument.addEventListener('pointerlockchange', onChange);

            const onError = () => {
                unsubscribe();
                resolve(false);
            };
            ownerDocument.addEventListener('pointerlockerror', onError);

            const unsubscribe = () => {
                ownerDocument.removeEventListener('pointerlockchange', onChange);
                ownerDocument.removeEventListener('pointerlockerror', onError);
            }
            target.requestPointerLock();
        });
    }

    /**
     * @function module:@webgears-app/input.DOMMouse#unlock
     * @summary Unlock pointer.
     * @returns {boolean} Whether pointer was unlocked successfully.
     * @async
     */
    unlock() {
        return new Promise((resolve) => {
            if (!this.isLocked) { return resolve(true); }

            const target = this._target;
            if (target === null) { return false; }
            const { ownerDocument } = target;

            const onChange = () => {
                unsubscribe();
                resolve(!this.isLocked);
            };
            ownerDocument.addEventListener('pointerlockchange', onChange);

            const onError = () => {
                unsubscribe();
                resolve(false);
            };
            ownerDocument.addEventListener('pointerlockerror', onError);

            const unsubscribe = () => {
                ownerDocument.removeEventListener('pointerlockchange', onChange);
                ownerDocument.removeEventListener('pointerlockerror', onError);
            }
            ownerDocument.exitPointerLock();
        });
    }

    /**
     * @function module:@webgears-app/input.DOMMouse#isButtonPressed
     * @summary Whether button is currently pressed.
     * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
     * @returns {boolean}
     */
    isButtonPressed(button) {
        return this._target !== null && (this._buttonStates.get(button) || false);
    }
}
/**
 * @var module:@webgears-app/input.DOMMouse#onMove
 * @summary Pointer moved.
 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.MoveEventSignature>}
 * @readonly
 */

/**
 * @var module:@webgears-app/input.DOMMouse#onLock
 * @summary Pointer locked.
 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.LockEventSignature>}
 * @readonly
 */

/**
 * @var module:@webgears-app/input.DOMMouse#onUnlock
 * @summary Pointer unlocked.
 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.UnlockEventSignature>}
 * @readonly
 */

/**
 * @var module:@webgears-app/input.DOMMouse#onScroll
 * @summary Wheel scrolled.
 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ScrollEventSignature>}
 * @readonly
 */

/**
 * @function module:@webgears-app/input.DOMMouse#onButtonPress
 * @summary Get event emitted when button is pressed.
 * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
 * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ButtonPressEventSignature>} Button press.
 */

/**
 * @function module:@webgears-app/input.DOMMouse#onButtonRelease
 * @summary Get event emitted when button is relesed.
 * @param {module:@webgears-app/input.Mouse.Buttons} button Button.
 * @returns {module:@webgears-app/event.Event.<module:@webgears-app/input.Mouse.ButtonReleaseEventSignature>} Button release.
 */

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/touchscreen.js




const touchscreen_Touchscreen = (() => {
    /**
     * @summary A touch on a {@link module:@webgears-app/input.Touchscreen}.
     * @memberof module:@webgears-app/input.Touchscreen
     * @abstract
     * @param {module:@webgears-app/input.Touchscreen} touchscreen Touchscreen this touch is happening on.
     */
    class Touch {
        constructor(touchscreen) {
            console.assert(touchscreen instanceof Touchscreen);

            Object.defineProperties(this, {
                /**
                 * @var module:@webgears-app/input.Touchscreen.Touch#touchscreen
                 * @summary Touchscreen this touch is happening on.
                 * @type {module:@webgears-app/input.Touchscreen}
                 * @readonly
                 */
                touchscreen: { value: touchscreen },
            });

            Object.defineProperties(this, {
                /**
                 * @callback module:@webgears-app/input.Touchscreen.Touch.MoveEventSignature
                 * @param {module:@webgears-app/math.Vector2} delta Touch position displacement.
                 */
                /**
                 * @var module:@webgears-app/input.Touchscreen.Touch#onMove
                 * @summary Touch moved.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Touchscreen.Touch.MoveEventSignature>}
                 * @readonly
                 */
                onMove: { value: new Event() },

                /**
                 * @callback module:@webgears-app/input.Touchscreen.Touch.EndEventSignature
                 * @param {boolean} cancelled Whether the touch has been cancelled.
                 *     E.g. the tab is switched or a pop-up interrupts focus.
                 */
                /**
                 * @var module:@webgears-app/input.Touchscreen.Touch#onEnd
                 * @summary Touch ended.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Touchscreen.Touch.EndEventSignature>}
                 * @readonly
                 */
                onEnd: { value: new Event() },
            });

            /**
             * @var module:@webgears-app/input.Touchscreen.Touch#_isEnded
             * @summary Whether the touch ended.
             * @desc Implementations must assign true to this before emitting {@link module:@webgears-app/input.Touchscreen.Touch#onEnd}. 
             * @type {boolean}
             * @protected
             * @see {@link module:@webgears-app/input.Touchscreen.Touch#isEnded} for client side.
             */
            this._isEnded = false;
        }

        /**
         * @var module:@webgears-app/input.Touchscreen.Touch#surfaceSize
         * @summary Current size of underlying surface.
         * @desc Alias for {@link module:@webgears-app/input.Touchscreen#surfaceSize}.
         * @type {module:@webgears-app/math.Vector2}
         * @readonly
         */
        get surfaceSize() {
            return this.touchscreen.surfaceSize;
        }

        /**
         * @var module:@webgears-app/input.Touchscreen.Touch#position
         * @summary Current position.
         * @type {module:@webgears-app/math.Vector2}
         * @readonly
         * @abstract
         */
        get position() {
            console.assert(false, 'not implemented');
            return new Vector2();
        }

        /**
         * @var module:@webgears-app/input.Touchscreen.Touch#isEnded
         * @summary Whether the touch ended.
         * @desc Intended for clients.
         * @type {boolean}
         * @readonly
         * @see {@link module:@webgears-app/input.Touchscreen.Touch#_isEnded} for implementation side.
         */
        get isEnded() {
            return this._isEnded;
        }
    }

    /**
     * @class module:@webgears-app/input.Touchscreen
     * @summary Touchscreen-like input device.
     * @abstract
     * @example
     * let nextTouchId = 0;
     * touchscreen.onTouchStart.subscribe(touch => {
     *     const id = nextTouchId++;
     *     console.log(`touch #${id} started at ${touch.position}`);
     *     touch.onMove.subscribe((delta) => {
     *         console.log(`touch #${id} moved to ${touch.position} by ${delta}`);
     *     });
     *     touch.onEnd.subscribe((cancelled) => {
     *         console.log(`touch #${id} ${cancelled ? 'cancelled' : 'ended normally'} at ${touch.position}`);
     *     });
     * })
     */
    class Touchscreen {
        constructor() {
            Object.defineProperties(this, {
                /**
                 * @callback module:@webgears-app/input.Touchscreen.TouchStartEventSignature
                 * @param {module:@webgears-app/input.Touchscreen.Touch} touch New touch.
                 */
                /**
                 * @var module:@webgears-app/input.Touchscreen#onTouchStart
                 * @summary New touch started.
                 * @desc Must be emitted by implementation.
                 * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Touchscreen.TouchStartEventSignature>}
                 * @readonly
                 */
                onTouchStart: { value: new Event() },
            });
        }

        /**
         * @var module:@webgears-app/input.Touchscreen#surfaceSize
         * @summary Current size of underlying surface.
         * @type {module:@webgears-app/math.Vector2}
         * @abstract
         * @readonly
         */
        get surfaceSize() {
            console.assert(false, 'not implemented');
            return new Vector2();
        }

        /**
         * @function module:@webgears-app/input.Touchscreen#touches
         * @summary Currently happening touches.
         * @generator
         * @yields {module:@webgears-app/input.Touchscreen.Touch}
         * @abstract
         */
        *touches() {
            console.assert(false, 'not implemented');
        }
    }

    Object.defineProperties(Touchscreen, {
        Touch: { value: Touch },
    });

    return Touchscreen;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/dom-touchscreen.js



const dom_touchscreen_DOMTouchscreen = (() => {
    /**
     * @summary A touch on a {@link module:@webgears-app/input.DOMTouchscreen}.
     * @alias module:@webgears-app/input.DOMTouchscreen.Touch
     * @extends module:@webgears-app/input.Touchscreen.Touch
     * @hideconstructor
     */
    class DOMTouch extends touchscreen_Touchscreen.Touch {
        constructor(touchscreen) {
            super(touchscreen);

            Object.defineProperties(this, {
                position: { value: new Vector2() },
            });
        }

        _reflect(domTouch) {
            const { target } = this.touchscreen;
            if (target instanceof Element) {
                const rect = this.touchscreen.target.getBoundingClientRect();
                this.position.set(domTouch.clientX - rect.left,
                                  domTouch.clientY - rect.top);
            } else if (target instanceof Document) {
                this.position.set(domTouch.pageX, domTouch.pageY);
            }
        }
    }
    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#touchscreen
     * @summary Touchscreen this touch is happening on.
     * @type {module:@webgears-app/input.DOMTouchscreen}
     * @readonly
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#onMove
     * @summary Touch moved.
     * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Touchscreen.Touch.MoveEventSignature>}
     * @readonly
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#onEnd
     * @summary Touch ended.
     * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.Touchscreen.Touch.EndEventSignature>}
     * @readonly
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#surfaceSize
     * @summary Current size of underlying surface.
     * @desc Client size of element, page size of document or (1, 1) for
     *     null target. Alias for {@link module:@webgears-app/input.DOMTouchscreen#surfaceSize}.
     * @type {module:@webgears-app/math.Vector2}
     * @readonly
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#position
     * @summary Current position.
     * @desc Client coordinates for element, page coordinates for
     *     document or (0, 0) for null target.
     * @type {module:@webgears-app/math.Vector2}
     * @readonly
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#_isEnded
     * @ignore
     */

    /**
     * @var module:@webgears-app/input.DOMTouchscreen.Touch#isEnded
     * @summary Whether the touch ended.
     * @type {boolean}
     * @readonly
     */

    /**
     * @class module:@webgears-app/input.DOMTouchscreen
     * @summary Wrapper for DOM Touch API.
     * @extends module:@webgears-app/input.Touchscreen
     * @param {?(Element|Document)} [target=null] Target element or document.
     *     See {@link module:@webgears-app/input.DOMTouchscreen#target}.
     */
    class DOMTouchscreen extends touchscreen_Touchscreen {
        constructor(target = null) {
            super();

            this._target = null;
            this._surfaceSize = new Vector2();
            this._touches = new Map();

            this.target = target;
        }

        /**
         * @var module:@webgears-app/input.DOMTouchscreen#target
         * @summary Current target element or document.
         * @type {?(Element|Document)}
         */
        get target() {
            return this._target;
        }

        set target(target) {
            console.assert(target === null ||
                           target instanceof Element ||
                           target instanceof Document);

            if (target === this._target) { return; }

            if (this._target !== null) {
                this._unsubscribe();
                this._cancelTouches();
            }
            this._target = target;
            if (target === null) {
                this._unsubscribe = undefined;
                return;
            }

            const onTouchStart = (event) => {
                const touches = this._touches;
                for (const domTouch of event.changedTouches) {
                    console.assert(!touches.has(domTouch.identifier));
                    const touch = new DOMTouch(this);
                    touch._reflect(domTouch);
                    touches.set(domTouch.identifier, touch);
                    if (this.onTouchStart.emit(touch)) { event.preventDefault(); }
                }
            };
            target.addEventListener('touchstart', onTouchStart, { passive: false });

            const onTouchMove = (event) => {
                const touches = this._touches;
                for (const domTouch of event.changedTouches) {
                    const touch = touches.get(domTouch.identifier);
                    if (touch === undefined) { continue; }
                    if (touch.isEnded) { continue; }
                    const delta = touch.position.clone();
                    touch._reflect(domTouch);
                    delta.negate().add(touch.position);
                    touch.onMove.emit(Object.freeze(delta));
                }
            };
            target.addEventListener('touchmove', onTouchMove);

            const onTouchEnd = (event) => {
                const touches = this._touches;
                for (const domTouch of event.changedTouches) {
                    const touch = touches.get(domTouch.identifier);
                    if (touch === undefined) { continue; }
                    if (touch.isEnded) { continue; }
                    touch._isEnded = true;
                    touch.onEnd.emit(false);
                    touches.delete(domTouch.identifier);
                }
            };
            target.addEventListener('touchend', onTouchEnd);

            const onTouchCancel = (event) => {
                this._cancelTouches();
            };
            target.addEventListener('touchcancel', onTouchCancel);

            this._unsubscribe = () => {
                target.removeEventListener('touchstart', onTouchStart);
                target.removeEventListener('touchmove', onTouchMove);
                target.removeEventListener('touchend', onTouchEnd);
                target.removeEventListener('touchcancel', onTouchCancel);
            };
        }

        /**
         * @var module:@webgears-app/input.DOMTouchscreen#surfaceSize
         * @summary Current size of underlying surface.
         * @desc Client size of element, page size of document or (1, 1) for
         *     null target.
         * @type {module:@webgears-app/math.Vector2}
         * @readonly
         */
        get surfaceSize() {
            const target = this._target;
            let width = 1, height = 1;
            if (target instanceof Element) {
                ({ clientWidth: width, clientHeight: height } = target);
            } else if (target instanceof Document) {
                ({ width, height } = target);
            }
            return this._surfaceSize.set(width, height);
        }

        /**
         * @function module:@webgears-app/input.DOMTouchscreen#touches
         * @summary Currently happening touches.
         * @generator
         * @yields {module:@webgears-app/input.DOMTouchscreen.Touch}
         */
        touches() {
            return this._touches.values();
        }

        _cancelTouches() {
            const touches = this._touches;
            for (const touch of touches.values()) {
                if (touch.isEnded) { continue; }
                touch._isEnded = true;
                touch.onEnd.emit(true);
            }
            touches.clear();
        }
    }
    /**
     * @callback module:@webgears-app/input.DOMTouchscreen.TouchStartEventSignature
     * @param {module:@webgears-app/input.DOMTouchscreen.Touch} touch New touch.
     */
    /**
     * @var module:@webgears-app/input.DOMTouchscreen#onTouchStart
     * @summary New touch started.
     * @type {module:@webgears-app/event.Event.<module:@webgears-app/input.DOMTouchscreen.TouchStartEventSignature>}
     * @readonly
     */

    Object.defineProperties(DOMTouchscreen, {
        Touch: { value: DOMTouch },
    });

    return DOMTouchscreen;
})();

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/input/lib/index.js
/**
 * @module @webgears-app/input
 */







// CONCATENATED MODULE: ./src/core/input/utils.ts
function utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



let DEVICE_TYPE;

(function (DEVICE_TYPE) {
  DEVICE_TYPE["DEVICE_TYPE_TOUCH"] = "touch";
  DEVICE_TYPE["DEVICE_TYPE_MOUSE"] = "mouse";
  DEVICE_TYPE["DEVICE_TYPE_UNKNOWN"] = "unknown";
})(DEVICE_TYPE || (DEVICE_TYPE = {}));

let POINTER_EVENTS;

(function (POINTER_EVENTS) {
  POINTER_EVENTS["POINTER_MOVE"] = "pointer-move";
  POINTER_EVENTS["POINTER_START"] = "pointer-start";
  POINTER_EVENTS["POINTER_DRAG"] = "pointer-drag";
  POINTER_EVENTS["POINTER_CLICK"] = "pointer-click";
  POINTER_EVENTS["POINTER_END"] = "pointer-end";
})(POINTER_EVENTS || (POINTER_EVENTS = {}));

function getDeviceType(device) {
  if (device instanceof dom_mouse_DOMMouse) {
    return DEVICE_TYPE.DEVICE_TYPE_MOUSE;
  }

  if (device.touchscreen) {
    return DEVICE_TYPE.DEVICE_TYPE_TOUCH;
  }

  return DEVICE_TYPE.DEVICE_TYPE_UNKNOWN;
}

function getNdc(device) {
  if (!device.position) {
    return null;
  }

  const height = device.surfaceSize.y;
  const width = device.surfaceSize.x;
  const {
    x,
    y
  } = device.position;
  return new math_lib["m" /* Vector2 */](x / width * 2 - 1, (height - y) / height * 2 - 1);
}

class ProxyDevice {
  constructor(type, device) {
    utils_defineProperty(this, "type", void 0);

    utils_defineProperty(this, "_device", void 0);

    utils_defineProperty(this, "persisted", false);

    this.type = type;
    this._device = device;
  }

  get deviceType() {
    return getDeviceType(this._device);
  }

  get position() {
    return this._device.position;
  }

  get surfaceSize() {
    return this._device.surfaceSize;
  }

  get ndc() {
    return getNdc(this._device);
  }

  persist() {
    return {
      type: this.type,
      _device: this._device,
      deviceType: this.deviceType,
      position: this.position,
      surfaceSize: this.surfaceSize,
      ndc: this.ndc,
      persisted: true,
      persist: () => this
    };
  }

}
function getDeviceEvent(type, device) {
  return new ProxyDevice(type, device);
}
class Drag {
  constructor({
    device,
    onDrag,
    onEnd
  }) {
    utils_defineProperty(this, "device", void 0);

    utils_defineProperty(this, "onDrag", void 0);

    utils_defineProperty(this, "onEnd", void 0);

    utils_defineProperty(this, "_lastPosition", void 0);

    utils_defineProperty(this, "_handleEnd", () => {
      this.onEnd(this.device);
      this.dispose();
    });

    utils_defineProperty(this, "_handleDrag", () => {
      if (!this.device.position) {
        return;
      }

      if (this._lastPosition.x === this.device.position.x && this._lastPosition.y === this.device.position.y) {
        return;
      }

      this._lastPosition.copy(this.device.position);

      this.onDrag(this.device);
    });

    utils_defineProperty(this, "dispose", () => {
      this.device.onEnd.unsubscribe(this._handleEnd);
      this.device.onMove.unsubscribe(this._handleDrag);
    });

    this.device = device;
    this.onEnd = onEnd;
    this.onDrag = onDrag;

    if (!this.device.position) {
      throw new Error('position is null');
    }

    this._lastPosition = this.device.position.clone();
    device.onMove.subscribe(this._handleDrag);
    device.onEnd.subscribe(this._handleEnd, {
      once: true
    });
  }

}
// CONCATENATED MODULE: ./src/core/input/index.ts
function input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const TIME_FOR_CLICK = 300;
const MIN_CLICK_DELTA = 3;
class input_Input {
  constructor({
    domElement
  }) {
    input_defineProperty(this, "sources", void 0);

    input_defineProperty(this, "onPointerClick", void 0);

    input_defineProperty(this, "onPointerDrag", void 0);

    input_defineProperty(this, "onPointerStart", void 0);

    input_defineProperty(this, "onPointerMove", void 0);

    input_defineProperty(this, "onPointerEnd", void 0);

    input_defineProperty(this, "_eventsByDevice", void 0);

    input_defineProperty(this, "_startTime", void 0);

    input_defineProperty(this, "_startPosition", void 0);

    if (!(domElement instanceof HTMLElement)) {
      throw new Error('domElement should be passed');
    }

    this.sources = {
      mouse: new dom_mouse_DOMMouse(domElement),
      touchscreen: new dom_touchscreen_DOMTouchscreen(domElement),
      keyboard: new dom_keyboard_DOMKeyboard(domElement)
    };
    this._eventsByDevice = new Map();
    this.onPointerClick = new global_helpers_event["a" /* Event */]();
    this.onPointerDrag = new global_helpers_event["a" /* Event */]();
    this.onPointerStart = new global_helpers_event["a" /* Event */]();
    this.onPointerMove = new global_helpers_event["a" /* Event */]();
    this.onPointerEnd = new global_helpers_event["a" /* Event */]();
    this._startTime = 0;
    this._startPosition = new math_lib["m" /* Vector2 */]();

    this._addMouseListeners();

    this._addTouchListeners();
  }

  _addMouseListeners() {
    const {
      mouse
    } = this.sources;

    this._setDeviceEvents(mouse);

    mouse.onButtonPress(mouse_Mouse.Buttons.LEFT).subscribe(() => {
      this._handlePointerStart(mouse);

      const onDrag = () => this._handlePointerDrag(mouse);

      mouse.onMove.subscribe(onDrag);
      mouse.onButtonRelease(mouse_Mouse.Buttons.LEFT).subscribe(() => {
        mouse.onMove.unsubscribe(onDrag);
      }, {
        once: true
      });
    });
    mouse.onButtonRelease(mouse_Mouse.Buttons.LEFT).subscribe(() => {
      this._checkClick(mouse);

      this._handlePointerEnd(mouse);
    });
    mouse.onMove.subscribe(() => this._handlePointerMove(mouse));
  }

  _addTouchListeners() {
    const {
      touchscreen
    } = this.sources;
    const dragsByTouches = new Map();

    const getTouches = () => [...touchscreen.touches()];

    const clearAllDrags = () => {
      getTouches().forEach(touch => {
        const drag = dragsByTouches.get(touch);

        if (drag) {
          drag.dispose();
        }
      });
    };

    touchscreen.onTouchStart.subscribe(touch => {
      const touches = getTouches();

      if (touches.length > 1) {
        clearAllDrags();
        return;
      }

      this._setDeviceEvents(touch);

      this._handlePointerStart(touch);

      const drag = new Drag({
        device: touch,
        onDrag: () => {
          this._handlePointerDrag(touch);
        },
        onEnd: () => {
          this._checkClick(touch);

          this._handlePointerEnd(touch);
        }
      });
      dragsByTouches.set(touch, drag);
    });
  }

  _handlePointerStart(device) {
    if (!device.position) {
      return;
    }

    this._startTime = performance.now();

    this._startPosition.copy(device.position);

    this.onPointerStart.emit(this._getDeviceEvent(device, POINTER_EVENTS.POINTER_START));
  }

  _handlePointerMove(device) {
    this.onPointerMove.emit(this._getDeviceEvent(device, POINTER_EVENTS.POINTER_MOVE));
  }

  _handlePointerDrag(device) {
    this.onPointerDrag.emit(this._getDeviceEvent(device, POINTER_EVENTS.POINTER_DRAG));
  }

  _handlePointerEnd(device) {
    this.onPointerEnd.emit(this._getDeviceEvent(device, POINTER_EVENTS.POINTER_END));
  }

  _setDeviceEvents(device) {
    const deviceType = getDeviceType(device);

    this._eventsByDevice.set(deviceType, {
      [POINTER_EVENTS.POINTER_START]: getDeviceEvent(POINTER_EVENTS.POINTER_START, device),
      [POINTER_EVENTS.POINTER_MOVE]: getDeviceEvent(POINTER_EVENTS.POINTER_MOVE, device),
      [POINTER_EVENTS.POINTER_DRAG]: getDeviceEvent(POINTER_EVENTS.POINTER_DRAG, device),
      [POINTER_EVENTS.POINTER_CLICK]: getDeviceEvent(POINTER_EVENTS.POINTER_CLICK, device),
      [POINTER_EVENTS.POINTER_END]: getDeviceEvent(POINTER_EVENTS.POINTER_END, device)
    });
  }

  _getDeviceEvent(device, type) {
    const deviceType = getDeviceType(device);

    const events = this._eventsByDevice.get(deviceType);

    if (!events) {
      throw new Error(`Events with ${deviceType} not found`);
    }

    return events[type];
  }

  _checkClick(device) {
    if (!device.position) {
      return;
    }

    const timeIsOver = performance.now() - this._startTime > TIME_FOR_CLICK;
    const isChangedPosition = device.position.distance(this._startPosition) > MIN_CLICK_DELTA;

    if (timeIsOver || isChangedPosition) {
      return;
    }

    this.onPointerClick.emit(this._getDeviceEvent(device, POINTER_EVENTS.POINTER_CLICK));
  }

}

input_defineProperty(input_Input, "POINTER_MOVE", POINTER_EVENTS.POINTER_MOVE);

input_defineProperty(input_Input, "POINTER_START", POINTER_EVENTS.POINTER_START);

input_defineProperty(input_Input, "POINTER_DRAG", POINTER_EVENTS.POINTER_DRAG);

input_defineProperty(input_Input, "POINTER_CLICK", POINTER_EVENTS.POINTER_CLICK);

input_defineProperty(input_Input, "POINTER_END", POINTER_EVENTS.POINTER_END);
// CONCATENATED MODULE: ./src/core/store/window.ts
var _class, _descriptor, _temp;

function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function window_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


let WindowStore = (_class = (_temp = class WindowStore {
  constructor() {
    window_defineProperty(this, "pixelRatio", 1);

    _initializerDefineProperty(this, "size", _descriptor, this);
  }

  get vertical() {
    const {
      width,
      height
    } = this.size;
    return height > width;
  }

  resize(width, height) {
    const newWidth = Math.max(1, width);
    const newHeight = Math.max(1, height);

    if (newWidth !== this.size.width || newHeight !== this.size.height) {
      this.size = {
        width: newWidth,
        height: newHeight
      };
    }
  }

}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "size", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      width: 1,
      height: 1
    };
  }
}), _applyDecoratedDescriptor(_class.prototype, "vertical", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(_class.prototype, "vertical"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "resize", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(_class.prototype, "resize"), _class.prototype)), _class);

// CONCATENATED MODULE: ./src/core/store/click.ts
var _dec, click_class, click_descriptor, click_temp;

function click_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function click_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function click_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function click_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


const EMPTY_CLICK_EVENT = {
  screenPosition: null,
  position: null,
  normal: null,
  id: null
};
let Click = (_dec = mobx_module["g" /* observable */].ref, (click_class = (click_temp = class Click {
  constructor() {
    click_initializerDefineProperty(this, "clicking", click_descriptor, this);
  }

  reset() {
    Object.assign(this.clicking, EMPTY_CLICK_EVENT);
  }

  click(id, position, screenPosition, normal) {
    this.clicking = {
      position,
      screenPosition,
      normal,
      id
    };
  }

}, click_temp), (click_descriptor = click_applyDecoratedDescriptor(click_class.prototype, "clicking", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return { ...EMPTY_CLICK_EVENT
    };
  }
}), click_applyDecoratedDescriptor(click_class.prototype, "reset", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(click_class.prototype, "reset"), click_class.prototype), click_applyDecoratedDescriptor(click_class.prototype, "click", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(click_class.prototype, "click"), click_class.prototype)), click_class));

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/platform/src/index.js
let _mobile = false;
let _tablet = false;
let _ios = false;
let _mac = false;
let _android = false;
let _windows = false;
let _cocoonjs = false;
let _xbox = false;
let _gamepads = false;
let _touch = false;

(function getPlatform() {
  const ua = navigator.userAgent;

  if (/(windows|mac os|linux|cros)/i.test(ua)) {
    _mobile = false;
  }

  if (/(mac os)/i.test(ua)) {
    _mac = true;
  }

  if (/xbox/i.test(ua)) {
    _xbox = false;
  }

  if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
    _mobile = true;
    _windows = true;
  } else if (/android/i.test(ua)) {
    _mobile = true;
    _android = true;
  } else if (/ip([ao]d|hone)/i.test(ua)) {
    _mobile = true;
    _ios = true;
  }

  if (/(ipad|tablet)/.test(ua)) {
    _mobile = false;
    _tablet = true;
  }

  if (navigator.isCocoonJS) {
    _cocoonjs = true;
  }

  _touch = 'ontouchstart' in window;
  _gamepads = 'getGamepads' in navigator;
})();

class Platform {
  static get mobile() {
    return _mobile;
  }

  static get tablet() {
    return _tablet;
  }

  static get desktop() {
    return !_mobile && !_tablet;
  }

  static get ios() {
    return _ios;
  }

  static get android() {
    return _android;
  }

  static get windows() {
    return _windows;
  }

  static get mac() {
    return _mac;
  }

  static get cocoonjs() {
    return _cocoonjs;
  }

  static get xbox() {
    return _xbox;
  }

  static get gamepads() {
    return _gamepads;
  }

  static get touchscreen() {
    return _touch;
  }

}

/* harmony default export */ var src = (Platform);
// CONCATENATED MODULE: ./src/core/store/renderer.ts
var renderer_class, renderer_descriptor, _descriptor2, _descriptor3, _descriptor4, renderer_temp;

function renderer_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function renderer_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let AAMode;

(function (AAMode) {
  AAMode["NONE"] = "NONE";
  AAMode["FXAA"] = "FXAA";
  AAMode["SSAA"] = "SSAA";
})(AAMode || (AAMode = {}));

const toByte = (size, level = 2) => size * 1024 ** level;

let RendererStore = (renderer_class = (renderer_temp = class RendererStore {
  constructor() {
    renderer_initializerDefineProperty(this, "progressiveRendererAuto", renderer_descriptor, this);

    renderer_initializerDefineProperty(this, "progressiveRenderer", _descriptor2, this);

    renderer_initializerDefineProperty(this, "stagingMemorySize", _descriptor3, this);

    renderer_initializerDefineProperty(this, "antialiasing", _descriptor4, this);
  }

  get byteLength() {
    const byteLength = toByte(this.stagingMemorySize) / 2;
    return {
      vertex: byteLength,
      element: byteLength
    };
  }

  setStagingMemorySize(value) {
    if (typeof value !== 'number') {
      return;
    }

    this.stagingMemorySize = value;
  }

  setProgressiveRenderer(options) {
    this.progressiveRenderer = Object.assign({}, this.progressiveRenderer, options);
  }

  setProgressiveRendererAuto(value) {
    if (typeof value !== 'boolean') {
      return;
    }

    this.progressiveRendererAuto = value;
  }

  setAntialiasing(options) {
    this.antialiasing = {
      mode: options.mode,
      pixelRatio: options.pixelRatio
    };
  }

}, renderer_temp), (renderer_descriptor = renderer_applyDecoratedDescriptor(renderer_class.prototype, "progressiveRendererAuto", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return true;
  }
}), _descriptor2 = renderer_applyDecoratedDescriptor(renderer_class.prototype, "progressiveRenderer", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: true,
      maxDrawcalls: 512
    };
  }
}), _descriptor3 = renderer_applyDecoratedDescriptor(renderer_class.prototype, "stagingMemorySize", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return src.desktop ? 64 * 2 : 48 * 2;
  }
}), _descriptor4 = renderer_applyDecoratedDescriptor(renderer_class.prototype, "antialiasing", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      mode: AAMode.FXAA,
      pixelRatio: window.devicePixelRatio > 1 ? 1 : 2
    };
  }
}), renderer_applyDecoratedDescriptor(renderer_class.prototype, "byteLength", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(renderer_class.prototype, "byteLength"), renderer_class.prototype), renderer_applyDecoratedDescriptor(renderer_class.prototype, "setStagingMemorySize", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(renderer_class.prototype, "setStagingMemorySize"), renderer_class.prototype), renderer_applyDecoratedDescriptor(renderer_class.prototype, "setProgressiveRenderer", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(renderer_class.prototype, "setProgressiveRenderer"), renderer_class.prototype), renderer_applyDecoratedDescriptor(renderer_class.prototype, "setProgressiveRendererAuto", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(renderer_class.prototype, "setProgressiveRendererAuto"), renderer_class.prototype), renderer_applyDecoratedDescriptor(renderer_class.prototype, "setAntialiasing", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(renderer_class.prototype, "setAntialiasing"), renderer_class.prototype)), renderer_class);

// CONCATENATED MODULE: ./src/core/store/base-store.ts
var base_store_class, _class2, base_store_temp;

function base_store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function base_store_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

/* eslint-disable @typescript-eslint/no-explicit-any */
 // Proposal legacy type

let base_store_Store = (base_store_class = (base_store_temp = _class2 = class Store {
  constructor() {
    base_store_defineProperty(this, "error", null);
  }

  reset() {
    const Class = this.constructor;

    for (const key in Class.initialState) {
      if (key in this) {
        // @ts-ignore
        this[key] = this.getInitialProp(key);
      }
    }
  }

  get isReady() {
    return true;
  }

  get isError() {
    return false;
  }

  getInitialProp(key) {
    var _Class$initialState$k, _Class$initialState;

    const Class = this.constructor;
    return (_Class$initialState$k = (_Class$initialState = Class.initialState)[key]) === null || _Class$initialState$k === void 0 ? void 0 : _Class$initialState$k.call(_Class$initialState);
  }

}, base_store_defineProperty(_class2, "initialState", void 0), base_store_temp), (base_store_applyDecoratedDescriptor(base_store_class.prototype, "reset", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(base_store_class.prototype, "reset"), base_store_class.prototype)), base_store_class);
 // property decorator

function resettable(target, key, descriptor) {
  const Class = target.constructor;
  Class.initialState = { ...Class.initialState,
    [key]: descriptor === null || descriptor === void 0 ? void 0 : descriptor.initializer
  };
}
// CONCATENATED MODULE: ./src/core/store/section-box.ts
var section_box_dec, _dec2, section_box_class, section_box_descriptor, section_box_descriptor2, section_box_descriptor3, section_box_temp;

function section_box_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function section_box_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function section_box_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function section_box_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let section_box_SectionBoxStore = (section_box_dec = mobx_module["g" /* observable */].ref, _dec2 = mobx_module["g" /* observable */].ref, (section_box_class = (section_box_temp = class SectionBoxStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    section_box_initializerDefineProperty(this, "enabled", section_box_descriptor, this);

    section_box_initializerDefineProperty(this, "min", section_box_descriptor2, this);

    section_box_initializerDefineProperty(this, "max", section_box_descriptor3, this);
  }

  get restrictions() {
    return {
      min: this.min,
      max: this.max
    };
  }

  set({
    min,
    max,
    enabled = true
  }) {
    this.min = min;
    this.max = max;
    this.enabled = enabled;
  }

  setEnabled(flag) {
    this.enabled = flag;
  }

  updateRestrictions(min, max) {
    if (!this.min || !this.max) {
      return;
    }

    this.min.copy(min);
    this.max.copy(max);
  }

}, section_box_temp), (section_box_descriptor = section_box_applyDecoratedDescriptor(section_box_class.prototype, "enabled", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), section_box_descriptor2 = section_box_applyDecoratedDescriptor(section_box_class.prototype, "min", [section_box_dec, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), section_box_descriptor3 = section_box_applyDecoratedDescriptor(section_box_class.prototype, "max", [_dec2, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), section_box_applyDecoratedDescriptor(section_box_class.prototype, "restrictions", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(section_box_class.prototype, "restrictions"), section_box_class.prototype), section_box_applyDecoratedDescriptor(section_box_class.prototype, "set", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(section_box_class.prototype, "set"), section_box_class.prototype), section_box_applyDecoratedDescriptor(section_box_class.prototype, "setEnabled", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(section_box_class.prototype, "setEnabled"), section_box_class.prototype), section_box_applyDecoratedDescriptor(section_box_class.prototype, "updateRestrictions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(section_box_class.prototype, "updateRestrictions"), section_box_class.prototype)), section_box_class));

// CONCATENATED MODULE: ./src/core/store/stats.ts
var stats_class, stats_descriptor, stats_descriptor2, stats_descriptor3, stats_descriptor4, _descriptor5, stats_temp;

function stats_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function stats_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function stats_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function stats_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


const defaultStyle = {
  position: 'absolute',
  left: '0',
  top: '0'
};
let stats_StatsStore = (stats_class = (stats_temp = class StatsStore {
  constructor() {
    stats_initializerDefineProperty(this, "enabled", stats_descriptor, this);

    stats_initializerDefineProperty(this, "extensionRegistered", stats_descriptor2, this);

    stats_initializerDefineProperty(this, "needsUpdate", stats_descriptor3, this);

    stats_initializerDefineProperty(this, "systemsNeedsUpdate", stats_descriptor4, this);

    stats_initializerDefineProperty(this, "style", _descriptor5, this);

    Object(mobx_module["l" /* when */])(() => this.enabled, () => {
      if (!this.extensionRegistered && this.enabled) {
        // eslint-disable-next-line no-console
        console.warn('Can\'t enable stats, because its not registered as extension');
      }
    });
  }

  get works() {
    return this.extensionRegistered && this.enabled;
  }

  setNeedsUpdate(value) {
    this.needsUpdate = value;
  }

  setSystemsNeedsUpdate(value) {
    this.systemsNeedsUpdate = value;
  }

  registerExtension() {
    this.extensionRegistered = true;
  }

  setEnabled(value) {
    this.enabled = value;
  }

  setStyle(value) {
    this.style = value === null ? defaultStyle : value;
  }

}, stats_temp), (stats_descriptor = stats_applyDecoratedDescriptor(stats_class.prototype, "enabled", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), stats_descriptor2 = stats_applyDecoratedDescriptor(stats_class.prototype, "extensionRegistered", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), stats_descriptor3 = stats_applyDecoratedDescriptor(stats_class.prototype, "needsUpdate", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), stats_descriptor4 = stats_applyDecoratedDescriptor(stats_class.prototype, "systemsNeedsUpdate", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor5 = stats_applyDecoratedDescriptor(stats_class.prototype, "style", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultStyle;
  }
}), stats_applyDecoratedDescriptor(stats_class.prototype, "works", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "works"), stats_class.prototype), stats_applyDecoratedDescriptor(stats_class.prototype, "setNeedsUpdate", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "setNeedsUpdate"), stats_class.prototype), stats_applyDecoratedDescriptor(stats_class.prototype, "setSystemsNeedsUpdate", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "setSystemsNeedsUpdate"), stats_class.prototype), stats_applyDecoratedDescriptor(stats_class.prototype, "registerExtension", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "registerExtension"), stats_class.prototype), stats_applyDecoratedDescriptor(stats_class.prototype, "setEnabled", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "setEnabled"), stats_class.prototype), stats_applyDecoratedDescriptor(stats_class.prototype, "setStyle", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(stats_class.prototype, "setStyle"), stats_class.prototype)), stats_class);

// CONCATENATED MODULE: ./src/core/store/color.ts
var color_class, color_descriptor, color_descriptor2, color_temp;

function color_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function color_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function color_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function color_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



var ColorStatus;

(function (ColorStatus) {
  ColorStatus[ColorStatus["Pending"] = 0] = "Pending";
  ColorStatus[ColorStatus["Ready"] = 1] = "Ready";
  ColorStatus[ColorStatus["Error"] = 2] = "Error";
})(ColorStatus || (ColorStatus = {}));

let color_ColorStore = (color_class = (color_temp = class ColorStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    color_defineProperty(this, "coloredObjects", null);

    color_initializerDefineProperty(this, "status", color_descriptor, this);

    color_initializerDefineProperty(this, "error", color_descriptor2, this);
  }

  colorObjects(coloredObjects) {
    this.coloredObjects = coloredObjects;
    this.status = ColorStatus.Pending;
    this.error = null;
  }

  setReady() {
    this.status = ColorStatus.Ready;
    this.coloredObjects = null;
  }

  setError(error) {
    this.status = ColorStatus.Error;
    this.error = error;
  }

  get isPending() {
    return this.status === ColorStatus.Pending;
  }

  get isReady() {
    return this.status === ColorStatus.Ready;
  }

  get isError() {
    return this.status === ColorStatus.Error;
  }

}, color_temp), (color_descriptor = color_applyDecoratedDescriptor(color_class.prototype, "status", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return ColorStatus.Ready;
  }
}), color_descriptor2 = color_applyDecoratedDescriptor(color_class.prototype, "error", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), color_applyDecoratedDescriptor(color_class.prototype, "colorObjects", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(color_class.prototype, "colorObjects"), color_class.prototype), color_applyDecoratedDescriptor(color_class.prototype, "setReady", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(color_class.prototype, "setReady"), color_class.prototype), color_applyDecoratedDescriptor(color_class.prototype, "setError", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(color_class.prototype, "setError"), color_class.prototype), color_applyDecoratedDescriptor(color_class.prototype, "isPending", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(color_class.prototype, "isPending"), color_class.prototype), color_applyDecoratedDescriptor(color_class.prototype, "isReady", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(color_class.prototype, "isReady"), color_class.prototype), color_applyDecoratedDescriptor(color_class.prototype, "isError", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(color_class.prototype, "isError"), color_class.prototype)), color_class);

// EXTERNAL MODULE: ./src/global-helpers/index.ts + 13 modules
var global_helpers = __webpack_require__(6);

// CONCATENATED MODULE: ./src/core/store/select.ts
var select_class, select_descriptor, select_descriptor2, select_descriptor3, select_descriptor4, select_temp;

function select_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function select_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function select_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




let SelectStatus;

(function (SelectStatus) {
  SelectStatus[SelectStatus["Selecting"] = 0] = "Selecting";
  SelectStatus[SelectStatus["Coloring"] = 1] = "Coloring";
  SelectStatus[SelectStatus["Ready"] = 2] = "Ready";
  SelectStatus[SelectStatus["Error"] = 3] = "Error";
})(SelectStatus || (SelectStatus = {}));

let SelectionMode;

(function (SelectionMode) {
  SelectionMode["NONE"] = "none";
  SelectionMode["SINGLE"] = "single";
  SelectionMode["MULTI"] = "multi";
})(SelectionMode || (SelectionMode = {}));

const defaultColor = 'ff0000';
let select_SelectStore = (select_class = (select_temp = class SelectStore extends base_store_Store {
  constructor({
    structure
  }) {
    super();

    select_defineProperty(this, "_structure", void 0);

    select_defineProperty(this, "_selectedSet", void 0);

    select_defineProperty(this, "isModelLoaded", false);

    select_initializerDefineProperty(this, "color", select_descriptor, this);

    select_initializerDefineProperty(this, "status", select_descriptor2, this);

    select_initializerDefineProperty(this, "mode", select_descriptor3, this);

    select_initializerDefineProperty(this, "error", select_descriptor4, this);

    this._structure = structure;
    this._selectedSet = null;

    this._addListeners();
  }

  _addListeners() {
    Object(mobx_module["h" /* reaction */])(() => this.color, async () => {
      if (this.isModelLoaded) {
        this.status = SelectStatus.Coloring;
      }
    });
  }

  setMode(mode) {
    this.mode = mode || this.getInitialProp('mode');
  }

  setColor(color) {
    this.color = color || defaultColor;
  }

  clickToObject(objectId) {
    let elements;
    let selected;

    switch (this.mode) {
      case 'single':
        this.selectObjects(objectId !== null ? [objectId] : null);
        break;

      case 'multi':
        if (objectId === null) {
          break;
        }

        if (!this._structure.has(objectId)) {
          break;
        }

        selected = this._structure.getGroup('select');

        if (!selected) {
          selected = this._structure.addGroup('select');
        }

        this._selectedSet = selected;
        elements = this._structure.get(objectId);

        for (const element of elements) {
          if (this._structure.hasInGroup('select', element)) {
            this._structure.removeFromGroup('select', element);
          } else {
            this._structure.addToGroup('select', element);
          }
        }

        this.status = SelectStatus.Selecting;
        break;

      default:
        break;
    }
  }

  selectObjects(objectIdArray) {
    this.error = null;

    if (!this._structure.hasGroup('select')) {
      this._structure.addGroup('select');
    }

    this._selectedSet = this._structure.popGroup('select');

    if (objectIdArray) {
      for (const objectId of objectIdArray) {
        if (!this._structure.has(objectId)) {
          continue;
        }

        const elements = this._structure.get(objectId);

        this._structure.addToGroup('select', elements);
      }
    }

    if (!Object(global_helpers["w" /* isEqualSet */])(this._selectedSet, this._structure.getGroupStrict('select'))) {
      this.status = SelectStatus.Selecting;
    }
  }

  setReady() {
    this.status = SelectStatus.Ready;
  }

  setError(error) {
    this.status = SelectStatus.Error;
    this.error = error;
  }

  get isPending() {
    return this.status === SelectStatus.Coloring || this.status === SelectStatus.Selecting;
  }

  get isSelecting() {
    return this.status === SelectStatus.Selecting;
  }

  get isReady() {
    return this.status === SelectStatus.Ready;
  }

  get isError() {
    return this.status === SelectStatus.Error;
  }

}, select_temp), (select_descriptor = select_applyDecoratedDescriptor(select_class.prototype, "color", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultColor;
  }
}), select_descriptor2 = select_applyDecoratedDescriptor(select_class.prototype, "status", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return SelectStatus.Ready;
  }
}), select_descriptor3 = select_applyDecoratedDescriptor(select_class.prototype, "mode", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return SelectionMode.SINGLE;
  }
}), select_descriptor4 = select_applyDecoratedDescriptor(select_class.prototype, "error", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), select_applyDecoratedDescriptor(select_class.prototype, "setMode", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "setMode"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "setColor", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "setColor"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "clickToObject", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "clickToObject"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "selectObjects", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "selectObjects"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "setReady", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "setReady"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "setError", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(select_class.prototype, "setError"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "isPending", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(select_class.prototype, "isPending"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "isSelecting", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(select_class.prototype, "isSelecting"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "isReady", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(select_class.prototype, "isReady"), select_class.prototype), select_applyDecoratedDescriptor(select_class.prototype, "isError", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(select_class.prototype, "isError"), select_class.prototype)), select_class);

// CONCATENATED MODULE: ./src/core/store/filter.ts
var filter_dec, filter_class, filter_descriptor, filter_descriptor2, filter_descriptor3, filter_descriptor4, filter_descriptor5, _descriptor6, filter_temp;

function filter_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function filter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function filter_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function filter_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



var FilterStatus;

(function (FilterStatus) {
  FilterStatus[FilterStatus["Pending"] = 0] = "Pending";
  FilterStatus[FilterStatus["Ready"] = 1] = "Ready";
  FilterStatus[FilterStatus["Error"] = 2] = "Error";
})(FilterStatus || (FilterStatus = {}));

let filter_FilterStore = (filter_dec = mobx_module["g" /* observable */].ref, (filter_class = (filter_temp = class FilterStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    filter_initializerDefineProperty(this, "ghostMode", filter_descriptor, this);

    filter_initializerDefineProperty(this, "iterative", filter_descriptor2, this);

    filter_initializerDefineProperty(this, "blacklist", filter_descriptor3, this);

    filter_initializerDefineProperty(this, "filteredObjects", filter_descriptor4, this);

    filter_initializerDefineProperty(this, "error", filter_descriptor5, this);

    filter_initializerDefineProperty(this, "status", _descriptor6, this);
  }

  filterObjects(filteredObjects, options = {}) {
    const {
      blacklist = false,
      iterative = false
    } = options;
    this.iterative = iterative;
    this.blacklist = filteredObjects ? blacklist : !blacklist;
    this.filteredObjects = filteredObjects || new Set();
    this.status = FilterStatus.Pending;
    this.error = null;
  }

  setGhostMode(options) {
    this.ghostMode = { ...this.ghostMode,
      ...options
    };
  }

  setReady() {
    this.status = FilterStatus.Ready;
  }

  setError(error) {
    this.status = FilterStatus.Error;
    this.error = error;
  }

  get isPending() {
    return this.status === FilterStatus.Pending;
  }

  get isReady() {
    return this.status === FilterStatus.Ready;
  }

  get isError() {
    return this.status === FilterStatus.Error;
  }

}, filter_temp), (filter_descriptor = filter_applyDecoratedDescriptor(filter_class.prototype, "ghostMode", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: false,
      color: '000000',
      opacity: 0.02
    };
  }
}), filter_descriptor2 = filter_applyDecoratedDescriptor(filter_class.prototype, "iterative", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), filter_descriptor3 = filter_applyDecoratedDescriptor(filter_class.prototype, "blacklist", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return true;
  }
}), filter_descriptor4 = filter_applyDecoratedDescriptor(filter_class.prototype, "filteredObjects", [filter_dec, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return new Set();
  }
}), filter_descriptor5 = filter_applyDecoratedDescriptor(filter_class.prototype, "error", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), _descriptor6 = filter_applyDecoratedDescriptor(filter_class.prototype, "status", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return FilterStatus.Ready;
  }
}), filter_applyDecoratedDescriptor(filter_class.prototype, "filterObjects", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "filterObjects"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "setGhostMode", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "setGhostMode"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "setReady", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "setReady"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "setError", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "setError"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "isPending", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "isPending"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "isReady", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "isReady"), filter_class.prototype), filter_applyDecoratedDescriptor(filter_class.prototype, "isError", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(filter_class.prototype, "isError"), filter_class.prototype)), filter_class));

// CONCATENATED MODULE: ./src/core/store/controls.ts
var controls_dec, controls_dec2, _dec3, _dec4, _dec5, _dec6, controls_class, controls_descriptor, controls_descriptor2, controls_descriptor3, controls_descriptor4, controls_descriptor5, controls_descriptor6, _descriptor7, _descriptor8, _descriptor9, controls_temp;

function controls_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function controls_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function controls_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function controls_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




const defaultControllerConfig = {
  bbox: new math_lib["e" /* Box */](),
  target: {
    x: 443,
    y: 0,
    z: -43
  },
  enableControls: true,
  enableDamping: true,
  enableMoving: true,
  enableDollying: true,
  enableRotation: true,
  enablePanning: true,
  restrictRotation: true,
  restrictDollying: true,
  minDistance: 5,
  maxDistance: 20000,
  maxLatitude: Math.PI / 360,
  minLatitude: Math.PI / 2,
  minLongitude: -2 * Math.PI,
  maxLongitude: 2 * Math.PI,
  dollyingSpeed: 1,
  rotationSpeed: 1,
  panningSpeed: 1,
  dampingFactor: 0.64
};
var ActionType;

(function (ActionType) {
  ActionType[ActionType["ZOOMING"] = 1] = "ZOOMING";
  ActionType[ActionType["ROTATING"] = 2] = "ROTATING";
  ActionType[ActionType["PANNING"] = 4] = "PANNING";
})(ActionType || (ActionType = {}));

let controls_ControlsStore = (controls_dec = mobx_module["g" /* observable */].ref, controls_dec2 = mobx_module["g" /* observable */].ref, _dec3 = mobx_module["g" /* observable */].ref, _dec4 = mobx_module["g" /* observable */].ref, _dec5 = mobx_module["g" /* observable */].ref, _dec6 = mobx_module["g" /* observable */].ref, (controls_class = (controls_temp = class ControlsStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    controls_defineProperty(this, "defaultControllerConfig", defaultControllerConfig);

    controls_defineProperty(this, "ActionType", ActionType);

    controls_initializerDefineProperty(this, "actions", controls_descriptor, this);

    controls_initializerDefineProperty(this, "enabled", controls_descriptor2, this);

    controls_initializerDefineProperty(this, "keyboard", controls_descriptor3, this);

    controls_initializerDefineProperty(this, "zoom", controls_descriptor4, this);

    controls_initializerDefineProperty(this, "rotation", controls_descriptor5, this);

    controls_initializerDefineProperty(this, "panning", controls_descriptor6, this);

    controls_initializerDefineProperty(this, "damping", _descriptor7, this);

    controls_initializerDefineProperty(this, "target", _descriptor8, this);

    controls_initializerDefineProperty(this, "bbox", _descriptor9, this);
  }

  get isZooming() {
    return Boolean(this.actions & ActionType.ZOOMING);
  }

  get isRotating() {
    return Boolean(this.actions & ActionType.ROTATING);
  }

  get isPanning() {
    return Boolean(this.actions & ActionType.PANNING);
  }

  setActions(zooming, rotating, panning) {
    this.actions = 0;
    this.actions |= zooming ? ActionType.ZOOMING : 0;
    this.actions |= rotating ? ActionType.ROTATING : 0;
    this.actions |= panning ? ActionType.PANNING : 0;
  }

  setOptions(options) {
    const {
      enabled = this.enabled,
      keyboard = this.keyboard
    } = options;
    this.enabled = enabled;
    this.keyboard = keyboard;
    this.zoom = this._normalizeOptions(options.zoom, this.zoom);
    this.rotation = this._normalizeOptions(options.rotation, this.rotation);
    this.panning = this._normalizeOptions(options.panning, this.panning);
    this.damping = this._normalizeOptions(options.damping, this.damping);
  }

  setTarget(target) {
    this.target = target;
  }

  setBBox(value) {
    this.bbox = value;
  }

  _normalizeOptions(options, definedOptions) {
    if (options === undefined) {
      return definedOptions;
    }

    if (typeof options === 'boolean') {
      return { ...definedOptions,
        enabled: Boolean(options)
      };
    }

    return { ...definedOptions,
      ...options
    };
  }

}, controls_temp), (controls_descriptor = controls_applyDecoratedDescriptor(controls_class.prototype, "actions", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 0;
  }
}), controls_descriptor2 = controls_applyDecoratedDescriptor(controls_class.prototype, "enabled", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultControllerConfig.enableControls;
  }
}), controls_descriptor3 = controls_applyDecoratedDescriptor(controls_class.prototype, "keyboard", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultControllerConfig.enableMoving;
  }
}), controls_descriptor4 = controls_applyDecoratedDescriptor(controls_class.prototype, "zoom", [controls_dec, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: defaultControllerConfig.enableDollying,
      speed: defaultControllerConfig.dollyingSpeed,
      minDistance: defaultControllerConfig.minDistance,
      maxDistance: defaultControllerConfig.maxDistance
    };
  }
}), controls_descriptor5 = controls_applyDecoratedDescriptor(controls_class.prototype, "rotation", [controls_dec2, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: defaultControllerConfig.enableRotation,
      speed: defaultControllerConfig.rotationSpeed,
      minPolarAngle: defaultControllerConfig.maxLatitude,
      maxPolarAngle: defaultControllerConfig.minLatitude
    };
  }
}), controls_descriptor6 = controls_applyDecoratedDescriptor(controls_class.prototype, "panning", [_dec3, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: defaultControllerConfig.enablePanning,
      speed: defaultControllerConfig.panningSpeed
    };
  }
}), _descriptor7 = controls_applyDecoratedDescriptor(controls_class.prototype, "damping", [_dec4, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      enabled: defaultControllerConfig.enableDamping,
      factor: defaultControllerConfig.dampingFactor
    };
  }
}), _descriptor8 = controls_applyDecoratedDescriptor(controls_class.prototype, "target", [_dec5, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultControllerConfig.target;
  }
}), _descriptor9 = controls_applyDecoratedDescriptor(controls_class.prototype, "bbox", [_dec6, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultControllerConfig.bbox;
  }
}), controls_applyDecoratedDescriptor(controls_class.prototype, "isZooming", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "isZooming"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "isRotating", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "isRotating"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "isPanning", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "isPanning"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "setActions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "setActions"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "setOptions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "setOptions"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "setTarget", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "setTarget"), controls_class.prototype), controls_applyDecoratedDescriptor(controls_class.prototype, "setBBox", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(controls_class.prototype, "setBBox"), controls_class.prototype)), controls_class));

// CONCATENATED MODULE: ./src/core/store/camera.ts
var camera_dec, camera_class, camera_descriptor, camera_temp;

function camera_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function camera_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function camera_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function camera_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




let camera_CameraStore = (camera_dec = mobx_module["g" /* observable */].ref, (camera_class = (camera_temp = class CameraStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    camera_initializerDefineProperty(this, "options", camera_descriptor, this);
  }

  get yfov() {
    return this.options.fov * Math.PI / 180;
  }

  get position() {
    return this.options.position;
  }

  set(options) {
    this.options = { ...this.options,
      ...options
    };
  }

}, camera_temp), (camera_descriptor = camera_applyDecoratedDescriptor(camera_class.prototype, "options", [camera_dec, resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      position: {
        x: 1064,
        y: 487,
        z: -647
      },
      zfar: 40000,
      znear: 0.1,
      aperture: 7.9,
      shutterSpeed: 0.008,
      ISO: 100,
      expComp: 2,
      projectionType: lib["f" /* Camera */].ProjectionTypes.PERSPECTIVE,
      fov: 72
    };
  }
}), camera_applyDecoratedDescriptor(camera_class.prototype, "yfov", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(camera_class.prototype, "yfov"), camera_class.prototype), camera_applyDecoratedDescriptor(camera_class.prototype, "position", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(camera_class.prototype, "position"), camera_class.prototype), camera_applyDecoratedDescriptor(camera_class.prototype, "set", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(camera_class.prototype, "set"), camera_class.prototype)), camera_class));

// CONCATENATED MODULE: ./src/core/store/load.ts
var load_class, load_descriptor, load_descriptor2, load_temp;

function load_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function load_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function load_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function load_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


let LOADING_STATE;

(function (LOADING_STATE) {
  LOADING_STATE[LOADING_STATE["NONE"] = 0] = "NONE";
  LOADING_STATE[LOADING_STATE["LOADING"] = 1] = "LOADING";
  LOADING_STATE[LOADING_STATE["PREPARING"] = 2] = "PREPARING";
  LOADING_STATE[LOADING_STATE["LOADED"] = 3] = "LOADED";
})(LOADING_STATE || (LOADING_STATE = {}));

const defaultProgress = {
  loaded: 0,
  total: 1,
  chunksTotal: null,
  chunksLoaded: 0
};
let LoadStore = (load_class = (load_temp = class LoadStore {
  constructor() {
    load_initializerDefineProperty(this, "loadedStatus", load_descriptor, this);

    load_initializerDefineProperty(this, "progress", load_descriptor2, this);

    load_defineProperty(this, "url", '');
  }

  resetProgress() {
    this.progress = { ...defaultProgress
    };
  }

  setProgress(progress) {
    this.progress = { ...this.progress,
      ...progress
    };
  }

  setUrl(url) {
    this.url = url;
  }

  setStatus(status) {
    this.loadedStatus = status;
  }

  get isLoaded() {
    return this.loadedStatus === LOADING_STATE.LOADED;
  }

  get isNone() {
    return this.loadedStatus === LOADING_STATE.NONE;
  }

  get isLoading() {
    return this.loadedStatus === LOADING_STATE.LOADING;
  }

  get isPreparing() {
    return this.loadedStatus === LOADING_STATE.PREPARING;
  }

}, load_temp), (load_descriptor = load_applyDecoratedDescriptor(load_class.prototype, "loadedStatus", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return LOADING_STATE.NONE;
  }
}), load_descriptor2 = load_applyDecoratedDescriptor(load_class.prototype, "progress", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return { ...defaultProgress
    };
  }
}), load_applyDecoratedDescriptor(load_class.prototype, "resetProgress", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(load_class.prototype, "resetProgress"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "setProgress", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(load_class.prototype, "setProgress"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "setUrl", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(load_class.prototype, "setUrl"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "setStatus", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(load_class.prototype, "setStatus"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "isLoaded", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(load_class.prototype, "isLoaded"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "isNone", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(load_class.prototype, "isNone"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "isLoading", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(load_class.prototype, "isLoading"), load_class.prototype), load_applyDecoratedDescriptor(load_class.prototype, "isPreparing", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(load_class.prototype, "isPreparing"), load_class.prototype)), load_class);

// CONCATENATED MODULE: ./src/core/store/hover.ts
var hover_class, hover_descriptor, hover_descriptor2, hover_descriptor3, hover_temp;

function hover_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function hover_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hover_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function hover_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




const EPS = 0.1 ** 8;
const publicVector = new math_lib["n" /* Vector3 */]();
let hover_HoverStore = (hover_class = (hover_temp = class HoverStore extends base_store_Store {
  constructor({
    apiEvents,
    axes
  }) {
    super();

    hover_defineProperty(this, "_apiEvents", void 0);

    hover_defineProperty(this, "_axes", void 0);

    hover_defineProperty(this, "_position", new math_lib["n" /* Vector3 */]());

    hover_initializerDefineProperty(this, "instanceId", hover_descriptor, this);

    hover_initializerDefineProperty(this, "hoveredObject", hover_descriptor2, this);

    hover_initializerDefineProperty(this, "measuredHover", hover_descriptor3, this);

    this._apiEvents = apiEvents;
    this._axes = axes;
  }

  get position() {
    return this.hoveredObject !== null ? this._position : null;
  }

  setHover(hoveredObject, position) {
    if (this.hoveredObject === hoveredObject && this._position.distance(position) < EPS) {
      return;
    } // TODO Move it from here


    this._position.copy(position);

    publicVector.copy(this._position);
    publicVector.multiplyLinearMatrix(this._axes.coordinateSystemMatrix);
    this.hoveredObject = hoveredObject;

    this._apiEvents.fireEvent('hover', {
      type: 'hover',
      id: this.hoveredObject,
      position: this.hoveredObject !== null ? publicVector : null
    });

    if (this.measuredHover) {
      this.measuredHover = null;

      this._apiEvents.fireEvent('measure.hover', {
        type: 'measure.hover',
        id: null
      });
    }
  }

  setMeasureHover(hover) {
    if (this.measuredHover === hover) {
      return;
    }

    this.measuredHover = hover;

    this._apiEvents.fireEvent('measure.hover', {
      type: 'measure.hover',
      id: this.measuredHover
    });

    if (this.hoveredObject) {
      this.hoveredObject = null;

      this._apiEvents.fireEvent('hover', {
        type: 'hover',
        id: null,
        position: null
      });
    }
  }

}, hover_temp), (hover_descriptor = hover_applyDecoratedDescriptor(hover_class.prototype, "instanceId", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), hover_descriptor2 = hover_applyDecoratedDescriptor(hover_class.prototype, "hoveredObject", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), hover_descriptor3 = hover_applyDecoratedDescriptor(hover_class.prototype, "measuredHover", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), hover_applyDecoratedDescriptor(hover_class.prototype, "setHover", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(hover_class.prototype, "setHover"), hover_class.prototype), hover_applyDecoratedDescriptor(hover_class.prototype, "setMeasureHover", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(hover_class.prototype, "setMeasureHover"), hover_class.prototype)), hover_class);

// CONCATENATED MODULE: ./src/core/store/explode.ts
var explode_class, explode_descriptor, explode_temp;

function explode_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function explode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function explode_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function explode_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let explode_ExplodeStore = (explode_class = (explode_temp = class ExplodeStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    explode_initializerDefineProperty(this, "config", explode_descriptor, this);
  }

  setConfig(options) {
    const defaultOptions = this.getInitialProp('config');
    this.config = Object.assign({}, defaultOptions, options);
  }

}, explode_temp), (explode_descriptor = explode_applyDecoratedDescriptor(explode_class.prototype, "config", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      progress: 0,
      force: 2,
      center: null
    };
  }
}), explode_applyDecoratedDescriptor(explode_class.prototype, "setConfig", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(explode_class.prototype, "setConfig"), explode_class.prototype)), explode_class);

// EXTERNAL MODULE: /home/kirill/projects/industrial/utils/measures/src/index.ts
var measures_src = __webpack_require__(75);

// CONCATENATED MODULE: ./src/core/store/measure.ts
var measure_dec, measure_dec2, measure_class, measure_descriptor, measure_descriptor2, measure_descriptor3, measure_descriptor4, measure_descriptor5, measure_descriptor6, measure_descriptor7, measure_temp;

function measure_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function measure_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function measure_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function measure_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let MeasureStore = (measure_dec = mobx_module["g" /* observable */].ref, measure_dec2 = mobx_module["g" /* observable */].ref, (measure_class = (measure_temp = class MeasureStore {
  constructor() {
    measure_initializerDefineProperty(this, "mode", measure_descriptor, this);

    measure_initializerDefineProperty(this, "selectionMode", measure_descriptor2, this);

    measure_initializerDefineProperty(this, "defaultColor", measure_descriptor3, this);

    measure_initializerDefineProperty(this, "fontFamily", measure_descriptor4, this);

    measure_initializerDefineProperty(this, "samples", measure_descriptor5, this);

    measure_initializerDefineProperty(this, "sampleDescriptions", measure_descriptor6, this);

    measure_initializerDefineProperty(this, "selected", measure_descriptor7, this);
  }

  setMode(mode) {
    this.mode = mode;
  }

  setSamples(samples) {
    const sampleDescriptions = new Map();

    for (const sample of samples) {
      sampleDescriptions.set(sample.id, sample);
    }

    this.sampleDescriptions = sampleDescriptions;
  }

  addSample(sample) {
    this.samples.set(sample.id, sample);
  }

  deleteSample(sample) {
    this.samples.delete(sample.id);
  }

  clearSamples() {
    this.samples.clear();
    this.selected.clear();
  }

  selectSamples(sampleIds, updateSelected = false) {
    if (updateSelected) {
      this.selected.clear();
      sampleIds.forEach(id => this.selected.add(id));
    } else {
      this.selected = new Set([...sampleIds]);
    }
  }

  setOptions(options) {
    const {
      selectionMode,
      defaultColor,
      fontFamily
    } = options;

    if (selectionMode !== undefined) {
      this.selectionMode = selectionMode;
    }

    if (defaultColor !== undefined) {
      this.defaultColor = defaultColor;
    }

    if (fontFamily) {
      this.fontFamily = fontFamily;
    }
  }

}, measure_temp), (measure_descriptor = measure_applyDecoratedDescriptor(measure_class.prototype, "mode", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'view';
  }
}), measure_descriptor2 = measure_applyDecoratedDescriptor(measure_class.prototype, "selectionMode", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'single';
  }
}), measure_descriptor3 = measure_applyDecoratedDescriptor(measure_class.prototype, "defaultColor", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return measures_src["Sample"].DEFAULT_COLOR;
  }
}), measure_descriptor4 = measure_applyDecoratedDescriptor(measure_class.prototype, "fontFamily", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'Arial';
  }
}), measure_descriptor5 = measure_applyDecoratedDescriptor(measure_class.prototype, "samples", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return new Map();
  }
}), measure_descriptor6 = measure_applyDecoratedDescriptor(measure_class.prototype, "sampleDescriptions", [measure_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return new Map();
  }
}), measure_descriptor7 = measure_applyDecoratedDescriptor(measure_class.prototype, "selected", [measure_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return new Set();
  }
}), measure_applyDecoratedDescriptor(measure_class.prototype, "setMode", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "setMode"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "setSamples", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "setSamples"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "addSample", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "addSample"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "deleteSample", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "deleteSample"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "clearSamples", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "clearSamples"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "selectSamples", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "selectSamples"), measure_class.prototype), measure_applyDecoratedDescriptor(measure_class.prototype, "setOptions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(measure_class.prototype, "setOptions"), measure_class.prototype)), measure_class));

// CONCATENATED MODULE: ./src/core/store/navigation-cube.ts
var navigation_cube_class, navigation_cube_descriptor, navigation_cube_descriptor2, navigation_cube_descriptor3, navigation_cube_descriptor4, navigation_cube_temp;

function navigation_cube_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function navigation_cube_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function navigation_cube_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function navigation_cube_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let navigation_cube_NavigationCube = (navigation_cube_class = (navigation_cube_temp = class NavigationCube extends base_store_Store {
  constructor(...args) {
    super(...args);

    navigation_cube_initializerDefineProperty(this, "enabled", navigation_cube_descriptor, this);

    navigation_cube_initializerDefineProperty(this, "position", navigation_cube_descriptor2, this);

    navigation_cube_initializerDefineProperty(this, "offset", navigation_cube_descriptor3, this);

    navigation_cube_initializerDefineProperty(this, "size", navigation_cube_descriptor4, this);
  }

  setOptions(options) {
    const {
      enabled,
      position,
      offset,
      size
    } = options;

    if (enabled !== undefined) {
      this.enabled = enabled;
    }

    if (position !== undefined) {
      this.position = position;
    }

    if (offset !== undefined) {
      this.offset = offset;
    }

    if (size !== undefined) {
      this.size = size;
    }
  }

  getOptions() {
    const {
      x,
      y
    } = this.offset;
    return {
      enabled: this.enabled,
      position: this.position,
      offset: {
        x,
        y
      },
      size: this.size
    };
  }

}, navigation_cube_temp), (navigation_cube_descriptor = navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "enabled", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), navigation_cube_descriptor2 = navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "position", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'BOTTOM_RIGHT';
  }
}), navigation_cube_descriptor3 = navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "offset", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      x: 0,
      y: 0
    };
  }
}), navigation_cube_descriptor4 = navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "size", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 175;
  }
}), navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "setOptions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(navigation_cube_class.prototype, "setOptions"), navigation_cube_class.prototype), navigation_cube_applyDecoratedDescriptor(navigation_cube_class.prototype, "getOptions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(navigation_cube_class.prototype, "getOptions"), navigation_cube_class.prototype)), navigation_cube_class);

// EXTERNAL MODULE: ./src/presets/default.ts + 1 modules
var presets_default = __webpack_require__(86);

// CONCATENATED MODULE: ./src/core/store/environment.ts
var environment_class, environment_descriptor, environment_descriptor2, environment_descriptor3, environment_temp;

function environment_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function environment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function environment_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function environment_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




let EnvironmentStatus;

(function (EnvironmentStatus) {
  EnvironmentStatus[EnvironmentStatus["Pending"] = 0] = "Pending";
  EnvironmentStatus[EnvironmentStatus["Ready"] = 1] = "Ready";
  EnvironmentStatus[EnvironmentStatus["Error"] = 2] = "Error";
})(EnvironmentStatus || (EnvironmentStatus = {}));

let environment_Environment = (environment_class = (environment_temp = class Environment extends base_store_Store {
  constructor(...args) {
    super(...args);

    environment_initializerDefineProperty(this, "ibl", environment_descriptor, this);

    environment_initializerDefineProperty(this, "status", environment_descriptor2, this);

    environment_initializerDefineProperty(this, "error", environment_descriptor3, this);
  }

  set(preset) {
    this.ibl = { ...this.ibl,
      ...preset.ibl
    };
    this.status = EnvironmentStatus.Pending;
    this.error = null;
  }

  setReady() {
    this.status = EnvironmentStatus.Ready;
  }

  setPending() {
    this.status = EnvironmentStatus.Pending;
  }

  setError(error) {
    this.status = EnvironmentStatus.Error;
    this.error = error;
  }

  get isPending() {
    return this.status === EnvironmentStatus.Pending;
  }

  get isReady() {
    return this.status === EnvironmentStatus.Ready;
  }

  get isError() {
    return this.status === EnvironmentStatus.Error;
  }

}, environment_temp), (environment_descriptor = environment_applyDecoratedDescriptor(environment_class.prototype, "ibl", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return presets_default["default"].environment.ibl;
  }
}), environment_descriptor2 = environment_applyDecoratedDescriptor(environment_class.prototype, "status", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return EnvironmentStatus.Ready;
  }
}), environment_descriptor3 = environment_applyDecoratedDescriptor(environment_class.prototype, "error", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return null;
  }
}), environment_applyDecoratedDescriptor(environment_class.prototype, "set", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "set"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "setReady", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "setReady"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "setPending", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "setPending"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "setError", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "setError"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "isPending", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "isPending"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "isReady", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "isReady"), environment_class.prototype), environment_applyDecoratedDescriptor(environment_class.prototype, "isError", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(environment_class.prototype, "isError"), environment_class.prototype)), environment_class);

// CONCATENATED MODULE: ./src/core/store/theme.ts
var theme_class, theme_descriptor, theme_temp;

function theme_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function theme_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function theme_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


const defaultTheme = {
  background: 'transparent'
};
let Theme = (theme_class = (theme_temp = class Theme {
  constructor() {
    theme_initializerDefineProperty(this, "currentTheme", theme_descriptor, this);
  }

  set(theme) {
    this.currentTheme = { ...theme
    };
  }

}, theme_temp), (theme_descriptor = theme_applyDecoratedDescriptor(theme_class.prototype, "currentTheme", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultTheme;
  }
}), theme_applyDecoratedDescriptor(theme_class.prototype, "set", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(theme_class.prototype, "set"), theme_class.prototype)), theme_class);

// CONCATENATED MODULE: ./src/core/store/sectoring.ts
var sectoring_class, sectoring_descriptor, sectoring_descriptor2, sectoring_temp;

function sectoring_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function sectoring_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function sectoring_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function sectoring_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }


let sectoring_Sectoring = (sectoring_class = (sectoring_temp = class Sectoring {
  constructor() {
    sectoring_initializerDefineProperty(this, "enabled", sectoring_descriptor, this);

    sectoring_initializerDefineProperty(this, "color", sectoring_descriptor2, this);
  }

  setEnabled(value) {
    this.enabled = value;
  }

  setColor(color) {
    this.color = color;
  }

}, sectoring_temp), (sectoring_descriptor = sectoring_applyDecoratedDescriptor(sectoring_class.prototype, "enabled", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), sectoring_descriptor2 = sectoring_applyDecoratedDescriptor(sectoring_class.prototype, "color", [mobx_module["g" /* observable */]], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return '000000';
  }
}), sectoring_applyDecoratedDescriptor(sectoring_class.prototype, "setEnabled", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(sectoring_class.prototype, "setEnabled"), sectoring_class.prototype), sectoring_applyDecoratedDescriptor(sectoring_class.prototype, "setColor", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(sectoring_class.prototype, "setColor"), sectoring_class.prototype)), sectoring_class);

// CONCATENATED MODULE: ./src/core/store/axes.ts
var axes_dec, axes_dec2, axes_dec3, axes_dec4, axes_dec5, axes_class, axes_descriptor, axes_descriptor2, axes_descriptor3, axes_descriptor4, axes_descriptor5, axes_temp;

function axes_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function axes_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function axes_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }




let CoordinateSystem;

(function (CoordinateSystem) {
  CoordinateSystem["Y_UP"] = "Y_UP";
  CoordinateSystem["Z_UP"] = "Z_UP";
})(CoordinateSystem || (CoordinateSystem = {}));

const matrixBySystem = {
  [CoordinateSystem.Y_UP]: new math_lib["h" /* LinearMatrix3 */](1, 0, 0, 0, 1, 0, 0, 0, 1),
  [CoordinateSystem.Z_UP]: new math_lib["h" /* LinearMatrix3 */](1, 0, 0, 0, 0, 1, 0, -1, 0)
};
const positionVector = new math_lib["n" /* Vector3 */]();
let axes_AxesStore = (axes_dec = mobx_module["g" /* observable */].ref, axes_dec2 = mobx_module["g" /* observable */].ref, axes_dec3 = mobx_module["g" /* observable */].ref, axes_dec4 = mobx_module["g" /* observable */].ref, axes_dec5 = mobx_module["g" /* observable */].ref, (axes_class = (axes_temp = class AxesStore {
  constructor() {
    axes_initializerDefineProperty(this, "showOrigin", axes_descriptor, this);

    axes_initializerDefineProperty(this, "coordinateSystem", axes_descriptor2, this);

    axes_initializerDefineProperty(this, "coordinateSystemMatrix", axes_descriptor3, this);

    axes_initializerDefineProperty(this, "coordinateSystemMatrixInverted", axes_descriptor4, this);

    axes_initializerDefineProperty(this, "axesColors", axes_descriptor5, this);

    Object(mobx_module["c" /* autorun */])(() => {
      this.coordinateSystemMatrixInverted.copy(this.coordinateSystemMatrix).invert();
    });
  }

  setOriginVisibility(visible) {
    this.showOrigin = visible;
  }

  setCoordinateSystem(coordinateSystem) {
    this.coordinateSystemMatrix = matrixBySystem[coordinateSystem];
    this.coordinateSystem = coordinateSystem;
  }

  setAxesColors(axesColors) {
    this.axesColors = axesColors;
  }

  getInternalPosition(position) {
    positionVector.copy(position).multiplyLinearMatrix(this.coordinateSystemMatrixInverted);
    return Object(global_helpers["q" /* getVector3Like */])(positionVector);
  }

  getExternalPosition(position) {
    positionVector.copy(position).multiplyLinearMatrix(this.coordinateSystemMatrix);
    return Object(global_helpers["q" /* getVector3Like */])(positionVector);
  }

}, axes_temp), (axes_descriptor = axes_applyDecoratedDescriptor(axes_class.prototype, "showOrigin", [axes_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), axes_descriptor2 = axes_applyDecoratedDescriptor(axes_class.prototype, "coordinateSystem", [axes_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return CoordinateSystem.Y_UP;
  }
}), axes_descriptor3 = axes_applyDecoratedDescriptor(axes_class.prototype, "coordinateSystemMatrix", [axes_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return matrixBySystem[CoordinateSystem.Y_UP];
  }
}), axes_descriptor4 = axes_applyDecoratedDescriptor(axes_class.prototype, "coordinateSystemMatrixInverted", [axes_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return new math_lib["h" /* LinearMatrix3 */]();
  }
}), axes_descriptor5 = axes_applyDecoratedDescriptor(axes_class.prototype, "axesColors", [axes_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return {
      x: new math_lib["k" /* RGBColor */](1, 0, 0),
      y: new math_lib["k" /* RGBColor */](0, 1, 0),
      z: new math_lib["k" /* RGBColor */](0, 0, 1)
    };
  }
}), axes_applyDecoratedDescriptor(axes_class.prototype, "setOriginVisibility", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(axes_class.prototype, "setOriginVisibility"), axes_class.prototype), axes_applyDecoratedDescriptor(axes_class.prototype, "setCoordinateSystem", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(axes_class.prototype, "setCoordinateSystem"), axes_class.prototype), axes_applyDecoratedDescriptor(axes_class.prototype, "setAxesColors", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(axes_class.prototype, "setAxesColors"), axes_class.prototype)), axes_class));

// CONCATENATED MODULE: ./src/core/store/edges.ts
var edges_class, edges_descriptor, edges_descriptor2, edges_descriptor3, edges_descriptor4, edges_temp;

function edges_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function edges_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function edges_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function edges_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



var EdgesStatus;

(function (EdgesStatus) {
  EdgesStatus[EdgesStatus["Pending"] = 0] = "Pending";
  EdgesStatus[EdgesStatus["Ready"] = 1] = "Ready";
  EdgesStatus[EdgesStatus["Error"] = 2] = "Error";
})(EdgesStatus || (EdgesStatus = {}));

const edges_defaultColor = '202020';
const defaultThresholdAngle = 45;
let edges_EdgesStore = (edges_class = (edges_temp = class EdgesStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    edges_initializerDefineProperty(this, "enabled", edges_descriptor, this);

    edges_initializerDefineProperty(this, "thresholdAngle", edges_descriptor2, this);

    edges_initializerDefineProperty(this, "color", edges_descriptor3, this);

    edges_initializerDefineProperty(this, "status", edges_descriptor4, this);
  }

  setOptions(options) {
    const {
      enabled,
      color = edges_defaultColor,
      thresholdAngle = defaultThresholdAngle
    } = options;
    this.enabled = enabled;
    this.color = color;
    this.thresholdAngle = thresholdAngle;
    this.status = EdgesStatus.Pending;
    this.error = null;
  }

  setReady() {
    this.status = EdgesStatus.Ready;
  }

  setError(error) {
    this.status = EdgesStatus.Error;
    this.error = error;
  }

  get isPending() {
    return this.status === EdgesStatus.Pending;
  }

  get isReady() {
    return this.status === EdgesStatus.Ready;
  }

  get isError() {
    return this.status === EdgesStatus.Error;
  }

}, edges_temp), (edges_descriptor = edges_applyDecoratedDescriptor(edges_class.prototype, "enabled", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), edges_descriptor2 = edges_applyDecoratedDescriptor(edges_class.prototype, "thresholdAngle", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return defaultThresholdAngle;
  }
}), edges_descriptor3 = edges_applyDecoratedDescriptor(edges_class.prototype, "color", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return edges_defaultColor;
  }
}), edges_descriptor4 = edges_applyDecoratedDescriptor(edges_class.prototype, "status", [mobx_module["g" /* observable */], resettable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return EdgesStatus.Ready;
  }
}), edges_applyDecoratedDescriptor(edges_class.prototype, "setOptions", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "setOptions"), edges_class.prototype), edges_applyDecoratedDescriptor(edges_class.prototype, "setReady", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "setReady"), edges_class.prototype), edges_applyDecoratedDescriptor(edges_class.prototype, "setError", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "setError"), edges_class.prototype), edges_applyDecoratedDescriptor(edges_class.prototype, "isPending", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "isPending"), edges_class.prototype), edges_applyDecoratedDescriptor(edges_class.prototype, "isReady", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "isReady"), edges_class.prototype), edges_applyDecoratedDescriptor(edges_class.prototype, "isError", [mobx_module["d" /* computed */]], Object.getOwnPropertyDescriptor(edges_class.prototype, "isError"), edges_class.prototype)), edges_class);

// CONCATENATED MODULE: ./src/core/store/debug.ts
var debug_dec, debug_class, debug_descriptor, debug_temp;

function debug_initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

function debug_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function debug_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

function debug_initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }



let debug_DebugStore = (debug_dec = mobx_module["g" /* observable */].ref, (debug_class = (debug_temp = class DebugStore extends base_store_Store {
  constructor(...args) {
    super(...args);

    debug_initializerDefineProperty(this, "logsEnabled", debug_descriptor, this);
  }

  setLogsEnabled(value) {
    this.logsEnabled = value;
  }

}, debug_temp), (debug_descriptor = debug_applyDecoratedDescriptor(debug_class.prototype, "logsEnabled", [debug_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return true;
  }
}), debug_applyDecoratedDescriptor(debug_class.prototype, "setLogsEnabled", [mobx_module["b" /* action */]], Object.getOwnPropertyDescriptor(debug_class.prototype, "setLogsEnabled"), debug_class.prototype)), debug_class));

// CONCATENATED MODULE: ./src/core/store/index.ts
function store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























Object(mobx_module["e" /* configure */])({
  isolateGlobalState: true
});
class store_Store {
  constructor({
    structure,
    apiEvents
  }) {
    store_defineProperty(this, "load", void 0);

    store_defineProperty(this, "window", void 0);

    store_defineProperty(this, "click", void 0);

    store_defineProperty(this, "renderer", void 0);

    store_defineProperty(this, "sectionBox", void 0);

    store_defineProperty(this, "stats", void 0);

    store_defineProperty(this, "color", void 0);

    store_defineProperty(this, "select", void 0);

    store_defineProperty(this, "hover", void 0);

    store_defineProperty(this, "filter", void 0);

    store_defineProperty(this, "controls", void 0);

    store_defineProperty(this, "camera", void 0);

    store_defineProperty(this, "explode", void 0);

    store_defineProperty(this, "navigationCube", void 0);

    store_defineProperty(this, "environment", void 0);

    store_defineProperty(this, "theme", void 0);

    store_defineProperty(this, "measure", void 0);

    store_defineProperty(this, "sectoring", void 0);

    store_defineProperty(this, "axes", void 0);

    store_defineProperty(this, "edges", void 0);

    store_defineProperty(this, "debug", void 0);

    this.axes = new axes_AxesStore();
    this.edges = new edges_EdgesStore();
    this.load = new LoadStore();
    this.window = new WindowStore();
    this.click = new Click();
    this.renderer = new RendererStore();
    this.sectionBox = new section_box_SectionBoxStore();
    this.stats = new stats_StatsStore();
    this.color = new color_ColorStore();
    this.select = new select_SelectStore({
      structure
    });
    this.filter = new filter_FilterStore();
    this.controls = new controls_ControlsStore();
    this.camera = new camera_CameraStore();
    this.hover = new hover_HoverStore({
      apiEvents,
      axes: this.axes
    });
    this.explode = new explode_ExplodeStore();
    this.navigationCube = new navigation_cube_NavigationCube();
    this.environment = new environment_Environment();
    this.theme = new Theme();
    this.measure = new MeasureStore();
    this.sectoring = new sectoring_Sectoring();
    this.debug = new debug_DebugStore();

    this._addListeners();
  }

  _addListeners() {
    Object(mobx_module["h" /* reaction */])(() => this.load.isLoaded, isLoaded => {
      if (!isLoaded) {
        this.reset();
      }

      this.select.isModelLoaded = isLoaded;
    });
  }

  reset() {
    this.click.reset();
    this.sectionBox.reset();
    this.color.reset();
    this.select.reset();
    this.filter.reset();
    this.hover.reset();
    this.explode.reset();
    this.environment.reset();
    this.navigationCube.reset();
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/disposeableUsageCounter.js



/**
 * @class module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary Implements reference counting pattern.
 * @abstract
 */
class disposeableUsageCounter_DisposableUsageCounter {
    constructor() {
        this._useCount = 1;
        this._loadCount = 1;
        this._loadRequests = [];
        this._unloadRequestCount = 0;

        this._actuallyLoad = () => {};
    }

    _dispose() {
        this._emitDisposeEvent();
    }

    retain() {
        console.assert(this._useCount > 0); // , 'retaining already disposed object');
        ++this._useCount;
        return this;
    }

    release() {
        console.assert(this._useCount > 0); // 'releasing already disposed object');
        if (--this._useCount === 0) {
            this._dispose();
        }
    }

    async _loadDependencies() {}

    _actuallyUnload() {
        this._emitUnloadEvent();
    }

    load(amount = 1) {
        return new Promise((resolve, reject) => {
            if (this._loadCount > 0) {
                this._loadCount += amount;
                resolve(this);
                return;
            }

            this._loadRequests.push({resolve, reject, amount});
            if (this._loadRequests.length === 1) {
                (async () => {
                    await this._loadDependencies();
                    await this._actuallyLoad();
                })().then(() => {
                    for (const { resolve, amount } of this._loadRequests) {
                        this._loadCount += amount;
                        resolve(this);
                    }
                    this._loadRequests.length = 0;
                    this._emitLoadEvent();

                    this._loadCount -= this._unloadRequestCount;
                    this._unloadRequestCount = 0;
                    if (this._loadCount === 0) {
                        this._actuallyUnload();
                    }
                }).catch(error => {
                    for (const { reject } of this._loadRequests) {
                        reject(error);
                    }
                    this._loadRequests.length = 0;
                    this._unloadRequestCount = 0;
                });
            }
        });
    }

    unload(amount = 1) {
        console.assert(this._loadCount >= this._unloadRequestCount + amount);
        // , 'unloading already unloaded object');

        if (this.loading) {
            this._unloadRequestCount += amount;
        } else {
            this._loadCount -= amount;
            if (this._loadCount === 0) {
                this._actuallyUnload();
            }
        }
    }

    resetEvents() {
        delete this._onLoad;
        delete this._onUnload;
        delete this._onDispose;
    }

    get unloaded() {
        return this._loadCount === 0;
    }

    get loading() {
        return this._loadRequests.length > 0;
    }

    get onUnload() {
        return this._onUnload === undefined ? (this._onUnload = new Event()) : this._onUnload; // eslint-disable-line
    }

    get onLoad() {
        return this._onLoad === undefined ? (this._onLoad = new Event()) : this._onLoad; // eslint-disable-line
    }

    get onDispose() {
        return this._onDispose === undefined ? (this._onDispose = new Event()) : this._onDispose; // eslint-disable-line
    }

    _emitLoadEvent() {
        if (this._onLoad !== undefined) this._onLoad.emit();
    }

    _emitUnloadEvent() {
        if (this._onUnload !== undefined) this._onUnload.emit();
    }

    _emitDisposeEvent() {
        if (this._onDispose !== undefined) this._onDispose.emit();
    }
}

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#retain
 * @summary Increase usage counter
 * @returns this
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#release
 * @summary Decrease usage counter and dispose the object if counter gets to zero.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#_loadDependencies
 * @protected
 * @async
 * @summary Loads all dependencies required to consider this object fully loaded.
 * @desc Derived classes are supposed to override this when required. Typically
 * will just call
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter#load}
 * on all members that are themselves instances of
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter}.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#_actuallyLoad
 * @type {function}
 * @async
 * @protected
 * @summary The function to load this object itself.
 * @desc Default value does nothing. Particular loaders are supposed to assign
 * actual loading function, which will load the object entirely, or pull what it
 * needs from dependencies, which are already loaded by that point.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#_actuallyUnload
 * @protected
 * @async
 * @summary Unloads this object and dependencies.
 * @desc Derived classes are suppoed to override this when required. Typically
 * will just call
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter#unload}
 * on all members that are themselves instances of
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter}.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#load
 * @summary Load the object.
 * @desc If the object is not loaded and not loading, starts loading it by calling
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter#_loadDependencies}
 * followed by
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter#_actuallyLoad}
 * and increments the load counter once it is loaded. Otherwise, if the the object
 * is already loading, increments the load counter once it is loaded. Otherwise
 * (the object is already loaded), simply increments the load counter.
 * @param {number} [amount=1] How much to increment the load counter.
 * @async
 * @returns A promise that resolves once the object is loaded, or
 * rejects if the loading has failed.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#unloaded
 * @type {boolean}
 * @summary Whether the object is unloaded.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#loading
 * @type {boolean}
 * @summary Whether the object is currently loading.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#unload
 * @summary Unload the object.
 * @desc Decrements load counter. If it becomes zero, calls
 * {@link module:@webgears-app/engine-core.DisposableUsageCounter#_actuallyUnload}
 * @param {number} [amount=1] How much to decrement the load counter.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#_dispose
 * @abstract
 * @protected
 * @summary Dispose the objects.
 * @desc Derived class must provide the implementation.
 */

/**
 * @function module:@webgears-app/engine-core.DisposableUsageCounter#resetEvents
 * @summary removes all subscribers and reset event.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#onDispose
 * @type {module:@webgears-app/event.Event}
 * @readonly
 * @summary On dispose event.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#onLoad
 * @type {module:@webgears-app/event.Event}
 * @readonly
 * @summary Fires after the object becomes loaded.
 */

/**
 * @var module:@webgears-app/engine-core.DisposableUsageCounter#onUnload
 * @type {module:@webgears-app/event.Event}
 * @readonly
 * @summary Fires after the object becomes unloaded.
 */



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/containers/lib/tuple-map.js
class Node extends Map {
    constructor() {
        super();

        this.key = null;
        this.value = undefined;
        this.previous = null;
        this.next = null;
    }
}

class TupleMap {
    constructor(entries) {
        this._size = 0;
        this._root = new Node();
        this._first = null;
        this._last = null;
        if (entries !== undefined) {
            for (const [key, value] of entries) {
                this.set(key, value);
            }
        }
    }

    get size() { return this._size; }

    set(key, value) {
        // eslint-disable-next-line no-param-reassign
        key = [...key];
        let node = this._root;
        for (const subkey of key) {
            let child = node.get(subkey);
            if (child === undefined) {
                child = new Node();
                node.set(subkey, child);
            }
            node = child;
        }
        if (node.key === null) {
            const last = this._last;
            if (last === null) {
                this._first = node;
                this._last = node;
            } else {
                last.next = node;
                node.previous = last;
                this._last = node;
            }
            ++this._size;
        }
        node.key = key;
        node.value = value;
    }

    has(key) {
        let node = this._root;
        for (const subkey of key) {
            const child = node.get(subkey);
            if (child === undefined) { return false; }
            node = child;
        }
        return node.key !== null;
    }

    get(key) {
        let node = this._root;
        for (const subkey of key) {
            const child = node.get(subkey);
            if (child === undefined) { return; }
            node = child;
        }
        if (node.key === null) { return; }
        return node.value;
    }

    _delete(node, key) {
        const it = key.next();
        if (it.done) {
            if (node.key !== null) {
                const { previous, next } = node;
                if (previous === null) {
                    this._first = next;
                } else {
                    previous.next = next;
                }
                if (next === null) {
                    this._last = previous;
                } else {
                    next.previous = previous;
                }
                --this._size;
            }
            node.key = null;
            node.value = null;
            return;
        }
        const subkey = it.value;
        const child = node.get(subkey);
        if (child === undefined) { return; }
        this._delete(child, key);
        if (child.key === null && child.size === 0) { node.delete(subkey); }
    }

    delete(key) {
        this._delete(this._root, key[Symbol.iterator]());
    }

    clear() {
        this._size = 0;

        const root = this._root;
        root.clear();
        root.key = null;
        root.value = null;
        root.previous = null;
        root.next = null;

        this._first = null;
        this._last = null;
    }

    forEach(callback, thisArg) {
        for (let node = this._first; node !== null; node = node.next) {
            if (this._first === null) { break; }
            callback.call(thisArg, node.value, node.key.slice(), this);
        }
    }

    *keys() {
        for (let node = this._first; node !== null; node = node.next) {
            if (this._first === null) { break; }
            yield node.key.slice();
        }
    }

    *values() {
        for (let node = this._first; node !== null; node = node.next) {
            if (this._first === null) { break; }
            yield node.value;
        }
    }

    *entries() {
        for (let node = this._first; node !== null; node = node.next) {
            if (this._first === null) { break; }
            yield [node.key.slice(), node.value];
        }
    }

    [Symbol.iterator]() {
        return this.entries();
    }
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/instancedBatch.js

const needsUpdateFlag = 1;
const excludedFlag = 2;

/**
 * @class module:@webgears-app/engine-core.InstancedBatch
 * @param {number} instanceId Unique identifier of the instances of that batch.
 * @summary Class describes batch of instances.
 */
class InstancedBatch {
    constructor(instanceId = 0) {           // in packed state (inside typed array):
        this.flags = 0;                     // 4 bytes // +0
        this.firstInstance = null;          // 4 bytes // +4
        this.instanceCount = 0;             // 4 bytes // +8
        this.capacity = 0;                  // 4 bytes // +12
        this.instanceId = instanceId;       // 4 bytes // +16
    }

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#needsUpdate
     * @type {boolean}
     * @summary Whether the renderer should update instanced attributes for this batch.
     */
    get needsUpdate() {
        return (this.flags & needsUpdateFlag) !== 0;
    }

    set needsUpdate(value) {
        this.flags = value ? this.flags | needsUpdateFlag : this.flags & ~needsUpdateFlag;
    }

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#excluded
     * @type {boolean}
     * @summary Whether the renderer should exclude this batch.
     */
    get excluded() {
        return (this.flags & excludedFlag) !== 0;
    }

    set excluded(value) {
        return this.flags = value ? this.flags | excludedFlag : this.flags & ~excludedFlag; // eslint-disable-line
    }

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#firstInstance
     * @type {number}
     * @summary Index of the first instance in the staging buffer of instanced data.
     */

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#instanceCount
     * @type {number}
     * @summary Instances count in the batch.
     */

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#instanceId
     * @type {number}
     * @summary Unique identifier of the instances of that batch.
     */

    /**
     * @var module:@webgears-app/engine-core.InstancedBatch#capacity
     * @type {number}
     * @summary Pre allocated instances count for this batch.
     */

    static get bytesPerBatch() {
        return 20; // total: 20 bytes
    }
}

/* harmony default export */ var instancedBatch = (InstancedBatch);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/instancedBatches.js
 // eslint-disable-line

const { bytesPerBatch: instancedBatches_bytesPerBatch } = instancedBatch;

const excludedBatchFlag = 0x02;

class InstancedBatches {
    constructor({ initialBatchCount = 25, increaseStep = 5 }) {
        this.batchBuffer = new Uint8Array(instancedBatches_bytesPerBatch * initialBatchCount);
        this.batchCount = 0;
        this.batchCapacity = initialBatchCount;
        this.increaseStep = increaseStep;
    }

    emplaceBatch(instanceId, capacity = 0) {
        const { batchBuffer, increaseStep } = this;

        if (this.batchCapacity <= this.batchCount) {
            this.batchCapacity += increaseStep;

            const newBatchBuffer = new Uint8Array(this.batchCapacity * instancedBatches_bytesPerBatch);

            newBatchBuffer.set(batchBuffer);

            this.batchBuffer = newBatchBuffer;
        }

        const batchIdx = this.batchCount++;

        {
            const { buffer } = this.batchBuffer;

            const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);

            view[0] = 0;            // flags
            view[1] = -1;           // first instance
            view[2] = 0;            // instance count
            view[3] = capacity;     // capacity
            view[4] = instanceId;
        }

        return batchIdx;
    }

    packBatch(batchIdx, batch) {
        const { batchBuffer } = this;
        const { buffer } = batchBuffer;

        const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);

        view[0] = batch.flags;
        view[1] = batch.firstInstance === null ? -1 : batch.firstInstance;
        view[2] = batch.instanceCount;
        view[3] = batch.capacity;
        view[4] = batch.instanceId;
    }

    hasBatch(batchIdx) {
        return this.batchCount > batchIdx;
    }

    unpackBatch(batchIdx, batch) {
        const { batchBuffer } = this;
        const { buffer } = batchBuffer;

        const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch, 5);

        const [
            flags,
            firstInstance,
            instanceCount,
            capacity,
            instanceId
        ] = view;

        batch.flags = flags;
        batch.firstInstance = firstInstance >= 0 ? firstInstance : null;
        batch.instanceCount = instanceCount;
        batch.capacity = capacity;
        batch.instanceId = instanceId;
    }

    unpackLastBatch(batch) {
        const { batchBuffer, batchCount } = this;
        const { buffer } = batchBuffer;

        console.assert(batchCount > 0); //  it has no batches;

        const batchIdx = batchCount - 1;

        const view = new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch + 4, 4);

        const [
            firstInstance,
            instanceCount,
            capacity,
            instanceId
        ] = view;

        batch.firstInstance = firstInstance >= 0 ? firstInstance : null;
        batch.instanceCount = instanceCount;
        batch.capacity = capacity;
        batch.instanceId = instanceId;
    }

    shiftFirstInstance(batchIdx, shift) {
        const { batchBuffer, batchCount } = this;
        const { buffer } = batchBuffer;

        for (let i = batchIdx + 1; i < batchCount; i++) {
            (new Int32Array(buffer, i * instancedBatches_bytesPerBatch + 4, 1))[0] += shift;
        }
    }

    getBatchGlobalIndex(batchIdx, instanceIndex) {
        const { batchBuffer } = this;
        const { buffer } = batchBuffer;

        const firstInstance = (new Int32Array(buffer, batchIdx * instancedBatches_bytesPerBatch + 4, 1))[0];

        return firstInstance + instanceIndex;
    }

    disableBatch(batchIdx) {
        const { batchBuffer } = this;
        return batchBuffer[batchIdx * instancedBatches_bytesPerBatch] |= excludedBatchFlag; // eslint-disable-line
    }

    enableBatch(batchIdx) {
        const { batchBuffer } = this;
        return batchBuffer[batchIdx * instancedBatches_bytesPerBatch] &= ~excludedBatchFlag; // eslint-disable-line
    }

    disableAll() {
        const { batchBuffer, batchCount } = this;

        for (let i = 0; i <  batchCount; i++) {
            batchBuffer[i * instancedBatches_bytesPerBatch] |= excludedBatchFlag;
        }
    }

    enableAll() {
        const { batchBuffer, batchCount } = this;

        for (let i = 0; i <  batchCount; i++) {
            batchBuffer[i * instancedBatches_bytesPerBatch] &= ~excludedBatchFlag;
        }
    }
}

/* harmony default export */ var src_instancedBatches = (InstancedBatches);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/attributeSemantic.js

/**
 * @namespace module:@webgears-app/engine-core.AttributeSemantic
 * @desc Attribute semantic enum.
 * @property {number} NONE
 * @property {number} POSITION
 * @property {number} NORMAL
 * @property {number} TANGENT
 * @property {number} BITANGENT
 * @property {number} COLOR
 * @property {number} BONE_INDICES
 * @property {number} BONE_WEIGHTS
 * @property {number} TEX_COORD_CHANNEL_0
 * @property {number} TEX_COORD_CHANNEL_1
 * @property {number} TEX_COORD_CHANNEL_2
 * @property {number} TEX_COORD_CHANNEL_3
 * @property {number} TEX_COORD_CHANNEL_4
 * @property {number} TEX_COORD_CHANNEL_5
 * @property {number} TEX_COORD_CHANNEL_6
 * @property {number} TEX_COORD_CHANNEL_7
 * @property {number} POSITION_MORPH_0
 * @property {number} POSITION_MORPH_1
 * @property {number} POSITION_MORPH_2
 * @property {number} POSITION_MORPH_3
 * @property {number} POSITION_MORPH_4
 * @property {number} POSITION_MORPH_5
 * @property {number} POSITION_MORPH_6
 * @property {number} POSITION_MORPH_7
 * @property {number} NORMAL_MORPH_0
 * @property {number} NORMAL_MORPH_1
 * @property {number} NORMAL_MORPH_2
 * @property {number} NORMAL_MORPH_3
 * @property {number} NORMAL_MORPH_4
 * @property {number} NORMAL_MORPH_5
 * @property {number} NORMAL_MORPH_6
 * @property {number} NORMAL_MORPH_7
 * @property {number} CUSTOM_0
 * @property {number} CUSTOM_1
 * @property {number} CUSTOM_2
 * @property {number} CUSTOM_3
 * @property {number} CUSTOM_4
 * @property {number} INSTANCE_IDENTIFIERS
 * @property {number} INSTANCE_TRANSFORM_1
 * @property {number} INSTANCE_TRANSFORM_2
 * @property {number} INSTANCE_TRANSFORM_3
 * @property {number} INSTANCE_CUSTOM_0
 * @property {number} INSTANCE_CUSTOM_1
 * @property {number} INSTANCE_CUSTOM_2
 * @property {number} INSTANCE_CUSTOM_3
 */

class AttributeSemantic {
    static get NONE() { return 0; }
    static get POSITION() { return 1; }
    static get NORMAL() { return 2; }
    static get TANGENT() { return 3; }
    static get BITANGENT() { return 4; }
    static get COLOR() { return 5; }
    static get BONE_INDICES() { return 6; }
    static get BONE_WEIGHTS() { return 7; }
    static get TEX_COORD_CHANNEL_0() { return 8; }
    static get TEX_COORD_CHANNEL_1() { return 9; }
    static get TEX_COORD_CHANNEL_2() { return 10; }
    static get TEX_COORD_CHANNEL_3() { return 11; }
    static get TEX_COORD_CHANNEL_4() { return 12; }
    static get TEX_COORD_CHANNEL_5() { return 13; }
    static get TEX_COORD_CHANNEL_6() { return 14; }
    static get TEX_COORD_CHANNEL_7() { return 15; }
    static get POSITION_MORPH_0() { return 16; }
    static get POSITION_MORPH_1() { return 17; }
    static get POSITION_MORPH_2() { return 18; }
    static get POSITION_MORPH_3() { return 19; }
    static get POSITION_MORPH_4() { return 20; }
    static get POSITION_MORPH_5() { return 21; }
    static get POSITION_MORPH_6() { return 22; }
    static get POSITION_MORPH_7() { return 23; }
    static get NORMAL_MORPH_0() { return 24; }
    static get NORMAL_MORPH_1() { return 25; }
    static get NORMAL_MORPH_2() { return 26; }
    static get NORMAL_MORPH_3() { return 27; }
    static get NORMAL_MORPH_4() { return 28; }
    static get NORMAL_MORPH_5() { return 29; }
    static get NORMAL_MORPH_6() { return 30; }
    static get NORMAL_MORPH_7() { return 31; }
    static get CUSTOM_0() { return 32; }
    static get CUSTOM_1() { return 33; }
    static get CUSTOM_2() { return 34; }
    static get CUSTOM_3() { return 35; }
    static get CUSTOM_4() { return 36; }
    static get INSTANCE_IDENTIFIERS() { return 37; }
    static get INSTANCE_TRANSFORM_1() { return 38; }
    static get INSTANCE_TRANSFORM_2() { return 39; }
    static get INSTANCE_TRANSFORM_3() { return 40; }
    static get INSTANCE_CUSTOM_0() { return 41; }
    static get INSTANCE_CUSTOM_1() { return 42; }
    static get INSTANCE_CUSTOM_2() { return 43; }
    static get INSTANCE_CUSTOM_3() { return 44; }
    static get INSTANCE_CUSTOM_4() { return 45; }
}

function getAttributeSemanticName(attributeSemantic) {
    for (const name of Object.getOwnPropertyNames(AttributeSemantic)) {
        if (name === 'length') { continue; }
        if (AttributeSemantic[name] === attributeSemantic) { return name; }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/instanceDataManager.js




 // eslint-disable-line



let _lastInstanceId = 0;

const transformElementsPerInstance = 14;
const centerElementsPerInstance = 3;

function shiftBuffer(typedArray, firstInstance, shift, elementsPerInstance) {
    const offset = (firstInstance + shift) * elementsPerInstance;

    const move = new typedArray.constructor(
        typedArray.buffer,
        firstInstance * elementsPerInstance * typedArray.BYTES_PER_ELEMENT,
        typedArray.length - offset
    );

    typedArray.set(move, offset);
}

/**
 * @class module:@webgears-app/engine-core._BatchRenderable
 * @private
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
 * @summary Class encapsulates all necessary to render all instances with unique pair of geometry and material.
 */
class instanceDataManager_BatchRenderable extends disposeableUsageCounter_DisposableUsageCounter {
    constructor(instance) {
        super();

        this.renderQueueGroup = instance.renderQueueGroup;
        this.instanceId = instance.instanceId;
        this.material = instance.material;
        this.geometry = instance.geometry;

        this.depthMaterials = [...instance.depthMaterials];

        this.vao = null;
        this.depthVao = null;
        this.vaoLayoutVersion = 0;
        this.depthVaoLayoutVersion = 0;

        this.webGLAttributeSystem = null;
        this.viewZ = 0.0;
        this.visibleInstanceCount = 0;
        this.batchIdx = null;

        this.reallocStrategy = instance.reallocStrategy;

        this.skeletonBuffers = null;

        this.morphWeights = null;
        this.positionMorphTargetCount = 0;
        this.normalMorphTargetCount = 0;

        this._firstInstance = 0;
    }

    get firstInstance() {
        return this._firstInstance;
    }

    set firstInstance(value) {
        if (this._firstInstance !== value) {
            this.vaoLayoutVersion = 0;
            this.depthVaoLayoutVersion = 0;
        }

        this._firstInstance = value;
    }

    get hasMorph() {
        return this.positionMorphTargetCount > 0 || this.normalMorphTargetCount > 0;
    }

    _dispose() {
        const { webGLAttributeSystem } = this;

        if (webGLAttributeSystem !== null) {
            webGLAttributeSystem.deleteRenderable(this);

            this.webGLAttributeSystem = null;
        }
    }
}

/**
 * @typedef module:@webgears-app/engine-core.InstancedAttributeLayout
 * @property {number} byteOffset A byte offset.
 * @property {number} countComponents Component count.
 * @desc Describes instanced attribute.
 */

/**
 * @class module:@webgears-app/engine-core.InstanceDataManager
 * @summary Class encapsulate instanced data of all instances of the one scene.
 * @param {object} config An instanced data configuration parameters.
 * @param {number} [config.initialBatchCountPerThread=25] Initial batch count per thread.
 * @param {number} [config.initialRangeCountPerThread=128] Initial range count per thread.
 * @param {number} [config.increaseStep=5] Batch count growth value.
 * @param {number} [config.initialSceneNodes=concurrency] Initial count of nodes.
 * @param {object[]} [config.customAttributes=[]] An array of custom instanced attributes.
 * An each item have to contain pairs of attribute semantic and element count.
 * @example
 * const customAttributes = [
 * { semantic: AttributeSemantic.INSTANCE_CUSTOM_0, countComponents: 3 }, // vec3 attribute
 * { semantic: AttributeSemantic.INSTANCE_CUSTOM_1, countComponents: 2 }  // vec2 attribute
 * ];
 *
 * const instanceDataManager = new InstanceDataManager({ customAttributes });
 */
class instanceDataManager_InstanceDataManager {
    constructor(config = {}) {
        const {
            batchMap = null,
            initialRangeCount = 128,
            increaseStep = 5,
            initialSceneNodes = 2,
            customAttributes = []
        } = config;

        this._batchMap = batchMap || new TupleMap();

        let initialInstanceCount = 0;

        for (const k of this._batchMap.values()) {
            initialInstanceCount += k;
        }

        initialInstanceCount = Math.max(initialInstanceCount, initialSceneNodes);

        const uniqueInstances = new Map();
        this._uniqueInstances = uniqueInstances;

        const freeIndices = new WeakMap();
        this._freeIndices = freeIndices;

        const instanceIdentifiers = new Map();
        this._instanceIdentifiers = instanceIdentifiers;

        this._instanceCount = initialInstanceCount;

        let instancedElementsPerInstance = transformElementsPerInstance;
        let customAttributeByteOffset = transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;

        const customInstancedAttributes = new Map();
        this._customInstancedAttributes = customInstancedAttributes;

        for (const customAttribute of customAttributes) {
            const { semantic, countComponents } = customAttribute;

            customInstancedAttributes.set(semantic, { byteOffset: customAttributeByteOffset, countComponents });

            customAttributeByteOffset += countComponents * Float32Array.BYTES_PER_ELEMENT;

            instancedElementsPerInstance += countComponents;
        }

        this._instancedAttributes = new Map(customInstancedAttributes);
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_1, { byteOffset: 0, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_2, { byteOffset: 16, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_3, { byteOffset: 32, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_IDENTIFIERS, { byteOffset: 48, countComponents: 2 });

        this._instancedElementsPerInstance = instancedElementsPerInstance;

        this._worldTransformsBack = new Float32Array(instancedElementsPerInstance * initialInstanceCount);
        this._worldTransformsFront = new Float32Array(instancedElementsPerInstance * initialInstanceCount);
        this._centers = new Float32Array(centerElementsPerInstance * initialInstanceCount);
        this._flagBuffers = new Uint8Array(initialInstanceCount);

        const instancedBatches = new src_instancedBatches({ initialBatchCount: this._batchMap.size, increaseStep });

        this._instancedBatches = instancedBatches;

        this._flushRangeFrom = 0;
        this._flashRangeTo = 0;
        this._gpuInstancedData = null;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#addCustomAttributes
     * @param {object[]} customAttributes An array of custom instanced attributes.
     * @summary Adds new instanced attributes into the vertex layout.
     * @desc Can be called only before the first systems update.
     */
    addCustomAttributes(customAttributes) {
        let customAttributeByteOffset = transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;

        const { _customInstancedAttributes } = this;

        for (const customInstancedAttribute of _customInstancedAttributes.values()) {
            const { byteOffset } = customInstancedAttribute;
            customAttributeByteOffset += byteOffset;
        }

        for (const customAttribute of customAttributes) {
            const { semantic, countComponents } = customAttribute;

            if (_customInstancedAttributes.has(semantic)) continue;

            _customInstancedAttributes.set(semantic, { byteOffset: customAttributeByteOffset, countComponents });

            customAttributeByteOffset += countComponents * Float32Array.BYTES_PER_ELEMENT;

            this._instancedElementsPerInstance += countComponents;
        }

        this._instancedAttributes = new Map(_customInstancedAttributes);
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_1, { byteOffset: 0, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_2, { byteOffset: 16, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_TRANSFORM_3, { byteOffset: 32, countComponents: 4 });
        this._instancedAttributes.set(AttributeSemantic.INSTANCE_IDENTIFIERS, { byteOffset: 48, countComponents: 2 });

        {
            const { _instancedElementsPerInstance, _instanceCount } = this;

            this._worldTransformsBack = new Float32Array(_instancedElementsPerInstance * _instanceCount);
            this._worldTransformsFront = new Float32Array(_instancedElementsPerInstance * _instanceCount);
        }
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstanceIdentifier
     * @param {number} geometryId Geometry identifier.
     * @param {number} materialId Material identifier.
     * @returns {number}
     * @summary Returns instance identifier by geometry and material id.
     */
    getInstanceIdentifier(geometryId, materialId) {
        const { _instanceIdentifiers } = this;

        let materialIdentifiers = _instanceIdentifiers.get(geometryId);

        if (materialIdentifiers === undefined) {
            materialIdentifiers = new Map();

            _instanceIdentifiers.set(geometryId, materialIdentifiers);
        }

        let instanceId = materialIdentifiers.get(materialId);

        if (instanceId === undefined) {
            instanceId = ++_lastInstanceId;

            materialIdentifiers.set(materialId, instanceId);
        }

        return instanceId;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstanceRenderable
     * @summary Returns renderable to render whole batch of instances with defined instance id.
     * @param {number} instanceId
     * @returns {object}
     */
    getInstanceRenderable(instanceId) {
        return this._uniqueInstances.get(instanceId);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstanceGlobalIndex
     * @summary Returns instance global index in the instanced buffer.
     * @param {number} batchIdx A batch index.
     * @param {number} instanceIndex An index of the instance in the batch.
     * @returns {number}
     */
    getInstanceGlobalIndex(batchIdx, instanceIndex) {
        return this._instancedBatches.getBatchGlobalIndex(batchIdx, instanceIndex);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstancedAttributeStaging
     * @summary Returns whole instanced staging.
     * @returns {Float32Array}
     */
    getInstancedAttributeStaging() { return this._worldTransformsFront; }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#storeCenter
     * @param {module:@webgears-app/math.Vector3} center Center.
     * @param {number} globalIndex Instance global index.
     * @summary Stores instance center.
     */
    storeCenter(center, globalIndex) {
        const { _centers } = this;
        center.toArrayAt(globalIndex * centerElementsPerInstance, _centers);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#storeRenderableIdentifier
     * @param {number} globalIndex A renderable instance global identifier
     * @param {number} identifier A renderable unique identifier
     * @summary Stores unique renderable identifier
     */
    storeRenderableIdentifier(globalIndex, identifier) {
        const { _worldTransformsBack: buffer, _instancedElementsPerInstance } = this;
        const baseOffset = globalIndex * _instancedElementsPerInstance;
        const uniqueInstanceOffset = 13;
        buffer[baseOffset + uniqueInstanceOffset] = identifier;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getRenderableIdentifier
     * @param {number} globalIndex A renderable instance global identifier
     * @returns {number}
     * @summary Get unique renderable identifier
     */
    getRenderableIdentifier(globalIndex) {
        const { _worldTransformsBack: buffer, _instancedElementsPerInstance } = this;
        const baseOffset = globalIndex * _instancedElementsPerInstance;
        const uniqueInstanceOffset = 13;
        return buffer[baseOffset + uniqueInstanceOffset];
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#storeWorldTransform
     * @param {module:@webgears-app/math.AffineMatrix3} matrix World matrix.
     * @param {number} globalIndex Instance global index.
     * @summary Stores world matrix of the instance.
     */
    storeWorldTransform(matrix, globalIndex) {
        const { _worldTransformsBack: buffer, _flagBuffers, _instancedElementsPerInstance } = this;

        const baseOffset = globalIndex * _instancedElementsPerInstance;

        matrix.toAffineColumnArrayAt(baseOffset, buffer);

        _flagBuffers[globalIndex] |= 0x04; // transform update request
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#readWorldTransform
     * @param {module:@webgears-app/math.AffineMatrix3} matrix Matrix to result at.
     * @param {number} globalIndex Instance global index.
     */
    readWorldTransform(matrix, globalIndex) {
        const { _worldTransformsBack: buffer, _instancedElementsPerInstance } = this;
        const baseOffset = globalIndex * _instancedElementsPerInstance;

        matrix.fromAffineColumnArrayAt(baseOffset, buffer);
    }

    _reallocBuffers(currentBufferUsage) {
        const {
            _instanceCount,
            _instancedElementsPerInstance,
            _worldTransformsBack,
            _worldTransformsFront,
            _centers,
            _flagBuffers
        } = this;

        const  newNodeCount = Math.ceil(_instanceCount * 1.618);

        const newByteSize = _instancedElementsPerInstance * newNodeCount * Float32Array.BYTES_PER_ELEMENT;

        {
            const newBuffer = new Float32Array(_instancedElementsPerInstance * newNodeCount);

            newBuffer.set(_worldTransformsBack);

            this._worldTransformsBack = newBuffer;
        }

        {
            const newBuffer = new Float32Array(_instancedElementsPerInstance * newNodeCount);

            newBuffer.set(_worldTransformsFront);

            this._worldTransformsFront = newBuffer;
        }

        {
            const newBuffer = new Float32Array(centerElementsPerInstance * newNodeCount);

            newBuffer.set(_centers);

            this._centers = newBuffer;
        }

        {
            const newBuffer = new Uint8Array(newNodeCount);

            newBuffer.set(_flagBuffers);

            this._flagBuffers = newBuffer;
        }

        const countLeft = (newByteSize - currentBufferUsage) / this.bytesPerInstance;

        this._instanceCount = newNodeCount;

        return countLeft;
    }

    _setInstancedAttributeScalar(semantic, offset, value) {
        const { _worldTransformsBack } = this;
        _worldTransformsBack[offset] = value;
    }

    _setInstancedAttributeVector(semantic, offset, value) {
        const { _worldTransformsBack } = this;
        value.toArrayAt(offset, _worldTransformsBack);
    }

    _setInstancedAttributeRange(semantic, offset, value) {
        const { _worldTransformsBack } = this;
        _worldTransformsBack.set(value, offset);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#setInstancedAttribute
     * @summary Sets value of instanced attribute.
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {number|Vector2|Vector3|RGBColor|Array|Float32Array} value The value of the attribute.
     */
    setInstancedAttribute(instance, semantic, value) {
        const { customInstancedAttributeLayout, _instancedElementsPerInstance, _flagBuffers } = this;

        const { instanceId, instanceIndex, _instanceIdentifierExpired } = instance;

        console.assert(instanceId !== null && instanceIndex !== null && !_instanceIdentifierExpired);
        // 'instance is not valid');

        const batchRenderable = this.getInstanceRenderable(instanceId);

        // console.assert(batchRenderable instanceof _BatchRenderable,
        //    `batch renderable for instanceId ${instanceId} is not valid`);

        const { batchIdx } = batchRenderable;

        console.assert(customInstancedAttributeLayout.has(semantic)); // instanced attributes do not contain semantic

        const { byteOffset } = customInstancedAttributeLayout.get(semantic);
        const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;

        const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);

        const baseOffset = globalIndex * _instancedElementsPerInstance;

        const offset = baseOffset + elementOffset;

        if (!isNaN(value)) { // eslint-disable-line
            this._setInstancedAttributeScalar(semantic, offset, value);
        } else if (Array.isArray(value) || value instanceof Float32Array) {
            this._setInstancedAttributeRange(semantic, offset, value);
        } else {
            this._setInstancedAttributeVector(semantic, offset, value);
        }

        const customAttributeUpdateFlag = 0x10;

        _flagBuffers[globalIndex] |= customAttributeUpdateFlag;
    }

    _getInstancedAttributeScalar(semantic, offset) {
        const { _worldTransformsBack } = this;
        return _worldTransformsBack[offset];
    }

    _getInstancedAttributeVector(semantic, offset, vect) {
        const { _worldTransformsBack } = this;
        vect.fromArrayAt(offset, _worldTransformsBack);
        return vect;
    }

    _getInstancedAttributeRange(semantic, offset, range) {
        const { _worldTransformsBack } = this;

        for (let i = 0, count = range.length; i < count; i++) {
            range[i] = _worldTransformsBack[offset + i];
        }

        return range;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstancedAttribute
     * @summary Returns value of the instanced attribute.
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} outVal The output value.
     * @returns {number|Vector2|Vector3|RGBColor|Array|Float32Array}
     */
    getInstancedAttribute(instance, semantic, outVal) {
        const { _instancedAttributes, _instancedElementsPerInstance } = this;

        const { instanceId, instanceIndex, _instanceIdentifierExpired } = instance;

        console.assert(instanceId !== null && instanceIndex !== null && !_instanceIdentifierExpired);
        // 'instance is not valid');

        const batchRenderable = this.getInstanceRenderable(instanceId);

        // console.assert(batchRenderable instanceof _BatchRenderable);
        // `batch renderable for instanceId ${instanceId} is not valid`);

        const { batchIdx } = batchRenderable;

        console.assert(_instancedAttributes.has(semantic)); //, 'instanced attributes do not contain semantic');

        const { byteOffset } = _instancedAttributes.get(semantic);
        const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;

        const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);

        const baseOffset = globalIndex * _instancedElementsPerInstance;

        const offset = baseOffset + elementOffset;

        let out = null;

        if (outVal === undefined) {
            out = this._getInstancedAttributeScalar(semantic, offset);
        } else if (Array.isArray(outVal) || outVal instanceof Float32Array) {
            out = this._getInstancedAttributeRange(semantic, offset, outVal);
        } else {
            out = this._getInstancedAttributeVector(semantic, offset, outVal);
        }

        return out;
    }

    _extractInstancedData(instance, savedAttribs, matrix) {
        const {_instancedElementsPerInstance, _customInstancedAttributes} = this;

        const countElements = _instancedElementsPerInstance - transformElementsPerInstance;

        const buffer = new ArrayBuffer(countElements * Float32Array.BYTES_PER_ELEMENT);

        const { instanceId, instanceIndex } = instance;
        console.assert(instanceId !== null && instanceIndex !== null);

        const { batchIdx } = this.getInstanceRenderable(instanceId);
        const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);

        this.readWorldTransform(matrix, globalIndex);

        if (countElements < 1) return;

        for (const [semantic, attrib] of _customInstancedAttributes.entries()) {
            const { byteOffset, countComponents } = attrib;
            const offset = byteOffset - transformElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
            const outVal = new Float32Array(buffer, offset, countComponents);

            const elementOffset = byteOffset / Float32Array.BYTES_PER_ELEMENT;

            const baseOffset = globalIndex * _instancedElementsPerInstance;

            const globalElementOffset = baseOffset + elementOffset;

            this._getInstancedAttributeRange(semantic, globalElementOffset, outVal);

            savedAttribs.set(semantic, outVal);
        }
    }

    _resetCustomInstancedAttribs(instance) {
        const { _instancedElementsPerInstance, _worldTransformsBack, _flagBuffers } = this;

        const countCustomElements = _instancedElementsPerInstance - transformElementsPerInstance;

        if (countCustomElements === 0) return;

        const { instanceId, instanceIndex } = instance;

        const batchRenderable = this.getInstanceRenderable(instanceId);

        const { batchIdx } = batchRenderable;

        const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);

        const offset = (globalIndex * _instancedElementsPerInstance + transformElementsPerInstance)
            * Float32Array.BYTES_PER_ELEMENT;

        const view = new Float32Array(_worldTransformsBack.buffer, offset, countCustomElements);

        view.fill(0);

        const customAttributeUpdateFlag = 0x10;

        _flagBuffers[globalIndex] |= customAttributeUpdateFlag;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#capacity
     * @readonly
     * @types {number}
     * @summary Instance count the current instanced buffer can store in.
     */
    get capacity() {
        return this._instanceCount;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#customInstancedAttributeLayout
     * @summary The layout of custom instanced attributes.
     * @type {Map}
     */
    get customInstancedAttributeLayout() {
        return this._customInstancedAttributes;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#elementsPerInstance
     * @summary Elements count per instance.
     * @type {number}
     */
    get elementsPerInstance() {
        return this._instancedElementsPerInstance;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#bytesPerInstance
     * @summary Bytes count per instance.
     * @type {number}
     */
    get bytesPerInstance() {
        return this._instancedElementsPerInstance * Float32Array.BYTES_PER_ELEMENT;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#instancesMemorySize
     * @summary All instanced data size in bytes.
     * @type {number}
     */
    get instancesMemorySize() {
        const { _instanceCount } = this;
        return this.bytesPerInstance * _instanceCount;
    }

    /**
     * @var module:@webgears-app/engine-core.InstanceDataManager#gpuInstancedData
     * @summary GPU buffer to store instanced data
     * @returns {?WebGLBuffer}
     */
    get gpuInstancedData() {
        return this._gpuInstancedData;
    }

    _enableBatches(geometryMaterialPair = {}, value) {
        const { _uniqueInstances, _instancedBatches } = this;
        const { geometry = {}, material = {} } = geometryMaterialPair;
        const { id: geometryId = null } = geometry;
        const { id: materialId = null } = material;

        for (const uniqueInstance of _uniqueInstances.values()) {
            const { batchIdx, geometry: batchGeometry, material: batchMaterial } = uniqueInstance;

            if (batchGeometry.id === geometryId || batchMaterial.id === materialId) {
                if (value && !batchGeometry.unloaded && !batchMaterial.unloaded) {
                    _instancedBatches.enableBatch(batchIdx);
                } else {
                    uniqueInstance.vaoLayoutVersion = 0;
                    uniqueInstance.depthVaoLayoutVersion = 0;

                    _instancedBatches.disableBatch(batchIdx);
                }
            }
        }
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#generateBatchMap
     * @returns {TupleMap>}
     * @summary Generates map of pairs<batch, batch instance capacity>
     */
    generateBatchMap() {
        const { _uniqueInstances, _instancedBatches } = this;

        const batchMap = new TupleMap();
        const batch = new instancedBatch();

        const { batchCount } = _instancedBatches;

        for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
            _instancedBatches.unpackBatch(batchIdx, batch);

            const { instanceId, capacity } = batch;
            const { geometry, material } =  _uniqueInstances.get(instanceId);

            batchMap.set([geometry.id, material.id], capacity);
        }

        return batchMap;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#setInstancedMemoryFlushRange
     * @param {number} from Bytes offset to start update from
     * @param {number} to Bytes offset to the end of update range.
     * @summary sets a range to update instanced GPU buffer {from, to}
     */
    setInstancedMemoryFlushRange(from, to) {
        this._flushRangeFrom = from;
        this._flashRangeTo = to;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#flushInstancedMemory
     * @param {WebGLRenderingContext} ctx Current WebGLRendering context
     * @param {Function} allocator Function to allocate GPU memory.
     * @summary Flush instanced data from staging to GPU buffer.
     */
    flushInstancedMemory(ctx, allocator) {
        const { _flushRangeFrom = 0, _flashRangeTo = 0, instancesMemorySize, _worldTransformsFront } = this;
        const byteLength = _flashRangeTo - _flushRangeFrom;

        if (byteLength <= 0) return;

        if (this._gpuInstancedData === null) {
            this._gpuInstancedData = allocator(ctx, instancesMemorySize, ctx.ARRAY_BUFFER, ctx.DYNAMIC_DRAW);
            this._gpuInstancedData.subdata(_worldTransformsFront, 0);
        } else if (this._gpuInstancedData.size < instancesMemorySize) {
            this._gpuInstancedData.dispose();
            this._gpuInstancedData = allocator(ctx, instancesMemorySize, ctx.ARRAY_BUFFER, ctx.DYNAMIC_DRAW);
            this._gpuInstancedData.subdata(_worldTransformsFront, 0);
            this.invalidateBatchRenderables();
        } else {
            const elementCount = byteLength / _worldTransformsFront.BYTES_PER_ELEMENT;
            const offset = _flushRangeFrom;
            const view = new Float32Array(_worldTransformsFront.buffer, offset, elementCount);

            this._gpuInstancedData.subdata(view, offset);
        }

        this._flushRangeFrom = 0;
        this._flashRangeTo = 0;
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#invalidateBatchRenderables
     * @summary Invalidates all batch renderables / forces VAO reassembling.
     */
    invalidateBatchRenderables() {
        const { _uniqueInstances } = this;

        for (const r of _uniqueInstances.values()) {
            r.vaoLayoutVersion = 0;
            r.depthVaoLayoutVersion = 0;
        }
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#disableBatches
     * @param {object} [geometryMaterialPair={}] geometry material pair
     * @param {module:@webgears-app/engine-core.Geometry} [geometryMaterialPair.geometry=null]
     * @param {module:@webgears-app/engine-core.Material} [geometryMaterialPair.material=null]
     * @summary Excludes batches from render queue that matches material or geometry.
     */
    disableBatches(geometryMaterialPair) {
        this._enableBatches(geometryMaterialPair, false);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#enableBatches
     * @param {object} [geometryMaterialPair={}] geometry material pair
     * @param {module:@webgears-app/engine-core.Geometry} [geometryMaterialPair.geometry=null]
     * @param {module:@webgears-app/engine-core.Material} [geometryMaterialPair.material=null]
     * @summary Restores batches from render queue that matches material or geometry.
     */
    enableBatches(geometryMaterialPair) {
        this._enableBatches(geometryMaterialPair, true);
    }

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#shrinkToFit
     * @param {boolean} [emptyBatchesOnly = true] Specifies whether the method shrinks only empty batches memory (slow)
     * or unused instanced memory inside batches too (very slow).
     * @param {number} [byteCountThreshold = 0] Threshold to skip shrink in case expected memory amount to release
     * is less then threshold value
     * @returns {number}
     * @summary Shrinks instanced data memory, returns byte count had been released or estimated release memory amount
     * in case shrink had been skipped by threshold.
     * @desc After many operations to delete and add instances internal instanced data memory can be fragmented, this
     * method physically delete unused instanced memory.
     * The method is too expensive to call after any instance delete and an instance takes very few bytes of memory,
     * so it makes a sense to call this method only after deleting many thousands of instances.
     */
}

Object.assign(instanceDataManager_InstanceDataManager.prototype, {
    _saveInstancedData: (function __saveInstanceData() {
        const worldBoundingBox = new rectangle_and_box_Box();
        const center = new Vector3();

        return function _saveInstancedData(instance, batchIdx, instanceIndex, savedAttribs, matrix, restoreTransform) {
            if (restoreTransform) {
                const {geometry, id} = instance;
                const {boundingBox} = geometry;

                const globalIndex = this.getInstanceGlobalIndex(batchIdx, instanceIndex);

                this.storeWorldTransform(matrix, globalIndex);
                this.storeRenderableIdentifier(globalIndex, id);

                worldBoundingBox.copy(boundingBox).applyAffineMatrix(matrix);
                worldBoundingBox.centerPaste(center);

                this.storeCenter(center, globalIndex);
            }

            for (const [semantic, val] of savedAttribs.entries()) {
                this.setInstancedAttribute(instance, semantic, val);
            }

            savedAttribs.clear();
        };
    }()),

    shrinkToFit: (function _shrinkToFit() {
        const batch_ = new instancedBatch();

        return function shrinkToFit(emptyBatchesOnly = true, byteCountThreshold = 0) {
            const {
                _uniqueInstances,
                _instancedBatches,
                _freeIndices,
                _instancedElementsPerInstance,
                bytesPerInstance
            } = this;

            const { batchCount } = _instancedBatches;
            const batchMap = new Map(); // not the same as this._batchMap

            const allBytesPerInstance = 2 * bytesPerInstance // front + back
                + centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT
                + 1; // flags

            const { bytesPerBatch } = instancedBatch;

            let instanceCapacity = 0;
            let estimatedReleaseAmount = 0;

            const emptyRenderables = [];

            for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
                _instancedBatches.unpackBatch(batchIdx, batch_);

                const { instanceCount, capacity, instanceId } = batch_;
                const batchRenderable = _uniqueInstances.get(instanceId);
                const freeIndices = _freeIndices.get(batchRenderable) || [];

                if (freeIndices.length === instanceCount) { // empty
                    emptyRenderables.push(batchRenderable);
                    estimatedReleaseAmount += capacity * allBytesPerInstance;
                    estimatedReleaseAmount += bytesPerBatch;
                } else if (emptyBatchesOnly) { // not empty
                    batchMap.set(batchIdx, capacity);
                    instanceCapacity += capacity;
                } else if (!emptyBatchesOnly && instanceCount <= capacity) { // not empty and maybe fat
                    batchMap.set(batchIdx, instanceCount - freeIndices.length);
                    instanceCapacity += (instanceCount - freeIndices.length);
                    estimatedReleaseAmount += (capacity - instanceCount + freeIndices.length)  * allBytesPerInstance;
                }
            }

            if (estimatedReleaseAmount < byteCountThreshold) {
                return estimatedReleaseAmount;
            }

            // delete indices for empty
            for (const emptyRenderable of emptyRenderables) {
                _freeIndices.delete(emptyRenderable);
            }

            let prevMemoryUsage = 0;
            let newMemoryUsage = 0;

            {
                prevMemoryUsage += this._worldTransformsBack.byteLength;
                prevMemoryUsage += this._worldTransformsFront.byteLength;
                prevMemoryUsage += this._centers.byteLength;
                prevMemoryUsage += this._flagBuffers.byteLength;
                prevMemoryUsage += _instancedBatches.batchBuffer.byteLength;
            }

            {
                const worldTransformsBack = new Float32Array(_instancedElementsPerInstance * instanceCapacity);
                const worldTransformsFront = new Float32Array(_instancedElementsPerInstance * instanceCapacity);
                const centers = new Float32Array(centerElementsPerInstance * instanceCapacity);
                const flagBuffers = new Uint8Array(instanceCapacity);

                const { bytesPerBatch } = instancedBatch;
                const batchCapacity = batchMap.size;
                const batchCount = batchCapacity;
                const batchBuffer = new Uint8Array(batchCapacity * bytesPerBatch);
                const { buffer } = batchBuffer;

                let firstInstance = 0;
                let batchIdx = 0;

                for (const [oldBatchIdx, capacity] of batchMap.entries()) {
                    _instancedBatches.unpackBatch(oldBatchIdx, batch_);

                    const view = new Int32Array(buffer, batchIdx * bytesPerBatch, 5);

                    const oldFirstInstance = batch_.firstInstance;
                    const oldCapavity = batch_.capacity;

                    view[0] = batch_.flags;
                    view[1] = batch_.firstInstance = firstInstance;
                    view[2] = batch_.instanceCount = capacity;
                    view[3] = batch_.capacity = capacity;
                    view[4] = batch_.instanceId; // still the same

                    const batchRenderable = _uniqueInstances.get(batch_.instanceId);

                    batchRenderable.batchIdx = batchIdx++;

                    if (emptyBatchesOnly) { // oldCapacity == capacity
                        worldTransformsBack.set(
                            new Float32Array(this._worldTransformsBack.buffer,
                                oldFirstInstance * bytesPerInstance, oldCapavity * _instancedElementsPerInstance),
                            firstInstance * bytesPerInstance
                        ); // target offset in bytes or in elements?

                        worldTransformsFront.set(
                            new Float32Array(this._worldTransformsFront.buffer,
                                oldFirstInstance * bytesPerInstance, oldCapavity * _instancedElementsPerInstance),
                            firstInstance * bytesPerInstance
                        );

                        centers.set(
                            new Float32Array( this._centers.buffer,
                            oldFirstInstance * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT,
                            oldCapavity * centerElementsPerInstance),
                            firstInstance * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT
                        );

                        flagBuffers.set(
                            new Uint8Array(this._flagBuffers.buffer, oldFirstInstance, oldCapavity),
                            firstInstance
                        );
                    } else { // oldCapacity != capacity
                        const freeIndices = _freeIndices.get(batchRenderable) || [];

                        for (let instanceIdx = 0, validInstanceIdx = 0;
                             instanceIdx < oldCapavity && validInstanceIdx < capacity; instanceIdx++) {

                            if (freeIndices.includes(instanceIdx)) continue;

                            worldTransformsBack.set(
                                new Float32Array(this._worldTransformsBack.buffer,
                                    bytesPerInstance * (oldFirstInstance + instanceIdx), _instancedElementsPerInstance),
                                (firstInstance + validInstanceIdx));

                            worldTransformsFront.set(
                                new Float32Array(this._worldTransformsFront.buffer,
                                    bytesPerInstance * (oldFirstInstance + instanceIdx), _instancedElementsPerInstance),
                                (firstInstance + validInstanceIdx));

                            centers.set(
                                new Float32Array( this._centers.buffer,
                                    (oldFirstInstance + instanceIdx)
                                        * centerElementsPerInstance * Float32Array.BYTES_PER_ELEMENT,
                                    centerElementsPerInstance), (firstInstance + validInstanceIdx)
                            );

                            flagBuffers[firstInstance + validInstanceIdx]
                                = this._flagBuffers[oldFirstInstance + instanceIdx];

                            validInstanceIdx++;
                        }

                        freeIndices.length = 0;
                    }

                    firstInstance += capacity;
                }

                _instancedBatches.batchBuffer = batchBuffer;
                _instancedBatches.batchCount = batchCount;
                _instancedBatches.batchCapacity = batchCapacity;

                this._worldTransformsBack = worldTransformsBack;
                this._worldTransformsFront = worldTransformsFront;
                this._centers = centers;
                this._flagBuffers = flagBuffers;

                this._instanceCount = instanceCapacity;
            }

            {
                newMemoryUsage += this._worldTransformsBack.byteLength;
                newMemoryUsage += this._worldTransformsFront.byteLength;
                newMemoryUsage += this._centers.byteLength;
                newMemoryUsage += this._flagBuffers.byteLength;
                newMemoryUsage += _instancedBatches.batchBuffer.byteLength;
            }

            this._batchMap.clear(); // just in case

            return prevMemoryUsage - newMemoryUsage;
        }
    }()),

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#getInstanceCount
     * @summary Returns instance count of batch.
     * @returns {number}
     */
    getInstanceCount: (function __getInstanceCount() {
        const batch_ = new instancedBatch();

        return function getInstanceCount(instanceId) {
            const batch = this.getInstanceRenderable(instanceId);
            const { batchIdx } = batch;

            this._instancedBatches.unpackBatch(batchIdx, batch_);

            return batch_.instanceCount;
        };
    }()),

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#addInstance
     * @summary Adds a new instance, returns instance index in the batch.
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance renderable.
     * @returns {number}
     */
    addInstance: (function _addInstance() {
        const batch_ = new instancedBatch();
        const lastBatch_ = new instancedBatch();
        const prevBatch_ = new instancedBatch();
        const nextBatch_ = new instancedBatch();

        const _updateSkeleton = function(batch, instance) {
            const { skeleton, instanceIndex } = instance;

            if (skeleton === null) return;

            const skeletonBuffers = skeleton.getSkeletonBuffersByInstanceIndex(instanceIndex);

            const { skeletonBuffers: batchSkeletonBuffers } = batch;

            if (skeletonBuffers === null && batchSkeletonBuffers === null) { // everything new
                batch.skeletonBuffers = skeleton.addSkeletonBuffers(instanceIndex);
                return;
            }

            if (skeletonBuffers === batchSkeletonBuffers) return; // nothing do

            const { id: skeletonId } = skeleton;

            if (batchSkeletonBuffers == null) {
                // new batch
                // existed skeleton
                const owner = skeletonBuffers.getLineOwner(instanceIndex);

                if (skeletonId === owner || owner === -1) {
                    // this skeleton writes to the own buffer or can invade to this buffer at line instanceIndex
                    console.assert(skeletonId === owner); // 'skeleton does not own buffer');
                    batch.skeletonBuffers = skeletonBuffers;
                } else {
                    // batch is new
                    // skeleton can not continue to write to the same buffer
                    batch.skeletonBuffers = skeleton.setSkeletonBuffers(instanceIndex);
                    batch.skeletonBuffers.setLineOwner(instanceIndex, skeletonId);
                }
            } else if (skeletonBuffers === null) {
                // new skeleton
                // get into existed batch
                const owner = batchSkeletonBuffers.getLineOwner(instanceIndex);

                if (skeletonId === owner || owner === -1) {
                    // created new skeleton on existed butch
                    // case to invade to existed buffer (owner == -1)
                    skeleton.addSkeletonBuffers(instanceIndex, batchSkeletonBuffers);
                } else {
                    // when restored empty batch
                    batch.skeletonBuffers = skeleton.addSkeletonBuffers(instanceIndex);
                }
            } else /* skeletonBuffers !== batchSkeletonBuffers */ {
                // batch changed (skeleton buffer != null) and get into another existed batch (batch buffer != null)
                const owner = batchSkeletonBuffers.getLineOwner(instanceIndex);

                if (owner === skeletonId || owner === -1) {
                    skeleton.setSkeletonBuffers(instanceIndex, batchSkeletonBuffers);
                    batchSkeletonBuffers.setLineOwner(instanceIndex, skeletonId);
                }

                console.assert(skeletonId !== owner);
                // if you can see the assertion above, just give me an example how you ended up in this situation
            }
        };

        const savedCustomInstancedAttribs = new Map();
        const worldMatrix = new AffineMatrix3();

        return function addInstance(instance) {
            let restoreTransform = false;

            {
                const { _instanceIdentifierExpired } = instance;

                if (_instanceIdentifierExpired) {
                    this._extractInstancedData(instance, savedCustomInstancedAttribs, worldMatrix);
                    this.deleteInstance(instance);

                    restoreTransform = true;
                }
            }

            if (instance.instanceId === null) {
                const { geometry, material } = instance;
                instance._instanceId = this.getInstanceIdentifier(geometry.id, material.id);
            }

            const { instanceId } = instance;

            const {
                _instancedElementsPerInstance,
                _uniqueInstances,
                _freeIndices,
                _instancedBatches,
                _batchMap,
            } = this;

            let {
                _centers,
                _worldTransformsBack,
                _flagBuffers
            } = this;

            let batchRenderable = _uniqueInstances.get(instanceId);

            if (batchRenderable === undefined) {    // if new batch renderable
                batchRenderable = new instanceDataManager_BatchRenderable(instance);

                const capacity = _batchMap.size > 0
                    ? _batchMap.get([instance.geometry.id, instance.material.id]) || 0
                    : 0;

                batchRenderable.batchIdx = _instancedBatches.emplaceBatch(instanceId, capacity);

                _uniqueInstances.set(instanceId, batchRenderable);

                if (capacity > 0) _batchMap.delete([instance.geometry.id, instance.material.id]);
            }

            // console.assert(batchRenderable instanceof _BatchRenderable);
            // `batch renderable for instanceId ${instanceId} is not valid`);

            if (!_freeIndices.has(batchRenderable)) {
                _freeIndices.set(batchRenderable, []);
            }

            batchRenderable.retain();

            {
                const { batchIdx } = batchRenderable;
                const freeIndices = _freeIndices.get(batchRenderable);

                _instancedBatches.unpackBatch(batchIdx, batch_);
                _instancedBatches.unpackLastBatch(lastBatch_);

                const lastBatch = lastBatch_.instanceId === batch_.instanceId ? batch_ : lastBatch_;

                let prevBatch = null;
                let nextBatch = null;

                if (batchIdx > 0) {
                    _instancedBatches.unpackBatch(batchIdx - 1, prevBatch_);
                    prevBatch = prevBatch_;
                }

                if (_instancedBatches.hasBatch(batchIdx + 1)) {
                    _instancedBatches.unpackBatch(batchIdx + 1, nextBatch_);
                    nextBatch = nextBatch_;
                }

                if (batch_.firstInstance === null) {
                    batch_.firstInstance = (prevBatch === null) ? 0 : prevBatch.firstInstance + prevBatch.capacity;
                }

                if (batch_.instanceCount < batch_.capacity || freeIndices.length > 0) {
                    const resetCustomAttribs = freeIndices.length > 0 && savedCustomInstancedAttribs.size < 1;
                    const instanceIndex = freeIndices.length > 0 ? freeIndices.pop() : batch_.instanceCount++;

                    _instancedBatches.packBatch(batchIdx, batch_);

                    instance.instanceIndex = instanceIndex;

                    if (resetCustomAttribs) {
                        this._resetCustomInstancedAttribs(instance);
                    }

                    this._saveInstancedData(
                        instance, batchIdx, instanceIndex, savedCustomInstancedAttribs, worldMatrix, restoreTransform
                    );

                    _updateSkeleton(batchRenderable, instance);

                    return;
                }

                const bufferUsage = (lastBatch.firstInstance + lastBatch.capacity) * this.bytesPerInstance;

                const bufferSize = _worldTransformsBack.byteLength;

                let countLeft = (bufferSize - bufferUsage) / this.bytesPerInstance;

                if (countLeft < 1) {
                    countLeft = this._reallocBuffers(bufferUsage);
                    _worldTransformsBack = this._worldTransformsBack; // eslint-disable-line
                    _centers = this._centers; // eslint-disable-line
                    _flagBuffers = this._flagBuffers; // eslint-disable-line
                    console.assert(countLeft >= 1); // 'could not alloc more memory for instances');
                }

                const { reallocStrategy } = batchRenderable;

                const newCapacity = Math.min(reallocStrategy(batch_.capacity), batch_.capacity + countLeft);

                if (nextBatch === null) {
                    batch_.capacity = newCapacity;
                } else {
                    const shift = newCapacity - batch_.capacity;
                    batch_.capacity = newCapacity;

                    shiftBuffer(
                        _worldTransformsBack,
                        nextBatch.firstInstance,
                        shift,
                        _instancedElementsPerInstance
                    );

                    shiftBuffer(
                        _centers,
                        nextBatch.firstInstance,
                        shift,
                        centerElementsPerInstance
                    );

                    shiftBuffer(
                        _flagBuffers,
                        nextBatch.firstInstance,
                        shift,
                        1
                    );

                    // shift all after current
                    _instancedBatches.shiftFirstInstance(batchIdx, shift);
                }

                {
                    const instanceIndex = batch_.instanceCount++;

                    _instancedBatches.packBatch(batchIdx, batch_);

                    instance.instanceIndex = instanceIndex;

                    this._saveInstancedData(
                        instance, batchIdx, instanceIndex, savedCustomInstancedAttribs, worldMatrix, restoreTransform
                    );

                    _updateSkeleton(batchRenderable, instance);
                }
            }
        };
    }()),

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#deleteInstance
     * @summary Deletes an instance from the batch.
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance to delete.
     */
    deleteInstance: (function _deleteInstance() {
        const batch_ = new instancedBatch();

        return function deleteInstance(instance) {
            const { instanceId, instanceIndex } = instance;

            console.assert(instanceId !== null); // 'instanceId is not valid');
            console.assert(instanceIndex !== null); // 'instanceIndex is not valid');

            const { _instancedBatches, _uniqueInstances, _freeIndices } = this;

            const batchRenderable = _uniqueInstances.get(instanceId);

            const { batchIdx } = batchRenderable;

            _instancedBatches.unpackBatch(batchIdx, batch_);

            const freeIndices = _freeIndices.get(batchRenderable);

            this.setInstanceVisibility(instance, false, false);

            batchRenderable.release();

            freeIndices.push(instanceIndex);

            instance._instanceId = null;
            instance.instanceIndex = null;
            instance._instanceIdentifierExpired = false;
        };
    }()),

    /**
     * @function module:@webgears-app/engine-core.InstanceDataManager#setInstanceVisibility
     * @summary Sets instance visibility.
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @param {boolean} visibility Visibility.
     * @param {boolean} cullingEnabled Whether the culling is enabled for this instance.
     */
    setInstanceVisibility: (function _setInstanceVisibility() {
        const currentFrameVisibilityFlag = 0x02;
        const frustumCullingDisabledFlag = 0x08;

        const batch_ = new instancedBatch();

        return function setInstanceVisibility(instance, visibility, cullingEnabled) {
            const { _instancedBatches, _flagBuffers, _uniqueInstances } = this;
            const { instanceIndex, instanceId } = instance;
            const { batchIdx } = _uniqueInstances.get(instanceId);

            _instancedBatches.unpackBatch(batchIdx, batch_);

            const { firstInstance } = batch_;

            {
                const globalIndex = firstInstance + instanceIndex;

                if (visibility) {
                    _flagBuffers[globalIndex] |= currentFrameVisibilityFlag;
                } else {
                    _flagBuffers[globalIndex] &= ~currentFrameVisibilityFlag;
                }

                if (!cullingEnabled) {
                    _flagBuffers[globalIndex] |= frustumCullingDisabledFlag;
                } else {
                    _flagBuffers[globalIndex] &= ~frustumCullingDisabledFlag;
                }
            }
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/componentStorage.js
/**
 * @class module:@webgears-app/engine-core.ComponentStorage
 * @param {module:@webgears-app/engine-core.EntityManager} entityManager The entity manager the storage belongs to.
 * @param {class} componentClass A component's class
 * @summary The component storage base class.
 * @abstract
 */
class ComponentStorage {
    constructor(entityManager, componentClass) {
        this._componentClass = componentClass;
        this._entityManager = entityManager;
        this._entities = [];
    }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#add
     * @abstract
     * @param {number} entity An entity.
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @summary Adds component into the storage.
     * @desc Returns index of new component in the storage.
     * @returns {number}
     */
    add(entity, component) { return 0; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#has
     * @abstract
     * @param {number} index Index of the component in the storage.
     * @summary Tests if the storage has valid component in the position that is targeted by the index.
     * @desc Returns true if component in the index's position is valid.
     * @returns {boolean}
     */
    has(index) { return true; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#delete
     * @abstract
     * @param {number} index Index of the component in the storage.
     * @summary Deletes component in the position that is targeted by the index.
     */
    delete(index) { }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#get
     * @abstract
     * @param {number} index Index of the component in the storage.
     * @summary Returns a component by the index or null if component does not exists.
     * @returns {?module:@webgears-app/engine-core.Component}
     */
    get(index) { return null; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#getEntity
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @abstract
     * @returns {?number}
     * @summary Returns an entity by component or null if storage has no entity for the component.
     */
    getEntity(component) { return null; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#components
     * @returns {Iterator}
     * @summary Returns the component iterator.
     * @abstract
     */
    components() { return []; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#entries
     * @returns {Iterator}
     * @summary Returns the entries iterator where the each entry is a pair [entry, component]
     * @abstract
     */
    entries() { return []; }

    /**
     * @function module:@webgears-app/engine-core.ComponentStorage#dispose
     * @summary Disposes storage.
     * @abstract
     */
    dispose() { }

    /**
     * @var module:@webgears-app/engine-core.ComponentStorage#count
     * @type {number}
     * @readonly
     * @summary The number of components.
     */
    get count() { return 0; }

    /**
     * @var module:@webgears-app/engine-core.ComponentStorage#componentClass
     * @type {class}
     * @readonly
     * @summary The class of the components that are stored in that storage.
     */
    get componentClass() { return this._componentClass; }

    /**
     * @var module:@webgears-app/engine-core.ComponentStorage#entityManager
     * @type {module:@webgears-app/engine-core.EntityManager}
     * @summary The reference to the instance of entity manager.
     */
    get entityManager() { return this._entityManager; }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/defaultComponentStorage.js



class _ComponentIterator {
    constructor(components, countComponents) {
        this._components = components;
        this._result = { done: false, value: null };
        this._current = 0;
        this._componentCounter = 0;
        this._countComponents = countComponents;
    }

    [Symbol.iterator]() { return this; }

    next() {
        const {
            _components,
            _countComponents,
            _result,
            _componentCounter
        } = this;

        const len = _components.length;

        if (_result.done = (_componentCounter >= _countComponents || this._current >= len)) return _result; //eslint-disable-line

        for (let i = this._current; i < len;) {
            const component = _components[i++];

            if (component === null) continue;

            _result.value = component;

            this._current = i;

            break;
        }

        this._componentCounter++;

        return _result;
    }
}

class _EntryIterator {
    constructor(components, countComponents, entities) {
        const entryValue = [null, null];

        this._components = components;
        this._result = { done: false, value: entryValue };
        this._current = 0;
        this._componentCounter = 0;
        this._countComponents = countComponents;
        this._entities = entities;
    }

    [Symbol.iterator]() { return this; }

    next() {
        const {
            _components,
            _countComponents,
            _result,
            _componentCounter,
            _entities
        } = this;

        const len = _components.length;

        if (_result.done = (_componentCounter >= _countComponents || this._current >= len)) return _result; //eslint-disable-line

        for (let i = this._current; i < len;) {
            const entity = _entities[i];
            const component = _components[i++];

            if (component === null) continue;

            _result.value[0] = entity;
            _result.value[1] = component;

            this._current = i;

            break;
        }

        this._componentCounter++;

        return _result;
    }
}

/**
 * @class module:@webgears-app/engine-core.DefaultComponentStorage
 * @param {class} componentClass A component's class
 * @extends module:@webgears-app/engine-core.ComponentStorage
 * @summary Default components storage
 */
class defaultComponentStorage_DefaultComponentStorage extends ComponentStorage {
    constructor(entityManager, componentClass) {
        super(entityManager, componentClass);

        this._components = [];
        this._freeComponents = [];
        this._countComponents = 0;
    }

    /**
     * @function module:@webgears-app/engine-core.DefaultComponentStorage#add
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @summary Adds component into the storage.
     * @desc Returns index of new component in the storage.
     * @returns {number}
     */
    add(entity, component) {
        const { _freeComponents, _components, _entities } = this;

        const index = _freeComponents.length > 0 ? _freeComponents.pop() : _components.length;

        _components[index] = component;
        _entities[index] = entity;

        this._countComponents++;

        return index;
    }

    /**
     * @function module:@webgears-app/engine-core.DefaultComponentStorage#has
     * @param {number} index Index of the component in the storage.
     * @summary Tests if the storage has valid component in the position that is targeted by the index.
     * @desc Returns true if component in the index's position is valid.
     * @returns {boolean}
     */
    has(index) {
        const { _components, _componentClass } = this;
        return index < _components.length && _components[index] instanceof _componentClass;
    }

    _delete(index) {
        const { _freeComponents, _components, _entities } = this;

        _components[index] = null;
        _entities[index] = null;

        _freeComponents.push(index);

        this._countComponents--;
    }

    /**
     * @function module:@webgears-app/engine-core.DefaultComponentStorage#delete
     * @param {number} index Index of the component in the storage.
     * @summary Deletes component by the index.
     */
    delete(index) {
        console.assert(this.has(index), `index: ${index} is not valid`);
        this._delete(index);
    }

    /**
     * @function module:@webgears-app/engine-core.DefaultComponentStorage#get
     * @param {number} index Index of the component in the storage.
     * @summary Returns a component by the index or null if component does not exists.
     * @returns {?module:@webgears-app/engine-core.Component}
     */
    get(index) {
        return this._components[index];
    }

    getEntity(component) {
        const { _components, _entities } = this;
        const index = _components.indexOf(component);

        return index >= 0 ? _entities[index] : null;
    }

    components() { return new _ComponentIterator(this._components, this._countComponents); }

    entries() { return new _EntryIterator(this._components, this._countComponents, this._entities); }

    dispose() {
        for (const c of this.components()) {
            c.release();
        }

        this._components.length = 0;
        this._freeComponents.length = 0;
        this._countComponents = 0;
    }

    get count() { return this._countComponents; }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/component.js




/**
 * @class module:@webgears-app/engine-core.Component
 * @extends DisposableUsageCounter
 * @summary The component base class.
 * @abstract
 */
class component_Component extends disposeableUsageCounter_DisposableUsageCounter {
    // if component is registered, it has mask and index

    /**
     * @var module:@webgears-app/engine-core.Component#mask
     * @type {number}
     * @summary A component's mask for the mask element
     * @desc The entity manager stores components masks in the bit set made of unit32 elements.
     * Each component has unique index to refer mask elements.
     * Each component has mask index to refer mask's uint32 element.
     * Each component has uint32 bit mask.
     */
    get mask() { return this.constructor.mask; }

    /**
     * @var module:@webgears-app/engine-core.Component#mask
     * @type {number}
     * @summary A component's index to refer component's mask elements.
     * @desc The entity manager stores components masks in the bit set made of unit32 elements.
     * Each component has unique index to refer mask.
     * Each component has mask index to refer mask's uint32 element.
     * Each component has uint32 bit mask.
     */
    get index() { return this.constructor.index; }

    /**
     * @var module:@webgears-app/engine-core.Component#maskIndex
     * @type {number}
     * @summary A component's mask index to refer component's mask uint32 element.
     * @desc The entity manager stores components masks in the bit set made of unit32 elements.
     * Each component has unique index to refer mask.
     * Each component has mask index to refer mask's uint32 element.
     * Each component has uint32 bit mask.
     */
    get maskIndex() { return this.constructor.maskIndex; }

    /**
     * @function module:@webgears-app/engine-core.Component#clone
     * @abstract
     * @summary Make a clone of the component.
     */
    clone() {}

    /**
     * @var module:@webgears-app/engine-core.Component.storageClass
     * @type {class}
     * @summary A component's storage class.
     */
    static get storageClass() {
        return defaultComponentStorage_DefaultComponentStorage;
    }
}

Object.defineProperty(component_Component.prototype, 'isComponent', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/transforms/transform.js




const _splitTransform = new AffineSplitTransform3();

class _TransformStateMask {
    static get UPDATE_NOTHING() { return 0; }
    static get UPDATE_LOCAL() { return 1; }
    static get UPDATE_COMPONENTS() { return 2; }
    static get UPDATE_WORLD() { return 4; }
    static get UPDATE_ALL() { return 7; }
}

/**
 * @class module:@webgears-app/engine-core.Transform
 * @param {object} [parameters={}] Parameters.
 * @param {module:@webgears-app/math.Vector3} [parameters.position = new Vector3(0., 0., 0.)] Local position
 * @param {module:@webgears-app/math.Vector3} [parameters.scale = new Vector3(1., 1., 1.)] Local scale
 * @param {module:@webgears-app/math.Quaternion} [parameters.orientation = new Quaternion()] Local orientation.
 * @summary Transform component.
  */
class transform_Transform extends component_Component {
    /**
     * @namespace module:@webgears-app/engine-core.Transform.StateMask
     * @property {number} UPDATE_NOTHING
     * @property {number} UPDATE_LOCAL
     * @property {number} UPDATE_COMPONENTS
     * @property {number} UPDATE_WORLD
     * @property {number} UPDATE_ALL
     * @summary Transform's state flags
     */
    static get StateMask() {
        return _TransformStateMask;
    }

    constructor(parameters = {}) {
        const {
            position = new Vector3(0.0, 0.0, 0.0),
            scale = new Vector3(1.0, 1.0, 1.0),
            orientation = new quaternion_Quaternion()
        } = parameters;

        super();

        this.position = position.clone();
        this.scale = scale.clone();
        this.orientation = orientation.clone();

        _splitTransform.translation.copy(position);
        _splitTransform.scaling.copy(scale);
        _splitTransform.quaternion.copy(orientation);

        this.matrix = new AffineMatrix3().fromSplitTransform(_splitTransform);
        this.worldMatrix = new AffineMatrix3();

        this.state = _TransformStateMask.UPDATE_LOCAL | _TransformStateMask.UPDATE_WORLD;
    }

    /**
     * @var module:@webgears-app/engine-core.Transform#state
     * @type {module:@webgears-app/engine-core.Transform.StateMask}
     * @summary Flags to describe transform state
     */
    clone() {
        const clone_ = new transform_Transform();

        clone_.position.copy(this.position);
        clone_.scale.copy(this.scale);
        clone_.orientation.copy(this.orientation);
        clone_.matrix.copy(this.matrix);

        clone_.state = this.state | _TransformStateMask.UPDATE_WORLD;

        return clone_;
    }

    worldMatrixPaste(targetMatrix) {
        targetMatrix.copy(this.worldMatrix);
    }

    splitWorldTransformPaste(splitTransform = new AffineSplitTransform3()) {
        return splitTransform.fromMatrix(this.worldMatrix);
    }

    matrixPaste(targetMatrix) {
        targetMatrix.copy(this.matrix);
    }

    matrixCopy(sourceMatrix) {
        this.matrix.copy(sourceMatrix);
        this.state = _TransformStateMask.UPDATE_COMPONENTS | _TransformStateMask.UPDATE_COMPONENTS;
    }

    splitTransformPaste(splitTransform = new AffineSplitTransform3()) {
        return splitTransform.fromMatrix(this.matrix);
    }

    positionCopy(position) {
        this.position.copy(position);
        this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
    }

    scaleCopy(scale) {
        this.scale.copy(scale);
        this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
    }

    orientationCopy(orientation) {
        this.orientation.copy(orientation);
        this.state = _TransformStateMask.UPDATE_WORLD | _TransformStateMask.UPDATE_LOCAL;
    }
}

Object.defineProperty(transform_Transform.prototype, 'isTransform', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/common.js




// based on: http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/
function temperatureToHue(temperature, hue = new Vector3()) {
    let t = temperature;

    let r = 0;
    let g = 0;
    let b = 0;

    t /= 100.0;

    if (t <= 66.0) {
        r = 255;

        g = t;
        g = 99.4708025861 * Math.log(g) - 161.1195681661;

        if (g < 0) g = 0;
        if (g > 255) g = 255;
    } else {
        r = t - 60;
        r = 329.698727466 * Math.pow(r, -0.1332047592);

        if (r < 0) r = 0;
        if (r > 255) r = 255;

        g = t - 60;
        g = 288.1221695283 * Math.pow(g, -0.0755148492);

        if (g < 0) g = 0;
        if (g > 255) g = 255;
    }

    if (t >= 66) {
        b = 255;
    } else {
        if (t <= 19) {
            b = 0;
        } else {
            b = t - 10;
            b = 138.5177312231 * Math.log(b) - 305.0447927307;

            if (b < 0) b = 0;
            if (b > 255) b = 255;
        }
    }

    hue.set(r / 255.0, g / 255.0, b / 255.0);

    return hue;
}

function illuminanceToScalarLuminance(illuminance) {
    // https://en.wikipedia.org/wiki/Light_meter#Exposure_equations

    // Reflected-light meter calibration constant for Canon, Nikon, and Sekonic receptors.
    const K = 12.5;

    // Incident-light meter calibration constant for flat (cosine-responding) receptor.
    const C = 250;

    const twoPowInEV100 = illuminance / C;

    return K * twoPowInEV100;
}

function illuminanceToLuminance(illuminance, luminance = new Vector3(1.)) {
    // https://en.wikipedia.org/wiki/Light_meter#Exposure_equations

    // Reflected-light meter calibration constant for Canon, Nikon, and Sekonic receptors.
    const K = 12.5;

    // Incident-light meter calibration constant for flat (cosine-responding) receptor.
    const C = 250;

    const twoPowInEV100 = illuminance / C;

    luminance.multiplyNumber(K * twoPowInEV100);

    return luminance
}

function scalarLuminanceToIlluminance(luminance) {
    // https://en.wikipedia.org/wiki/Light_meter#Exposure_equations

    // Reflected-light meter calibration constant for Canon, Nikon, and Sekonic receptors.
    const K = 12.5;

    // Incident-light meter calibration constant for flat (cosine-responding) receptor.
    const C = 250;

    const twoPowInEV100 = luminance / K;

    return C * twoPowInEV100;
}

function luminousIntensityToScalarIlluminance(luminousIntensity, distance) {
    return luminousIntensity / Math.max(distance ** 2, 0.01 ** 2);
}

function computeLightProperties(light) {
    const { temperature, _colorFilter } = light;

    if (light.isDirectionalLight) {
        const { _luminance, _illuminance } = light;

        temperatureToHue(temperature, _luminance);

        _luminance.x *= _colorFilter.r;
        _luminance.y *= _colorFilter.g;
        _luminance.z *= _colorFilter.b;

        illuminanceToLuminance(_illuminance, _luminance);
    } else if (light.isAmbientLight) {
        const { _luminance, _illuminance } = light;

        temperatureToHue(temperature, _luminance);

        illuminanceToLuminance(_illuminance, _luminance);
    } else if (light.isPointLight) {
        const { _luminousIntensity, _luminousPower } = light;
        const solidAngle = 4.0 * Math.PI;

        temperatureToHue(temperature, _luminousIntensity);

        _luminousIntensity.x *= _colorFilter.r;
        _luminousIntensity.y *= _colorFilter.g;
        _luminousIntensity.z *= _colorFilter.b;

        _luminousIntensity.multiplyNumber(_luminousPower / solidAngle);

        light._illuminance = luminousIntensityToScalarIlluminance(_luminousPower / solidAngle, 1);
    } else if (light.isSpotLight) {
        const { _luminousIntensity, _luminousPower } = light;

        temperatureToHue(temperature, _luminousIntensity);

        _luminousIntensity.x *= _colorFilter.r;
        _luminousIntensity.y *= _colorFilter.g;
        _luminousIntensity.z *= _colorFilter.b;

        _luminousIntensity.multiplyNumber(_luminousPower / Math.PI);

        light._illuminance = luminousIntensityToScalarIlluminance(_luminousPower / Math.PI, 1);
    }
}



function updateLightPositionAndDirection(light, transformMatrix, viewMatrix) {
    if (light.isDirectionalLight) {
        const { _direction } = light;

        transformMatrix.axisZPaste(_direction);
        _direction.negate();

        _direction.multiplyLinearMatrix(viewMatrix);
        _direction.normalize();
    } else if (light.isSpotLight) {
        const { _position, _direction } = light;

        transformMatrix.translationPaste(_position);
        _position.multiplyAffineMatrix(viewMatrix);

        transformMatrix.axisZPaste(_direction);
        _direction.negate();
        _direction.multiplyLinearMatrix(viewMatrix);
        _direction.normalize();
    } else if (light.isPointLight) {
        const { _position } = light;

        transformMatrix.translationPaste(_position);
        _position.multiplyAffineMatrix(viewMatrix);
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/baseScene.js






/**
 * @class module:@webgears-app/engine-core.BaseScene
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @abstract
 * @param parameters Parameters.
 * @param {number} [parameters.maxSceneNode=undefined] Max number of nodes in the scene.
 * @param {number} [parameters.batchMap=null] Initial batch map.
 * @param {string} parameters.name The name of the scene.
 * @param {object} parameters.config The scene's configuration.
 * @param {Array} [parameters.config.customAttributes=[]] Instanced attributes layout.
 * It's described [here]{@link module:@webgears-app/engine-core.InstanceDataManager}
 * @summary Base scene class.
 */
class baseScene_BaseScene extends disposeableUsageCounter_DisposableUsageCounter {
    constructor({ maxSceneNodes, batchMap = null, name = '', config = {} } = {}) {
        const { customAttributes = [] } = config;

        super();

        this.name = name;

        this._instanceDataManager = new instanceDataManager_InstanceDataManager({
            batchMap,
            initialSceneNodes: maxSceneNodes,
            customAttributes
        });

        // light
        this._maxEnvIlluminance = 0; // lux
        this._maxIlluminance = 0;    // lux

        this.extras = undefined;

        this._config = {};
        this._saveConfig(config);

        this._forceUpdateRenderQueue = false;
        this._lastFrameSceneGraphUpdate = -1;
        this._lastCullingCamera = null;
        this._lastCullingFrameNumber = -1;
    }

    /**
     * @function module:@webgears-app/engine-core.BaseScene#shrinkToFit
     * @param {boolean} [emptyBatchesOnly = true] Specifies whether the method shrinks only empty batches memory (slow)
     * @param {number} [byteCountThreshold = 0] Threshold to skip shrink in case expected memory amount to release
     * is less then threshold value
     * @returns {number}
     * @summary Shrinks instanced data memory, returns byte count had been released or estimated release memory amount
     * in case shrink had been skipped by threshold.
     * @desc After many operations to delete and add instances internal instanced data memory can be fragmented, this
     * method physically delete unused instanced memory.
     * The method is too expensive to call after any instance delete and an instance takes very few bytes of memory,
     * so it makes a sense to call this method only after many thousands of scene management operations.
     * @example
     * const scene = new DotScene({});
     *
     * // any scene management operations... add / delete / change materials and etc.
     * // ...
     *
     * const byteCount = scene.shrinkToFit();
     *
     * console.log(`released: {byteCount} bytes`);
     *
     * scene.forceUpdateRenderQueue = true;
     *
     */
    shrinkToFit(emptyBatchesOnly = true, byteCountThreshold = 0) {
        return this._instanceDataManager.shrinkToFit(emptyBatchesOnly, byteCountThreshold);
    }

    /**
     * @function module:@webgears-app/engine-core.BaseScene#getDirectShadowCastersData
     * @abstract
     * @param {module:@webgears-app/engine-core.Camera} camera
     * @returns {?object}
     * @summary Returns directional shadow casters' data related to the camera.
     */
    getDirectShadowCastersData(camera) {
        return null;
    }

    /**
     * @function module:@webgears-app/engine-core.BaseScene#getSpotShadowCasters
     * @abstract
     * @exports {?Array<object>}
     * @summary Returns the array of light shadow shadow casters' data.
     */
    getSpotShadowCasters() {
        return null;
    }

    /**
     * @function module:@webgears-app/engine-core.BaseScene#getOmniShadowCasters
     * @abstract
     * @exports {?Array<object>}
     * @summary Returns the array of omnidirectional shadow casters' data.
     */
    getOmniShadowCasters() {
        return null;
    }

    _saveConfig(config = {}) {
        const { customAttributes = [] } = config;
        const { _config } = this;

        _config.customAttributes = [];

        for (const ca of customAttributes) {
            const { semantic, countComponents } = ca;
            _config.customAttributes.push({ semantic, countComponents });
        }
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#name
     * @type {string}
     * @summary The name of the scene.
     */

    /**
     * @var module:@webgears-app/engine-core.Scene#maxEnvLuminance
     * @type {number}
     * @summary The maximum value of scene environment brightness in cd / m^2.
     */
    get maxEnvLuminance() {
        return illuminanceToScalarLuminance(this._maxEnvIlluminance);
    }

    set maxEnvLuminance(value) {
        this._maxEnvIlluminance = scalarLuminanceToIlluminance(value);
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#maxLuminance
     * @type {number}
     * @summary The maximum value of scene brightness in cd / m^2.
     * @readonly
     */
    get maxLuminance() {
        return illuminanceToScalarLuminance(this._maxIlluminance);
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#forceUpdateRenderQueue
     * @summary Specifies whether frustum cull method must update render queue even if scene had no changes.
     * @type {boolean}
     */
    get forceUpdateRenderQueue() {
        return this._forceUpdateRenderQueue;
    }

    set forceUpdateRenderQueue(value) {
        return this._forceUpdateRenderQueue = value;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#instanceDataManager
     * @type {module:@webgears-app/engine-core.InstanceDataManager}
     * @readonly
     * @summary Instance data manager of the scene.
     */
    get instanceDataManager() {
        return this._instanceDataManager;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#config
     * @type {object}
     * @readonly
     * @summary Scene's configuration.
     */
    get config() {
        return this._config;
    }

    // private:
    _dispose() {
        super._dispose();
    }
}

Object.defineProperty(baseScene_BaseScene.prototype, 'isBaseScene', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/light.js




/**
 * @class module:@webgears-app/engine-core.Light
 * @extends module:@webgears-app/engine-core.Component
 * @abstract
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A light's name.
 * @param {number} parameters.temperature A light's temperature in Kelvins.
 * @param {module:@webgears-app/math.RGBColor} parameters.colorFilter A light's color filter.
 * @summary The light source class.
 */
class light_Light extends component_Component {
    constructor({ name, temperature, colorFilter = new rgb_color_RGBColor(1, 1, 1) }) {
        super();

        this._name = name;

        this._colorFilter = colorFilter.clone();

        this._temperatureUpdated = false;

        if (temperature !== undefined) {
            this._temperature = temperature; // Kelvin
            this._temperatureUpdated = true;
        }
    }

    // TODO:: make protected
    markUpdated() {
        this._temperatureUpdated = false;
    }

    /**
     * @var module:@webgears-app/engine-core.Light#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether light system should update this component.
     * @desc Any time light's temperature or color filter takes a change, needsUpdate property is gotten true.
     */
    get needsUpdate() {
        return this._temperatureUpdated;
    }

    /**
     * @var module:@webgears-app/engine-core.Light#getColorFilter
     * @param {module:@webgears-app/math.RGBColor} dst Destination RGBColor object.
     * @summary Copies light's color filter into destination color.
     */
    getColorFilter(dst) {
        dst.copy(this._colorFilter);
    }

    /**
     * @var module:@webgears-app/engine-core.Light#setColorFilter
     * @param {module:@webgears-app/math.RGBColor} color Source RGBColor object.
     * @summary Set light's color filter from source color.
     */
    setColorFilter(color) {
        this._colorFilter.copy(color);
        this._temperatureUpdated = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Light#temperature
     * @type {number}
     * @summary A light's temperature.
     */
    get temperature() {
        return this._temperature;
    }

    set temperature(value) {
        this._temperature = value;
        this._temperatureUpdated = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Light#name
     * @type {string}
     * @summary A light's name.
     */
    get name() {
        return this._name;
    }
}

Object.defineProperty(light_Light.prototype, 'isLight', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/lightShadowCaster.js



/**
 * @class module:@webgears-app/engine-core.LightShadowCaster
 * @extends module:@webgears-app/engine-core.Component
 * @param {object} parameters Parameters.
 * @param {boolean} [parameters.castShadow=false] Should the light casts shadows or not.
 * @summary The light shadow caster class.
 */
class lightShadowCaster_LightShadowCaster extends component_Component {
    constructor({ castShadow = false }) {
        super();

        this.castShadow = castShadow;

        this._casterIndex = -1;

        this._cascades = null;

        this._spotShadowCasterData = null;

        this._omniShadowCasterData = null;
    }
}

Object.defineProperty(lightShadowCaster_LightShadowCaster.prototype, 'isLightShadowCaster', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderQueueGroups.js



const RenderQueueGroup = makeEnum([
    ['EARLIEST', 0],
    ['BACKGROUND', 100],
    ['ENV_EARLY', 200],
    ['MAIN_EARLY', 300],
    ['MAIN', 400],
    ['MAIN_LATE', 500],
    ['ENV_LATE', 600],
    ['LENS_FLARES', 700],
    ['SPRITES', 800],
    ['OVERLAYS', 900],
    ['LATEST', Infinity]
]);




// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderable.js




/**
 * @callback module:@webgears-app/engine-core.InstancedBatchReallocationStrategy
 * @summary Calculates new batch capacity to emplace new instances in the batch.
 * @param {number} capacity Current capacity.
 * @returns {number}
 */

function _defaultReallocStrategy(capacity) {
    return capacity < 16 ? Math.max(1, capacity * 2) : capacity + 1;
}

let _lastRenderableId = 0;

/**
 * @class module:@webgears-app/engine-core.Renderable
 * @param {?module:@webgears-app/engine-core.Geometry} geometry A geometry.
 * @param {module:@webgears-app/engine-core.Material} material A material.
 * @summary The base class for any renderable objects.
 */
class renderable_Renderable {
    constructor(geometry, material) {
        this.renderQueueGroup = RenderQueueGroup.MAIN;

        if (material !== null) {
            material.retain();
        }

        this._material = material;
        this._depthMaterials = [ null, null ];

        if (geometry !== null) {
            geometry.retain();
        }

        this._geometry = geometry;

        this._instanceId = null; // Instance is an object with unique pair of geometry and material

        this.instanceIndex = null;

        this.reallocStrategy = _defaultReallocStrategy;

        this._instanceIdentifierExpired = false;
        this._lastUpdateFrameNumber = 0;

        this._customAttributesToRead = [];
        this._customAttributesToWrite = [];

        this._loaded = true;

        Object.defineProperty(this, 'id', { value: ++_lastRenderableId, writable: false });
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#id
     * @readonly
     * @type {number}
     * @summary Unique renderable identifier.
     */

    get unloaded() {
        return !this._loaded;
    }

    /**
     * @function module:@webgears-app/engine-core.Renderable#getInstancedAttribute
     * @summary Returns value of the instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} outVal The output value.
     * @returns {Promise<number|Vector2|Vector3|RGBColor|Array|Float32Array>}
     */
    getInstancedAttribute(semantic, outVal) {
        return new Promise((resolve) => {
            this._customAttributesToRead.push({ resolve, semantic, outVal });
        });
    }

    /**
     * @function module:@webgears-app/engine-core.Renderable#setInstancedAttribute
     * @summary Sets value of instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {number|Vector2|Vector3|RGBColor|Array|Float32Array} inVal The value of the attribute.
     */
    setInstancedAttribute(semantic, inVal) {
        this._customAttributesToWrite.push({ semantic, inVal });
    }

    get lastUpdateFrameNumber() {
        return this._lastUpdateFrameNumber;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#geometry
     * @type {module:@webgears-app/engine-core.Geometry}
     * @summary The renderable's geometry.
     */
    get geometry() {
        return this._geometry;
    }

    set geometry(value) {
        console.assert(value === null || value.unloaded === this.unloaded);
        // 'geometry must have the same .unloaded value as renderable');

        if (this._geometry === value) { return; }

        if (this._instanceId !== null) {
            this._instanceIdentifierExpired = true;
        }

        if (this._geometry !== null) {
            this._geometry.release();
        }

        this._geometry = value;
        if (this._geometry !== null) {
            this._geometry.retain();
        }
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#reallocStrategy
     * @type {module:@webgears-app/engine-core.InstancedBatchReallocationStrategy}
     * @summary The reallocation strategy for batch the renderable belongs to.
     * Default strategy is: capacity < 16 ? Math.max(1, capacity * 2) : capacity + 1;
     * @desc Changes can make any effects only before renderable first time rendered.
     */

    /**
     * @var module:@webgears-app/engine-core.Renderable#renderQueueGroup
     * @type {module:@webgears-app/engine-core.RenderQueueGroup}
     * @summary The render queue group.
     * Default is: RenderQueueGroup.MAIN
     * @desc Changes can make any effects only before renderable first time rendered.
     */

    /**
     * @var module:@webgears-app/engine-core.Renderable#material
     * @type {module:@webgears-app/engine-core.Material}
     * @summary The renderable's material.
     */
    get material() {
        return this._material;
    }

    set material(value) {
        console.assert(value === null || value.unloaded === this.unloaded);
        // 'material must have the same .unloaded value as renderable');

        if (this._material === value) { return; }

        if (this._instanceId !== null) {
            this._instanceIdentifierExpired = true;
        }

        if (this._material !== null) {
            this._material.release();
        }

        this._depthMaterials[0] = null;
        this._depthMaterials[1] = null;

        this._material = value;
        if (this._material !== null) {
            this._material.retain();
        }
    }

    get depthMaterials() {
        return this._depthMaterials;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#needsUpdate
     * @type {boolean}
     * @summary Specifies whether renderer should reassembly VAO for the renderable.
     */
    get needsUpdate() {
        return false;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#instanceId
     * @type {number}
     * @readonly
     * @summary The renderable's unique identifier.
     */
    get instanceId() {
        return this._instanceId;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#instanceIdentifierExpired
     * @type {boolean}
     * @readonly
     * @summary {Whether instanceId point to the actual batch or not.}
     */
    get instanceIdentifierExpired() {
        return this._instanceIdentifierExpired;
    }

    /**
     * @var module:@webgears-app/engine-core.SubMesh#skeleton
     * @type {?module:@webgears-app/engine-core.Skeleton}
     * @readonly
     * @summary The skeleton of the renderable.
     */
    get skeleton() {
        return null;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#instanceIndex
     * @type {number}
     * @summary Instance index.
     */

    /**
     * @function module:@webgears-app/engine-core.Renderable#clone
     * @summary Clones renderable.
     * @returns { module:@webgears-app/engine-core.Renderable}
     */
    clone() {
        const { geometry, material, _depthMaterials, renderQueueGroup, reallocStrategy } = this;

        const clone_ = new renderable_Renderable(geometry, material);

        clone_.renderQueueGroup = renderQueueGroup;
        clone_.reallocStrategy = reallocStrategy;

        clone_._depthMaterials = _depthMaterials.slice();

        return clone_;
    }

    async load() {
        console.assert(this.unloaded); //  'already loaded');

        await Promise.all((function* () {
            if (this._geometry !== null) {
                yield this._geometry.load();
            }
            if (this._material !== null) {
                yield this._material.load();
            }
        }).call(this))

        this._loaded = true;

        this._emitLoadEvent();
    }

    unload() {
        console.assert(this._loaded); // , 'already unloaded');

        if (this._geometry !== null) {
            this._geometry.unload();
        }

        if (this._material !== null) {
            this._material.unload();
        }

        this._loaded = false;

        this._emitUnloadEvent();
    }

    /**
     * @function module:@webgears-app/engine-core.Renderable#dispose
     * @summary Disposes the renderable. It releases renderable's material and geometry.
     */
    dispose() {
        if (this._geometry !== null) {
            this._geometry.release();
            this._geometry = null;
        }

        if (this._material !== null) {
            this._material.release();
            this._material = null;
        }

        this._emitDisposeEvent();
    }

    /**
     * @function module:@webgears-app/engine-core.Renderable#resetEvents
     * @summary removes all subscribers and resets events.
     */
    resetEvents() {
        delete this._onLoad;
        delete this._onUnload;
        delete this._onDispose;
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#onUnload
     * @type {module:@webgears-app/event.Event}
     * @readonly
     * @summary OnUnload event.
     */
    get onUnload() {
        return this._onUnload === undefined ? (this._onUnload = new Event()) : this._onUnload; // eslint-disable-line
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#onLoad
     * @type {module:@webgears-app/event.Event}
     * @readonly
     * @summary OnLoad event.
     */
    get onLoad() {
        return this._onLoad === undefined ? (this._onLoad = new Event()) : this._onLoad; // eslint-disable-line
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable#onDispose
     * @type {module:@webgears-app/event.Event}
     * @readonly
     * @summary OnDispose event.
     */
    get onDispose() {
        return this._onDispose === undefined ? (this._onDispose = new Event()) : this._onDispose; // eslint-disable-line
    }

    _emitLoadEvent() {
        if (this._onLoad !== undefined) this._onLoad.emit();
    }

    _emitUnloadEvent() {
        if (this._onUnload !== undefined) this._onUnload.emit();
    }

    _emitDisposeEvent() {
        if (this._onDispose !== undefined) this._onDispose.emit();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/meshes/mesh.js




/**
 * @class module:@webgears-app/engine-core.SubMesh
 * @extends module:@webgears-app/engine-core.Renderable
 * @summary The class defines a part of a complete mesh.
 * @param {object} parameters Parameters.
 * @param {string} parameters.name The name of the submesh.
 * @param {module:@webgears-app/engine-core.Geometry} parameters.geometry The geometry of the submesh.
 * @param {module:@webgears-app/engine-core.Material} parameters.material The material of the submesh.
 */
class mesh_SubMesh extends renderable_Renderable {
    constructor({ name, geometry, material }) {
        super(geometry, material);

        this.name = name;

        this._skeleton = null;

        /**
         * @var module:@webgears-app/engine-core.SubMesh#extras
         * @type {any}
         * @summary Unstructred application-specific imported/exported data.
         * @desc Must be {@link JSON.stringify}-able.
         */
        this.extras = undefined;
    }

    /**
     * @var module:@webgears-app/engine-core.SubMesh#name
     * @type {string}
     * @summary The name of the submesh.
     */

    /**
     * @var module:@webgears-app/engine-core.SubMesh#skeleton
     * @type {?module:@webgears-app/engine-core.Skeleton}
     * @readonly
     * @summary The skeleton of the SubMesh.
     */
    get skeleton() {
        return this._skeleton;
    }

    clone(newName) {
        const {
            name,
            geometry,
            material,
            renderQueueGroup,
            reallocStrategy,
            _skeleton
        } = this;

        const name_ = newName || name;

        const clone_ = new mesh_SubMesh({ name: name_, geometry, material });

        clone_.renderQueueGroup = renderQueueGroup;
        clone_.reallocStrategy = reallocStrategy;
        clone_._skeleton = _skeleton;

        return clone_;
    }
}

/**
 * @class module:@webgears-app/engine-core.Mesh
 * @extends module:@webgears-app/engine-core.Component
 * @summary The class encapsulates data about 3D mesh.
 * @param {object} parameters Parameters.
 * @param {string} parameters.name The name of the mesh.
 */
class mesh_Mesh extends component_Component {
    constructor({ name = '' }) {
        super();

        this._name = name;
        this._submeshes = [];
        this._skeleton = null;
        this._lastUpdateFrameNumber = 0;

        /**
         * @var module:@webgears-app/engine-core.Mesh#extras
         * @type {any}
         * @summary Unstructred application-specific imported/exported data.
         * @desc Must be {@link JSON.stringify}-able.
         */
        this.extras = undefined;
    }

    get lastUpdateFrameNumber() {
        return this._lastUpdateFrameNumber;
    }

    /**
     * @var module:@webgears-app/engine-core.Mesh#skeleton
     * @type {?module:@webgears-app/engine-core.Skeleton}
     * @summary The skeleton of the mesh.
     */
    get skeleton() {
        return this._skeleton;
    }

    set skeleton(value) {
        const { _skeleton, _submeshes } = this;

        if (_skeleton === value) { return; }

        this._skeleton = value;

        if (this._skeleton !== null) {
            this._skeleton.retain();
        }

        for (const submesh of _submeshes) {
            submesh._skeleton = value;
        }

        if (_skeleton !== null) {
            _skeleton.release();
        }
    }

    /**
     * @var module:@webgears-app/engine-core.Mesh#name
     * @readonly
     * @type {string}
     * @summary The name of the mesh.
     */
    get name() {
        return this._name;
    }

    /**
     * @function module:@webgears-app/engine-core.Mesh#addSubMesh
     * @param {module:@webgears-app/engine-core.SubMesh} subMesh SubMesh.
     * @summary Adds sub mesh into mesh.
     */
    addSubMesh(subMesh) {
        this._submeshes.push(subMesh);
    }

    /**
     * @function module:@webgears-app/engine-core.Mesh#getSubMesh
     * @param {number} subMeshIndex An index of the sub mesh.
     * @returns {module:@webgears-app/engine-core.SubMesh}
     * @summary Returns sub mesh by index.
     */
    getSubMesh(subMeshIndex) {
        return this._submeshes[subMeshIndex];
    }

    /**
     * @var module:@webgears-app/engine-core.Mesh#subMeshCount
     * @type {number}
     * @summary Sub mesh count of the mesh.
     */
    get subMeshCount() {
        return this._submeshes.length;
    }

    /**
     * @function module:@webgears-app/engine-core.Mesh#subMeshes
     * @summary Returns submesh iterator.
     * @returns {Iterator}
     */
    subMeshes() {
        return this._submeshes.values();
    }

    /**
     * @function module:module:@webgears-app/engine-core.Mesh#clone
     * @param {string} newName
     * @summary Makes a clone of the mesh.
     * @returns {module:module:@webgears-app/engine-core.Mesh}
     */
    clone(newName) {
        const { name, _submeshes, skeleton, extras } = this;
        const name_ = newName || name;

        const clone_ = new mesh_Mesh({ name: name_ });

        for (const sm of _submeshes) {
            clone_.addSubMesh(sm.clone());
        }

        clone_.skeleton = skeleton;
        clone_.extras = extras;

        return clone_;
    }

    async _loadDependencies() {
        await Promise.all([
            super._loadDependencies(),
            ...(function*() {
                for (const subMesh of this._submeshes) {
                    yield subMesh.load();
                }
            }).call(this),
        ]);
    }

    _actuallyUnload() {
        const { _submeshes } = this;

        for (const subMesh of _submeshes) {
            subMesh.unload();
        }

        super._actuallyUnload();
    }

    _dispose() {
        const { _submeshes } = this;

        for (const subMesh of _submeshes) {
            subMesh.dispose();
        }

        this._submeshes.length = 0;

        super._dispose();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/morphs/morph.js


/**
 * @class module:@webgears-app/engine-core.Morph
 * @extends module:@webgears-app/engine-core.Component
 * @summary The class encapsulates data about morph weights.
 * @param {Array<Number>} weights Weights.
 */
class morph_Morph extends component_Component {
    constructor(weights) {
        super();

        this.weights = new Float32Array(weights);
        this.needsUpdate = false;
    }

    /**
     * @function module:module:@webgears-app/engine-core.Morph#clone
     * @summary Makes a clone of the morph component.
     * @returns {module:module:@webgears-app/engine-core.Morph}
     */
    clone() {
        return new this.constructor(this.weights);
    }
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/sprites/sprite.js




class sprite_SpriteRenderable extends renderable_Renderable {
    constructor(material) {
        super(null, material);

        this.renderQueueGroup = RenderQueueGroup.SPRITES;

        this._needsUpdate = true;
    }

    get needsUpdate() {
        return this._needsUpdate;
    }

    set needsUpdate(value) {
        this._needsUpdate = value;
    }
}

class sprite_Sprite extends component_Component {
    constructor({ name, material }) {
        super();

        this._name = name;
        this._spriteRenderable = new sprite_SpriteRenderable(material);
    }

    /**
     * @function module:@webgears-app/engine-core.Sprite#getInstancedAttribute
     * @summary Returns value of the instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} outVal The output value.
     * @returns {Promise<number|Vector2|Vector3|RGBColor|Array|Float32Array>}
     */
    getInstancedAttribute(semantic, outVal) {
        return this._spriteRenderable.getInstancedAttribute(semantic, outVal);
    }

    /**
     * @function module:@webgears-app/engine-core.Sprite#setInstancedAttribute
     * @summary Sets value of instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {number|Vector2|Vector3|RGBColor|Array|Float32Array} inVal The value of the attribute.
     */
    setInstancedAttribute(semantic, inVal) {
        this._spriteRenderable.setInstancedAttribute(semantic, inVal);
    }

    /**
     * @var module:@webgears-app/engine-core.Renderable
     * @readonly
     * @summary Sprite renderable
     */
    get renderable() {
        return this._spriteRenderable;
    }

    /**
     * @var module:@webgears-app/engine-core.Sprite#material
     * @type {module:@webgears-app/engine-core.Material}
     * @summary Sprite's material.
     */
    get material() {
        return this._spriteRenderable.material;
    }

    set material(value) {
        this._spriteRenderable.material = value;
    }

    get name() {
        return this._name;
    }

    clone(newName) {
        const { name, extras, material } = this;
        const name_ = newName || name;

        const clone_ = new sprite_Sprite({ name: name_, material });

        clone_.extras = extras;

        return clone_;
    }

    _dispose() {
        this._spriteRenderable.dispose();
        this._spriteRenderable = null;

        super._dispose();
    }

    async _loadDependencies() {
        await Promise.all([
            super._loadDependencies(),
            this._spriteRenderable.load(),
        ]);
    }

    _actuallyUnload() {
        this._spriteRenderable.unload();
        super._actuallyUnload();
    }
}

Object.defineProperty(sprite_Sprite.prototype, 'isSprite', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/visibilities/visibility.js




/**
 * @class module:@webgears-app/engine-core.Visibility
 * @extends module:@webgears-app/engine-core.Component
 * @param {object} [parameters]
 * @param {boolean} [parameters.enableCulling=true] Specifies whether the frustum culling enabled.
 * @param {boolean} [parameters.visible=true] Specifies whether the entity visible.
 * @summary The visibility class.
 */
class visibility_Visibility extends component_Component {
    constructor(parameters = {}) {
        super();

        const { enableCulling = true, visible = true } = parameters;

        this._enableCulling = enableCulling;
        this._visible = visible;
        this._needsUpdate = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Visibility#needsUpdate
     * @type {boolean}
     * @summary Whether the renderer should update the renderable visibility.
     */
    get needsUpdate() {
        return this._needsUpdate;
    }

    /**
     * @var module:@webgears-app/engine-core.Visibility#visible
     * @type {boolean}
     * @summary Specifies whether the entity visible.
     */
    get visible() {
        return this._visible;
    }

    set visible(value) {
        this._visible = value;
        this._needsUpdate = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Visibility#enableCulling
     * @type {boolean}
     * @summary Specifies whether the frustum culling enabled.
     */
    get enableCulling() {
        return this._enableCulling;
    }

    set enableCulling(value) {
        this._enableCulling = value;
        this._needsUpdate = true;
    }

    /**
     * @function module:@webgears-app/engine-core.Visibility#clone
     * @summary Makes a clone of the visibility component.
     * @returns {module:@webgears-app/engine-core.Visibility}
     */
    clone() {
        const { visible, enableCulling } = this;
        const clone_ = new visibility_Visibility({ enableCulling, visible });

        return clone_;
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/cameras/camera.js




class _ProjectionTypes {
    static get NONE() { return 0; }
    static get ORTHOGRAPHIC() { return 1; }
    static get PERSPECTIVE() { return 2; }
    static get MIXED() { return 3; }
}

/**
 * @class module:@webgears-app/engine-core.Camera
 * @extends module:@webgears-app/engine-core.Component
 * @param {object} parameters Parameters.
 * @param {string} [parameters.name=''] A camera's name.
 * @param {number} [parameters.znear=1.0] A camera's frustum near plane distance.
 * @param {number} [parameters.zfar=2000.0] A camera's frustum far plane distance.
 * @param {module:@webgears-app/math.HalfSpace3} [parameters.clipper=null]
 * Specifies the plane to modifies frustum with additional clipping plane.
 * @param {boolean} [parameters.reflected=false]
 * Modifies this frustum so it always renders from the reflection of itself through the clipper plane specified.
 * @param {object} [parameters.orthographicProjection={}] Properties to create an orthographic projection matrix.
 * @param {number} [parameters.orthographicProjection.xmag=1.0] Horizontal magnification of the view. Must not be zero.
 * @param {number} [parameters.orthographicProjection.ymag=1.0] Vertical magnification of the view. Must not be zero.
 * @param {object} [parameters.perspectiveProjection={}] Properties to create a perspective projection matrix.
 * @param {number} [parameters.perspectiveProjection.aspect=1.0] Aspect ratio of the field of view.
 * @param {number} [parameters.perspectiveProjection.yfov=0.785] Vertical field of view in radians.
 * @param {number} [parameters.aperture = 16] The relative aperture value controls how wide the lens is opened.
 * Range is from 1 to 32 'f-stops'.
 * Use ['Sunny 16 rule']{@link https://en.wikipedia.org/wiki/Sunny_16_rule} and
 * ['EV as an indicator of camera settings']{@link https://en.wikipedia.org/wiki/Exposure_value#EV_as_an_indicator_of_camera_settings}
 * as reference.
 * @param {number} [parameters.shutterSpeed = 1/125] The camera shutter speed in seconds. Controls how long the
 * aperture is opened. Range from 1/10000 seconds to 2 second or longer. Use
 * ['EV as an indicator of camera settings']{@link https://en.wikipedia.org/wiki/Exposure_value#EV_as_an_indicator_of_camera_settings}
 * as reference.
 * @param {number} [parameters.ISO = 100] The camera sensor light speed.
 * @param {number} [parameters.expComp = 0] The exposure compensation defines
 * an additional scale on top of the computed exposure.
 * @summary The Camera class.
 */
class camera_Camera extends component_Component {
    /**
     * @namespace module:@webgears-app/engine-core.Camera.ProjectionTypes
     * @property {number} NONE
     * @property {number} ORTHOGRAPHIC
     * @property {number} PERSPECTIVE
     * @property {number} MIXED
     * @summary Camera's projection types enum
     */
    static get ProjectionTypes() {
        return _ProjectionTypes;
    }

    constructor({
        name = '',
        zfar = 2000.0,
        znear = 1.0,
        clipper = null,
        reflected = false,
        orthographicProjection = {},
        perspectiveProjection = {},
        aperture = 16,
        shutterSpeed = 1 / 125,
        ISO = 100,
        expComp = 0
    }) {
        super();

        this._name = name;

        this.viewMatrix = new AffineMatrix3();
        this.projectionMatrix = new HomogeneousMatrix3();
        this.viewProjectionMatrix = new HomogeneousMatrix3();
        this.worldMatrix = new AffineMatrix3();

        const { aspect = 1.0, yfov = 0.785 } = perspectiveProjection;
        const { xmag = 1.0, ymag = 1.0 } = orthographicProjection;

        this.zfar = zfar;
        this.znear = znear;

        this.clipper = (clipper === null) ? null : clipper.clone();
        this.reflected = reflected;

        this.aspect = aspect;
        this.yfov = yfov;

        this.xmag = xmag;
        this.ymag = ymag;

        this.projectionType = camera_Camera.ProjectionTypes.PERSPECTIVE;

        this.needsUpdateProjection = true;

        this.lastFrameUpdate = 0;

        this.extras = undefined;

        this.setEV100({ aperture, shutterSpeed, ISO, expComp });

        this._aperture = aperture;
        this._shutterSpeed = shutterSpeed;
        this._ISO = ISO;
        this._expComp = expComp;

        Object.defineProperties(this, {
            onEarlyUpdateStart: { value: new Event() },
            onEarlyUpdateEnd: { value: new Event() },
            onLateUpdateEnd: { value: new Event() }
        });
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#name
     * @type {string}
     * @readonly
     * @summary A camera's name.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#viewMatrix
     * @type {module:@webgears-app/math.AffineMatrix3}
     * @summary A camera's view matrix.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#projectionMatrix
     * @type {module:@webgears-app/math.HomogeneousMatrix3}
     * @summary A camera's projection matrix.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#viewProjectionMatrix
     * @type {module:@webgears-app/math.HomogeneousMatrix3}
     * @summary The product of view and projection matrices.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#znear
     * @type {number}
     * @summary A camera's frustum near plane distance.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#zfar
     * @type {number}
     * @summary A camera's frustum far plane distance.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#aspect
     * @type {number}
     * @summary Aspect ratio of the field of view.
     * @desc It has a sense only for perspective projection.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#yfov
     * @type {number}
     * @summary Vertical field of view in radians.
     * @desc It has a sense only for perspective projection.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#xmag
     * @type {number}
     * @summary Horizontal magnification of the view. Must not be zero.
     * @desc It has a sense only for orthographic projection.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#ymag
     * @type {number}
     * @summary Vertical magnification of the view. Must not be zero.
     * @desc It has a sense only for orthographic projection.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#clipper
     * @type {module:@webgears-app/math.HalfSpace3}
     * @summary Specifies the plane to modifies frustum with additional clipping plane.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#reflected
     * @type {boolean}
     * @summary Whether camera system should modify the frustum to render from the reflection of itself.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#projectionType
     * @type {module:@webgears-app/engine-core.Camera.ProjectionTypes}
     * @summary A camera's projection type
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#needsUpdateProjection
     * @type {boolean}
     * @summary Whether camera system should update projection matrix.
     */

    /**
     * @var module:@webgears-app/engine-core.Camera#extras
     * @type {any}
     * @summary Unstructred application-specific imported/exported data.
     * @desc Must be {@link JSON.stringify}-able.
     */

    get name() {
        return this._name;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#exposure
     * @type {number}
     * @readonly
     * @summary Exposure.
     */
    get exposure() {
        return this._exposure;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#EV100
     * @type {number}
     * @readonly
     * @summary Exposure value for ISO 100 speed.
     */
    get EV100() {
        return this._EV100;
    }

    /**
     * @function module:@webgears-app/engine-core.Camera#EV100
     * @param {number} aperture The relative aperture value controls how wide the lens is opened.
     * @param {number} shutterSpeed The camera shutter speed in seconds.
     * @param {number} [ISO = 100] The camera sensor light speed.
     * @param {number} [expComp = 0] The exposure compensation.
     * @summary Set exposure value for ISO 100 speed.
     */
    setEV100({ aperture, shutterSpeed, ISO = 100, expComp = 0 }) {
        // https://en.wikipedia.org/wiki/Exposure_value
        this._EV100 = Math.log2(aperture ** 2 / shutterSpeed * 100 / ISO) - expComp;

        // https://en.wikipedia.org/wiki/Film_speed#Saturation-based_speed
        // const maxLuminance = 78 / (100 * 0.65) * 2 ** this._EV100;

        // https://en.wikipedia.org/wiki/Light_meter#Exposure_meter_calibration
        const maxLuminance = 2 ** (this._EV100 - 3);

        this._exposure = 1 / maxLuminance;

        this._aperture = aperture;
        this._shutterSpeed = shutterSpeed;
        this._ISO = ISO;
        this._expComp = expComp;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#aperture
     * @type {number}
     * @readonly
     * @summary The relative aperture value controls how wide the lens is opened.
     */
    get aperture() {
        return this._aperture;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#shutterSpeed
     * @type {number}
     * @readonly
     * @summary The camera shutter speed in seconds.
     */
    get shutterSpeed() {
        return this._shutterSpeed;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#ISO
     * @type {number}
     * @readonly
     * @summary The camera sensor light speed.
     */
    get ISO() {
        return this._ISO;
    }

    /**
     * @var module:@webgears-app/engine-core.Camera#expComp
     * @type {number}
     * @readonly
     * @summary The exposure compensation.
     */
    get expComp() {
        return this._expComp;
    }

    /**
     * @function module:@webgears-app/engine-core.Camera#clone
     * @summary Makes a clone of the camera.
     * @returns {module:@webgears-app/engine-core.Camera}
     */
    clone() {
        const {
            name,
            zfar,
            znear,
            clipper,
            reflected,
            aspect,
            yfov,
            xmag,
            ymag,
            projectionType,
            aperture,
            shutterSpeed,
            ISO,
            expComp
        } = this;

        const perspectiveProjection = { aspect, yfov };
        const orthographicProjection = { xmag, ymag };

        const clone_ = new camera_Camera({
            name,
            zfar,
            znear,
            clipper,
            reflected,
            orthographicProjection,
            perspectiveProjection,
            aperture,
            shutterSpeed,
            ISO,
            expComp
        });

        clone_.projectionType = projectionType;

        return clone_;
    }
}

Object.defineProperty(camera_Camera.prototype, 'isCamera', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/cubeCameras/cubeCamera.js




/**
 * @class module:@webgears-app/engine-core.CubeCamera
 * @extends module:@webgears-app/engine-core.Component
 * @param {object} parameters Parameters.
 * @param {string} [parameters.name=''] The cube camera's name.
 * @param {number} [parameters.znear=0.1] The cube camera's frustum near plane distance.
 * @param {number} [parameters.zfar=10] The cube camera's frustum far plane distance.
 * @summary The CubeCamera class.
 */
class cubeCamera_CubeCamera extends component_Component {
    constructor({
        name = '',
        zfar = 10,
        znear = 0.1
    }) {
        super();

        this._name = name;

        this.projectionMatrix = new HomogeneousMatrix3();

        this.viewMatrices =
            Array(...Array(6)).map((/* el */) => { return new AffineMatrix3(); });

        this.viewProjectionMatrices =
            Array(...Array(6)).map((/* el */) => { return new HomogeneousMatrix3(); });

        this.zfar = zfar;
        this.znear = znear;

        this.aspect = 1;
        this.yfov = 90 * Math.PI / 180;

        this.lastFrameUpdate = 0;

        this.cubeSideIndex = 0;

        this.needsUpdateProjection = true;
    }

    get viewMatrix() {
        const { viewMatrices, cubeSideIndex } = this;
        return viewMatrices[cubeSideIndex];
    }

    get viewProjectionMatrix() {
        const { viewProjectionMatrices, cubeSideIndex } = this;
        return viewProjectionMatrices[cubeSideIndex];
    }

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#name
     * @type {string}
     * @readonly
     * @summary The cube camera's name.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#projectionMatrix
     * @type {module:@webgears-app/math.HomogeneousMatrix3}
     * @summary The cube camera's projection matrix.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#viewMatrices
     * @type {module:@webgears-app/math.AffineMatrix3}
     * @summary The cube camera's view matrices.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#viewProjectionMatrices
     * @type {module:@webgears-app/math.HomogeneousMatrix3}
     * @summary The product of view and projection matrices for each side of cube.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#znear
     * @type {number}
     * @summary The cube camera's frustum near plane distance.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#zfar
     * @type {number}
     * @summary The cube camera's frustum far plane distance.
     */

    /**
     * @var module:@webgears-app/engine-core.CubeCamera#needsUpdateProjection
     * @type {boolean}
     * @summary Whether the [CubeCameras]{@link module:@webgears-app/engine-core.CubeCameras} system should update projection matrix.
     */

    get name() {
        return this._name;
    }

    /**
     * @function module:@webgears-app/engine-core.CubeCamera#clone
     * @summary Makes a clone of the cube camera.
     * @returns {module:@webgears-app/engine-core.CubeCamera}
     */
    clone() {
        const { name, zfar, znear } = this;
        return new cubeCamera_CubeCamera({ name, zfar, znear });
    }
}

Object.defineProperty(cubeCamera_CubeCamera.prototype, 'isCubeCamera', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/animations/nodeAnimation.js





function _defaultUpdate(/* target, valueView */) {}

function _morphUpdate(target, valueView) {
    console.assert(target instanceof morph_Morph,
        `morphUpdate expects ${morph_Morph.name} as target, target type: ${target.constructor.name}`);

    target.weights.set(valueView);
    target.needsUpdate = true;
}

function _translationUpdate(target, valueView) {
    console.assert(target instanceof transform_Transform,
        `translationUpdate expects ${transform_Transform.name} as target, target type: ${target.constructor.name}`);

    target.position.fromArray(valueView);
    target.state |= transform_Transform.StateMask.UPDATE_LOCAL;
}

function _scaleUpdate(target, valueView) {
    console.assert(target instanceof transform_Transform,
        `scaleUpdate expects ${transform_Transform.name} as target, target type: ${target.constructor.name}`);

    target.scale.fromArray(valueView);
    target.state |= transform_Transform.StateMask.UPDATE_LOCAL;
}

function _orientationUpdate(target, valueView) {
    console.assert(target instanceof transform_Transform,
        `orientationUpdate expects ${transform_Transform.name} as target, target type: ${target.constructor.name}`);

    target.orientation.fromArray(valueView);
    target.orientation.normalize();
    target.state |= transform_Transform.StateMask.UPDATE_LOCAL;
}

function _matrixUpdate(target, valueView) {
    console.assert(target instanceof transform_Transform,
        `matrixUpdate expects ${transform_Transform.name} as target, target type: ${target.constructor.name}`);

    target.matrix.fromArray(valueView);
    target.state |= transform_Transform.StateMask.UPDATE_COMPONENTS;
}

class _Channel {
    static get translationUpdate() {
        return _translationUpdate;
    }

    static get scaleUpdate() {
        return _scaleUpdate;
    }

    static get orientationUpdate() {
        return _orientationUpdate;
    }

    static get matrixUpdate() {
        return _matrixUpdate;
    }

    static get morphUpdate() {
        return _morphUpdate;
    }

    constructor(target, sampler, animation) {
        this.target = target;
        this.sampler = sampler;
        this.animation = animation;
        this._updater = _defaultUpdate; // to make possible to copy channels
        this._update = (valueView) => { _defaultUpdate(target, valueView); };
    }

    set update(updater) {
        const { target } = this;

        this._updater = updater;

        this._update = (valueView) => {
            updater(target, valueView);
        };
    }

    get update() {
        return this._update;
    }
}

/**
 * @summary The NodeAnimation class.
 * @desc The component that represents binding between animation samplers and animation channels.
 * @memberOf module:@webgears-app/engine-core
 */
class nodeAnimation_NodeAnimation extends component_Component {
    /**
     * @class module:@webgears-app/engine-core.NodeAnimation.Channel
     * @memberOf module:@webgears-app/engine-core.NodeAnimation
     * @summary NodeAnimation nested class that represents animation channel.
     * @param {object} target The reference to the object that is going to be animated.
     * @param {number} sampler Index of the sampler in the animation track.
     * @param {number} animation Index of animation the sampler belongs to.
     */
    static get Channel() {
        /**
         * @var module:@webgears-app/engine-core.NodeAnimation.Channel#target
         * @type {object}
         * @summary The reference to the object that is going to be animated.
         */

        /**
         * @var module:@webgears-app/engine-core.NodeAnimation.Channel#sampler
         * @type {number}
         * @summary Index of the sampler in the animation track.
         */

        /**
         * @var module:@webgears-app/engine-core.NodeAnimation.Channel#animation
         * @type {number}
         * @summary Index of animation the sampler belongs to.
         */

        /**
         * @var module:@webgears-app/engine-core.NodeAnimation.Channel#update
         * @type {function}
         * @summary Updates target properties from sampler values.
         */

        return _Channel;
    }

    constructor() {
        super();
        this.channels = [];
    }
}

/**
 * @var module:@webgears-app/engine-core.NodeAnimation#channels
 * @type {module:@webgears-app/engine-core.NodeAnimation.Channel[]}
 * @summary Array of channels.
 */



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/animations/bone.js




/**
 * @summary The Bone class.
 * @desc The component that represents a bone of skeleton.
 * @extends module:@webgears-app/engine-core.Component
 * @memberOf module:@webgears-app/engine-core
 */
class bone_Bone extends component_Component {
    /**
     * @param {number} skeletonIndex Index of skeleton the bone belongs to.
     * @param {number} boneIndex Index of bone in the skeleton.
     */
    constructor(skeletonIndex, boneIndex) {
        super();
        this.boneIndex = boneIndex;
        this.skeletonIndex = skeletonIndex;

        this._inverseBindMatrix = new AffineMatrix3();
    }

    /**
     * @var module:@webgears-app/engine-core.Bone#boneIndex
     * @type {number}
     * @summary Index of the bone in the skeleton.
     */

    /**
     * @var module:@webgears-app/engine-core.Bone#skeletonIndex
     * @type {number}
     * @summary Index of skeleton the bone belongs to.
     */

    /**
     * @var module:@webgears-app/engine-core.Bone#inverseBindMatrix
     * @type {module:@webgears-app/math.AffineMatrix3}
     * @summary The matrix to transform the vertices into the local space of the bone.
     */
    get inverseBindMatrix() {
        return this._inverseBindMatrix;
    }

    /**
     * @function module:@webgears-app/engine-core.Bone#clone
     * @summary Makes a clone of the bone.
     * @returns {module:@webgears-app/engine-core.Bone}
     */
    clone() {
        const { boneIndex, skeletonIndex, _inverseBindMatrix } = this;
        const clone_ = new bone_Bone(skeletonIndex, boneIndex);

        clone_._inverseBindMatrix.copy(_inverseBindMatrix);

        return clone_;
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/entityManager.js















const maxUint32 = Math.pow(2, 32) - 1;

function _getComponentsMask(componentClasses, countComponents) {
    const mask = new Uint32Array(countComponents);

    mask.fill(0);

    for (const compClass of componentClasses) {
        const { maskIndex } = compClass;
        mask[maskIndex] |= compClass.mask;
    }

    return mask;
}

function _isNotEmptyMask(masks, count, i) {
    for (let n = 0; n < count; n++) {
        if (masks[count * i + n] !== 0)  {
            return true;
        }
    }

    return false;
}

function _matchMaskStrict(masks, filter, i) {
    for (let n = 0, count = filter.length; n < count; n++) {
        if ((masks[i * count + n] & filter[n]) !== filter[n]) return false;
    }

    return true;
}

function _matchMask(masks, filter, i) {
    for (let n = 0, count = filter.length; n < count; n++) {
        if ((masks[i * count + n] & filter[n]) !== 0) return true;
    }

    return false;
}

class EntitiesIterator {
    constructor(masks, countEntities, validEntityCount, maskElementCount, filter = null, strict = false) {
        // console.assert(filter === null || filter.length === maskElementCount,
        //     'filter size does not correspond with mask size');

        this._masks = masks;
        this._filter = filter;
        this._strict = strict;
        this._countEntities = countEntities;
        this._validEntityCount = validEntityCount;
        this._maskElementCount = maskElementCount;
        this._result = { done: false, value: null };
        this._current = 0;
        this._entityCounter = 0;
    }

    [Symbol.iterator]() { return this; }

    next() {
        const {
            _masks,
            _filter,
            _strict,
            _countEntities,
            _validEntityCount,
            _maskElementCount,
            _result,
            _entityCounter
        } = this;

        _result.done = true;

        if (_entityCounter >= _validEntityCount) {
            return _result;
        }

        for (let i = this._current; i < _countEntities; i++) {
            this._current = i + 1;

            const isOk = _filter === null // eslint-disable-line
                ? _isNotEmptyMask(_masks, _maskElementCount, i)
                : _strict
                    ? _matchMaskStrict(_masks, _filter, i)
                    : _matchMask(_masks, _filter, i);

            if (isOk) {
                _result.done = false;
                _result.value = i;

                this._entityCounter++;

                break;
            }
        }

        return _result;
    }
}

function _isComponent(registry, classOrInstance) {
    const { index } = classOrInstance;

    for (const cmp of registry.values()) {
        if (cmp.index === index) return true;
    }

    return false;
}

function _setupDummyComponents(registry, i, index) {
    for (let n = i; n < index; n++) registry.add({ index: null, mask: 0 });
}

let _lastComponentIndex = 0;

class ComponentRegistry {
    constructor(componentClasses) {
        this._componentRegistry = new Set();
        this._registryComponents(componentClasses);
    }

    get registry() {
        return this._componentRegistry;
    }

    get actualComponentCount() {
        const { _componentRegistry } = this;

        let count = 0;

        for (const cmp of _componentRegistry.values()) {
            if (cmp.index !== null) count++;
        }

        return count;
    }

    _registryComponents(componentClasses) {
        const { _componentRegistry } = this;

        componentClasses.sort((a, b) => {
            const { index: idx1 = Infinity } = a;
            const { index: idx2 = Infinity } = b;

            return idx1 - idx2;
        });

        const maskSize = Uint32Array.BYTES_PER_ELEMENT * 8;

        for (const [i, componentClass] of componentClasses.entries()) {
            let index = null;

            if (componentClass.index === undefined) {
                index = _lastComponentIndex++;

                const maskIndex = Math.floor(index / maskSize);

                const bitIndex = index % maskSize;

                Object.defineProperty(componentClass, 'index', { value: index, writable: false });

                Object.defineProperty(componentClass, 'maskIndex', { value: maskIndex, writable: false });

                Object.defineProperty(componentClass, 'mask', {value: 1 << bitIndex, writable: false});
            } else {
                index = componentClasses.index; // eslint-disable-line
            }

            _setupDummyComponents(_componentRegistry, i, index);

            _componentRegistry.add(componentClass);
        }
    }
}

let _defaultComponentRegistry = null;

function _registryComponents(componentClasses = [
    transform_Transform,
    mesh_Mesh,
    morph_Morph,
    sprite_Sprite,
    light_Light,
    camera_Camera,
    cubeCamera_CubeCamera,
    nodeAnimation_NodeAnimation,
    bone_Bone,
    lightShadowCaster_LightShadowCaster,
    visibility_Visibility
]) {
    return new ComponentRegistry(componentClasses);
}

/**
 * @class module:@webgears-app/engine-core.EntityManager
 * @param {module:@webgears-app/engine-core.Scene} [scene] Scene.
 * @param {object} [config={}] Entity manager configuration.
 * @param {function} [config.entityAllocationStrategy] Strategy defines how to allocate memory for the entities.
 * @param {number} [config.initialCountEntities=512] Initial entities' capacity.
 * @param {number} [config.componentClasses=[]] Component classes to registry as allowed types of component.
 * @summary The Entity manager class manages entities in a [scene]{@link module:@webgears-app/engine-core.Scene}.
 */
class EntityManager {
    constructor(scene, config = {}) {
        this._scene = scene;

        this._config = {};
        this._componentRegistry = null; // registryComponents().registry;
        this._actualComponentCount = 0;
        this._entitiesCapacity = 0;
        this._entityCount = 0;
        this._validEntityCount = 0;
        this._masks = null;
        this._maskElementCount = 0;
        this._indices = null;
        this._freeEntities = [];
        this._storage = [];

        const {
            componentClasses = [],
            entityAllocationStrategy = (size) => { return Math.floor(size * 1.618) + 1; },
            initialCountEntities = 512
        } = config;

        const componentRegistry = componentClasses.length === 0 // eslint-disable-line
            ? _defaultComponentRegistry === null
                ? _defaultComponentRegistry = _registryComponents() // assignment operator must return value
                : _defaultComponentRegistry
            : _registryComponents(componentClasses);

        this._componentRegistry = componentRegistry.registry;
        this._actualComponentCount = componentRegistry.actualComponentCount;

        this._config.entityAllocationStrategy = entityAllocationStrategy;

        this._reAlloc(initialCountEntities);

        for (const componentClass of this._componentRegistry.values()) {
            const { index, storageClass } = componentClass;
            this._storage[index] = index === null ? null : new storageClass(this, componentClass); // eslint-disable-line
        }
    }

    _reAlloc(countEntities) {
        const { _entitiesCapacity, _indices, _masks, _componentRegistry } = this;

        const componentCount = _componentRegistry.size;

        if (_entitiesCapacity >= countEntities) {
            return;
        }

        const indices = new Uint32Array(countEntities * componentCount);
        indices.fill(maxUint32);

        this._indices = _indices !== null ? (indices.set(_indices), indices) : indices;

        this._entitiesCapacity = countEntities;

        this._maskElementCount = Math.ceil(componentCount / 32);

        const masks = new Uint32Array(countEntities * this._maskElementCount);

        masks.fill(0);

        this._masks = _masks !== null ? (masks.set(_masks), masks) : masks;
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#createEntity
     * @summary Creates new entity.
     * @returns {number}
     */
    createEntity() {
        const { _freeEntities, _entitiesCapacity, _config } = this;

        const { entityAllocationStrategy } = _config;

        this._validEntityCount++;

        const entity = _freeEntities.length > 0 ? _freeEntities.pop() : this._entityCount++;

        if (this._entityCount >= _entitiesCapacity) {
            this._reAlloc(entityAllocationStrategy(_entitiesCapacity));
        }

        return entity;
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#isValidEntity
     * @param {number} entity An entity.
     * @summary Tests if an entity is valid.
     * @returns {number}
     */
    isValidEntity(entity) {
        const { _freeEntities, _entityCount } = this;

        return entity < _entityCount && !_freeEntities.includes(entity);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#destroyEntity
     * @param {number} entity An entity.
     * @summary Destroys entity and all associated components.
     * Keep in mind, EntityManager#destroyEntity does not destroy transforms of children nodes.
     * @returns {number}
     */
    destroyEntity(entity) {
        const { _masks, _freeEntities, _maskElementCount, _componentRegistry, _storage, _indices } = this;
        const { size: componentCount } = _componentRegistry;

        for (let i = 0; i < componentCount; i++) {
            if (_storage[i] === null) continue;

            const offset = entity * componentCount + i;

            const idx = _indices[offset];

            if (idx === maxUint32) continue;

            _indices[offset] = maxUint32;

            const cmp = _storage[i].get(idx);

            _storage[i]._delete(idx);

            EntityManager.onDetach.emit(this, entity, cmp);

            cmp.release();
        }

        _masks.fill(0, entity * _maskElementCount, entity * _maskElementCount + _maskElementCount);

        _freeEntities.push(entity);

        this._validEntityCount--;
    }

    _entities(filter, strict = false) {
        const {
            _masks,
            _entityCount,
            _validEntityCount,
            _maskElementCount
        } = this;

        return new EntitiesIterator(_masks, _entityCount, _validEntityCount, _maskElementCount, filter, strict);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#allEntities
     * @summary Returns an iterator to iterate over all entities that have at least one component.
     * @returns {EntitiesIterator}
     */
    allEntities() {
        return this._entities(null);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#entitiesWithComponents
     * @param {Array<class>} componentClasses Component type list.
     * @summary Returns an iterator to iterate over all entities that match list of components strictly.
     * @returns {EntitiesIterator}
     */
    entitiesWithComponents(componentClasses) {
        const { _maskElementCount } = this;

        const filter = _getComponentsMask(componentClasses, _maskElementCount);

        return this._entities(filter, true);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#entitiesWithAtLeastAComponent
     * @param {Array<class>} componentClasses Component type list.
     * @summary Returns an iterator to iterate over all entities that have at least one component from the list.
     * @returns {EntitiesIterator}
     */
    entitiesWithAtLeastAComponent(componentClasses) {
        const { _maskElementCount } = this;

        const filter = _getComponentsMask(componentClasses, _maskElementCount);

        return this._entities(filter, false);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#getAllEntityComponents
     * @param {number} entity An entity.
     * @param {Array<module:@webgears-app/engine-core.Component>}  [result=[]] Optional array to store result.
     * @summary Returns all components associated with entity.
     * @returns {Array<module:@webgears-app/engine-core.Component>}
     */
    getAllEntityComponents(entity, result = []) {
        const { _indices, _componentRegistry, _storage } = this;
        const componentCount = _componentRegistry.size;

        // console.assert(this.isValidEntity(entity), `entity: ${entity} is not valid`);

        result.length = 0;

        for (let i = 0; i < componentCount; i++) {
            if (_storage[i] === null) continue;

            const idx = _indices[entity * componentCount + i];

            if (idx === maxUint32) continue;

            result.push(_storage[i].get(idx));
        }

        return result;
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#getEntityComponents
     * @param {number} entity An entity.
     * @param {class[]} componentClasses Component classes.
     * @param {Array<module:@webgears-app/engine-core.Component>}  [result=[]] Optional array to store result.
     * @summary Returns all components of entity that correspond with component classes array.
     * @returns {Array<(module:@webgears-app/engine-core.Component|null)>}
     * @example
     * //
     * entityManager.attach(entity, meshComponent);
     * entityManager.attach(entity, nodeAnimationComponent);
     * // entityManager.attach(entity, cameraComponent); // Camera was not attached to the entity.
     *
     * const [mesh, camera, nodeAnimation] = entityManager.getEntityComponents([Mesh, Camera, NodeAnimation]);
     *
     * console.log(mesh instanceof Mesh); // true
     * console.log(nodeAnimation instanceof NodeAnimation); // true
     * console.log(camera instanceof Camera); // false
     * console.log(camera === null); // true
     */
    getEntityComponents(entity, componentClasses, result = []) {
        const { _indices, _componentRegistry, _storage } = this;
        const componentCount = _componentRegistry.size;

        // console.assert(this.isValidEntity(entity), `entity: ${entity} is not valid`);

        result.length = 0;

        for (const componentClass of componentClasses) {
            // console.assert(_isComponent(_componentRegistry, componentClass),
            //    'class or instance is not registered as component');

            const { index } = componentClass;

            const idx = _indices[entity * componentCount + index];

            const component = idx !== maxUint32 ? _storage[index].get(idx) : null;

            result.push(component);
        }

        return result;
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#attach
     * @param {number} entity An entity.
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @summary Associates a component with an entity.
     * @desc One entity can have only one component of the each type.
     */
    attach(entity, component) {
        // console.assert(this.isValidEntity(entity), `entity: ${entity} is not valid`);

        // console.assert(component.isComponent,
        //    `entityManager.attach 2nd argument type: ${typeof component}, expects Component`);

        const { _masks, _indices, _componentRegistry, _storage, _maskElementCount } = this;

        const componentCount = _componentRegistry.size;

        const { mask, index, maskIndex } = component;

        // console.assert(index < _storage.length && _storage[index] !== null,
        //    `component type ${typeof component} is not registered as possible component type.`);

        const offset = entity * componentCount + index;

        // console.assert(_indices[offset] === maxUint32,
        //    `attempt to attach ${component.constructor.name} component twice to entity ${entity}`);

        _masks[_maskElementCount * entity + maskIndex] |= mask;

        _indices[offset] = _storage[index].add(entity, component);

        component.retain();

        EntityManager.onAttach.emit(this, entity, component);
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#detach
     * @param {number} entity An entity.
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @summary Removes a component from an entity.
     */
    detach(entity, component) {
        // console.assert(this.isValidEntity(entity), `entity: ${entity} is not valid`);

        const { _masks, _indices, _componentRegistry, _storage, _maskElementCount } = this;

        const componentCount = _componentRegistry.size;

        const { mask, index, maskIndex } = component;

        // console.assert(index < componentCount && _storage[index] !== null,
        //    `component type ${typeof component} is not registered as possible component type.`);

        const offset = entity * componentCount + index;

        // console.assert(_indices[offset] !== maxUint32,
        //    `entity ${entity} has no component ${component.constructor.name}`);

        _masks[_maskElementCount * entity + maskIndex] &= ~mask;

        const i = _indices[offset];

        _indices[offset] = maxUint32;

        const cmp = _storage[index].get(i);

        _storage[index].delete(i);

        EntityManager.onDetach.emit(this, entity, cmp);

        cmp.release();
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#getComponentStorage
     * @param {module:@webgears-app/engine-core.Component|class} instanceOrClass A component's instance or class
     * @summary Returns storage of component's type
     * @returns {module:@webgears-app/engine-core.ComponentStorage}
     */
    getComponentStorage(instanceOrClass) {
        const { _storage } = this;
        const { index } = instanceOrClass;

        // console.assert(_storage[index] !== null && _storage[index] !== undefined,
        //    `class of ${instanceOrClass} was not registered as component`);

        return _storage[index];
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#getEntity
     * @param {module:@webgears-app/engine-core.Component} component A component.
     * @summary Returns an entity the component belongs to.
     * @returns {?number}
     */
    getEntity(component) {
        // console.assert(component.isComponent,
        //    `entityManager.getEntity argument type: ${typeof component}, expects Component`);

        const { index } = component;

        return this._storage[index].getEntity(component);
    }

    /**
     * @var module:@webgears-app/engine-core.EntityManager#validEntityCount
     * @type {number}
     * @readonly
     * @summary Valid entity count.
     */
    get validEntityCount() {
        return this._validEntityCount;
    }

    /**
     * @var module:@webgears-app/engine-core.EntityManager#componentCount
     * @type {number}
     * @readonly
     * @summary Component count.
     */
    get componentCount() {
        return this._actualComponentCount;
    }

    /**
     * @var module:@webgears-app/engine-core.EntityManager#entitiesCapacity
     * @type {number}
     * @readonly
     * @summary Entity capacity.
     */
    get entitiesCapacity() {
        return this._entitiesCapacity;
    }

    isComponent(componentClass) {
        const index = componentClass.index >= 0 ?  componentClass.index : Infinity;
        const storage = this._storage[index];
        return storage !== null && storage !== undefined;
    }

    /**
     * @function module:@webgears-app/engine-core.EntityManager#dispose
     * @summary Disposes entity manager.
     */
    dispose() {
        this._scene = null;

        this._componentRegistry = null;
        this._entitiesCapacity = 0;
        this._entityCount = 0;
        this._validEntityCount = 0;
        this._maskElementCount = 0;
        this._masks = null;
        this._indices = null;
        this._freeEntities.length = 0;

        const { _storage } = this;

        for (const s of _storage) {
            if (s === null) continue;
            s.dispose();
        }

        _storage.length = 0;
    }
}


/**
 * @var module:@webgears-app/engine-core.EntityManager.onAttach
 * @type {module:@webgears-app/event.Event}
 * @readonly
 * @summary Event raises on attach any component.
 */
Object.defineProperty(EntityManager, 'onAttach', { value: new Event() });

/**
 * @var module:@webgears-app/engine-core.EntityManager.onDetach
 * @type {module:@webgears-app/event.Event}
 * @readonly
 * @summary Event raises on detach any component.
 */
Object.defineProperty(EntityManager, 'onDetach', { value: new Event() });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/sceneNode.js




function _testMergeCompatibility(src, dst) {
    const { _componentRegistry: srcRegistry } = src.entityManager;
    const { _componentRegistry: dstRegistry } = dst.entityManager;

    for (const componentClass of srcRegistry.values()) {
        const { index } = componentClass;

        if (index === null) continue;

        if (!dstRegistry.has(componentClass)) return false;
    }

    return true;
}

/**
 * @class module:@webgears-app/engine-core.SceneNode
 * @summary Class represents a node in the scene graph.
 * @param {module:@webgears-app/engine-core.Scene} scene
 * @param {number} entity
 * @param {string} [name='']
 * @hideconstructor
 */
class sceneNode_SceneNode {
    constructor(scene, entity, name = '') {
        this.name = name;

        this._entity = entity;

        this._children = [];

        this._parent = null;

        this._scene = scene;

        /**
         * @var module:@webgears-app/engine-core.SceneNode#extras
         * @type {any}
         * @summary Unstructred application-specific imported/exported data.
         * @desc Must be {@link JSON.stringify}-able.
         */
        this.extras = undefined;
    }

    /**
     * @var module:@webgears-app/engine-core.SceneNode#scene
     * @type {module:@webgears-app/engine-core.Scene}
     * @summary Scene this node belongs to.
     */
    get scene() {
        return this._scene;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#traverse
     * @summary Executes the callback on this scene node and all descendants.
     * @desc Callback should return true to continue traverse or false to stop.
     * @param {function} callback A callback function with scene node as argument.
     */
    traverse(callback) {
        if (!callback(this)) {
            return false;
        }

        const { _children } = this;

        for (const child of _children) {
            if (!child.traverse(callback)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @var module:@webgears-app/engine-core.SceneNode#parent
     * @type {module:@webgears-app/engine-core.SceneNode}
     * @summary The parent node in the scene graph.
     */
    get parent() {
        return this._parent;
    }

    set parent(parent) {
        parent.adopt(this);
    }

    /**
     * @var module:@webgears-app/engine-core.SceneNode#isRoot
     * @type {boolean}
     * @readonly
     * @summary Whether this node is the root of the scene graph.
     */
    get isRoot() {
        return this._parent === null;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#createChild
     * @summary Creates new one child node in the scene graph.
     * @param {object} parameters Parameters.
     * @param {string} [parameters.name=''] The name of the new node.
     * @returns {module:@webgears-app/engine-core.SceneNode}
     */
    createChild({ name = '' }) {
        const { _scene, _children } = this;
        const { entityManager } = _scene;

        const entity = entityManager.createEntity();

        const child = new sceneNode_SceneNode(_scene, entity, name);

        _scene._entityToNode.set(entity, child);

        child._parent = this;

        _children.push(child);

        return child;
    }

    _destroy() {
        for (const child of this._children) { child._destroy(); }

        this._scene._entityToNode.delete(this._entity);
        this._scene.entityManager.destroyEntity(this._entity);
        this._entity = 2 ** 32 - 1;

        this._scene = null;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#destroy
     * @summary Destroys this node and all children.
     */
    destroy() {
        if (this._parent) {
            const siblings = this._parent.children;
            siblings.splice(siblings.indexOf(this), 1);
            this._parent = null;
        }

        const [transform] = this.getComponents([transform_Transform]);

        if (transform !== null) {
            this.detach(transform);
        }

        this._destroy();
    }

    _updateTransformHierarchy() {
        const [transform] = this.getComponents([transform_Transform]);

        if (transform === null) return;

        transform.state |= transform_Transform.StateMask.UPDATE_WORLD;

        for (const child of this.children) {
            child._updateTransformHierarchy();
        }
    }

    _getCountNodeInBranch() {
        let count_ = 0;

        const { _children } = this;

        count_ += _children.length;

        for (const child of _children) {
            count_ += child._getCountNodeInBranch();
        }

        return count_;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#splitCopy
     * @param {object} [parameters] Parameters.
     * @param {string} [parameters.name] A name of the new scene.
     * @param {boolean} [parameters.cloneMaterials] Whether the new scene will share materials with old scene or not.
     * @summary Splits branch of the scene graph into separated scene.
     * @returns {Promise<object>}
     */
    splitCopy(parameters = {}) {
        const { name, cloneMaterials = true } = parameters;
        const countNodes = this._getCountNodeInBranch();
        const name_ = name || `${this.name}-scene`;
        const srcScene = this._scene;
        const dstScene = new scene_Scene({ maxSceneNodes: countNodes, name: name_, config: srcScene.config });

        const copyContext = {
            nodeToNode: new Map(),
            skeletonToSkeleton: new Map(),
            animationToAnimation: new Map(),
            cloneMaterials
        };

        dstScene.root._adoptForeignNode(this, copyContext);

        return new Promise((resolve) => {
            const task = new scene_Scene._SceneManagementDeferredTask(
                scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY,
                resolve
            );

            task.data.srcScene = srcScene;
            task.data.dstScene = dstScene;
            task.data.copyContext = copyContext;
            task.output.scene = dstScene;

            this._scene._deferredTasks.push(task);
        });
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#mergeCopy
     * @summary Merge scene's copy into the branch of the current scene.
     * @param {module:@webgears-app/engine-core.Scene} scene Source scene.
     * @returns {Promise<object>}
     */
    mergeCopy(scene) {
        console.assert(_testMergeCompatibility(scene, this._scene),
            'can not merge scenes with different sets of registered components');

        return new Promise((resolve) => {
            const copyContext = {
                nodeToNode: new Map(),
                skeletonToSkeleton: new Map(),
                animationToAnimation: new Map()
            };

            const task = new scene_Scene._SceneManagementDeferredTask(
                scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY,
                resolve
            );

            task.data.srcScene = scene;
            task.data.dstScene = this._scene;
            task.data.dstNode = this;
            task.data.copyContext = copyContext;

            this._scene._deferredTasks.push(task);
        });
    }

    _adoptForeignNode(node, copyContext) {
        const { name, children } = node;
        const { nodeToNode } = copyContext;

        const node_ = this.createChild({ name });

        nodeToNode.set(node, node_);

        for (const child of children) {
            node_._adoptForeignNode(child, copyContext);
        }
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#adopt
     * @summary Adopts child scene node.
     * @desc The node must be from the same scene as the parent.
     * @param {module:@webgears-app/engine-core.SceneNode} child The child to adopt.
     */
    adopt(child) {
        for (let ancestor = this; ancestor !== null; ancestor = ancestor._parent) {
            if (ancestor === child) { throw new Error('can\'t adopt ancestors'); }
        }

        if (child._parent) {
            if (child._parent === this) { return; }
            const siblings = child._parent._children;
            siblings.splice(siblings.indexOf(child), 1);
            child._parent = null;
        }

        let [parentTransform] = this.getComponents([transform_Transform]);
        const [childTransform] = child.getAllComponents([transform_Transform]);

        if (childTransform !== null && parentTransform === null) {
            parentTransform = new transform_Transform();
            parentTransform.state = transform_Transform.StateMask.UPDATE_ALL;

            this.attach(parentTransform);
        }

        if (parentTransform !== null && childTransform !== null) {
            child._updateTransformHierarchy();
        }

        child._parent = this;
        this._children.push(child);
    }

    /**
     * @var module:@webgears-app/engine-core.SceneNode#children
     * @type {Array<module:@webgears-app/engine-core.SceneNode>}
     * @summary Array of children.
     */
    get children() {
        return this._children;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#getComponents
     * @param {Array<class>} componentClasses Component classes.
     * @param {Array<module:@webgears-app/engine-core.Component>} [result=[]] Optional array to store result.
     * @returns {Array<module:@webgears-app/engine-core.Component>}
     * @summary Returns all components of the node's entity that correspond with component classes in array.
     */
    getComponents(componentClasses, result = []) {
        const { _scene, _entity } = this;
        const { entityManager } = _scene;

        return entityManager.getEntityComponents(_entity, componentClasses, result);
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#getAllComponents
     * @param {Array<module:@webgears-app/engine-core.Component>} [result=[]] Optional array to store result.
     * @returns {Array<module:@webgears-app/engine-core.Component>}
     * @summary Returns all components of the node's entity.
     */
    getAllComponents(result = []) {
        const { _scene, _entity } = this;
        const { entityManager } = _scene;

        return entityManager.getAllEntityComponents(_entity, result);
    }

    /**
     * @var module:@webgears-app/engine-core.SceneNode#entity
     * @type {number}
     * @readonly
     * @summary The entity of the node.
     */
    get entity() {
        return this._entity;
    }

    /**
     * @function module:@webgears-app/engine-core.SceneNode#attach
     * @param {module:@webgears-app/engine-core.Component} component A component to attach.
     * @returns {module:@webgears-app/engine-core.SceneNode}
     * @summary Attaches a component to the entity associated with the scene node.
     */

    /**
     * @function module:@webgears-app/engine-core.SceneNode#detach
     * @param {module:@webgears-app/engine-core.SceneNode|class} instanceOrClass
     * A component or class of a component to detach.
     * @summary Detaches a component from the entity associated with the scene node.
     */
}

Object.assign(sceneNode_SceneNode.prototype, {
    attach: (function _attach() {
        const type = [transform_Transform];
        const cmp = [null];
        return function attach(component) {
            const { _scene, _entity } = this;

            _scene.entityManager.attach(_entity, component);

            if (component.isTransform && this._parent != null) {
                let [ transform ] = this._parent.getComponents(type, cmp);

                if (transform === null) {
                    transform = new transform_Transform();
                    transform.state = transform_Transform.StateMask.UPDATE_ALL;

                    this._parent.attach(transform);
                }
            }

            return this;
        };
    }()),

    detach: (function _detach() {
        const type = [transform_Transform];
        const cmp = [null];

        return function detach(instanceOrClass) {
            const { _scene, _entity, _children } = this;
            const { entityManager } = _scene;

            const [component] = typeof instanceOrClass === 'function'
                ? entityManager.getEntityComponents(_entity, [instanceOrClass])
                : (cmp[0] = instanceOrClass, cmp);

            entityManager.detach(_entity, component);

            if (component.isTransform) {
                for (const child of _children) {
                    const [ transform ] = child.getComponents(type, cmp);
                    if (transform !== null) child.detach(transform);
                }
            }
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/webglContext.js

const webglContext = {};

(function getStaticContext() {
    if (typeof WebGLRenderingContext !== 'undefined') {
        Object.assign(webglContext, WebGLRenderingContext);
    }

    if (typeof WebGL2RenderingContext !== 'undefined') {
        Object.assign(webglContext, WebGL2RenderingContext);
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/dataTypes.js



/**
 * @namespace module:@webgears-app/engine-core.DataType
 * @desc Data type enum. All values correspond to WebGL enums.
 * @property {number} BYTE
 * @property {number} UNSIGNED_BYTE
 * @property {number} SHORT
 * @property {number} UNSIGNED_SHORT
 * @property {number} INT
 * @property {number} UNSIGNED_INT
 * @property {number} FLOAT
 * @property {number} UNSIGNED_SHORT_5_6_5
 * @property {number} UNSIGNED_SHORT_4_4_4_4
 * @property {number} UNSIGNED_SHORT_5_5_5_1
 * @property {number} HALF_FLOAT
 * @property {number} UNSIGNED_INT_10F_11F_11F_REV
 * @property {number} UNSIGNED_INT_2_10_10_10_REV
 * @property {number} UNSIGNED_INT_5_9_9_9_REV
 * @property {number} UNSIGNED_INT_24_8
 * @property {number} FLOAT_32_UNSIGNED_INT_24_8_REV
 */
class DataType {}

(function prepEnum() {
    const dataTypes = [
        'BYTE',
        'UNSIGNED_BYTE',
        'SHORT',
        'UNSIGNED_SHORT',
        'INT',
        'UNSIGNED_INT',
        'FLOAT',
        'UNSIGNED_SHORT_5_6_5',
        'UNSIGNED_SHORT_4_4_4_4',
        'UNSIGNED_SHORT_5_5_5_1',
        'HALF_FLOAT',
        'UNSIGNED_INT_10F_11F_11F_REV',
        'UNSIGNED_INT_2_10_10_10_REV',
        'UNSIGNED_INT_5_9_9_9_REV',
        'UNSIGNED_INT_24_8',
        'FLOAT_32_UNSIGNED_INT_24_8_REV'
    ];

    for (const dataType of dataTypes) {
        const value = webglContext[dataType];

        Object.defineProperty(DataType, dataType, { value, writeable: false });
    }
}());

function getDataTypeSize(type) {
    switch (type) {
        case DataType.BYTE:
        case DataType.UNSIGNED_BYTE:
            return 1;
        case DataType.UNSIGNED_SHORT:
        case DataType.SHORT:
        case DataType.HALF_FLOAT:
        case DataType.UNSIGNED_SHORT_5_6_5:
        case DataType.UNSIGNED_SHORT_4_4_4_4:
        case DataType.UNSIGNED_SHORT_5_5_5_1:
            return 2;
        case DataType.UNSIGNED_INT:
        case DataType.FLOAT:
        case DataType.UNSIGNED_INT_10F_11F_11F_REV:
        case DataType.UNSIGNED_INT_2_10_10_10_REV:
        case DataType.UNSIGNED_INT_5_9_9_9_REV:
        case DataType.UNSIGNED_INT_24_8:
        case DataType.FLOAT_32_UNSIGNED_INT_24_8_REV:
            return 4;
        default:
            throw new Error('Unknown scalar type');
    }
}

function getArrayTypeForDataType(type) {
    switch (type) {
        case DataType.BYTE:
            return Int8Array;
        case DataType.UNSIGNED_BYTE:
            return Uint8Array;
        case DataType.HALF_FLOAT:
        case DataType.UNSIGNED_SHORT:
        case DataType.UNSIGNED_SHORT_5_6_5:
        case DataType.UNSIGNED_SHORT_4_4_4_4:
        case DataType.UNSIGNED_SHORT_5_5_5_1:
            return Uint16Array;
        case DataType.SHORT:
            return Int16Array;
        case DataType.UNSIGNED_INT:
        case DataType.UNSIGNED_INT_10F_11F_11F_REV:
        case DataType.UNSIGNED_INT_2_10_10_10_REV:
        case DataType.UNSIGNED_INT_5_9_9_9_REV:
        case DataType.UNSIGNED_INT_24_8:
            return Uint32Array;
        case DataType.FLOAT:
        case DataType.FLOAT_32_UNSIGNED_INT_24_8_REV:
            return Float32Array;
        default:
            throw new Error('Unknown type');
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/pixelDataFormat.js



/**
 * @namespace module:@webgears-app/engine-core.PixelDataFormat
 * @desc Pixel data format enum. All values correspond to WebGL enums.
 * @property {number} RGB
 * @property {number} RGBA
 * @property {number} LUMINANCE_ALPHA
 * @property {number} LUMINANCE
 * @property {number} ALPHA
 * @property {number} RED
 * @property {number} RED_INTEGER
 * @property {number} RG
 * @property {number} RG_INTEGER
 * @property {number} RGB_INTEGER
 * @property {number} RGBA_INTEGER
 * @property {number} DEPTH_COMPONENT
 * @property {number} DEPTH_STENCIL
 */
class PixelDataFormat {}

(function prepEnum() {
    const pixelFormats = [
        'RGB',
        'RGBA',
        'LUMINANCE_ALPHA',
        'LUMINANCE',
        'ALPHA',
        'RED',
        'RED_INTEGER',
        'RG',
        'RG_INTEGER',
        'RGB_INTEGER',
        'RGBA_INTEGER',
        'DEPTH_COMPONENT',
        'DEPTH_STENCIL'
    ];

    for (const pixelFormat of pixelFormats) {
        const value = webglContext[pixelFormat];

        Object.defineProperty(PixelDataFormat, pixelFormat, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/texture.js







class _CustomImageType {
    static get RGBE() { return 1; }
}

/**
 * @class module:@webgears-app/engine-core.CustomImageData
 * @param {number} imageType Image type. Must be 1.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number} depth Depth.
 * @param {module:@webgears-app/engine-core.PixelDataFormat} format Format.
 * @param {module:@webgears-app/engine-core.InternalFormat} internalFormat Internal format.
 * @param {module:@webgears-app/engine-core.DataType} componentType Component type.
 * @param {TypedArray} buffer Buffer.
 * @summary Class represents a data source for the texture's level.
 */
class CustomImageData {
    static get Type() {
        return _CustomImageType;
    }

    constructor(imageType, width, height, depth, format, internalFormat, componentType, buffer) {
        this.width = width;
        this.height = height;
        this.depth = depth;

        this.imageType = imageType;

        this.format = format;
        this.internalFormat = internalFormat;
        this.componentType = componentType;

        this.buffer = buffer;
        this.extras = {};

        Object.defineProperty(CustomImageData.prototype, 'isCustomImageData', { value: true });
    }
}

/**
 * @class module:@webgears-app/engine-core.TextureLevelData
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary Class represents a pixels source for the texture.
 * @param {object} parameters Parameters.
 * @param {number} [parameters.xoffset=0] Specifies the x offset within the texture's data.
 * @param {number} [parameters.yoffset=0] Specifies the y offset within the texture's data.
 * @param {number} [parameters.zoffset=0] Specifies the z offset within the texture's data.
 * @param {number} [parameters.width] Specifies the width of the texture's level.
 * @param {number} [parameters.height] Specifies the height of the texture's level.
 * @param {number} [parameters.depth] Specifies the depth of the texture's level.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|base64Image|TypedArray|module:@webgears-app/engine-core.CustomImageData}
 * [parameters.data] The texture's level data.
 */
class texture_TextureLevelData extends disposeableUsageCounter_DisposableUsageCounter {
    constructor({ xoffset = 0, yoffset = 0, zoffset = 0, width, height, depth, data }) {
        super();

        this.xoffset = xoffset;
        this.yoffset = yoffset;
        this.zoffset = zoffset;

        if (data instanceof CustomImageData) {
            this.width = data.width;
            this.height = data.height;
            this.depth = data.depth;
        } else {
            this.width = width;
            this.height = height;
            this.depth = depth;
        }

        this.data = data;   // data possible values:
                            // 1. HTMLImageElement
                            // 2. HTMLCanvasElement
                            // 3. HTMLVideoElement
                            // 4. base64 image
                            // 5. raw pixels data as typed array
                            // 6. instance of CustomImageData
    }

    clone() {
        return new this.contructor(this);
    }

    _actuallyUnload() {
        this.data = null;
        return super._actuallyUnload();
    }
}

class _BindingPoint {
    static get NONE() { return 0; }
}

class _WrappingMode {}

class _Filter {}

class _CompareFunc {}

class _CompareMode {}

(function prepEnums() {
    const bindingPoints = [
        'TEXTURE_2D',
        'TEXTURE_CUBE_MAP',
        'TEXTURE_3D',
        'TEXTURE_2D_ARRAY',
        'TEXTURE_CUBE_MAP_POSITIVE_X',
        'TEXTURE_CUBE_MAP_NEGATIVE_X',
        'TEXTURE_CUBE_MAP_POSITIVE_Y',
        'TEXTURE_CUBE_MAP_NEGATIVE_Y',
        'TEXTURE_CUBE_MAP_POSITIVE_Z',
        'TEXTURE_CUBE_MAP_NEGATIVE_Z'
    ];

    const wrappingModes = [
        'REPEAT',
        'CLAMP_TO_EDGE',
        'MIRRORED_REPEAT'
    ];

    const filters = [
        'NEAREST',
        'LINEAR',
        'NEAREST_MIPMAP_NEAREST',
        'LINEAR_MIPMAP_NEAREST',
        'NEAREST_MIPMAP_LINEAR',
        'LINEAR_MIPMAP_LINEAR'
    ];

    // TODO:: move this enum out of texture
    const compareFuncs = [
        'LEQUAL',
        'GEQUAL',
        'LESS',
        'GREATER',
        'EQUAL',
        'NOTEQUAL',
        'ALWAYS',
        'NEVER'
    ];

    const compareModes = [
        'NONE',
        'COMPARE_REF_TO_TEXTURE'
    ];

    for (const bindingPoint of bindingPoints) {
        const value = webglContext[bindingPoint];

        Object.defineProperty(_BindingPoint, bindingPoint, { value, writeable: false });
    }

    for (const wrappingMode of wrappingModes) {
        const value = webglContext[wrappingMode];

        Object.defineProperty(_WrappingMode, wrappingMode, { value, writeable: false });
    }

    for (const filter of filters) {
        const value = webglContext[filter];

        Object.defineProperty(_Filter, filter, { value, writeable: false });
    }

    for (const compareFunc of compareFuncs) {
        const value = webglContext[compareFunc];

        Object.defineProperty(_CompareFunc, compareFunc, { value, writeable: false });
    }

    for (const compareMode of compareModes) {
        const value = webglContext[compareMode];

        Object.defineProperty(_CompareMode, compareMode, { value, writeable: false });
    }
}());

function getTextureBindingPointName(bindingPoint) {
    for (const name of Object.getOwnPropertyNames(_BindingPoint)) {
        if (name === 'length') { continue; }
        if (_BindingPoint[name] === bindingPoint) { return name; }
    }
}

function _deleteDataFromTextureLevelData(levelData) {
    if (Array.isArray(levelData)) {
        for (const ld of levelData) {
            _deleteDataFromTextureLevelData(ld);
        }
    } else if (levelData !== undefined && levelData !== null) {
        levelData.data = null;
    }
}

let _lastTextureId = 0;

/**
 * @class module:@webgears-app/engine-core.Texture
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary The class represents a Texture resource.
 * @param {object} [properties={}] Properties.
 * @param {string} [properties.name=''] The name of the texture.
 * @param {number} [properties.width=1] The width of the texture.
 * @param {number} [properties.height=1] The height of the texture.
 * @param {number} [properties.depth=1] The depth of the texture.
 * @param {module:@webgears-app/engine-core.Texture.BindingPoint} [properties.bindingPoint=BindingPoint.NONE]
 * The binding point of the texture.
 * @param {module:@webgears-app/engine-core.Texture.WrappingMode} [properties.wrapS=WrappingMode.REPEAT] S(U) wrapping mode.
 * @param {module:@webgears-app/engine-core.Texture.WrappingMode} [properties.wrapT=WrappingMode.REPEAT] T(V) wrapping mode.
 * @param {module:@webgears-app/engine-core.Texture.Filter} [properties.magFilter]
 * Specifies how the texture is sampled when a texel covers more than one pixel.
 * @param {module:@webgears-app/engine-core.Texture.Filter} [properties.minFilter]
 * Specifies how the texture is sampled when a texel covers less than one pixel
 * @param {number} [properties.compareFunc=515] The texture's compare func. Default is gl.LEQUAL
 * @param {module:@webgears-app/engine-core.Texture.CompareMode} [properties.compareMode=CompareMode.NONE] Texture comparison mode.
 * @param {number} [properties.anisotropyDegree=1] Texture anisotropic filtering degree.
 * @param {number} [properties.baseLevel=0] Texture mipmap level.
 * @param {number} [properties.maxLevel=0] Maximum texture mipmap array level.
 * @param {module:@webgears-app/engine-core.DataType} [properties.componentType=DataType.UNSIGNED_BYTE]
 * Specifies the data type of the texel data.
 * @param {module:@webgears-app/engine-core.PixelDataFormat} [properties.format=PixelDataFormat.RGB]
 * Specifies the format of the texel data.
 * @param {number} [properties.levels] The number of mip map levels.
 * @param {?module:@webgears-app/engine-core.InternalFormat} [properties.internalFormat=null]
 * Specifies the color components in the texture.
 * @param {Array<module:@webgears-app/engine-core.TextureLevelData>} [properties.levelsData=[]] The data of the texture's pixels.
 * @param {boolean} [properties.dynamic=false]
 * If texture is not dynamic, then you can not change anything after first texture update.
 */
class texture_Texture extends disposeableUsageCounter_DisposableUsageCounter {
    /**
     * @namespace module:@webgears-app/engine-core.Texture.BindingPoint
     * @desc Binding point enum.
     * @property {number} NONE
     * @property {number} TEXTURE_2D
     * @property {number} TEXTURE_CUBE_MAP
     * @property {number} TEXTURE_3D
     * @property {number} TEXTURE_2D_ARRAY
     * @property {number} TEXTURE_CUBE_MAP_POSITIVE_X
     * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_X
     * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Y
     * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Y
     * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Z
     * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Z
     */
    static get BindingPoint() {
        return _BindingPoint;
    }

    /**
     * @namespace module:@webgears-app/engine-core.Texture.WrappingMode
     * @desc Wrapping Mode enum. All values correspond to WebGL enums.
     * @property {number} REPEAT
     * @property {number} CLAMP_TO_EDGE
     * @property {number} MIRRORED_REPEAT
     */
    static get WrappingMode() {
        return _WrappingMode;
    }

    /**
     * @namespace module:@webgears-app/engine-core.Texture.Filter
     * @desc Texture filter enum. All values correspond to WebGL enums.
     * @property {number} NEAREST
     * @property {number} LINEAR
     * @property {number} NEAREST_MIPMAP_NEAREST
     * @property {number} LINEAR_MIPMAP_NEAREST
     * @property {number} NEAREST_MIPMAP_LINEAR
     * @property {number} LINEAR_MIPMAP_LINEAR
     */
    static get Filter() {
        return _Filter;
    }

    static get CompareFunc() {
        return _CompareFunc;
    }

    /**
     * @namespace module:@webgears-app/engine-core.Texture.CompareMode
     * @desc Texture compare mode enum.
     * @property {number} NONE
     * @property {number} COMPARE_REF_TO_TEXTURE
     */
    static get CompareMode() {
        return _CompareMode;
    }

    constructor(properties = {}) {
        const {
            name = '',
            width = 1,
            height = 1,
            depth = 1,
            bindingPoint = texture_Texture.BindingPoint.NONE,
            wrapS = texture_Texture.WrappingMode.REPEAT,
            wrapT = texture_Texture.WrappingMode.REPEAT,
            magFilter,
            minFilter,
            compareFunc = texture_Texture.CompareFunc.LEQUAL,
            compareMode = texture_Texture.CompareMode.NONE,
            anisotropyDegree = 1,
            baseLevel = 0,
            maxLevel = 0,
            componentType = DataType.UNSIGNED_BYTE,
            format = PixelDataFormat.RGB,
            levels,                 // required mip levels
            internalFormat = null,  // no default value
            levelsData = [],        // for 2d textures: [baseLevel, mipmaps]
                                    // for cubemaps: faces = [[baseLevel, mipmaps], [baseLevel, mipmaps], ...]
                                    // for 3d textures: array layers = [baseLevel, mipmaps, ...]
                                    // for texture_2d_array: array layers = [[baseLevel, mipmaps], [baseLevel, mipmaps], ...]
            dynamic = false
        } = properties;

        super();

        this._id = ++_lastTextureId;

        this.name = name;

        // TODO:: maybe hide direct access to values and properties and set needsUpdate on any property change
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.bindingPoint = bindingPoint;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.compareFunc = compareFunc;
        this.compareMode = compareMode;
        this.anisotropyDegree = anisotropyDegree;
        this.baseLevel = baseLevel;
        this.maxLevel = maxLevel;
        this.componentType = componentType;
        this.format = format;
        this.internalFormat = internalFormat;

        this._levelsData = [...levelsData];
        this.levels = levels;

        this._gammaDecode = false;

        this._dynamic = dynamic;
        this._needsUpdate = true;
        this._needsUpdateLevels = false;

        this._webGLTexture = null;
        this._webGLTextureSystem = null;

        this.extras = undefined;
    }

    /**
     * @var module:@webgears-app/engine-core.Texture#width
     * @type {number}
     * @summary The width of the texture.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#height
     * @type {number}
     * @summary The height of the texture.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#depth
     * @type {number}
     * @summary The depth of the texture.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#bindingPoint
     * @type {module:@webgears-app/engine-core.Texture.BindingPoint}
     * @summary The binding point of the texture.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#wrapS
     * @type {module:@webgears-app/engine-core.Texture.WrappingMode}
     * @summary S(U) wrapping mode.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#wrapT
     * @type {module:@webgears-app/engine-core.Texture.WrappingMode}
     * @summary T(V) wrapping mode.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#magFilter
     * @type {module:@webgears-app/engine-core.Texture.Filter}
     * @summary Specifies how the texture is sampled when a texel covers more than one pixel.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#minFilter
     * @type {module:@webgears-app/engine-core.Texture.Filter}
     * @summary Specifies how the texture is sampled when a texel covers less than one pixel.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#compareFunc
     * @type {number}
     * @summary The texture's compare func. Default is gl.LEQUAL
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#compareMode
     * @type {module:@webgears-app/engine-core.Texture.CompareMode}
     * @summary Texture comparison mode.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#anisotropyDegree
     * @type {number}
     * @summary Texture anisotropic filtering degree.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#baseLevel
     * @type {number}
     * @summary Texture mipmap level.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#maxLevel
     * @type {number}
     * @summary Maximum texture mipmap array level.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#componentType
     * @type {module:@webgears-app/engine-core.DataType}
     * @summary Specifies the data type of the texel data.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#format
     * @type {module:@webgears-app/engine-core.PixelDataFormat}
     * @summary Specifies the format of the texel data.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#internalFormat
     * @type {module:@webgears-app/engine-core.InternalFormat}
     * @summary Specifies the color components in the texture.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#levels
     * @type {number}
     * @summary The number of mip map levels.
     */

    /**
     * @var module:@webgears-app/engine-core.Texture#extras
     * @type {any}
     * @summary Unstructred application-specific imported/exported data.
     * @desc Must be {@link JSON.stringify}-able.
     */

    /**
     * @function module:@webgears-app/engine-core.Texture#updateLevels
     * @param {function} callback Callback to handle levels data.
     * @summary Updates levels data of the texture.
     * @desc Callback function expects following arguments:
     * 1. levelsData as array of [TextureLevelData]{@link module:@webgears-app/engine-core.TextureLevelData}
     * 2. levels The number of the levels.
     * @example
     * myTexture.updateLevels((levelsData, levels) => {
     *  // do everything you want here
     *  // ...
     *  // return false if you read texture's data only, and true if you're going to rewrite something.
     *  return false;
     * });
     */
    updateLevels(callback) {
        console.assert(this._dynamic, `can not update levels of texture ${this.name}, texture is not dynamic`);
        const { _levelsData, levels } = this;
        this._needsUpdateLevels = callback(_levelsData, levels);
    }

    /**
     * @var module:@webgears-app/engine-core.Texture#id
     * @type {number}
     * @readonly
     * @summary The unique texture identifier.
     */
    get id() {
        return this._id;
    }

    /**
     * @var module:@webgears-app/engine-core.Texture#needsUpdate
     * @type {boolean}
     * @summary Whether the renderer should recreate webGLTexture object for the texture.
     */
    get needsUpdate() {
        return this._needsUpdate;
    }

    set needsUpdate(value) {
        console.assert(!value || this._dynamic || this._webGLTexture === null,
            `can not update texture ${this.name}, texture is not dynamic`);

        this._needsUpdate = value;
    }

    /**
     * @var module:@webgears-app/engine-core.Texture#dynamic
     * @type {boolean}
     * @readonly
     * @summary Specifies whether the texture is dynamic or not.
     */
    get dynamic() {
        return this._dynamic;
    }

    // TODO:: make this property private
    get gammaDecode() {
        return this._gammaDecode;
    }

    /**
     * @var module:@webgears-app/engine-core.Texture#webGLTexture
     * @readonly
     * @type {?WebGLTexture}
     * @summary [The webgl texture object]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture}
     * to which texture data can be bound to.
     */
    get webGLTexture() {
        return this._webGLTexture;
    }

    /**
     * @function module:@webgears-app/engine-core.Texture#clone
     * @summary Makes a clone of the texture.
     * @returns {module:@webgears-app/engine-core.Texture}
     */
    clone(cloneGPUData = false) {
        const {
            name,
            width,
            height,
            depth,
            bindingPoint,
            wrapS,
            wrapT,
            magFilter,
            minFilter,
            componentType,
            format,
            internalFormat,
            _levelsData,
            levels,
            _dynamic,
        } = this;

        console.assert(_dynamic, `texture: ${name} can not be cloned, texture is not dynamic`);

        const cloned = new texture_Texture({
            name,
            width,
            height,
            depth,
            bindingPoint,
            wrapS,
            wrapT,
            magFilter,
            minFilter,
            componentType,
            format,
            internalFormat,
            levelsData: _levelsData.map(x => x.clone()),
            levels,
            dynamic: _dynamic
        });

        if (cloneGPUData) {
            throw new Error('not implemented yet');
        }

        return cloned;
    }

    async _loadDependencies() {
        await Promise.all([
            super._loadDependencies(),
            ...(function* walk(levelDatas) {
                for (const levelData of levelDatas) {
                    if (Array.isArray(levelData)) {
                        yield *walk(levelData);
                        continue;
                    }

                    yield levelData.load();
                }
            }).call(this, this._levelsData),
        ]);
    }

    _actuallyUnload() {
        const { _webGLTextureSystem, _levelsData } = this;

        if (_webGLTextureSystem !== null) {
            _webGLTextureSystem.disposeTexture(this);
            this._webGLTextureSystem = null;
        }

        _levelsData.forEach(function walk(levelData) {
            if (Array.isArray(levelData)) {
                levelData.forEach(walk, this);
                return;
            }

            levelData.unload();
        }, this);

        super._actuallyUnload();
    }

    /**
     * @function module:@webgears-app/engine-core.Texture#_dispose
     * @summary Disposes texture's resources.
     * @protected
     */
    _dispose() {
        const { _webGLTextureSystem, _levelsData } = this;

        if (_webGLTextureSystem !== null) {
            _webGLTextureSystem.disposeTexture(this);
            this._webGLTextureSystem = null;
        }

        _deleteDataFromTextureLevelData(_levelsData);

        super._dispose();
    }
}

Object.defineProperties(texture_Texture.prototype, { isTexture: { value: true } });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/internalFormat.js



/**
 * @namespace module:@webgears-app/engine-core.InternalFormat
 * @desc Internal format enum. All values correspond to WebGL enums.
 * @property {number} RGB
 * @property {number} RGBA
 * @property {number} LUMINANCE_ALPHA
 * @property {number} LUMINANCE
 * @property {number} ALPHA
 * @property {number} DEPTH_COMPONENT
 * @property {number} R8
 * @property {number} R16F
 * @property {number} R32F
 * @property {number} R8UI
 * @property {number} RG8
 * @property {number} RG16F
 * @property {number} RG32F
 * @property {number} RG8UI
 * @property {number} RGB8
 * @property {number} SRGB8
 * @property {number} SRGB565
 * @property {number} R11F_G11F_B10F
 * @property {number} RGB9_E5
 * @property {number} RGB16F
 * @property {number} RGB32F
 * @property {number} RGB8UI
 * @property {number} RGBA8
 * @property {number} SRGB8_ALPHA8
 * @property {number} RGB5_A1
 * @property {number} RGB10_A2
 * @property {number} RGBA4
 * @property {number} RGBA16F
 * @property {number} RGBA32F
 * @property {number} RGBA8UI
 * @property {number} DEPTH_STENCIL
 * @property {number} DEPTH_COMPONENT16
 * @property {number} DEPTH_COMPONENT24
 * @property {number} DEPTH_COMPONENT32F
 * @property {number} DEPTH32F_STENCIL8
 * @property {number} DEPTH24_STENCIL8
 * @property {number} STENCIL_INDEX8
 */
class InternalFormat {}

(function prepEnum() {
    let i = 0;

    const internalFormats = [
        'RGB',
        'RGBA',
        'LUMINANCE_ALPHA',
        'LUMINANCE',
        'ALPHA',
        'DEPTH_COMPONENT',
        'R8',
        'R16F',
        'R32F',
        'R8UI',
        'RG8',
        'RG16F',
        'RG32F',
        'RG8UI',
        'RGB8',
        'SRGB8',
        'RGB565',
        'R11F_G11F_B10F',
        'RGB9_E5',
        'RGB16F',
        'RGB32F',
        'RGB8UI',
        'RGBA8',
        'SRGB8_ALPHA8',
        'RGB5_A1',
        'RGB10_A2',
        'RGBA4',
        'RGBA16F',
        'RGBA32F',
        'RGBA8UI',
        'DEPTH_STENCIL',
        'DEPTH_COMPONENT16',
        'DEPTH_COMPONENT24',
        'DEPTH_COMPONENT32F',
        'DEPTH32F_STENCIL8',
        'DEPTH24_STENCIL8',
        'STENCIL_INDEX8'
    ];

    for (const internalFormat of internalFormats) {
        let value = webglContext[internalFormat];

        if (value === undefined) {
            value = --i;
        }

        Object.defineProperty(InternalFormat, internalFormat, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/octree/index.js
/**
 * @module @webgears-app/octree
 */


const SPLIT_THRESHOLD = 20;
const MERGE_THRESHOLD = 12;

function tryShrinkBounds(cell) {
    const count = cell.values.length;
    const length = 6 * count;

    const { bounds } = cell;
    const capacity = bounds.length;

    if (length * 4 > capacity) { return; }

    const newCapacity = 6 * functions_max(SPLIT_THRESHOLD, count * 2)
    if (newCapacity === capacity) { return; }

    const newBounds = new Float64Array(newCapacity);
    for (let offset = 0; offset < length; offset += 6) {
        newBounds[offset    ] = bounds[offset    ];
        newBounds[offset + 1] = bounds[offset + 1];
        newBounds[offset + 2] = bounds[offset + 2];
        newBounds[offset + 3] = bounds[offset + 3];
        newBounds[offset + 4] = bounds[offset + 4];
        newBounds[offset + 5] = bounds[offset + 5];
    }
    cell.bounds = newBounds;
}

const frustumProperties = {
    lX: 0, lY: 0, lZ: 0, lW: 0,
    rX: 0, rY: 0, rZ: 0, rW: 0,
    bX: 0, bY: 0, bZ: 0, bW: 0,
    tX: 0, tY: 0, tZ: 0, tW: 0,
    nX: 0, nY: 0, nZ: 0, nW: 0,
    fX: 0, fY: 0, fZ: 0, fW: 0,

    minX: 0, minY: 0, minZ: 0,
    maxX: 0, maxY: 0, maxZ: 0,
};

const crossEdgeSeparators = (() => {
    const cess = new Array(12);
    for (let i = 0; i < cess.length; ++i) {
        cess[i] = {
            eX: 0, eY: 0, eZ: 0,

            loX: 0, hiX: 0,
            loY: 0, hiY: 0,
            loZ: 0, hiZ: 0,
        };
    }
    cess.count = 0;
    return cess;
})();

function generateCrossEdgeSeparators(eX, eY, eZ,
                                     minX, minY, minZ, maxX, maxY, maxZ,
                                     c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                     c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                     c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)
{
    const cess = crossEdgeSeparators;
    const ces = cess[cess.count++];
    ces.eX = eX;
    ces.eY = eY;
    ces.eZ = eZ;
    {
        const y = -eZ,
              z =  eY;
        const p0 = c0Y * y + c0Z * z,
              p1 = c1Y * y + c1Z * z,
              p2 = c2Y * y + c2Z * z,
              p3 = c3Y * y + c3Z * z,
              p4 = c4Y * y + c4Z * z,
              p5 = c5Y * y + c5Z * z,
              p6 = c6Y * y + c6Z * z,
              p7 = c7Y * y + c7Z * z;
        const lo = ces.loX = functions_min(p0, p1, p2, p3, p4, p5, p6, p7);
        if (lo > y * ((y < 0) ? minY : maxY) +
                 z * ((z < 0) ? minZ : maxZ))
        { return true; }
        const hi = ces.hiX = functions_max(p0, p1, p2, p3, p4, p5, p6, p7);
        if (hi < y * ((y < 0) ? maxY : minY) +
                 z * ((z < 0) ? maxZ : minZ))
        { return true; }
    }
    {
        const z = -eX,
              x =  eZ;
        const p0 = c0Z * z + c0X * x,
              p1 = c1Z * z + c1X * x,
              p2 = c2Z * z + c2X * x,
              p3 = c3Z * z + c3X * x,
              p4 = c4Z * z + c4X * x,
              p5 = c5Z * z + c5X * x,
              p6 = c6Z * z + c6X * x,
              p7 = c7Z * z + c7X * x;
        const lo = ces.loY = functions_min(p0, p1, p2, p3, p4, p5, p6, p7);
        if (lo > z * ((z < 0) ? minZ : maxZ) +
                 x * ((x < 0) ? minX : maxX))
        { return true; }
        const hi = ces.hiY = functions_max(p0, p1, p2, p3, p4, p5, p6, p7);
        if (hi < z * ((z < 0) ? maxZ : minZ) +
                 x * ((x < 0) ? maxX : minX))
        { return true; }
    }
    {
        const x = -eY,
              y =  eX;
        const p0 = c0X * x + c0Y * y,
              p1 = c1X * x + c1Y * y,
              p2 = c2X * x + c2Y * y,
              p3 = c3X * x + c3Y * y,
              p4 = c4X * x + c4Y * y,
              p5 = c5X * x + c5Y * y,
              p6 = c6X * x + c6Y * y,
              p7 = c7X * x + c7Y * y;
        const lo = ces.loZ = functions_min(p0, p1, p2, p3, p4, p5, p6, p7);
        if (lo > x * ((x < 0) ? minX : maxX) +
                 y * ((y < 0) ? minY : maxY))
        { return true; }
        const hi = ces.hiZ = functions_max(p0, p1, p2, p3, p4, p5, p6, p7);
        if (hi < x * ((x < 0) ? maxX : minX) +
                 y * ((y < 0) ? maxY : minY))
        { return true; }
    }
    return false;
}

class octree_Cell {
    constructor(parent) {
        this.parent = parent;

        this.deepCount = 0;

        this.bounds = new Float64Array(6 * SPLIT_THRESHOLD);
        this.values = [];

        this.child000 = null;
        this.child001 = null;
        this.child010 = null;
        this.child011 = null;
        this.child100 = null;
        this.child101 = null;
        this.child110 = null;
        this.child111 = null;
    }

    insert(valueLocations,
           centerX, centerY, centerZ,
           quarterSize,
           valueMinX, valueMinY, valueMinZ,
           valueMaxX, valueMaxY, valueMaxZ,
           value)
    {
        const { deepCount } = this;
        if ((this.deepCount = deepCount + 1) > SPLIT_THRESHOLD) {
            if (deepCount === SPLIT_THRESHOLD) {
                const { bounds, values } = this;
                const count = values.length;

                this.values = [];

                let offset = 0;
                for (let i = 0; i < count; ++i) {
                    this.insert(valueLocations,
                                centerX, centerY, centerZ,
                                quarterSize,
                                bounds[offset    ],
                                bounds[offset + 1],
                                bounds[offset + 2],
                                bounds[offset + 3],
                                bounds[offset + 4],
                                bounds[offset + 5],
                                values[i]);
                    offset += 6;
                }
                this.deepCount -= count;

                tryShrinkBounds(this);
            }

            let childCenterX,
                childCenterY,
                childCenterZ;
            let child = null;

            const mask0 = (valueMaxZ >= centerZ) << 2 |
                          (valueMaxY >= centerY) << 1 |
                          (valueMaxX >= centerX);
            const mask1 = (valueMinZ > centerZ) << 2 |
                          (valueMinY > centerY) << 1 |
                          (valueMinX > centerX);
            switch ((mask0 ^ mask1) << 3 | mask0 & mask1) {
              case 0b000:
                childCenterX = centerX - quarterSize;
                childCenterY = centerY - quarterSize;
                childCenterZ = centerZ - quarterSize;
                if ((child = this.child000) === null) {
                    this.child000 = child = new octree_Cell(this);
                }
                break;
              case 0b001:
                childCenterX = centerX + quarterSize;
                childCenterY = centerY - quarterSize;
                childCenterZ = centerZ - quarterSize;
                if ((child = this.child001) === null) {
                    this.child001 = child = new octree_Cell(this);
                }
                break;
              case 0b010:
                childCenterX = centerX - quarterSize;
                childCenterY = centerY + quarterSize;
                childCenterZ = centerZ - quarterSize;
                if ((child = this.child010) === null) {
                    this.child010 = child = new octree_Cell(this);
                }
                break;
              case 0b011:
                childCenterX = centerX + quarterSize;
                childCenterY = centerY + quarterSize;
                childCenterZ = centerZ - quarterSize;
                if ((child = this.child011) === null) {
                    this.child011 = child = new octree_Cell(this);
                }
                break;
              case 0b100:
                childCenterX = centerX - quarterSize;
                childCenterY = centerY - quarterSize;
                childCenterZ = centerZ + quarterSize;
                if ((child = this.child100) === null) {
                    this.child100 = child = new octree_Cell(this);
                }
                break;
              case 0b101:
                childCenterX = centerX + quarterSize;
                childCenterY = centerY - quarterSize;
                childCenterZ = centerZ + quarterSize;
                if ((child = this.child101) === null) {
                    this.child101 = child = new octree_Cell(this);
                }
                break;
              case 0b110:
                childCenterX = centerX - quarterSize;
                childCenterY = centerY + quarterSize;
                childCenterZ = centerZ + quarterSize;
                if ((child = this.child110) === null) {
                    this.child110 = child = new octree_Cell(this);
                }
                break;
              case 0b111:
                childCenterX = centerX + quarterSize;
                childCenterY = centerY + quarterSize;
                childCenterZ = centerZ + quarterSize;
                if ((child = this.child111) === null) {
                    this.child111 = child = new octree_Cell(this);
                }
                break;
            }

            if (child !== null) {
                child.insert(valueLocations,
                             childCenterX, childCenterY, childCenterZ,
                             quarterSize * 0.5,
                             valueMinX, valueMinY, valueMinZ,
                             valueMaxX, valueMaxY, valueMaxZ,
                             value);
                return;
            }
        }

        let { bounds, values } = this;

        const count = values.length;
        const offset = 6 * count;
        if (offset === bounds.length) {
            const oldBounds = bounds;
            (bounds = new Float64Array(offset * 2)).set(oldBounds);
            this.bounds = bounds;
        }
        bounds[offset    ] = valueMinX;
        bounds[offset + 1] = valueMinY;
        bounds[offset + 2] = valueMinZ;
        bounds[offset + 3] = valueMaxX;
        bounds[offset + 4] = valueMaxY;
        bounds[offset + 5] = valueMaxZ;

        values.push(value);

        let location = valueLocations.get(value);
        if (location === undefined) {
            location = { cell: this, index: count };
            valueLocations.set(value, location);
        } else {
            location.cell = this;
            location.index = count;
        }
    }

    gather(foundValues, foundCount) {
        const { values } = this;
        const count = values.length;

        for (let i = 0; i < count; ++i) {
            foundValues[foundCount++] = values[i];
        }

        let child;
        if ((child = this.child000) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child001) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child010) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child011) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child100) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child101) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child110) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }
        if ((child = this.child111) !== null) {
            foundCount = child.gather(foundValues, foundCount);
        }

        return foundCount;
    }

    find(centerX, centerY, centerZ,
         quarterSize,
         queryMinX, queryMinY, queryMinZ,
         queryMaxX, queryMaxY, queryMaxZ,
         coverX0, coverY0, coverZ0, 
         coverX1, coverY1, coverZ1,
         foundValues, foundCount)
    {
        const { bounds, values } = this;
        const count = values.length;

        let offset = 0;
        for (let i = 0; i < count; ++i) {
            if (bounds[offset    ] <= queryMaxX &&
                bounds[offset + 1] <= queryMaxY &&
                bounds[offset + 2] <= queryMaxZ &&
                bounds[offset + 3] >= queryMinX &&
                bounds[offset + 4] >= queryMinY &&
                bounds[offset + 5] >= queryMinZ)
            { foundValues[foundCount++] = values[i]; }
            offset += 6;
        }

        const hitX0 = queryMinX <= centerX,
              hitY0 = queryMinY <= centerY,
              hitZ0 = queryMinZ <= centerZ;
        const hitX1 = queryMaxX >= centerX,
              hitY1 = queryMaxY >= centerY,
              hitZ1 = queryMaxZ >= centerZ;

        const centerX0 = centerX - quarterSize,
              centerY0 = centerY - quarterSize,
              centerZ0 = centerZ - quarterSize;
        const centerX1 = centerX + quarterSize,
              centerY1 = centerY + quarterSize,
              centerZ1 = centerZ + quarterSize;

        const childQuarterSize = quarterSize * 0.5;

        let child;
        if ((child = this.child000) !== null) {
            if (coverX0 && coverY0 && coverZ0 && hitX1 && hitY1 && hitZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX0 && hitY0 && hitZ0) {
                foundCount = child.find(centerX0, centerY0, centerZ0,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        coverX0, coverY0, coverZ0,
                                        hitX1, hitY1, hitZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child001) !== null) {
            if (hitX0 && coverY0 && coverZ0 && coverX1 && hitY1 && hitZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX1 && hitY0 && hitZ0) {
                foundCount = child.find(centerX1, centerY0, centerZ0,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        hitX0, coverY0, coverZ0,
                                        coverX1, hitY1, hitZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child010) !== null) {
            if (coverX0 && hitY0 && coverZ0 && hitX1 && coverY1 && hitZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX0 && hitY1 && hitZ0) {
                foundCount = child.find(centerX0, centerY1, centerZ0,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        coverX0, hitY0, coverZ0,
                                        hitX1, coverY1, hitZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child011) !== null) {
            if (hitX0 && hitY0 && coverZ0 && coverX1 && coverY1 && hitZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX1 && hitY1 && hitZ0) {
                foundCount = child.find(centerX1, centerY1, centerZ0,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        hitX0, hitY0, coverZ0,
                                        coverX1, coverY1, hitZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child100) !== null) {
            if (coverX0 && coverY0 && hitZ0 && hitX1 && hitY1 && coverZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX0 && hitY0 && hitZ1) {
                foundCount = child.find(centerX0, centerY0, centerZ1,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        coverX0, coverY0, hitZ0,
                                        hitX1, hitY1, coverZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child101) !== null) {
            if (hitX0 && coverY0 && hitZ0 && coverX1 && hitY1 && coverZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX1 && hitY0 && hitZ1) {
                foundCount = child.find(centerX1, centerY0, centerZ1,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        hitX0, coverY0, coverZ0,
                                        coverX1, hitY1, coverZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child110) !== null) {
            if (coverX0 && hitY0 && hitZ0 && hitX1 && coverY1 && coverZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX0 && hitY1 && hitZ1) {
                foundCount = child.find(centerX0, centerY1, centerZ1,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        coverX0, hitY0, hitZ0,
                                        hitX1, coverY1, coverZ1,
                                        foundValues, foundCount);
            }
        }
        if ((child = this.child111) !== null) {
            if (hitX0 && hitY0 && hitZ0 && coverX1 && coverY1 && coverZ1) {
                foundCount = child.gather(foundValues, foundCount);
            } else if (hitX1 && hitY1 && hitZ1) {
                foundCount = child.find(centerX1, centerY1, centerZ1,
                                        childQuarterSize,
                                        queryMinX, queryMinY, queryMinZ,
                                        queryMaxX, queryMaxY, queryMaxZ,
                                        hitX0, hitY0, hitZ0,
                                        coverX1, coverY1, coverZ1,
                                        foundValues, foundCount);
            }
        }

        return foundCount;
    }

    frustumFindAsChild(centerX, centerY, centerZ,
                       quarterSize,
                       minX, minY, minZ,
                       maxX, maxY, maxZ,
                       lCover, rCover,
                       bCover, tCover,
                       nCover, fCover,
                       foundValues, foundCount)
    {
        const fp = frustumProperties;

        if (minX <= fp.maxX && maxX >= fp.minX &&
            minY <= fp.maxY && maxY >= fp.minY &&
            minZ <= fp.maxZ && maxZ >= fp.minZ)
        {
            const {
                lX, lY, lZ, lW,
                rX, rY, rZ, rW,
                bX, bY, bZ, bW,
                tX, tY, tZ, tW,
                nX, nY, nZ, nW,
                fX, fY, fZ, fW,
            } = fp;

            lCover = lCover || 0 < lX * ((lX < 0) ? maxX : minX) +
                                   lY * ((lY < 0) ? maxY : minY) +
                                   lZ * ((lZ < 0) ? maxZ : minZ) +
                                   lW;
            rCover = rCover || 0 < rX * ((rX < 0) ? maxX : minX) +
                                   rY * ((rY < 0) ? maxY : minY) +
                                   rZ * ((rZ < 0) ? maxZ : minZ) +
                                   rW;
            bCover = bCover || 0 < bX * ((bX < 0) ? maxX : minX) +
                                   bY * ((bY < 0) ? maxY : minY) +
                                   bZ * ((bZ < 0) ? maxZ : minZ) +
                                   bW;
            tCover = tCover || 0 < tX * ((tX < 0) ? maxX : minX) +
                                   tY * ((tY < 0) ? maxY : minY) +
                                   tZ * ((tZ < 0) ? maxZ : minZ) +
                                   tW;
            nCover = nCover || 0 < nX * ((nX < 0) ? maxX : minX) +
                                   nY * ((nY < 0) ? maxY : minY) +
                                   nZ * ((nZ < 0) ? maxZ : minZ) +
                                   nW;
            fCover = fCover || 0 < fX * ((fX < 0) ? maxX : minX) +
                                   fY * ((fY < 0) ? maxY : minY) +
                                   fZ * ((fZ < 0) ? maxZ : minZ) +
                                   fW;

            if (lCover && rCover && bCover && tCover && nCover && fCover) {
                foundCount = this.gather(foundValues, foundCount);
            } else do {
                if (!lCover && 0 > lX * ((lX < 0) ? minX : maxX) +
                                   lY * ((lY < 0) ? minY : maxY) +
                                   lZ * ((lZ < 0) ? minZ : maxZ) +
                                   lW)
                { break; }
                if (!rCover && 0 > rX * ((rX < 0) ? minX : maxX) +
                                   rY * ((rY < 0) ? minY : maxY) +
                                   rZ * ((rZ < 0) ? minZ : maxZ) +
                                   rW)
                { break; }
                if (!bCover && 0 > bX * ((bX < 0) ? minX : maxX) +
                                   bY * ((bY < 0) ? minY : maxY) +
                                   bZ * ((bZ < 0) ? minZ : maxZ) +
                                   bW)
                { break; }
                if (!tCover && 0 > tX * ((tX < 0) ? minX : maxX) +
                                   tY * ((tY < 0) ? minY : maxY) +
                                   tZ * ((tZ < 0) ? minZ : maxZ) +
                                   tW)
                { break; }
                if (!nCover && 0 > nX * ((nX < 0) ? minX : maxX) +
                                   nY * ((nY < 0) ? minY : maxY) +
                                   nZ * ((nZ < 0) ? minZ : maxZ) +
                                   nW)
                { break; }
                if (!fCover && 0 > fX * ((fX < 0) ? minX : maxX) +
                                   fY * ((fY < 0) ? minY : maxY) +
                                   fZ * ((fZ < 0) ? minZ : maxZ) +
                                   fW)
                { break; }

                const cess = crossEdgeSeparators;

                let disjoint = false;
                for (let i = 0; i < 12; ++i) {
                    const ces = cess[i];
                    const { eX, eY, eZ } = ces;
                    {
                        const y = -eZ,
                              z =  eY;
                        if (ces.loX > y * ((y < 0) ? minY : maxY) +
                                      z * ((z < 0) ? minZ : maxZ) ||
                            ces.hiX < y * ((y < 0) ? maxY : minY) +
                                      z * ((z < 0) ? maxZ : minZ))
                        {
                            disjoint = true;
                            break;
                        }
                    }
                    {
                        const z = -eX,
                              x =  eZ;
                        if (ces.loY > z * ((z < 0) ? minZ : maxZ) +
                                      x * ((x < 0) ? minX : maxX) ||
                            ces.hiY < z * ((z < 0) ? maxZ : minZ) +
                                      x * ((x < 0) ? maxX : minX))
                        {
                            disjoint = true;
                            break;
                        }
                    }
                    {
                        const x = -eY,
                              y =  eX;
                        if (ces.loZ > x * ((x < 0) ? minX : maxX) +
                                      y * ((y < 0) ? minY : maxY) ||
                            ces.hiZ < x * ((x < 0) ? maxX : minX) +
                                      y * ((y < 0) ? maxY : minY))
                        {
                            disjoint = true;
                            break;
                        }
                    }
                }
                if (disjoint) { continue; }

                foundCount = this.frustumFind(centerX, centerY, centerZ,
                                              quarterSize,
                                              minX, minY, minZ,
                                              maxX, maxY, maxZ,
                                              lCover, rCover,
                                              bCover, tCover,
                                              nCover, fCover,
                                              foundValues, foundCount);
            } while (false);
        }

        return foundCount;
    }

    frustumFind(midX, midY, midZ,
                quarterSize,
                minX, minY, minZ,
                maxX, maxY, maxZ,
                lCover, rCover,
                bCover, tCover,
                nCover, fCover,
                foundValues, foundCount)
    {
        const fp = frustumProperties;
        const cess = crossEdgeSeparators;

        const { bounds, values } = this;
        const count = values.length;
        for (let i = 0, offset = 0; i < count; ++i, offset += 6) {
            const minX = bounds[offset    ];
            if (minX > fp.maxX) { continue; }
            const minY = bounds[offset + 1];
            if (minY > fp.maxY) { continue; }
            const minZ = bounds[offset + 2];
            if (minZ > fp.maxZ) { continue; }
            const maxX = bounds[offset + 3];
            if (maxX < fp.minX) { continue; }
            const maxY = bounds[offset + 4];
            if (maxY < fp.minY) { continue; }
            const maxZ = bounds[offset + 5];
            if (maxZ < fp.minZ) { continue; }

            if (!lCover) {
                const { lX: x, lY: y, lZ: z, lW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }
            if (!rCover) {
                const { rX: x, rY: y, rZ: z, rW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }
            if (!bCover) {
                const { bX: x, bY: y, bZ: z, bW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }
            if (!tCover) {
                const { tX: x, tY: y, tZ: z, tW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }
            if (!nCover) {
                const { nX: x, nY: y, nZ: z, nW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }
            if (!fCover) {
                const { fX: x, fY: y, fZ: z, fW: w } = fp;
                if (0 > x * ((x < 0) ? minX : maxX) +
                        y * ((y < 0) ? minY : maxY) +
                        z * ((z < 0) ? minZ : maxZ) +
                        w)
                { continue; }
            }

            let disjoint = false;
            for (let i = 0; i < 12; ++i) {
                const ces = cess[i];
                const { eX, eY, eZ } = ces;
                {
                    const y = -eZ,
                          z =  eY;
                    if (ces.loX > y * ((y < 0) ? minY : maxY) +
                                  z * ((z < 0) ? minZ : maxZ) ||
                        ces.hiX < y * ((y < 0) ? maxY : minY) +
                                  z * ((z < 0) ? maxZ : minZ))
                    {
                        disjoint = true;
                        break;
                    }
                }
                {
                    const z = -eX,
                          x =  eZ;
                    if (ces.loY > z * ((z < 0) ? minZ : maxZ) +
                                  x * ((x < 0) ? minX : maxX) ||
                        ces.hiY < z * ((z < 0) ? maxZ : minZ) +
                                  x * ((x < 0) ? maxX : minX))
                    {
                        disjoint = true;
                        break;
                    }
                }
                {
                    const x = -eY,
                          y =  eX;
                    if (ces.loZ > x * ((x < 0) ? minX : maxX) +
                                  y * ((y < 0) ? minY : maxY) ||
                        ces.hiZ < x * ((x < 0) ? maxX : minX) +
                                  y * ((y < 0) ? maxY : minY))
                    {
                        disjoint = true;
                        break;
                    }
                }
            }
            if (disjoint) { continue; }

            foundValues[foundCount++] = values[i];
        }

        const loCenterX = midX - quarterSize,
              loCenterY = midY - quarterSize,
              loCenterZ = midZ - quarterSize;
        const hiCenterX = midX + quarterSize,
              hiCenterY = midY + quarterSize,
              hiCenterZ = midZ + quarterSize;

        const halfQuarterSize = quarterSize * 0.5;

        let child;
        if ((child = this.child000) !== null) {
            foundCount = child.frustumFindAsChild(loCenterX, loCenterY, loCenterZ,
                                                  halfQuarterSize,
                                                  minX, minY, minZ,
                                                  midX, midY, midZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child001) !== null) {
            foundCount = child.frustumFindAsChild(hiCenterX, loCenterY, loCenterZ,
                                                  halfQuarterSize,
                                                  midX, minY, minZ,
                                                  maxX, midY, midZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child010) !== null) {
            foundCount = child.frustumFindAsChild(loCenterX, hiCenterY, loCenterZ,
                                                  halfQuarterSize,
                                                  minX, midY, minZ,
                                                  midX, maxY, midZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child011) !== null) {
            foundCount = child.frustumFindAsChild(hiCenterX, hiCenterY, loCenterZ,
                                                  halfQuarterSize,
                                                  midX, midY, minZ,
                                                  maxX, maxY, midZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child100) !== null) {
            foundCount = child.frustumFindAsChild(loCenterX, loCenterY, hiCenterZ,
                                                  halfQuarterSize,
                                                  minX, minY, midZ,
                                                  midX, midY, maxZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child101) !== null) {
            foundCount = child.frustumFindAsChild(hiCenterX, loCenterY, hiCenterZ,
                                                  halfQuarterSize,
                                                  midX, minY, midZ,
                                                  maxX, midY, maxZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child110) !== null) {
            foundCount = child.frustumFindAsChild(loCenterX, hiCenterY, hiCenterZ,
                                                  halfQuarterSize,
                                                  minX, midY, midZ,
                                                  midX, maxY, maxZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }
        if ((child = this.child111) !== null) {
            foundCount = child.frustumFindAsChild(hiCenterX, hiCenterY, hiCenterZ,
                                                  halfQuarterSize,
                                                  midX, midY, midZ,
                                                  maxX, maxY, maxZ,
                                                  lCover, rCover,
                                                  bCover, tCover,
                                                  nCover, fCover,
                                                  foundValues, foundCount);
        }

        return foundCount;
    }

    rayFind(originX, originY, originZ,
            recDirectionX, recDirectionY, recDirectionZ,
            tMinX, tMinY, tMinZ,
            tMaxX, tMaxY, tMaxZ,
            foundValues, foundCount)
    {
        const near = functions_max((tMinX <= tMaxX) ? tMinX : tMaxX, 
                         (tMinY <= tMaxY) ? tMinY : tMaxY, 
                         (tMinZ <= tMaxZ) ? tMinZ : tMaxZ,
                         0);
        const far = functions_min((tMinX > tMaxX) ? tMinX : tMaxX, 
                        (tMinY > tMaxY) ? tMinY : tMaxY, 
                        (tMinZ > tMaxZ) ? tMinZ : tMaxZ);
        if (near <= far) {
            const { bounds, values } = this;
            const count = values.length;
            for (let i = 0, offset = 0; i < count; ++i, offset += 6) {
                let tMinX = (bounds[offset    ] - originX) * recDirectionX,
                    tMinY = (bounds[offset + 1] - originY) * recDirectionY,
                    tMinZ = (bounds[offset + 2] - originZ) * recDirectionZ;
                if (!isFinite(tMinX)) { tMinX = -Infinity; } 
                if (!isFinite(tMinY)) { tMinY = -Infinity; } 
                if (!isFinite(tMinZ)) { tMinZ = -Infinity; } 

                let tMaxX = (bounds[offset + 3] - originX) * recDirectionX,
                    tMaxY = (bounds[offset + 4] - originY) * recDirectionY,
                    tMaxZ = (bounds[offset + 5] - originZ) * recDirectionZ;
                if (!isFinite(tMaxX)) { tMaxX = +Infinity; }
                if (!isFinite(tMaxY)) { tMaxY = +Infinity; }
                if (!isFinite(tMaxZ)) { tMaxZ = +Infinity; }

                if (tMinX > tMaxX) { const t = tMinX; tMinX = tMaxX; tMaxX = t; }
                if (tMinY > tMaxY) { const t = tMinY; tMinY = tMaxY; tMaxY = t; }
                if (tMinZ > tMaxZ) { const t = tMinZ; tMinZ = tMaxZ; tMaxZ = t; }

                if (functions_max(tMinX, tMinY, tMinZ, 0) <= functions_min(tMaxX, tMaxY, tMaxZ)) {
                    foundValues[foundCount++] = values[i];
                }
            }

            const tMidX = (tMinX + tMaxX) * 0.5,
                  tMidY = (tMinY + tMaxY) * 0.5,
                  tMidZ = (tMinZ + tMaxZ) * 0.5;
            const tLoMidX = functions_isNaN(tMidX) ? +Infinity : tMidX,
                  tLoMidY = functions_isNaN(tMidY) ? +Infinity : tMidY,
                  tLoMidZ = functions_isNaN(tMidZ) ? +Infinity : tMidZ;
            const tHiMidX = functions_isNaN(tMidX) ? -Infinity : tMidX,
                  tHiMidY = functions_isNaN(tMidY) ? -Infinity : tMidY,
                  tHiMidZ = functions_isNaN(tMidZ) ? -Infinity : tMidZ;

            let child;
            if ((child = this.child000) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tMinX, tMinY, tMinZ,
                                           tLoMidX, tLoMidY, tLoMidZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child001) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tHiMidX, tMinY, tMinZ,
                                           tMaxX, tLoMidY, tLoMidZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child010) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tMinX, tHiMidY, tMinZ,
                                           tLoMidX, tMaxY, tLoMidZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child011) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tHiMidX, tHiMidY, tMinZ,
                                           tMaxX, tMaxY, tLoMidZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child100) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tMinX, tMinY, tHiMidZ,
                                           tLoMidX, tLoMidY, tMaxZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child101) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tHiMidX, tMinY, tHiMidZ,
                                           tMaxX, tLoMidY, tMaxZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child110) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tMinX, tHiMidY, tHiMidZ,
                                           tLoMidX, tMaxY, tMaxZ,
                                           foundValues, foundCount);
            }
            if ((child = this.child111) !== null) {
                foundCount = child.rayFind(originX, originY, originZ,
                                           recDirectionX, recDirectionY, recDirectionZ,
                                           tHiMidX, tHiMidY, tHiMidZ,
                                           tMaxX, tMaxY, tMaxZ,
                                           foundValues, foundCount);
            }
        }

        return foundCount;
    }
}

const invProjectionTmp = new HomogeneousMatrix3();

/**
 * @class module:@webgears-app/octree.Octree
 * @summary Dynamic octree for spatial queries.
 * @param {Interable} [values=[]] `[value, boundingBox]` pairs to put into octree.
 */
class octree_Octree {
    constructor(values = []) {
        this._centerX = 0;
        this._centerY = 0;
        this._centerZ = 0;
        this._halfSize = 0;

        this._minX = 0;
        this._minY = 0;
        this._minZ = 0;
        this._maxX = 0;
        this._maxY = 0;
        this._maxZ = 0;

        this._root = null;

        this._valueLocations = new Map();

        for (const [value, valueBound] of values) {
            this.insert(value, valueBound);
        }
    }

    /**
     * @var module:@webgears-app/octree.Octree#count
     * @summary Count of entries in octree.
     * @type {number}
     * @readonly
     */
    get count() {
        return this._valueLocations.size;
    }

    /**
     * @function module:@webgears-app/octree.Octree#insert
     * @summary Set a bounding box for a value.
     * @desc Updates the value's bounding box it the value is already in octree.
     * @param {object} value Value to add into octree. Can be anything that can be used as a `Map`
     * key, with the same equality definition.
     * @param {module:@webgears-app/math.Box} valueBound Bounding box to associate with the value.
     */
    insert(value, valueBound) {
        this.remove(value);

        let {
            min: { x: valueMinX, y: valueMinY, z: valueMinZ },
            max: { x: valueMaxX, y: valueMaxY, z: valueMaxZ },
        } = valueBound;

        let centerX, centerY, centerZ;
        let halfSize;

        let root = this._root;
        if (root === null) {
            halfSize = ceilPow2(functions_max(valueMaxX - valueMinX,
                                    valueMaxY - valueMinY,
                                    valueMaxZ - valueMinZ));
            const recSize = 1 / (2 * halfSize);

            centerX = round((valueMinX + valueMaxX) * recSize) * halfSize;
            centerY = round((valueMinY + valueMaxY) * recSize) * halfSize;
            centerZ = round((valueMinZ + valueMaxZ) * recSize) * halfSize;

            root = new octree_Cell(null);

            this._centerX = centerX;
            this._centerY = centerY;
            this._centerZ = centerZ;
            this._halfSize = halfSize;

            this._minX = centerX - halfSize;
            this._minY = centerY - halfSize;
            this._minZ = centerZ - halfSize;
            this._maxX = centerX + halfSize;
            this._maxY = centerY + halfSize;
            this._maxZ = centerZ + halfSize;

            this._root = root;
        } else {
            ({
                _centerX: centerX,
                _centerY: centerY,
                _centerZ: centerZ,
                _halfSize: halfSize,
            } = this);

            let {
                _minX: minX, _minY: minY, _minZ: minZ,
                _maxX: maxX, _maxY: maxY, _maxZ: maxZ,
            } = this;

            if (valueMinX < minX || valueMinY < minY || valueMinZ < minZ ||
                valueMaxX > maxX || valueMaxY > maxY || valueMaxZ > maxZ)
            {
                const { deepCount } = root;
                const noLift = deepCount > SPLIT_THRESHOLD;
                const complexLift = deepCount === SPLIT_THRESHOLD;

                const valueCenterX = (valueMinX + valueMaxX) * 0.5,
                      valueCenterY = (valueMinY + valueMaxY) * 0.5,
                      valueCenterZ = (valueMinZ + valueMaxZ) * 0.5;
                while (true) {
                    const downX = (valueCenterX - centerX) < 0,
                          downY = (valueCenterY - centerY) < 0,
                          downZ = (valueCenterZ - centerZ) < 0;

                    centerX += downX ? -halfSize : halfSize;
                    centerY += downY ? -halfSize : halfSize;
                    centerZ += downZ ? -halfSize : halfSize;
                    halfSize *= 2;

                    minX = centerX - halfSize;
                    minY = centerY - halfSize;
                    minZ = centerZ - halfSize;
                    maxX = centerX + halfSize;
                    maxY = centerY + halfSize;
                    maxZ = centerZ + halfSize;

                    const contained = valueMinX >= minX &&
                                      valueMinY >= minY &&
                                      valueMinZ >= minZ &&
                                      valueMaxX <= maxX &&
                                      valueMaxY <= maxY &&
                                      valueMaxZ <= maxZ;

                    if (noLift || complexLift && contained) {
                        const newRoot = new octree_Cell(null);

                        newRoot.deepCount = root.deepCount;

                        switch (downZ << 2 | downY << 1 | downX) {
                          case 0b000:
                            newRoot.child000 = root;
                            break;
                          case 0b001:
                            newRoot.child001 = root;
                            break;
                          case 0b010:
                            newRoot.child010 = root;
                            break;
                          case 0b011:
                            newRoot.child011 = root;
                            break;
                          case 0b100:
                            newRoot.child100 = root;
                            break;
                          case 0b101:
                            newRoot.child101 = root;
                            break;
                          case 0b110:
                            newRoot.child110 = root;
                            break;
                          case 0b111:
                            newRoot.child111 = root;
                            break;
                        }

                        root.parent = newRoot;

                        root = newRoot;
                    }

                    if (contained) { break; }
                }

                this._centerX = centerX;
                this._centerY = centerY;
                this._centerZ = centerZ;
                this._halfSize = halfSize;

                this._minX = minX;
                this._minY = minY;
                this._minZ = minZ;
                this._maxX = maxX;
                this._maxY = maxY;
                this._maxZ = maxZ;

                this._root = root;
            }
        }

        root.insert(this._valueLocations,
                    centerX, centerY, centerZ,
                    halfSize * 0.5,
                    valueMinX, valueMinY, valueMinZ,
                    valueMaxX, valueMaxY, valueMaxZ,
                    value);
    }

    /**
     * @function module:@webgears-app/octree.Octree#contains
     * @summary Test whether value is in octree.
     * @param {object} value Value to test.
     * @returns {boolean} Whether value is in octree.
     */
    contains(value) {
        return this._valueLocations.has(value);
    }

    /**
     * @function module:@webgears-app/octree.Octree#boundOf
     * @summary Get bounding box for a value in octree.
     * @desc If the value is not in octree, returns undefined.
     * @param {object} value Value to get bounding box of.
     * @returns {module:@webgears-app/math.Box|undefined} Bounding box of the value.
     */
    boundOf(value) {
        const location = this._valueLocations.get(value);
        if (location === undefined) { return; }

        const { bounds } = location.cell;
        const offset = location.index * 6;

        const valueBound = new rectangle_and_box_Box();
        valueBound.min.fromArrayAt(offset    , bounds);
        valueBound.max.fromArrayAt(offset + 3, bounds);
        return valueBound;
    }

    /**
     * @function module:@webgears-app/octree.Octree#values
     * @summary Get iterator over values in octree.
     * @returns {Iterator} Values in octree.
     */
    values() {
        return this._valueLocations.keys();
    }

    /**
     * @function module:@webgears-app/octree.Octree#bounds
     * @summary Get iterator over value bounds in octree.
     * @returns {Iterator.<module:@webgears-app/math.Box>} Value bounds in octree.
     */
    *bounds() {
        for (const value of this.values()) {
            yield this.boundOf(value);
        }
    }

    /**
     * @function module:@webgears-app/octree.Octree#entries
     * @summary Get iterator over `[value, valueBound]` pairs in octree.
     * @desc Can also be used as `[Symbol.iterator]()`.
     * @returns {Iterator} Values in octree.
     */
    *entries() {
        for (const value of this.values()) {
            yield [value, this.boundOf(value)];
        }
    }

    [Symbol.iterator]() {
        return this.entries();
    }

    /**
     * @function module:@webgears-app/octree.Octree#remove
     * @summary Delete value from octree.
     * @desc Does nothing if the value is not in octree.
     * @param {object} value Value to remove.
     */
    remove(value) {
        const valueLocations = this._valueLocations;
        const location = valueLocations.get(value);
        if (location === undefined) { return; }
        valueLocations.delete(value);

        const removeCell = location.cell;
        const removeIndex = location.index;
        const { values: removeValues, bounds: removeBounds } = removeCell;
        const lastIndex = removeValues.length - 1;
        if (removeIndex !== lastIndex) {
            const lastValue = removeValues[lastIndex];
            removeValues[removeIndex] = lastValue;
            const lastOffset = lastIndex * 6;
            removeBounds.copyWithin(removeIndex * 6, lastOffset, lastOffset + 6);
            valueLocations.get(lastValue).index = removeIndex;
        }
        removeValues.length = lastIndex;

        let mergeCell = null;
        for (let cell = removeCell; cell !== null; cell = cell.parent) {
            if (--cell.deepCount <= MERGE_THRESHOLD) { mergeCell = cell; }
        }
        if (mergeCell === null) {
            tryShrinkBounds(removeCell);
        } else {
            const { values: mergeValues, bounds: mergeBounds } = mergeCell;
            const baseMergeCount = mergeValues.length;

            for (let cell = removeCell, mergeOffset = baseMergeCount * 6; ; ) {
                let child;
                if ((child = cell.child000) !== null) {
                    cell.child000 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child001) !== null) {
                    cell.child001 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child010) !== null) {
                    cell.child010 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child011) !== null) {
                    cell.child011 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child100) !== null) {
                    cell.child100 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child101) !== null) {
                    cell.child101 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child110) !== null) {
                    cell.child110 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if ((child = cell.child111) !== null) {
                    cell.child111 = null;
                    const { values: childValues, bounds: childBounds } = child;
                    const childCount = childValues.length;
                    for (let i = 0, childOffset = 0; i < childCount; ++i) {
                        mergeValues.push(childValues[i]);
                        mergeBounds[mergeOffset    ] = childBounds[childOffset    ];
                        mergeBounds[mergeOffset + 1] = childBounds[childOffset + 1];
                        mergeBounds[mergeOffset + 2] = childBounds[childOffset + 2];
                        mergeBounds[mergeOffset + 3] = childBounds[childOffset + 3];
                        mergeBounds[mergeOffset + 4] = childBounds[childOffset + 4];
                        mergeBounds[mergeOffset + 5] = childBounds[childOffset + 5];
                        mergeOffset += 6;
                        childOffset += 6;
                    }
                }
                if (cell === mergeCell) { break; }
                cell = cell.parent;
            }

            const mergeCount = mergeValues.length;
            for (let i = baseMergeCount; i < mergeCount; ++i) {
                const location = valueLocations.get(mergeValues[i]);
                location.cell = mergeCell;
                location.index = i;
            }
        }

        let {
            _centerX: centerX,
            _centerY: centerY,
            _centerZ: centerZ,
            _halfSize: halfSize,
            _root: root,
        } = this;

        while (root.values.length === 0) {
            let newCenterX = centerX,
                newCenterY = centerY,
                newCenterZ = centerZ;
            const quarterSize = halfSize * 0.5;

            let newRoot = null;

            let child;
            if ((child = root.child000) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX - quarterSize;
                newCenterY = centerY - quarterSize;
                newCenterZ = centerZ - quarterSize;
                newRoot = child;
            }
            if ((child = root.child001) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX + quarterSize;
                newCenterY = centerY - quarterSize;
                newCenterZ = centerZ - quarterSize;
                newRoot = child;
            }
            if ((child = root.child010) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX - quarterSize;
                newCenterY = centerY + quarterSize;
                newCenterZ = centerZ - quarterSize;
                newRoot = child;
            }
            if ((child = root.child011) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX + quarterSize;
                newCenterY = centerY + quarterSize;
                newCenterZ = centerZ - quarterSize;
                newRoot = child;
            }
            if ((child = root.child100) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX - quarterSize;
                newCenterY = centerY - quarterSize;
                newCenterZ = centerZ + quarterSize;
                newRoot = child;
            }
            if ((child = root.child101) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX + quarterSize;
                newCenterY = centerY - quarterSize;
                newCenterZ = centerZ + quarterSize;
                newRoot = child;
            }
            if ((child = root.child110) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX - quarterSize;
                newCenterY = centerY + quarterSize;
                newCenterZ = centerZ + quarterSize;
                newRoot = child;
            }
            if ((child = root.child111) !== null) {
                if (newRoot !== null) { break; }
                newCenterX = centerX + quarterSize;
                newCenterY = centerY + quarterSize;
                newCenterZ = centerZ + quarterSize;
                newRoot = child;
            }

            if ((root = newRoot) === null) { break; }

            centerX = newCenterX;
            centerY = newCenterY;
            centerZ = newCenterZ;
            halfSize = quarterSize;
        }

        this._root = root;
        if (root === null) { return; }
        root.parent = null;

        this._centerX = centerX;
        this._centerY = centerY;
        this._centerZ = centerZ;
        this._halfSize = halfSize;

        this._minX = centerX - halfSize;
        this._minY = centerY - halfSize;
        this._minZ = centerZ - halfSize;
        this._maxX = centerX + halfSize;
        this._maxY = centerY + halfSize;
        this._maxZ = centerZ + halfSize;
    }

    /**
     * @function module:@webgears-app/octree.Octree#clear
     * @summary Delete all entries from octree.
     */
    clear() {
        this._root = null;
        this._valueLocations.clear();
    }

    /**
     * @function module:@webgears-app/octree.Octree#find
     * @summary Find all values bounding boxes of which intersect a given box.
     * @param {module:@webgears-app/math.Box} queryBound Query box.
     * @param {Array} [foundValues=[]] Array into which to put found values.
     * It will be truncated to required length.
     * @returns {Array} `foundValues`.
     */
    find(queryBound, foundValues = []) {
        let foundCount = 0;

        const root = this._root;
        if (root !== null) {
            const {
                _centerX: centerX,
                _centerY: centerY,
                _centerZ: centerZ,
                _halfSize: halfSize,
                _minX: minX, _minY: minY, _minZ: minZ,
                _maxX: maxX, _maxY: maxY, _maxZ: maxZ,
            } = this;

            const {
                min: { x: queryMinX, y: queryMinY, z: queryMinZ },
                max: { x: queryMaxX, y: queryMaxY, z: queryMaxZ },
            } = queryBound;

            const coverX0 = queryMinZ <= minZ,
                  coverY0 = queryMinY <= minY,
                  coverZ0 = queryMinX <= minX;
            const coverX1 = queryMaxZ >= maxZ,
                  coverY1 = queryMaxY >= maxY,
                  coverZ1 = queryMaxX >= maxX;

            if (coverX0 && coverY0 && coverZ0 && 
                coverX1 && coverY1 && coverZ1)
            {
                foundCount = root.gather(foundValues, foundCount);
            } else if (queryMinX <= maxX &&
                       queryMinY <= maxY &&
                       queryMinZ <= maxZ &&
                       queryMaxX >= minX &&
                       queryMaxY >= minY &&
                       queryMaxZ >= minZ)
            {
                foundCount = root.find(centerX, centerY, centerZ,
                                       halfSize * 0.5,
                                       queryMinX, queryMinY, queryMinZ,
                                       queryMaxX, queryMaxY, queryMaxZ,
                                       coverX0, coverY0, coverZ0, 
                                       coverX1, coverY1, coverZ1,
                                       foundValues, foundCount);
            }
        }

        foundValues.length = foundCount;
        return foundValues;
    }

    /**
     * @function module:@webgears-app/octree.Octree#webGLFrustumFind
     * @summary Find all values bounding boxes of which intersect a given frustum.
     * @param {module:@webgears-app/math.HomogeneousMatrix3|module:@webgears-app/math.AffineMatrix3} queryViewProjection
     * Query frustum specified via a WebGL view-projection matrix. Both perspective and orthographic projections are
     * supported.
     * @param {Array} [foundValues=[]] Array into which to put found values.
     * It will be truncated to required length.
     * @returns {Array} `foundValues`.
     */
    webGLFrustumFind(queryViewProjection, foundValues = []) {
        let foundCount = 0;

        const root = this._root;
        if (root !== null) {
            const {
                _centerX: centerX,
                _centerY: centerY,
                _centerZ: centerZ,
                _halfSize: halfSize,
                _minX: minX, _minY: minY, _minZ: minZ,
                _maxX: maxX, _maxY: maxY, _maxZ: maxZ,
            } = this;

            const {
                _00, _10, _20, _30 = 0,
                _01, _11, _21, _31 = 0,
                _02, _12, _22, _32 = 0,
                _03, _13, _23, _33 = 1,
            } = queryViewProjection;

            const fp = frustumProperties;

            // https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf
            const lX = fp.lX = _03 + _00, lY = fp.lY = _13 + _10, lZ = fp.lZ = _23 + _20, lW = fp.lW = _33 + _30,
                  rX = fp.rX = _03 - _00, rY = fp.rY = _13 - _10, rZ = fp.rZ = _23 - _20, rW = fp.rW = _33 - _30,
                  bX = fp.bX = _03 + _01, bY = fp.bY = _13 + _11, bZ = fp.bZ = _23 + _21, bW = fp.bW = _33 + _31,
                  tX = fp.tX = _03 - _01, tY = fp.tY = _13 - _11, tZ = fp.tZ = _23 - _21, tW = fp.tW = _33 - _31,
                  nX = fp.nX = _03 + _02, nY = fp.nY = _13 + _12, nZ = fp.nZ = _23 + _22, nW = fp.nW = _33 + _32,
                  fX = fp.fX = _03 - _02, fY = fp.fY = _13 - _12, fZ = fp.fZ = _23 - _22, fW = fp.fW = _33 - _32;

            // We are doing a specialized Separating Axis Theorem test (http://www.dyn4j.org/2010/01/sat/) here.

            const lCover = 0 < lX * ((lX < 0) ? maxX : minX) +
                               lY * ((lY < 0) ? maxY : minY) +
                               lZ * ((lZ < 0) ? maxZ : minZ) +
                               lW;
            const rCover = 0 < rX * ((rX < 0) ? maxX : minX) +
                               rY * ((rY < 0) ? maxY : minY) +
                               rZ * ((rZ < 0) ? maxZ : minZ) +
                               rW;
            const bCover = 0 < bX * ((bX < 0) ? maxX : minX) +
                               bY * ((bY < 0) ? maxY : minY) +
                               bZ * ((bZ < 0) ? maxZ : minZ) +
                               bW;
            const tCover = 0 < tX * ((tX < 0) ? maxX : minX) +
                               tY * ((tY < 0) ? maxY : minY) +
                               tZ * ((tZ < 0) ? maxZ : minZ) +
                               tW;
            const nCover = 0 < nX * ((nX < 0) ? maxX : minX) +
                               nY * ((nY < 0) ? maxY : minY) +
                               nZ * ((nZ < 0) ? maxZ : minZ) +
                               nW;
            const fCover = 0 < fX * ((fX < 0) ? maxX : minX) +
                               fY * ((fY < 0) ? maxY : minY) +
                               fZ * ((fZ < 0) ? maxZ : minZ) +
                               fW;

            if (lCover && rCover && bCover && tCover && nCover && fCover) {
                foundCount = root.gather(foundValues, foundCount);
            } else do {
                if (!lCover && 0 > lX * ((lX < 0) ? minX : maxX) +
                                   lY * ((lY < 0) ? minY : maxY) +
                                   lZ * ((lZ < 0) ? minZ : maxZ) +
                                   lW)
                { break; }
                if (!rCover && 0 > rX * ((rX < 0) ? minX : maxX) +
                                   rY * ((rY < 0) ? minY : maxY) +
                                   rZ * ((rZ < 0) ? minZ : maxZ) +
                                   rW)
                { break; }
                if (!bCover && 0 > bX * ((bX < 0) ? minX : maxX) +
                                   bY * ((bY < 0) ? minY : maxY) +
                                   bZ * ((bZ < 0) ? minZ : maxZ) +
                                   bW)
                { break; }
                if (!tCover && 0 > tX * ((tX < 0) ? minX : maxX) +
                                   tY * ((tY < 0) ? minY : maxY) +
                                   tZ * ((tZ < 0) ? minZ : maxZ) +
                                   tW)
                { break; }
                if (!nCover && 0 > nX * ((nX < 0) ? minX : maxX) +
                                   nY * ((nY < 0) ? minY : maxY) +
                                   nZ * ((nZ < 0) ? minZ : maxZ) +
                                   nW)
                { break; }
                if (!fCover && 0 > fX * ((fX < 0) ? minX : maxX) +
                                   fY * ((fY < 0) ? minY : maxY) +
                                   fZ * ((fZ < 0) ? minZ : maxZ) +
                                   fW)
                { break; }

                const {
                    _00: i00, _01: i01, _02: i02, _03: i03, 
                    _10: i10, _11: i11, _12: i12, _13: i13, 
                    _20: i20, _21: i21, _22: i22, _23: i23, 
                    _30: i30, _31: i31, _32: i32, _33: i33, 
                } = invProjectionTmp.set(_00, _01, _02, _03,
                                         _10, _11, _12, _13,
                                         _20, _21, _22, _23,
                                         _30, _31, _32, _33)
                                    .invert();

                const c0rW = 1 / (i33 - i03 - i13 - i23),
                      c1rW = 1 / (i33 + i03 - i13 - i23),
                      c2rW = 1 / (i33 - i03 + i13 - i23),
                      c3rW = 1 / (i33 + i03 + i13 - i23),
                      c4rW = 1 / (i33 - i03 - i13 + i23),
                      c5rW = 1 / (i33 + i03 - i13 + i23),
                      c6rW = 1 / (i33 - i03 + i13 + i23),
                      c7rW = 1 / (i33 + i03 + i13 + i23);

                const c0X = (i30 - i00 - i10 - i20) * c0rW,
                      c1X = (i30 + i00 - i10 - i20) * c1rW,
                      c2X = (i30 - i00 + i10 - i20) * c2rW,
                      c3X = (i30 + i00 + i10 - i20) * c3rW,
                      c4X = (i30 - i00 - i10 + i20) * c4rW,
                      c5X = (i30 + i00 - i10 + i20) * c5rW,
                      c6X = (i30 - i00 + i10 + i20) * c6rW,
                      c7X = (i30 + i00 + i10 + i20) * c7rW;
                if ((fp.minX = functions_min(c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X)) > maxX) { break; }
                if ((fp.maxX = functions_max(c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X)) < minX) { break; }

                const c0Y = (i31 - i01 - i11 - i21) * c0rW,
                      c1Y = (i31 + i01 - i11 - i21) * c1rW,
                      c2Y = (i31 - i01 + i11 - i21) * c2rW,
                      c3Y = (i31 + i01 + i11 - i21) * c3rW,
                      c4Y = (i31 - i01 - i11 + i21) * c4rW,
                      c5Y = (i31 + i01 - i11 + i21) * c5rW,
                      c6Y = (i31 - i01 + i11 + i21) * c6rW,
                      c7Y = (i31 + i01 + i11 + i21) * c7rW;
                if ((fp.minY = functions_min(c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y)) > maxY) { break; }
                if ((fp.maxY = functions_max(c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y)) < minY) { break; }

                const c0Z = (i32 - i02 - i12 - i22) * c0rW,
                      c1Z = (i32 + i02 - i12 - i22) * c1rW,
                      c2Z = (i32 - i02 + i12 - i22) * c2rW,
                      c3Z = (i32 + i02 + i12 - i22) * c3rW,
                      c4Z = (i32 - i02 - i12 + i22) * c4rW,
                      c5Z = (i32 + i02 - i12 + i22) * c5rW,
                      c6Z = (i32 - i02 + i12 + i22) * c6rW,
                      c7Z = (i32 + i02 + i12 + i22) * c7rW;
                if ((fp.minZ = functions_min(c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) > maxZ) { break; }
                if ((fp.maxZ = functions_max(c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z)) < minZ) { break; }

                crossEdgeSeparators.count = 0;
                if (generateCrossEdgeSeparators(c1X - c0X, c1Y - c0Y, c1Z - c0Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c3X - c2X, c3Y - c2Y, c3Z - c2Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c5X - c4X, c5Y - c4Y, c5Z - c4Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c7X - c6X, c7Y - c6Y, c7Z - c6Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c2X - c0X, c2Y - c0Y, c2Z - c0Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c3X - c1X, c3Y - c1Y, c3Z - c1Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c6X - c4X, c6Y - c4Y, c6Z - c4Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c7X - c5X, c7Y - c5Y, c7Z - c5Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c4X - c0X, c4Y - c0Y, c4Z - c0Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c5X - c1X, c5Y - c1Y, c5Z - c1Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c6X - c2X, c6Y - c2Y, c6Z - c2Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }
                if (generateCrossEdgeSeparators(c7X - c3X, c7Y - c3Y, c7Z - c3Z,
                                                minX, minY, minZ, maxX, maxY, maxZ,
                                                c0X, c1X, c2X, c3X, c4X, c5X, c6X, c7X,
                                                c0Y, c1Y, c2Y, c3Y, c4Y, c5Y, c6Y, c7Y,
                                                c0Z, c1Z, c2Z, c3Z, c4Z, c5Z, c6Z, c7Z))
                { break; }

                foundCount = root.frustumFind(centerX, centerY, centerZ,
                                              halfSize * 0.5,
                                              minX, minY, minZ,
                                              maxX, maxY, maxZ,
                                              lCover, rCover,
                                              bCover, tCover,
                                              nCover, fCover,
                                              foundValues, foundCount);
            } while (false);
        }

        foundValues.length = foundCount;
        return foundValues;
    }

    /**
     * @function module:@webgears-app/octree.Octree#rayFind
     * @summary Find all values bounding boxes of which intersect a given ray.
     * @param {module:@webgears-app/math.Ray3} ray Query ray.
     * @param {Array} [foundValues=[]] Array into which to put found values.
     * It will be truncated to required length.
     * @returns {Array} `foundValues`.
     */
    rayFind(ray, foundValues = []) {
        let foundCount = 0;

        const root = this._root;
        if (root !== null) {
            const {
                _minX: minX, _minY: minY, _minZ: minZ,
                _maxX: maxX, _maxY: maxY, _maxZ: maxZ,
            } = this;

            const {
                origin: { x: originX, y: originY, z: originZ },
                direction,
            } = ray;

            const recDirectionX = 1 / direction.x,
                  recDirectionY = 1 / direction.y,
                  recDirectionZ = 1 / direction.z;

            let tMinX = (minX - originX) * recDirectionX,
                tMinY = (minY - originY) * recDirectionY,
                tMinZ = (minZ - originZ) * recDirectionZ;
            if (!isFinite(tMinX)) { tMinX = -Infinity; } 
            if (!isFinite(tMinY)) { tMinY = -Infinity; } 
            if (!isFinite(tMinZ)) { tMinZ = -Infinity; } 

            let tMaxX = (maxX - originX) * recDirectionX,
                tMaxY = (maxY - originY) * recDirectionY,
                tMaxZ = (maxZ - originZ) * recDirectionZ;
            if (!isFinite(tMaxX)) { tMaxX = +Infinity; }
            if (!isFinite(tMaxY)) { tMaxY = +Infinity; }
            if (!isFinite(tMaxZ)) { tMaxZ = +Infinity; }

            foundCount = root.rayFind(originX, originY, originZ,
                                      recDirectionX, recDirectionY, recDirectionZ,
                                      tMinX, tMinY, tMinZ,
                                      tMaxX, tMaxY, tMaxZ,
                                      foundValues, foundCount);
        }

        foundValues.length = foundCount;
        return foundValues;
    }
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/spatialIndex.js
/**
 * @class module:@webgears-app/engine-core.SpatialIndex
 * @summary Base class for spatial indices for looking up things in space.
 */
class SpatialIndex {
    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#insert
     * @summary Insert value associated with a bounding box into the index.
     * @desc If value is already in the index, reassociates it with the new
     * bounding box.
     * @param {object} value Value to insert.
     * @param {module:@webgears-app/math.Box} boundingBox
     * Bounding box associated with the value.
     * @abstract
     */
    insert(value, boundingBox) {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#remove
     * @summary Remove value form the index.
     * @desc Has no effect if value is no in the index.
     * @param {object} value Value to remove.
     * @abstract
     */
    remove(value) {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#boxFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given box.
     * @param {module:@webgears-app/math.Box} box Query box.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     * @abstract
     */
    boxFind(box, foundValues) {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#webGLFrustumFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given camera frustum.
     * @param {module:@webgears-app/math.AffineMatrix3|
     *         module:@webgears-app/math.HomogeneousMatrix3} viewProjectionMatrix
     * Matrix specyfying the frustum.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     * @abstract
     */
    webGLFrustumFind(viewProjectionMatrix, foundValues) {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#boxFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given ray.
     * @param {module:@webgears-app/math.Ray3} ray Query Ray.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     * @abstract
     */
    rayFind(ray, foundValues) {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#_clear
     * @summary Clears the index.
     * @desc Is only intended to be called by the engine.
     * @abstract
     */
    _clear() {
        throw new Error('not implemented');
    }

    /**
     * @function module:@webgears-app/engine-core.SpatialIndex#_copyInto
     * @summary Insert all entries in this spatial index into the other one.
     * @desc Is only intended to be called by the engine.
     * @param {module:@webgears-app/engine-core.SpatialIndex} other
     * Spatial index to insert into.
     * @abstract
     */
    _copyInto(other) {
        throw new Error('not implemented');
    }
};

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/octreeSpatialIndex.js



/**
 * @class module:@webgears-app/engine-core.OctreeSpatialIndex
 * @summary {@link module:@webgears-app/octree.Octree}-based spatial index.
 * @extends {module:@webgears-app/engine-core.SpatialIndex}
 */
class octreeSpatialIndex_OctreeSpatialIndex extends SpatialIndex {
    constructor() {
        super();
        this._octree = new octree_Octree();
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#insert
     * @summary Insert value associated with a bounding box into the index.
     * @desc If value is already in the index, reassociates it with the new
     * bounding box.
     * @param {object} value Value to insert.
     * @param {module:@webgears-app/math.Box} boundingBox
     * Bounding box associated with the value.
     */
    insert(value, boundingBox) {
        this._octree.insert(value, boundingBox);
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#boxFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given box.
     * @param {module:@webgears-app/math.Box} box Query box.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     */
    remove(value) {
        this._octree.remove(value);
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#webGLFrustumFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given camera frustum.
     * @param {module:@webgears-app/math.AffineMatrix3|
     *         module:@webgears-app/math.HomogeneousMatrix3} viewProjectionMatrix
     * Matrix specyfying the frustum.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     */
    boxFind(box, foundValues) {
        return this._octree.find(box, foundValues);
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#webGLFrustumFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given camera frustum.
     * @param {module:@webgears-app/math.AffineMatrix3|
     *         module:@webgears-app/math.HomogeneousMatrix3} viewProjectionMatrix
     * Matrix specyfying the frustum.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     */
    webGLFrustumFind(viewProjectionMatrix, foundValues) {
        return this._octree.webGLFrustumFind(viewProjectionMatrix, foundValues);
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#boxFind
     * @summary Find all values in the index whose associated bounding boxes
     * intersect the given ray.
     * @param {module:@webgears-app/math.Ray3} ray Query Ray.
     * @param {Array} [foundValues=[]] Array that found values will go into.
     * @returns {Array} `foundValues`.
     */
    rayFind(ray, foundValues) {
        return this._octree.rayFind(ray, foundValues);
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#_clear
     * @summary Clears the index.
     * @desc Is only intended to be called by the engine.
     */
    _clear() {
        this._octree.clear();
    }

    /**
     * @function module:@webgears-app/engine-core.OctreeSpatialIndex#_copyInto
     * @summary Insert all entries in this spatial index into the other one.
     * @desc Is only intended to be called by the engine.
     * @param {module:@webgears-app/engine-core.SpatialIndex} other
     * Spatial index to insert into.
     * @abstract
     */
    _copyInto(other) {
        for (const [value, boundingBox] of this._octree) {
            other.insert(value, boundingBox);
        }
    }
};

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/scene.js


















const _TaskType = makeEnum([
   ['MERGE_COPY', 0],
   ['SPLIT_COPY', 1]
]);

class _SceneManagementTask {
    static get TaskType() {
        return _TaskType;
    }

    constructor(type, resolve) {
        this.type = type;
        this.resolve = resolve;
        this.data = {};
        this.output = {};
    }
}

/**
 * @class module:@webgears-app/engine-core.Scene
 * @extends module:@webgears-app/engine-core.BaseScene
 * @summary The scene class.
 * @param {object} parameters Parameters.
 * @param {number} [parameters.maxSceneNode=undefined] Max number of nodes in the scene.
 * @param {number} [parameters.batchMap=null] Initial batch map.
 * @param {string} parameters.name The name of the scene.
 * @param {object} parameters.config The scene's configuration.
 * @param {Array} [parameters.config.customAttributes=[]] Instanced attributes layout.
 * It's described [here]{@link module:@webgears-app/engine-core.InstanceDataManager}
 * @param {Array} [parameters.config.componentClasses=[]]
 * Component classes to registry them as allowed components of the scene.
 */
class scene_Scene extends baseScene_BaseScene {
    static get _SceneManagementDeferredTask() {
        return _SceneManagementTask;
    }

    constructor({ maxSceneNodes, batchMap = null, name = '', config = {} } = {}) {
        const { componentClasses = [] } = config;

        super({ maxSceneNodes, batchMap, name, config });

        this.name = name;

        const entityManager = new EntityManager(this, { initialCountEntities: maxSceneNodes, componentClasses });
        this._entityManager = entityManager;

        this._animations = new Map();
        this._skeletons = new Map();

        const entity = entityManager.createEntity();

        this.root = new sceneNode_SceneNode(this, entity, name);

        this._entityToNode = new Map([[entity, this.root]]);
        this._instanceKeys = new Map();

        this.shadowBiasMin = 0.0001;
        this.shadowBiasMax = 0.001;

        /**
         * @var module:@webgears-app/engine-core.Scene#extras
         * @type {any}
         * @summary Unstructred application-specific imported/exported data.
         * @desc Must be {@link JSON.stringify}-able.
         */
        this.extras = undefined;

        this._deferredTasks = [];

        this._perCameraData = new Map();
        this._directShadowCastersCountChanged = true;
        this._enabledDirectShadowCastersCount = 0;
        this._directShadowCastersMask = [];
        this._shadowTextureArray = null;
        this._shadowMapSize = 0;
        this._cascadesCount = 0;

        this._spotShadowCasters = [];
        this._spotShadowCastersMask = [];
        this._enabledSpotShadowCastersCount = 0;
        this._spotCastersDepthTextureArray = null;

        this._omniShadowCasters = [];
        this._omniShadowCastersMask = [];
        this._enabledOmniShadowCastersCount = 0;

        this._spatialIndex = new octreeSpatialIndex_OctreeSpatialIndex();
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#spatialIndex
     * @type {module:@webgears-app/engine-core.SpatialIndex}
     */
    get spatialIndex() {
        return this._spatialIndex;
    }

    set spatialIndex(newSpatialIndex) {
        if (newSpatialIndex === this._spatialIndex) { return; }
        newSpatialIndex._clear();
        this._spatialIndex._copyInto(newSpatialIndex);
        this._spatialIndex = newSpatialIndex;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getDirectShadowCastersData
     * @param {module:@webgears-app/engine-core.Camera} camera The render pass camera.
     * @summary Returns directional shadow casters count related to the camera.
     */
    getDirectShadowCastersCount(camera) {
        const { _perCameraData } = this;

        if (_perCameraData.has(camera)) {
            const { directShadowCasters } = _perCameraData.get(camera);

            return directShadowCasters.length;
        }

        return 0;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getDirectShadowCastersData
     * @param {module:@webgears-app/engine-core.Camera} camera The render pass camera.
     * @summary Returns directional shadow casters' data related to the camera.
     */
    getDirectShadowCastersData(camera) {
        const { _perCameraData } = this;

        if (_perCameraData.has(camera)) {
            return _perCameraData.get(camera);
        }

        return { };
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#directShadowCastersMask
     * @type {array}
     * @summary The array of corresponding masks between directional lights and shadow casters.
     * @readonly
     */
    get directShadowCastersMask() {
        return this._directShadowCastersMask;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#spotShadowCastersCount
     * @type {number}
     * @summary Spot light shadow casters count.
     * @readonly
     */
    get spotShadowCastersCount() {
        return this._spotShadowCasters.length;
    }

    getSpotShadowCasters() {
        return this._spotShadowCasters;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#spotShadowCasters
     * @type {array}
     * @summary The array of light shadow shadow casters' data.
     * @readonly
     */
    get spotShadowCasters() {
        console.warn('Scene#spotShadowCasters property is deprecated, use method getSpotShadowCasters instead.');
        return this.getSpotShadowCasters();
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#spotShadowCastersMask
     * @type {array}
     * @summary The array of corresponding masks between spot lights and shadow casters.
     * @readonly
     */
    get spotShadowCastersMask() {
        return this._spotShadowCastersMask;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#omniShadowCastersCount
     * @type {number}
     * @summary Omnidirectional shadow casters count.
     * @readonly
     */
    get omniShadowCastersCount() {
        return this._omniShadowCasters.length;
    }

    getOmniShadowCasters() {
        return this._omniShadowCasters;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#omniShadowCasters
     * @type {array}
     * @summary The array of omnidirectional shadow casters' data.
     * @readonly
     */
    get omniShadowCasters() {
        console.warn('Scene#omniShadowCasters property is deprecated, use method getOmniShadowCasters instead.');
        return this.getOmniShadowCasters();
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#omniShadowCastersMask
     * @type {array}
     * @summary The array of corresponding masks between omnidirectional lights and shadow casters.
     * @readonly
     */
    get omniShadowCastersMask() {
        return this._omniShadowCastersMask;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#shadowTextureArray
     * @type {module:@webgears-app/engine-core.Texture}
     * @summary The shadow map array for CSM technique.
     * @readonly
     */
    get shadowTextureArray() {
        return this._shadowTextureArray;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#spotCastersDepthTextureArray
     * @type {module:@webgears-app/engine-core.Texture}
     * @summary The shadow map array for spot shadow casters.
     * @readonly
     */
    get spotCastersDepthTextureArray() {
        return this._spotCastersDepthTextureArray;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#forceUpdateRenderQueue
     * @summary Specifies whether frustum cull method must update render queue even if scene had no changes.
     * @type {boolean}
     */
    get forceUpdateRenderQueue() {
        return this._forceUpdateRenderQueue;
    }

    set forceUpdateRenderQueue(value) {
        return this._forceUpdateRenderQueue = value;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#addSkeleton
     * @param {module:@webgears-app/engine-core.Skeleton} skeleton A skeleton.
     * @returns {number}
     * @summary Adds skeleton into scene and returns skeleton's index.
     */
    addSkeleton(skeleton) {
        const { _skeletons } = this;

        let lastIndex = -1;

        for (const [i, s] of _skeletons.entries()) {
            lastIndex = Math.max(i, lastIndex);

            if (s === skeleton) return i;
        }

        _skeletons.set(++lastIndex, skeleton);

        skeleton.onDispose.subscribe(() => {
           this._skeletons.delete(lastIndex);
        });

        return lastIndex;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#addAnimation
     * @param {module:@webgears-app/engine-core.Animation} animation An animation.
     * @returns {number}
     * @summary Adds animation into scene and returns animation's index.
     */
    addAnimation(animation) {
        const { _animations } = this;

        let lastIndex = -1;

        for (const [i, a] of _animations.entries()) {
            lastIndex = Math.max(i, lastIndex);

            if (a === animation) return i;
        }

        _animations.set(++lastIndex, animation);

        animation.onDispose.subscribe(() => {
            this._animations.delete(lastIndex);
        });

        return lastIndex;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getAnimationIndex
     * @param {module:@webgears-app/engine-core.Animation} animation An animation.
     * @returns {number}
     * @summary Returns an index to the animation.
     */
    getAnimationIndex(animation) {
        let index = -1;

        for (const [i, a] of this._animations.entries()) {
            if (a === animation) {
                index = i;
                break;
            }
        }

        return index;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getSkeletonIndex
     * @param {module:@webgears-app/engine-core.Skeleton} skeleton An animation.
     * @returns {number}
     * @summary Returns an index to the skeleton.
     */
    getSkeletonIndex(skeleton) {
        let index = -1;

        for (const [i, s] of this._skeletons.entries()) {
            if (s === skeleton) {
                index = i;
                break;
            }
        }

        return index;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#animations
     * @returns {Iterator}
     * @summary Returns iterator to iterate over animations.
     */
    animations() {
        return this._animations.values();
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#skeletons
     * @returns {Iterator}
     * @summary Returns iterator to iterate over skeletons.
     */
    skeletons() {
        return this._skeletons.values();
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#animationEntries
     * @returns {Iterator}
     * @summary Returns iterator to iterate over index, animation pairs.
     */
    animationEntries() {
        return this._animations.entries();
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#skeletonEntries
     * @returns {Iterator}
     * @summary Returns iterator to iterate over index, skeleton pairs.
     */
    skeletonEntries() {
        return this._skeletons.entries();
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getAnimation
     * @param {number} animationIndex The index of the animation.
     * @returns {module:@webgears-app/engine-core.Animation}
     * @summary Returns animation by index.
     */
    getAnimation(animationIndex) {
        console.assert(this._animations.has(animationIndex),
            `animation with index ${animationIndex} does not exist`);

        return this._animations.get(animationIndex);
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getAnimationByName
     * @param {string} name Animation's name.
     * @returns {?module:@webgears-app/engine-core.Animation}
     * @summary Returns animation by name.
     */
    getAnimationByName(name) {
        for (const animation of this._animations.values()) {
            if (name === animation.name) return animation;
        }
        return null;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getSkeleton
     * @param {number} skeletonIndex The index of the skeleton.
     * @returns {?module:@webgears-app/engine-core.Skeleton}
     * @summary Returns skeleton by index.
     */
    getSkeleton(skeletonIndex) {
        console.assert(this._skeletons.has(skeletonIndex),
            `skeleton with index ${skeletonIndex} does not exist`);

        return this._skeletons.get(skeletonIndex);
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#getSkeletonByName
     * @param {string} name Skeleton's name.
     * @returns {?module:@webgears-app/engine-core.Skeleton}
     * @summary Returns skeleton by index.
     */
    getSkeletonByName(name) {
        for (const skeleton of this._skeletons.values()) {
            if (name === skeleton.name) return skeleton;
        }
        return null;
    }

    _updateDepthTextureArray(cascadesCount, shadowMapSize) {
        const { _enabledDirectShadowCastersCount } = this;

        if (_enabledDirectShadowCastersCount === 0) { return; }

        if (this._shadowTextureArray !== null) {
            this._shadowTextureArray.release();
            this._shadowTextureArray = null;
        }

        this._shadowTextureArray = new texture_Texture({
            name: 'shadow-map-array',

            width: shadowMapSize,
            height: shadowMapSize,
            depth: _enabledDirectShadowCastersCount * cascadesCount,

            bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D_ARRAY,

            magFilter: texture_Texture.Filter.LINEAR,
            minFilter: texture_Texture.Filter.LINEAR,

            wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

            compareFunc: texture_Texture.CompareFunc.LESS,
            compareMode: texture_Texture.CompareMode.COMPARE_REF_TO_TEXTURE,

            format: PixelDataFormat.DEPTH_COMPONENT,
            internalFormat: InternalFormat.DEPTH_COMPONENT32F,
            componentType: DataType.FLOAT,

            levels: 1
        });
    }

    _updateSpotCastersDepthTextureArray(shadowMapSize) {
        const { _enabledSpotShadowCastersCount } = this;

        if (_enabledSpotShadowCastersCount === 0) { return; }

        if (this._spotCastersDepthTextureArray !== null) {
            this._spotCastersDepthTextureArray.release();
            this._spotCastersDepthTextureArray = null;
        }

        this._spotCastersDepthTextureArray = new texture_Texture({
            name: 'spot-shadow-map-array',

            width: shadowMapSize,
            height: shadowMapSize,
            depth: _enabledSpotShadowCastersCount,

            bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D_ARRAY,

            magFilter: texture_Texture.Filter.LINEAR,
            minFilter: texture_Texture.Filter.LINEAR,

            wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

            compareFunc: texture_Texture.CompareFunc.LESS,
            compareMode: texture_Texture.CompareMode.COMPARE_REF_TO_TEXTURE,

            format: PixelDataFormat.DEPTH_COMPONENT,
            internalFormat: InternalFormat.DEPTH_COMPONENT32F,
            componentType: DataType.FLOAT,

            levels: 1
        });
    }

    _disposePerCameraData() {
        const { _perCameraData } = this;

        for (const [ , perCameraData ] of _perCameraData) {
            for (const { _cascades } of perCameraData.directShadowCasters) {
                for (const cascade of _cascades) {
                    if (cascade.renderTarget) {
                        cascade.renderTarget.release();
                        cascade.renderTarget = null;
                    }

                    if (cascade.texture) {
                        cascade.texture.release();
                        cascade.texture = null;
                    }

                    if (cascade.depthTexture) {
                        cascade.depthTexture.release();
                        cascade.depthTexture = null;
                    }
                }
            }
        }
    }

    _disposeShadowTextureArray() {
        if (this._shadowTextureArray !== null) {
            this._shadowTextureArray.release();
            this._shadowTextureArray = null;
        }
    }

    _disposeSpotCastersDepthTextureArray() {
        if (this._spotCastersDepthTextureArray !== null) {
            this._spotCastersDepthTextureArray.release();
            this._spotCastersDepthTextureArray = null;
        }
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#name
     * @type {string}
     * @summary The name of the scene.
     */

    /**
     * @var module:@webgears-app/engine-core.Scene#root
     * @type {module:@webgears-app/engine-core.SceneNode}
     * @summary The root node of the scene.
     */

    traverse(callback) {
        this.root.traverse(callback);
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#shadowBiasMin
     * @type {number}
     * @summary The lowest value of bias for shadow mapping techiques.
     */

    /**
     * @var module:@webgears-app/engine-core.Scene#shadowBiasMax
     * @type {number}
     * @summary The highest value of bias for shadow mapping techiques.
     */

    /**
     * @var module:@webgears-app/engine-core.Scene#animationCount
     * @type {number}
     * @readonly
     * @summary Animations' count belongs to the scene.
     */
    get animationCount() {
        return this._animations.size;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#animationCount
     * @type {number}
     * @readonly
     * @summary Skeletons' count belongs to the scene.
     */
    get skeletonCount() {
        return this._skeletons.size;
    }

    /**
     * @var module:@webgears-app/engine-core.Scene#entityManager
     * @type {module:@webgears-app/engine-core.EntityManager}
     * @readonly
     * @summary Entities' manager of the scene.
     */
    get entityManager() {
        return this._entityManager;
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#dotSceneCast
     * @returns {module:@webgears-app/engine-core.DotScene}
     * @summary Scene to DotScene cast method.
     */
    dotSceneCast() {
        const { instanceDataManager: srcInstanceDataManager, name, config: srcConfig } = this;
        const { capacity: maxSceneNodes, _instancedBatches: batches } = srcInstanceDataManager;

        const config = { customAttributes: srcConfig.customAttributes };

        const dotScene = new dotScene_DotScene({
            maxSceneNodes,
            batchMap: srcInstanceDataManager.generateBatchMap(),
            name
        });

        const components = [];
        const classes = [mesh_Mesh, transform_Transform, light_Light];

        const matrix = new AffineMatrix3();

        this.traverse((node) => {
            const [mesh, transform, light] = node.getComponents(classes, components);

            if (mesh !== null) {
                for (let i = 0, count = mesh.subMeshCount; i < count; i++) {
                    const subMesh = mesh.getSubMesh(0);

                    if (transform !== null) {
                        console.assert(transform.state === transform_Transform.StateMask.UPDATE_NOTHING,
                            'transform is not in actual state, update transform system before cast');

                        dotScene.addInstance(subMesh, transform.worldMatrix);
                    } else {
                        const { instanceId, instanceIndex } = subMesh;
                        const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);
                        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

                        srcInstanceDataManager.readWorldTransform(matrix, globalIndex);

                        dotScene.addInstance(subMesh, matrix);
                    }
                }
            }

            if (light !== null) {
                console.assert(transform !== null && transform.state === transform_Transform.StateMask.UPDATE_NOTHING,
                    'light must have transform in actual state');

                dotScene.addLight(light, transform.worldMatrix);
            }
        });

        return scene;
    }

    unload() {
        this.traverse((node) => {
            const components = node.getComponents([mesh_Mesh, bone_Bone]);
            for (const component of components) {
                if (components === null) { continue; }
                component.unload();
            }
            return true;
        });

        if (this._shadowTextureArray !== null) {
            this._shadowTextureArray.unload();
        }
        if (this._spotCastersDepthTextureArray !== null) {
            this._spotCastersDepthTextureArray.unload();
        }

        super.unload();
    }

    /**
     * @function module:@webgears-app/engine-core.Scene#dispose
     * @summary Disposes the scene.
     */
    _dispose() {
        this.spatialIndex._clear();

        this.root.destroy();
        this.entityManager.dispose();
        this._disposeShadowTextureArray();
        this._disposeSpotCastersDepthTextureArray();
        this._disposePerCameraData();

        super._dispose();
    }
}

Object.defineProperty(scene_Scene.prototype, 'isScene', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/dotScene.js






 // eslint-disable-line






/**
 * @class module:@webgears-app/engine-core.DotScene
 * @extends module:@webgears-app/engine-core.BaseScene
 * @param parameters Parameters.
 * @param {number} [parameters.maxSceneNode=undefined] Max number of nodes in the scene.
 * @param {number} [parameters.batchMap=null] Initial batch map.
 * @param {string} parameters.name The name of the scene.
 * @param {object} parameters.config The scene's configuration.
 * @param {Array} [parameters.config.customAttributes=[]] Instanced attributes layout.
 * It's described [here]{@link module:@webgears-app/engine-core.InstanceDataManager}
 * @summary Flat scene targeted to low-level work with instanced data.
 * @desc This type of scene does not support any scene management operations like split, merge, adopt and etc.
 * does not store scene hierarchy and does not support any animations as well.
 * This type of scene does not manage components and does not own components, and as result any addInstance call
 * just copy all necessary instanced data and does not retain instance themself.
 */
class dotScene_DotScene extends baseScene_BaseScene {
    constructor({ maxSceneNodes, batchMap = null, name = '', config = {} } = {}) {
        super({ maxSceneNodes, batchMap, name, config });
        this._lights = new Map();
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#addInstance
     * @param {module:@webgears-app/engine-core.Renderable} instance Any object that is derived from Renderable class.
     * @param {module:@webgears-app/math.AffineMatrix3} [worldMatrix=new AffineMatrix3().fromNumber(1.)] Instance world matrix.
     * @summary Copy all necessary instanced data from renderable into instanceDataManager.
     * @example
     * import { createBoxMesh } from '@webgears-app/procedural-geometry';
     * import { DotScene } from '@webgears-app/engine-core';
     *
     * const boxMesh = createBoxMesh({ vertexStaging, elementStaging, material });
     *
     * const scene = new DotScene({});
     *
     * scene.addInstance(boxMesh.getSubMesh(0));
     */
    addInstance(instance, worldMatrix = new AffineMatrix3().fromNumber(1.)) {
        if (instance.instanceId !== null && !instance._instanceIdentifierExpired) return; // nothing to do here

        const { instanceDataManager } = this;

        console.assert(instance.geometry !== null);
        console.assert(instance.material !== null);
        console.assert(!instance.unloaded);

        if (instance.geometry.needsUpdateBoundingBox) {
            instance.geometry.updateBoundingBox();
        }

        instanceDataManager.addInstance(instance);
        instanceDataManager.setInstanceVisibility(instance, true, true);

        // dot scene has no cases when depth is required, at least for now
        // this._updateDepthMaterial(instanceDataManager, instance);

        const { instanceId, instanceIndex, id } = instance;
        const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

        instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
        instanceDataManager.storeRenderableIdentifier(globalIndex, id);

        this.forceUpdateRenderQueue = true;
    }


    /**
     * @function module:@webgears-app/engine-core.DotScene#deleteInstance
     * @param {module:@webgears-app/engine-core.Renderable} instance Any instance that is added into scene earlier.
     * @summary The method just mark a piece of instanced batch memory as free to make it possible to be occupied
     * with some other instance later. To free vertices memory from stagings call instance.release() manually or
     * instance.unload() to unload only vertices themself and save vertices layout.
     */
    deleteInstance(instance) {
        if (instance.instanceId === null) return;

        const { instanceDataManager } = this;

        instanceDataManager.deleteInstance(instance);

        this.forceUpdateRenderQueue = true;
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#setWorldMatrix
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance to set world matrix for.
     * @param {module:@webgears-app/math.AffineMatrix3} worldMatrix world matrix.
     * @summary Sets world matrix.
     */
    setWorldMatrix(instance, worldMatrix) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);

        const { instanceDataManager } = this;

        const { instanceId, instanceIndex } = instance;
        const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

        instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#getWorldMatrix
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance to get world matrix for.
     * @param {module:@webgears-app/math.AffineMatrix3} [worldMatrix=new AffineMatrix3()]
     * An AffineMatrix3 to store result to.
     * @summary Gets world matrix of an instance.
     */
    getWorldMatrix(instance, worldMatrix = new AffineMatrix3()) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);

        const { instanceDataManager } = this;

        const { instanceId, instanceIndex } = instance;
        const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

        instanceDataManager.readWorldTransform(worldMatrix, globalIndex);

        return worldMatrix;
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#changeInstanceMaterial
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @param {module:@webgears-app/engine-core.Material} material A new material of an instance.
     * @summary Changes an instance material.
     */
    changeInstanceMaterial(instance, material) {
        const { instanceDataManager } = this;

        instance.material = material;

        instanceDataManager.addInstance(instance);

        this.forceUpdateRenderQueue = true;
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#getInstancedAttribute
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance to get attribute from.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Attribute semantic.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} [outVal=undefined] An output to write result to.
     * @returns {Vector2|Vector3|RGBColor|Array|Float32Array}
     * @summary Gets instanced attribute of defined instance and semantic.
     */
    getInstancedAttribute(instance, semantic, outVal) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);
        const { instanceDataManager } = this;

        return instanceDataManager.getInstancedAttribute(instance, semantic, outVal);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#setInstancedAttribute
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance to set attribute for.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Attribute semantic.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} [outVal=undefined] A value to set.
     * @summary Sets instanced attribute of defined instance and semantic.
     */
    setInstancedAttribute(instance, semantic, value) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);
        const { instanceDataManager } = this;

        instanceDataManager.setInstancedAttribute(instance, semantic, value);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#setInstanceVisibility
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @param {boolean} value New visibility value.
     * @summary Sets instance visibility.
     */
    setInstanceVisibility(instance, value) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);

        this.instanceDataManager.setInstanceVisibility(instance, value, true);
        this.forceUpdateRenderQueue = true;
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#getInstanceVisibility
     * @param {module:@webgears-app/engine-core.Renderable} instance An instance.
     * @returns {boolean}
     * @summary Gets instance visibility.
     */
    getInstanceVisibility(instance) {
        console.assert(instance.instanceId !== null && !instance._instanceIdentifierExpired);

        const currentFrameVisibilityFlag = 0x02;
        const { instanceDataManager } = this;

        const { _flagBuffers } = instanceDataManager;
        const { instanceId, instanceIndex } = instance;
        const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);
        const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

        return (_flagBuffers[globalIndex] & currentFrameVisibilityFlag) !== 0;
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#updateLight
     * @param {module:@webgears-app/engine-core.Light} light A light.
     * @summary Updates light properties.
     * @desc Any time application change anything like a light temperature, filter color
     * or any other light properties except direction and position, application have to call
     * light update to light changes have effect.
     */
    updateLight(light) {
        if (this._lights.has(light)) computeLightProperties(light);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#addLight
     * @param {module:@webgears-app/engine-core.Light} light A light.
     * @param {module:@webgears-app/math.AffineMatrix3} [matrix = new AffineMatrix3().fromNumber(1.)]
     * Light transformation matrix.
     * @summary Adds light into scene.
     */
    addLight(light, matrix = new AffineMatrix3().fromNumber(1.)) {
        computeLightProperties(light);

        this._forceMaterialsUpdate();

        this._lights.set(light, matrix);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#setLightTransform
     * @param {module:@webgears-app/engine-core.Light} light A light.
     * @param {module:@webgears-app/math.AffineMatrix3} matrix New light's transforamtion matrix.
     * @summary Sets light transformation matrix.
     */
    setLightTransform(light, matrix) {
        const { _lights } = this;
        if (_lights.has(light)) _lights.set(light, matrix);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#getLightTransform
     * @param {module:@webgears-app/engine-core.Light} light A light.
     * @returns {module:@webgears-app/math.AffineMatrix3}
     * @summary Gets light transformation matrix.
     */
    getLightTransform(light) {
        console.assert(this._lights.has(light)); // light is not in scene
        return this._lights.get(light);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#deleteLight
     * @param {module:@webgears-app/engine-core.Light} light A light to delete.
     * @summary Deletes light from scene.
     */
    deleteLight(light) {
        this._forceMaterialsUpdate();
        this._lights.delete(light);
    }

    _update(camera) {
        const { _lights } = this;
        const { viewMatrix } = camera;

        let maxIlluminance = 0;

        for (const [light, matrix] of _lights) {
            updateLightPositionAndDirection(light, matrix, viewMatrix);

            maxIlluminance = Math.max(maxIlluminance, light._illuminance);
        }

        this._maxIlluminance = Math.max(this._maxEnvIlluminance, maxIlluminance);
    }

    /**
     * @function module:@webgears-app/engine-core.DotScene#castScene
     * @returns {module:@webgears-app/engine-core.Scene}
     * @summary DotScene to scene cast method.
     * @desc In case scene cast to DotScene and back - new scene may not be equal with original scene,
     * cause of data loses.
     */
    sceneCast() {
        const { instanceDataManager: srcInstanceDataManager, name, config: srcConfig, lights } = this;
        const { capacity: maxSceneNodes, _instancedBatches: batches, _freeIndices } = srcInstanceDataManager;

        const config = { customAttributes: srcConfig.customAttributes };

        const scene = new scene_Scene({
            maxSceneNodes,
            batchMap: srcInstanceDataManager.generateBatchMap(),
            name,
            config
        });

        const splitTransform = new AffineSplitTransform3();

        const { batchCount } = batches;
        const batch = new instancedBatch();
        const matrix = new AffineMatrix3();

        for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
            batches.unpackBatch(batchIdx, batch);

            const { capacity, instanceCount, instanceId } = batch;
            const batchRenderable = srcInstanceDataManager.getInstanceRenderable(instanceId);
            const freeIndices = _freeIndices.get(batchRenderable) || [];
            const { geometry, material } = batchRenderable;

            for (let instanceIdx = 0, validInstanceCount = 0; instanceIdx < capacity; instanceIdx++) {
                if (freeIndices.includes(instanceIdx)) continue;

                const node = scene.root.createChild({});

                const mesh = new mesh_Mesh({});
                const subMesh = new mesh_SubMesh({ geometry, material });

                mesh.addSubMesh(subMesh);

                node.attach(mesh);

                const globalIndex = srcInstanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIdx);

                srcInstanceDataManager.readWorldTransform(matrix, globalIndex);

                splitTransform.fromAffineMatrix(matrix);

                const { scaling: scale, quaternion: orientation, translation: position } = splitTransform;

                node.attach(new transform_Transform({ scale, position, orientation }));

                if (++validInstanceCount >= instanceCount) break;
            }
        }

        for (const [light, matrix] of lights.entries()) {
            const node = scene.root.createChild({});

            splitTransform.fromAffineMatrix(matrix);

            const { scaling: scale, quaternion: orientation, translation: position } = splitTransform;

            node.attach(light);
            node.attach(new transform_Transform({ scale, position, orientation }));
        }

        return scene;
    }

    /**
     * @var module:@webgears-app/engine-core.DotScene#lights
     * @readonly
     * @type {Map<module:@webgears-app/engine-core.Light, module:@webgears-app/math.AffineMatrix3>}
     * @summary The list of scene lights.
     */
    get lights() {
        return this._lights;
    }

    _forceMaterialsUpdate() {
        const { instanceDataManager } = this;
        const { _uniqueInstances } = instanceDataManager;

        for (const batch of _uniqueInstances.values()) {
            batch.material.needsUpdate = true;
        }
    }
}

Object.defineProperty(dotScene_DotScene.prototype, 'isDotScene', { value: true });



// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/binary-search-bounds/search-bounds.js
var search_bounds = __webpack_require__(53);
var search_bounds_default = /*#__PURE__*/__webpack_require__.n(search_bounds);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/system.js
/**
 * @class module:@webgears-app/engine-core.System
 * @summary The system base class.
 * @desc The system provides the logic how to add, delete or update definite types of components.
 * @abstract
 */
class System {
    constructor() {
        this._initialized = false;
        this.enabled = false;
    }

    /**
     * @function module:@webgears-app/engine-core.System#init
     * @summary Initializes system.
     */
    init() {
        this.enabled = true;
        this._initialized = true;
    }

    _updateScene(/*task*/) { }

    _update(/*stage, renderPass*/) { }

    /**
     * @function module:@webgears-app/engine-core.System#dispose
     * @summary Release all resources that are belong to system.
     */
    dispose() {}
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/animations/skeleton.js







let _lastSkeletonId = 0;

/**
 * @class module:@webgears-app/engine-core._SkeletonBuffers
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @private
 */
class skeleton_SkeletonBuffers extends disposeableUsageCounter_DisposableUsageCounter {
    constructor(width, height = 1.0) {
        super();

        this._width = width;
        this._height = height;

        this._boneStaging = null;
        this._boneGPU = null;

        this._lineOwners = [-1];
    }

    get isOk() {
        return this._boneGPU !== null;
    }

    init() {
        const floatsPerPixel = 4.0;

        const { _width: width, _height: height } = this;

        const data = new Float32Array(width * height * floatsPerPixel);

        this._boneStaging = data;

        this._boneGPU = new texture_Texture({
            name: `${name}_gpu_skeleton_storage`,
            width,
            height,
            bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D,
            wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            magFilter: texture_Texture.Filter.NEAREST,
            minFilter: texture_Texture.Filter.NEAREST,
            componentType: DataType.FLOAT,
            format: PixelDataFormat.RGBA,
            levels: 1,
            levelsData: [
                new texture_TextureLevelData({ width, height, depth: 1, data })
            ],
            dynamic: true
        });
    }

    setLineOwner(line, owner) {
        this._lineOwners[line] = owner;
    }

    getLineOwner(line) {
        return line < this._lineOwners.length ? this._lineOwners[line] : -1;
    }

    _reAlloc(width, height) {
        const { _boneStaging, _boneGPU } = this;
        const floatsPerPixel = 4.0;

        const boneStaging = new Float32Array(width * height * floatsPerPixel);

        boneStaging.set(_boneStaging);

        this._boneStaging = boneStaging;

        _boneGPU.height = height;
        _boneGPU._levelsData[0].height = height;
        _boneGPU._levelsData[0].data = boneStaging;
        _boneGPU.needsUpdate = true;

        const lineOwners = new Array(height);

        for (let i = 0, count = lineOwners.length; i < count; i++) {
            lineOwners[i] = i < this._lineOwners.length ? this._lineOwners[i] : -1;
        }

        this._lineOwners = lineOwners;
    }

    get boneStaging() {
        return this._boneStaging;
    }

    get boneGPU() {
        return this._boneGPU;
    }

    unload() {
        if (!this.isOk) return;

        this._boneGPU.unload();
        this._boneStaging = null;
        this._boneGPU = null;
        this._lineOwners.length = 0;

        super.unload();
    }

    _dispose() {
        if (!this.isOk) return;

        this._boneGPU.release();
        this._boneStaging = null;
        this._boneGPU = null;
        this._lineOwners.length = 0;

        super._dispose();
    }
}

/**
 * @class module:@webgears-app/engine-core.Skeleton
 * @summary The Skeleton class.
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @param {string} name The name of the skeleton.
 * @param {module:@webgears-app/engine-core.Transform} rootTransform The reference to the component
 * that represents root transform of the skeleton.
 * @param {number} countBones Count bones of the skeleton.
 */
class skeleton_Skeleton extends disposeableUsageCounter_DisposableUsageCounter {
    constructor(name, rootTransform, countBones) {
        super();

        this._id = ++_lastSkeletonId;

        this.name = name;
        this.root = rootTransform;

        this._instanceSkeletonBuffers = [];
        this._instanceIndices = [];

        this._countBones = countBones;
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#getSkeletonBuffersByInstanceIndex
     * @param {number} instanceIndex Index of the instance index in the batch.
     * @returns {module:@webgears-app/engine-core._SkeletonBuffers}
     * @summary Returns skeleton buffers by instance index.
     */
    getSkeletonBuffersByInstanceIndex(instanceIndex) {
        const i = this._instanceIndices.indexOf(instanceIndex);
        return i !== -1 ? this._instanceSkeletonBuffers[i] : null;
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#getInstanceIndex
     * @param {number} i Index of the instance index in the skeleton.
     * @returns {number}
     * @summary Returns instance index by index.
     */
    getInstanceIndex(i) {
        return this._instanceIndices[i];
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#getBoneMatrices
     * @param {number} i Index of the skeleton buffers.
     * @returns {module:@webgears-app/engine-core._SkeletonBuffers}
     * @summary Returns skeleton buffers by index.
     */
    getBoneMatrices(i) {
        return this._instanceSkeletonBuffers[i].boneStaging;
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#addSkeletonBuffers
     * @param {number} instanceIndex The index of the instance in the batch.
     * @param {module:@webgears-app/engine-core._SkeletonBuffers} [skeletonBuffers=null]
     * Buffers to store skeleton bones.
     * @returns {module:@webgears-app/engine-core._SkeletonBuffers}
     * @summary Adds skeleton buffers to store bones for instances with specified index.
     */
    addSkeletonBuffers(instanceIndex, skeletonBuffers = null) {
        const { _instanceSkeletonBuffers, _instanceIndices, id } = this;

        let skeletonBuffers_ = skeletonBuffers;

        if (skeletonBuffers_ === null) { // new batch case
            console.assert(instanceIndex === 0); // , 'new batch must start from 0 instance index');

            skeletonBuffers_ = this._createNewSkeletonBuffers();
        }

        const { boneGPU } = skeletonBuffers_;
        const { height, width } = boneGPU;

        if (height <= instanceIndex) {
            const height_ = ceilPow2(instanceIndex + 1) * 2;
            skeletonBuffers_._reAlloc(width, height_);
        }

        skeletonBuffers_.setLineOwner(instanceIndex, id);

        skeletonBuffers_.retain();

        _instanceIndices.push(instanceIndex);
        _instanceSkeletonBuffers.push(skeletonBuffers_);

        return skeletonBuffers_;
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#setSkeletonBuffers
     * @param {number} instanceIndex The index of the instance in the batch.
     * @param {module:@webgears-app/engine-core._SkeletonBuffers} [batchSkeletonBuffers=null]
     * Buffers to store skeleton bones.
     * @returns {module:@webgears-app/engine-core._SkeletonBuffers}
     * @summary Sets new skeleton buffers to store bones for instances with specified index.
     */
    setSkeletonBuffers(instanceIndex, batchSkeletonBuffers = null) {
        const { _instanceSkeletonBuffers, _instanceIndices } = this;
        const i = _instanceIndices.indexOf(instanceIndex);

        console.assert(i >= 0); // `skeleton has no buffers for instance index: ${instanceIndex}`);

        _instanceSkeletonBuffers[i].release();

        const skeletonBuffers = batchSkeletonBuffers !== null ? batchSkeletonBuffers : this._createNewSkeletonBuffers();

        const { boneGPU } = skeletonBuffers;
        const { height, width } = boneGPU;

        if (height <= instanceIndex) {
            const height_ = ceilPow2(instanceIndex + 1) * 2;
            skeletonBuffers._reAlloc(width, height_);
        }

        skeletonBuffers.retain();

        _instanceSkeletonBuffers[i] = skeletonBuffers;

        return skeletonBuffers;
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#update
     * @param {number} i Skeleton's buffer index.
     * @summary Updates all bones in the GPU storage of the skeleton with data from the staging buffer.
     */
    update(i) {
        const { _instanceSkeletonBuffers } = this;
        const { boneGPU } = _instanceSkeletonBuffers[i];

        boneGPU.updateLevels(() => { return true; });
    }

    /**
     * @var module:@webgears-app/engine-core.Skeleton#id
     * @type {number}
     * @summary Unique skeleton identifier.
     */
    get id() {
        return this._id;
    }

    /**
     * @var module:@webgears-app/engine-core.Skeleton#skeletonBuffersCount
     * @type {number}
     * @summary Skeleton buffers count to store bones.
     */
    get skeletonBuffersCount() {
        return this._instanceIndices.length;
    }

    /**
     * @var module:@webgears-app/engine-core.Skeleton#name
     * @type {string}
     * @summary The name of the skeleton.
     */

    /**
     * @var module:@webgears-app/engine-core.Skeleton#root
     * @type {module:@webgears-app/engine-core.Transform}
     * @summary The root transform of the skeleton.
     */

    /**
     * @var module:@webgears-app/engine-core.Skeleton#countBones
     * @type {number}
     * @readonly
     * @summary Count bones of the skeleton.
     */
    get countBones() {
        return this._countBones;
    }

    _createNewSkeletonBuffers() {
        const colSize = 3;

        const { countBones } = this;

        const width = countBones * colSize;
        const height = 1;

        const skeletonBuffers = new skeleton_SkeletonBuffers(width, height);
        skeletonBuffers.init();

        return skeletonBuffers;
    }

    _actuallyUnload() {
        const { _instanceSkeletonBuffers, _instanceIndices } = this;

        for (const skeletonBuffers of _instanceSkeletonBuffers) {
            skeletonBuffers.unload();
        }

        _instanceSkeletonBuffers.length = 0;
        _instanceIndices.length = 0;

        super._actuallyUnload();
    }

    /**
     * @function module:@webgears-app/engine-core.Skeleton#_dispose
     * @protected
     * @summary Release buffers of the skeleton.
     */
    _dispose() {
        const { _instanceSkeletonBuffers, _instanceIndices } = this;

        for (const skeletonBuffers of _instanceSkeletonBuffers) {
            skeletonBuffers.release();
        }

        _instanceSkeletonBuffers.length = 0;
        _instanceIndices.length = 0;

        super._dispose();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/interpolator.js



const q1 = new quaternion_Quaternion();
const q2 = new quaternion_Quaternion();
const qr = new quaternion_Quaternion();

const slerp = new quaternion_slerper_QuaternionSlerper();

function interpolate(countSamplers, samplersBuffer) {
    let offset = 0;

    for (let i = 0; i < countSamplers; i++) {
        const playtime = samplersBuffer[offset++];
        const k1 = samplersBuffer[offset++];
        const k2 = samplersBuffer[offset++];

        const interpolation = samplersBuffer[offset++];
        const countComponents = samplersBuffer[offset++];

        const ofs = countComponents;
        const ofs2 = countComponents * 2;
        const ofs3 = countComponents * 3;
        const ofs4 = countComponents * 4;

        const dt = k2 - k1;

        let alpha = (playtime - k1) / dt;

        alpha = Number.isFinite(alpha) ? alpha : 1.0;

        if (interpolation === 0.0) {            // linear
            for (let j = 0; j < countComponents; j++) {
                const out1 = samplersBuffer[offset + j];
                const out2 = samplersBuffer[offset + ofs + j];

                samplersBuffer[offset + ofs2 + j] = (1.0 - alpha) * out1 + alpha * out2;
            }

            offset += ofs3;
        } else if (interpolation === 1.0) {     // step
            for (let j = 0; j < countComponents; j++) {
                const out1 = samplersBuffer[offset + j];
                const out2 = samplersBuffer[offset + ofs + j];

                samplersBuffer[offset + ofs2 + j] = alpha > 0.5 ? out2 : out1;
            }
            offset += ofs3;
        } else if (interpolation === 2.0) {     // cubic
            // if any questions:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-c-spline-interpolation

            const a2 = alpha * alpha;
            const a3 = a2 * alpha;

            const s2 = -2 * a3 + 3 * a2;
            const s3 = a3 - a2;
            const s0 = 1.0 - s2;
            const s1 = s3 - a2 + alpha;

            for (let j = 0; j < countComponents; j++) {
                const p0 = samplersBuffer[offset + j];              // vertex k
                const m0 = samplersBuffer[offset + ofs + j] * dt;   // out tangent k * (t_k+1 - t_k)
                const p1 = samplersBuffer[offset + ofs2 + j];       // vertex k+1
                const m1 = samplersBuffer[offset + ofs3 + j] * dt;  // in tangent k+1 * (t_k+1 - t_k)

                samplersBuffer[offset + ofs4 + j] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
            }

            offset = offset + ofs4 + ofs;
        } else if (interpolation === 3.0) {     // catmullrom
            console.assert(false, 'Catmull-Rom splines interpolation is not implemented yet');
        } else if (interpolation === 4.0) {     // for quaternions only
            console.assert(countComponents === 4, `count components: ${countComponents}`
                + ', quaternion interpolation expects 4 components');

            q1.fromArrayAt(offset, samplersBuffer);
            q2.fromArrayAt(offset + ofs, samplersBuffer);

            q1.normalize();
            q2.normalize();

            slerp.set(q1, q2);

            slerp.evaluate(alpha, qr);

            qr.toArrayAt(offset + ofs2, samplersBuffer);

            offset += ofs3;
        } else {
            console.assert(false, `unexpected interpolation: ${interpolation} of sampler: ${i}`);
        }
    } // samplers cycle end
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/animations/index.js


















function _cmp(a, b) { return a - b; }

/**
 * @namespace module:@webgears-app/engine-core.Animation.Sampler.Interpolation
 * @summary Interpolation enum.
 * @property {number} LINEAR
 * @property {number} STEP
 * @property {number} CUBIC
 * @property {number} CATMULLROM
 */

class _Interpolation {
    static get LINEAR() { return 0; }
    static get STEP() { return 1; }
    static get CUBIC() { return 2; }
    static get CATMULLROM() { return 3; }
}

class animations_Sampler {
    static get Interpolation() {
        return _Interpolation;
    }

    constructor(input, output, interpolation) {
        this.input = input;
        this.output = output;
        this.interpolation = interpolation;
        this.value = null;

        this._isQuat = false;
    }

    clone() {
        const { input, output, interpolation, _isQuat } = this;

        const clone_ = new animations_Sampler(input, output, interpolation);
        clone_._isQuat = _isQuat;

        return clone_;
    }

    static _getSamplerSize(sampler, outputs) {
        let size = 5; // playtime, t_k1, t_k2, interpolation, count components

        const { output, interpolation } = sampler;

        const output_ = outputs[output];

        const { countComponents } = output_;

        switch (interpolation) {
            case animations_Sampler.Interpolation.LINEAR:
            case animations_Sampler.Interpolation.STEP:
                size += countComponents * 2;
                break;
            case animations_Sampler.Interpolation.CUBIC:
            case animations_Sampler.Interpolation.CATMULLROM:
                size += countComponents * 4;
                break;
            default:
                console.assert(false, 'unexpected type of interpolation');
        }

        size += countComponents;

        return size;
    }

    static _unpackSampler(sampler, buffer, offset) {
        let size = 4; // playtime, t_k1, t_k2, interpolation

        const { interpolation } = sampler;
        const countComponents = buffer[offset + size++];

        switch (interpolation) {
            case animations_Sampler.Interpolation.LINEAR:
            case animations_Sampler.Interpolation.STEP:
                size += countComponents * 2;
                break;
            case animations_Sampler.Interpolation.CUBIC:
            case animations_Sampler.Interpolation.CATMULLROM:
                size += countComponents * 4;
                break;
            default:
                console.assert(false, 'unexpected type of interpolation');
        }

        const valueOffset = (offset + size) * Float32Array.BYTES_PER_ELEMENT;

        sampler.value = new Float32Array(buffer.buffer, valueOffset, countComponents);

        size += countComponents; // step over result

        return size;
    }

    static _packSampler(playtime, sampler, inputs, outputs, buffer, offset) {
        let size = 0;

        const { input, output, interpolation, _isQuat } = sampler;

        const input_ = inputs[input];

        const output_ = outputs[output];

        const { min, max } = input_;

        let playtime_ = playtime;

        playtime_ = Math.max(playtime_, min);
        playtime_ = Math.min(playtime_, max);

        buffer[offset + size++] = playtime_;

        // TODO:: optimize index search with lo, hi

        const keyIndex1 = Math.max(search_bounds_default.a.le(input_.view, playtime_, _cmp), 0);

        const keyIndex2 = Math.min(keyIndex1 + 1, input_.view.length - 1);

        const key1 = input_.view[keyIndex1];

        const key2 = input_.view[keyIndex2];

        buffer[offset + size++] = key1;
        buffer[offset + size++] = key2;

        const { countComponents, view } = output_;

        buffer[offset + size++] = _isQuat && interpolation === animations_Sampler.Interpolation.LINEAR
            ? animations_Sampler.Interpolation.CATMULLROM + 1
            : interpolation;

        buffer[offset + size++] = countComponents;

        const ofs = countComponents;
        const ofs2 = countComponents * 2;
        const ofs3 = countComponents * 3;

        switch (interpolation) {
            case animations_Sampler.Interpolation.LINEAR:
            case animations_Sampler.Interpolation.STEP:
                {
                    const vofs1 = keyIndex1 * countComponents;
                    const vofs2 = keyIndex2 * countComponents;

                    for (let i = 0; i < countComponents; i++) {
                        buffer[offset + size + i] = view[vofs1 + i];
                        buffer[offset + size + ofs + i] = view[vofs2 + i];
                    }
                }

                size += countComponents * 2;

                break;
            case animations_Sampler.Interpolation.CUBIC:
            case animations_Sampler.Interpolation.CATMULLROM:
                {
                    const vofs1 = keyIndex1 * countComponents * 3; // do not forget:
                    const vofs2 = keyIndex2 * countComponents * 3; // 3 == [in tangent, vertex, out tangent]

                    for (let i = 0; i < countComponents; i++) {
                        buffer[offset + size + i] = view[vofs1 + ofs + i];          // spline vertex k
                        buffer[offset + size + ofs + i] = view[vofs1 + ofs2 + i];   // out tangent k
                        buffer[offset + size + ofs2 + i] = view[vofs2 + ofs + i];   // spline vertex k+1
                        buffer[offset + size + ofs3 + i] = view[vofs2 + i];         // in tangent k+1
                    }
                }

                size += countComponents * 4;

                break;
            default:
                console.assert(false, 'unexpected type of interpolation');
        }

        size += countComponents; // to store result;

        return size;
    }
}

/**
 * @class module:@webgears-app/engine-core.Animation
 * @param {object} parameters Parameters.
 * @param {string} [parameters.name=''] The name of the animation.
 * @param {number} [parameters.concurrency = module:@webgears-app/worker-pool.size] // TODO:: remove parameter
 * How many threads the animation can use to calculate interpolation values.
 * @param {number} [parameters.duration = 0] The duration of the animation track in seconds.
 * @param {Float32Array[]} parameters.inputs The buffers of input values.
 * @param {Float32Array[]} parameters.outputs The buffers of output values.
 * @summary Represents the animation track.
 */
class animations_Animation extends disposeableUsageCounter_DisposableUsageCounter {
    /**
     * @class module:@webgears-app/engine-core.Animation.Sampler
     * @memberOf module:@webgears-app/engine-core.Animation
     * @summary The sampler of animation.
     * @desc Sampler specifies indices to access keyframe data of the animation and interpolation method.
     * @param {number} input Index to access buffer with input data.
     * @param {number} output Index to access buffer with output data.
     * @param {module:@webgears-app/engine-core.Animation.Sampler.Interpolation} interpolation Interpolation type.
     */
    static get Sampler() {
        /**
         * @var module:@webgears-app/engine-core.Animation.Sampler#input
         * @type {number}
         * @summary Index to access buffer with input data.
         */

        /**
         * @var module:@webgears-app/engine-core.Animation.Sampler#output
         * @type {number}
         * @summary Index to access buffer with output data.
         */

        /**
         * @var module:@webgears-app/engine-core.Animation.Sampler#interpolation
         * @type {number}
         * @summary Interpolation type.
         */

        /**
         * @var module:@webgears-app/engine-core.Animation.Sampler#value
         * @type {Float32Array}
         * @summary The result of interpolation is actual for current frame.
         */

        /**
         * @var module:@webgears-app/engine-core.Animation.Sampler#_isQuat
         * @type {boolean}
         * @private
         * @summary Whether interpolator should choose spherical interpolation method instead of linear.
         * @desc It's supposed to be true if output data is presented with quaternions.
         */

        /**
         * @function module:@webgears-app/engine-core.Animation.Sampler#clone
         * @returns {module:@webgears-app/engine-core.Animation.Sampler}
         * @summary Makes a clone of animation sampler.
         */
        return animations_Sampler;
    }

    constructor({
            name = '',
            duration = 0.0,
            inputs,
            outputs
    }) {
        super();

        this.name = name;

        this._active = true;

        this._lastFrame = false;

        this.looped = false;

        this.weight = 1.0;

        this._samplers = [];

        this._samplerBuffer = null;

        this._playtime = 0.0;

        this._duration = duration;

        this.timescale = 1.0;

        this._inputs = inputs;

        this._outputs = outputs;

        /**
         * @var module:@webgears-app/engine-core.Animation#extras
         * @type {any}
         * @summary Unstructred application-specific imported/exported data.
         * @desc Must be {@link JSON.stringify}-able.
         */
        this.extras = undefined;

        this.needsUpdate = true;

        Object.defineProperties(this, {
            /**
             * @callback module:@webgears-app/engine-core.Animation.EndEventSignature
             */

            /**
             * @var module:@webgears-app/engine-core.Animation#onEnd
             * @summary Animation ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.Animation.EndEventSignature>}
             * @readonly
             */
            onEnd: { value: new Event() },
        });
    }

    /**
     * @var module:@webgears-app/engine-core.Animation#name
     * @type {string}
     * @summary The name of the animation.
     */

    /**
     * @var module:@webgears-app/engine-core.Animation#looped
     * @type {boolean}
     * @summary Whether the animation system should play the track again from the beginning after the end.
     */

    /**
     * @var module:@webgears-app/engine-core.Animation#weight
     * @type {number}
     * @summary The weight to blend that animation track with any other animation.
     */

    /**
     * @var module:@webgears-app/engine-core.Animation#timescale
     * @type {number}
     * @summary The multiplier for delta time.
     */

    /**
     * @var module:@webgears-app/engine-core.Animation#needsUpdate
     * @type {boolean}
     * @summary Whether the animation system should reassembly animation from input / output buffers.
     * @desc if's supposed to be true, if animation took a new data into the input or output buffer.
     */

    /**
     * @function module:@webgears-app/engine-core.Animation#clone
     * @return {module:@webgears-app/engine-core.Animation}
     * @summary Makes a clone of animation track.
     */

    clone() {
        const { name, duration, _inputs, _outputs, looped, _samplers, timescale, _active, extras } = this;
        const clone_ = new animations_Animation({ name, duration, inputs: _inputs, outputs: _outputs });

        clone_.looped = looped;
        clone_.timescale = timescale;
        clone_._active = _active;

        if (extras !== undefined) {
            clone_.extras = JSON.parse(JSON.stringify(extras));
        }

        for (const s of _samplers) {
            clone_.samplers.push(s.clone());
        }

        return clone_;
    }

    /**
     * @var module:@webgears-app/engine-core.Animation#duration
     * @type {number}
     * @summary The duration of the animation track in seconds.
     */
    get duration() {
        return this._duration;
    }

    set duration(value) {
        this._duration = value;
    }


    /**
     * @var module:@webgears-app/engine-core.Animation#playtime
     * @readonly
     * @type {number}
     * @summary The current time position for this animation track.
     */
    get playtime() {
        return this._playtime;
    }

    /**
     * @var module:@webgears-app/engine-core.Animation#active
     * @type {boolean}
     * @readonly
     * @summary It's is true if animation is active.
     */
    get active() {
        return this._active;
    }

    /**
     * @var module:@webgears-app/engine-core.Animation#samplers
     * @type {module:@webgears-app/engine-core.Animation.Sampler[]}
     * @readonly
     * @summary Array of animation samplers.
     */
    get samplers() {
        return this._samplers;
    }

    /**
     * @function module:@webgears-app/engine-core.Animation#pause
     * @summary Stops animation updating, but does not reset track into beginning.
     */
    pause() {
        this._active = false;
    }

    /**
     * @function module:@webgears-app/engine-core.Animation#play
     * @summary Starts animation updating from the current position in the animation track.
     */
    play() {
        this._active = true;
    }

    /**
     * @function module:@webgears-app/engine-core.Animation#stop
     * @summary Stops animation updating and resets track into beginning.
     */
    stop() {
        this._playtime = 0.0;
        this._active = false;
    }

    _updateSamplerBuffers() {
        const { _samplers, _outputs } = this;

        let bufferSize = 0;

        for (let i = 0, count = _samplers.length; i < count; i++) {
            bufferSize += animations_Sampler._getSamplerSize(_samplers[i], _outputs);
        }

        this._samplerBuffer = new Float32Array(bufferSize);

        this.needsUpdate = false;
    }

    /**
     * @function module:@webgears-app/engine-core.Animation#_startUpdate
     * @async
     * @private
     * @param {number} dt Delta tine in seconds.
     * @summary Updates values of all animation samplers.
     * @desc The animation system calls _startUpdate each frame for any animation
     */
    _startUpdate(dt) {
        if (!this._active) { return; }

        if (this.needsUpdate) {
            this._updateSamplerBuffers();
        }

        const {
            _duration,
            _playtime,
            timescale,
            _samplers,
            _samplerBuffer,
            _inputs,
            _outputs
        } = this;

        const playtime = _playtime + dt * timescale;

        if (playtime <= _duration && playtime >= 0.0) {
            this._playtime = playtime;
        } else if (playtime < 0.0 || playtime > _duration) {
            this._playtime = playtime < 0.0 ? 0.0 : _duration;
            this._lastFrame = true;
        }

        const count = _samplers.length;
        let offset = 0;

        for (let i = 0; i < count; i++) {
            offset += animations_Sampler._packSampler(playtime, _samplers[i], _inputs, _outputs, _samplerBuffer, offset);
        }

        interpolate(count, _samplerBuffer);

        offset = 0;

        for (let i = 0; i < count; i++) {
            offset += animations_Sampler._unpackSampler(_samplers[i], _samplerBuffer, offset);
        }
    }

    _endUpdate() {
        const { active, looped, _lastFrame, _playtime } = this;

        if (!active) { return; }

        if (_lastFrame) {
            this._lastFrame = false;
            this._active = looped;

            this._playtime = looped // eslint-disable-line
                ? _playtime > 0.0 ? 0.0 : this.duration
                : _playtime;

            this.onEnd.emit();
        }
    }

    _actuallyUnload() {
        this.stop();

        for (const track of (function*() {
            yield* this._inputs;
            yield* this._outputs;
        }).call(this)) {
            track.view = null;
        }

        this._samplerBuffer = null; // set this.needsUpdate = true to restore buffers

        super._actuallyUnload();
    }

    _dispose() {
        this.stop();

        delete this._samplerBuffer;
        delete this._inputs;
        delete this._outputs;

        super._dispose();
    }
}

/**
 * @class module:@webgears-app/engine-core.Animations
 * @summary The class of animation system
 * @extends module:@webgears-app/engine-core.System
 */
class animations_Animations extends System {
    init() {
        EntityManager.onAttach.subscribe(function _onAttach(entityManager, entity, component) {
            const { index } = component;
            const { _scene } = entityManager;

            switch (index) {
                case nodeAnimation_NodeAnimation.index:
                    {
                        const {channels} = component;
                        for (const channel of channels) {
                            _scene.getAnimation(channel.animation).retain();
                        }
                    }
                    break;
                case bone_Bone.index:
                    _scene.getSkeleton(component.skeletonIndex).retain();
                    break;
                default:
            }
        });

        EntityManager.onDetach.subscribe(function _onDetach(entityManager, entity, component) {
            const { index } = component;
            const { _scene } = entityManager;

            switch (index) {
                case nodeAnimation_NodeAnimation.index:
                    {
                        const {channels} = component;
                        for (const channel of channels) {
                            _scene.getAnimation(channel.animation).release();
                        }
                    }
                    break;
                case bone_Bone.index:
                    _scene.getSkeleton(component.skeletonIndex).release();
                    break;
                default:
            }
        });

        super.init();
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                this._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _earlyUpdate(renderPass) {
        const { scene, dt } = renderPass;
        const { entityManager } = scene;

        if (!entityManager.isComponent(nodeAnimation_NodeAnimation)) return;

        const nodeAnimationStorage = entityManager.getComponentStorage(nodeAnimation_NodeAnimation);

        for (const animation of scene.animations()) {
            animation._startUpdate(dt);
        }


        for (const nodeAnimation of nodeAnimationStorage.components()) {
            const { channels } = nodeAnimation;

            for (const channel of channels) {
                const { animation, sampler } = channel;
                const animation_ = scene.getAnimation(animation);

                const { active, samplers } = animation_;

                if (!active) { continue; }

                channel.update(samplers[sampler].value);
            }
        }

        for (const animation of scene.animations()) {
            animation._endUpdate();
        }
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                animations_Animations._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ srcScene, dstScene, copyContext }) {
        const {
            nodeToNode = new Map(),
            skeletonToSkeleton = new Map(),
            animationToAnimation = new Map()
        } = copyContext;

        const xfrmToXfrm = new Map();
        const skeletonsToCopy = new Set();
        const animationsToCopy = new Set();

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            let [dstTransform] = dstNode.getComponents([transform_Transform]);

            const [srcTransform, srcNodeAnimation, srcBone] = srcNode.getComponents(
                [transform_Transform, nodeAnimation_NodeAnimation, bone_Bone]
            );

            if (srcTransform !== null && dstTransform === null) {
                dstTransform = srcTransform.clone();
                dstNode.attach(dstTransform);
            } else if (srcTransform !== null && dstTransform !== null) {
                dstTransform.position.copy(srcTransform.position);
                dstTransform.scale.copy(srcTransform.scale);
                dstTransform.orientation.copy(srcTransform.orientation);
                dstTransform.state = transform_Transform.StateMask.UPDATE_LOCAL;
            }

            if (srcNodeAnimation !== null) {
                for (const ch of srcNodeAnimation.channels) {
                    animationsToCopy.add(ch.animation);
                }
            }

            if (srcBone !== null) {
                skeletonsToCopy.add(srcBone.skeletonIndex);
            }

            xfrmToXfrm.set(srcTransform, dstTransform);
        }


        for (const [srcIndex, a] of srcScene.animationEntries()) {
            if (!animationsToCopy.has(srcIndex)) continue;

            const c = a.clone();

            const dstIndex  = dstScene.addAnimation(c);

            animationToAnimation.set(srcIndex, dstIndex);
        }


        for (const [srcIndex, srcSkeleton] of srcScene.skeletonEntries()) {
            if (!skeletonsToCopy.has(srcIndex)) continue;

            const { countBones } = srcSkeleton;

            const dstRoot = xfrmToXfrm.get(srcSkeleton.root);

            console.assert(dstRoot !== undefined, 'can not find skeleton root');

            const dstSkeleton = new skeleton_Skeleton(srcSkeleton.name, dstRoot, countBones);

            const dstIndex = dstScene.addSkeleton(dstSkeleton);

            skeletonToSkeleton.set(srcIndex, dstIndex);
        }

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcBone] = srcNode.getComponents([bone_Bone]);

            if (srcBone === null) continue;

            const dstBone = srcBone.clone();

            const skeletonIndex = skeletonToSkeleton.get(srcBone.skeletonIndex);

            console.assert(skeletonIndex !== undefined, 'can not find skeleton');

            dstBone.skeletonIndex = skeletonIndex;

            dstNode.attach(dstBone);
        }

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcNodeAnimation] = srcNode.getComponents([nodeAnimation_NodeAnimation]);

            if (srcNodeAnimation === null) continue;

            const srcChannels = srcNodeAnimation.channels;
            const dstChannels = [];

            const dstNodeAnimation = new nodeAnimation_NodeAnimation();
            dstNodeAnimation.channels = dstChannels;

            for (const srcChannel of srcChannels) {
                const { target, sampler, animation, _updater } = srcChannel;

                const target_ = target instanceof transform_Transform ? xfrmToXfrm.get(target) : target;
                const animation_ = animationToAnimation.get(animation);

                console.assert(target_ !== undefined, 'can not find target for animation channel');
                console.assert(animation_ !== undefined, 'can not find animation');

                const dstChannel = new nodeAnimation_NodeAnimation.Channel(target_, sampler, animation_);

                dstChannel.update = _updater;

                dstChannels.push(dstChannel);
            }

            dstNode.attach(dstNodeAnimation);
        }
    }
}

Object.assign(animations_Animations.prototype, {
    _lateUpdate: (function __lateUpdate() {
        const boneMatrixSize = 12;
        const componentClasses = [transform_Transform];
        const entityComponents = [];
        const boneMatrix = new AffineMatrix3();

        return function _lateUpdate(renderPass) {
            const { scene } = renderPass;
            const { entityManager } = scene;

            if (!entityManager.isComponent(bone_Bone)) return;

            const boneStorage = entityManager.getComponentStorage(bone_Bone);

            for (const [entity, bone] of boneStorage.entries()) {
                const [ transform ] = entityManager.getEntityComponents(entity, componentClasses, entityComponents);
                const { skeletonIndex, boneIndex, inverseBindMatrix } = bone;

                const skeleton = scene.getSkeleton(skeletonIndex);

                const { root, skeletonBuffersCount, _countBones } = skeleton;
                const { state, worldMatrix } = transform;

                if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0) {
                    boneMatrix.copy(root.worldMatrix).invert()
                        .preMultiply(worldMatrix)
                        .preMultiply(inverseBindMatrix);

                    for (let i = 0; i < skeletonBuffersCount; i++) {
                        const instanceIndex = skeleton.getInstanceIndex(i);
                        const boneMatrices = skeleton.getBoneMatrices(i);
                        const instanceOffset = boneMatrixSize * _countBones * instanceIndex;

                        boneMatrix.toAffineColumnArrayAt(instanceOffset + boneMatrixSize * boneIndex, boneMatrices);

                        skeleton.update(i);
                    }
                }
            }
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/cameras/index.js







const localClipper = new HalfSpace3();

function applyClipper(camera) {
    // http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

    console.assert(camera.projectionType === camera_Camera.ProjectionTypes.PERSPECTIVE,
                   'clipping is only implemented for standard perspective projection');

    localClipper.copy(camera.clipper).applyAffineMatrix(camera.viewMatrix);

    if (camera.reflected) { localClipper.flip(); }
    const { normal, offset } = localClipper;

    const proj = camera.projectionMatrix;

    const x = (sign(normal.x) + proj._20) / proj._00;
    const y = (sign(normal.y) + proj._21) / proj._11;
    const z = -1;
    const w = (1 + proj._22) / proj._32;

    const f = 2 / (normal.x * x + normal.y * y + normal.z * z - offset * w);

    proj._02 = normal.x * f;
    proj._12 = normal.y * f;
    proj._22 = normal.z * f + 1;
    proj._32 = -offset * f;
}

const cameras_center = new Vector3();
const reflector = new AffineMatrix3();

function reflect(camera) {
    const { worldMatrix, clipper } = camera;

    reflector.fromReflection(clipper.normal);

    clipper.centerPaste(cameras_center);
    reflector.translate(cameras_center);
    reflector.preTranslate(cameras_center.negate());

    worldMatrix.multiply(reflector);

    worldMatrix._00 *= -1;
    worldMatrix._01 *= -1;
    worldMatrix._02 *= -1;
}

const lateUpdateClasses = [transform_Transform];

/**
 * @class module:@webgears-app/engine-core.Cameras
 * @extends module:@webgears-app/engine-core.System
 * @summary The class of the camera system
 */
class cameras_Cameras extends System {
    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                cameras_Cameras._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ copyContext }) {
        const { nodeToNode } = copyContext;

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcCamera] = srcNode.getComponents([camera_Camera]);

            if (srcCamera === null) continue;

            const dstCamera = srcCamera.clone();

            dstNode.attach(dstCamera);
        }
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                this._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _earlyUpdate(renderPass) {
        const { scene } = renderPass;
        const { entityManager } = scene;

        if (!entityManager.isComponent(camera_Camera)) return;

        const storage = entityManager.getComponentStorage(camera_Camera);

        for (const camera of storage.components()) {
            const { projectionType, needsUpdateProjection } = camera;

            if (!needsUpdateProjection) { continue; }
            camera.onEarlyUpdateStart.emit();

            if (projectionType === camera_Camera.ProjectionTypes.PERSPECTIVE) {
                camera.projectionMatrix.fromWebGLPerspectiveProjection(
                    camera.aspect, camera.yfov, camera.znear, camera.zfar
                );
            } else if (projectionType === camera_Camera.ProjectionTypes.ORTHOGRAPHIC) {
                camera.projectionMatrix.fromWebGLOrthographicProjection(
                    camera.xmag, camera.ymag, camera.znear, camera.zfar
                );
            }

            // event happens only if projection matrix is updated.
            camera.onEarlyUpdateEnd.emit();
        }
    }

    _lateUpdate(renderPass) {
        const { scene } = renderPass;
        const { entityManager } = scene;
        const { frameNumber } = renderPass;

        if (!entityManager.isComponent(camera_Camera)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(camera_Camera);

        for (const [entity, camera] of storage.entries()) {
            const [transform] = entityManager.getEntityComponents(entity, lateUpdateClasses, components);

            const { state } = transform;
            const { needsUpdateProjection, worldMatrix, viewMatrix, projectionMatrix, viewProjectionMatrix } = camera;

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0) {
                worldMatrix.copy(transform.worldMatrix);
                if (camera.clipper && camera.reflected) {
                    reflect(camera);
                }
                viewMatrix.copy(worldMatrix).invert();

                camera.lastFrameUpdate = frameNumber;
            }

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0 || needsUpdateProjection) {
                viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);

                if (camera.clipper) {
                    applyClipper(camera);
                }

                camera.lastFrameUpdate = frameNumber;
            }

            if (camera.lastFrameUpdate === frameNumber) {
                camera.onLateUpdateEnd.emit();
            }

            camera.needsUpdateProjection = false;
        }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/cubeCameras/index.js









const cubeCameras_lateUpdateClasses = [ transform_Transform ];

/**
 * @class module:@webgears-app/engine-core.CubeCameras
 * @extends module:@webgears-app/engine-core.System
 * @summary The class of the cube camera system
 */
class cubeCameras_CubeCameras extends System {
    constructor() {
        super();

        this._perCubeFaceMatrices = [
            new AffineMatrix3().fromLookDirection(new Vector3(+1, 0, 0), new Vector3(0, -1, 0)), // +x
            new AffineMatrix3().fromLookDirection(new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -x
            new AffineMatrix3().fromLookDirection(new Vector3(0, -1, 0), new Vector3(0, 0, -1)), // +y
            new AffineMatrix3().fromLookDirection(new Vector3(0, +1, 0), new Vector3(0, 0, +1)), // -y
            new AffineMatrix3().fromLookDirection(new Vector3(0, 0, +1), new Vector3(0, -1, 0)), // +z
            new AffineMatrix3().fromLookDirection(new Vector3(0, 0, -1), new Vector3(0, -1, 0))  // -z
        ];

        this._tempMatrix = new AffineMatrix3();

        Object.defineProperties(this, {
            /**
             * @callback module:@webgears-app/engine-core.CubeCameras.UpdateEndEventSignature
             */

            /**
             * @var module:@webgears-app/engine-core.CubeCameras#onEarlyUpdateEnd
             * @summary Early update ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.CubeCameras.UpdateEndEventSignature>}
             * @readonly
             */
            onEarlyUpdateEnd: { value: new Event() },

            /**
             * @var module:@webgears-app/engine-core.CubeCameras#onEarlyUpdateEnd
             * @summary Late update ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.CubeCameras.UpdateEndEventSignature>}
             * @readonly
             */
            onLateUpdateEnd: { value: new Event() },
        });
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                cubeCameras_CubeCameras._copyFromScene(data);
                break;
            default:
        }
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                this._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _earlyUpdate(renderPass) {
        const { scene } = renderPass;
        const { entityManager } = scene;

        if (!entityManager.isComponent(cubeCamera_CubeCamera)) return;

        const storage = entityManager.getComponentStorage(cubeCamera_CubeCamera);

        for (const cubeCamera of storage.components()) {
            const { needsUpdateProjection } = cubeCamera;

            if (needsUpdateProjection) {
                cubeCamera.projectionMatrix.fromWebGLPerspectiveProjection(
                    cubeCamera.aspect, cubeCamera.yfov, cubeCamera.znear, cubeCamera.zfar
                );
            }
        }

        this.onEarlyUpdateEnd.emit(renderPass);
    }

    _lateUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;
        const { entityManager } = scene;

        if (!entityManager.isComponent(cubeCamera_CubeCamera)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(cubeCamera_CubeCamera);

        for (const [entity, cubeCamera] of storage.entries()) {
            const [ transform ] = entityManager.getEntityComponents(entity, cubeCameras_lateUpdateClasses, components);

            const { state, worldMatrix } = transform;
            const { needsUpdateProjection, projectionMatrix, viewMatrices, viewProjectionMatrices } = cubeCamera;

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0) {
                const { _perCubeFaceMatrices, _tempMatrix } = this;

                _tempMatrix.copy(worldMatrix).invert();

                for (const [i, viewMatrix] of viewMatrices.entries()) {
                    viewMatrix.copy(_tempMatrix).multiply(_perCubeFaceMatrices[i]);
                }

                cubeCamera.lastFrameUpdate = frameNumber;
            }

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0 || needsUpdateProjection) {
                for (const [i, viewProjectionMatrix ] of viewProjectionMatrices.entries()) {
                    viewProjectionMatrix.fromAffine(viewMatrices[i]).multiply(projectionMatrix);
                }

                cubeCamera.needsUpdateProjection = false;
                cubeCamera.lastFrameUpdate = frameNumber;
            }
        }

        this.onLateUpdateEnd.emit(renderPass);
    }

    static _copyFromScene({ copyContext }) {
        const { nodeToNode } = copyContext;

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcCamera] = srcNode.getComponents([cubeCamera_CubeCamera]);

            if (srcCamera === null) continue;

            const dstCamera = srcCamera.clone();

            dstNode.attach(dstCamera);
        }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderBuffer.js




/**
 * @class module:@webgears-app/engine-core.RenderBuffer
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary The render buffer class.
 * @param {object} parameters Parameters
 * @param {number} parameters.width The render buffer's width.
 * @param {number} parameters.height The render buffer's height.
 * @param {number} [parameters.samplers=1] The number of samples in the buffer.
 * @param {module:@webgears-app/engine-core.InternalFormat} [parameters.internalFormat=InternalFormat.RGBA]
 * Specifies the internal format of the renderbuffer.
 */
class renderBuffer_RenderBuffer extends disposeableUsageCounter_DisposableUsageCounter {
    constructor({ width, height, samples = 1, internalFormat = InternalFormat.RGBA }) {
        super();

        this.width = width;
        this.height = height;
        this.samples = samples;
        this.internalFormat = internalFormat;

        this.needsUpdate = true;

        this._webGLRenderBuffer = null;
        this._webGLRenderBufferSystem = null;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#width
     * @type {number}
     * @summary Width.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#height
     * @type {number}
     * @summary Height.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#samples
     * @type {number}
     * @summary The number of samples in the buffer.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#internalFormat
     * @type {module:@webgears-app/engine-core.InternalFormat}
     * @summary Specifies the internal format of the renderbuffer.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#needsUpdate
     * @type {boolean}
     * @summary Specifies whether the renderer should update the render buffer.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderBuffer#webGLRenderBuffer
     * @type {?WebGLRenderbuffer}
     * @readonly
     * @summary [The webgl render buffer object]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer}.
     */
    get webGLRenderBuffer() {
        return this._webGLRenderBuffer;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderBuffer#clone
     * @summary Makes a clone of the render buffer.
     * @returns {module:@webgears-app/engine-core.RenderBuffer}
     */
    clone() {
        const {
            width,
            height,
            samples,
            internalFormat
        } = this;

        return new renderBuffer_RenderBuffer({ width, height, samples, internalFormat });
    }

    unload() {
        const { _webGLRenderBufferSystem } = this;

        if (_webGLRenderBufferSystem !== null) {
            _webGLRenderBufferSystem.disposeRenderBuffer(this);
            this._webGLRenderBufferSystem = null;
        }

        super.unload();
    }

    /**
     * @function module:@webgears-app/engine-core.RenderBuffer#_dispose
     * @protected
     * @summary Disposes resources of the render buffer.
     */
    _dispose() {
        const { _webGLRenderBufferSystem } = this;

        if (_webGLRenderBufferSystem !== null) {
            _webGLRenderBufferSystem.disposeRenderBuffer(this);
            this._webGLRenderBufferSystem = null;
        }

        super._dispose();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderTarget/index.js



/**
 * @class module:@webgears-app/engine-core.RenderTarget
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @abstract
 * @summary The render target class.
 */
class renderTarget_RenderTarget extends disposeableUsageCounter_DisposableUsageCounter {
    constructor() {
        super();

        this._lastFrameNumber = 0;

        this._needsUpdate = true;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTarget#needsUpdate
     * @type {boolean}
     * @summary Whether the renderer should update the render target.
     */
    get needsUpdate() {
        return this._needsUpdate;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTarget#clone
     * @abstract
     * @summary Makes a clone of the render target.
     * @returns {module:@webgears-app/engine-core.RenderTarget}
     */
    clone() {
        const cloned = new renderTarget_RenderTarget();

        cloned._lastFrameNumber = this._lastFrameNumber;

        return cloned;
    }

    get webGLFramebuffer() {
        return null;
    }
}

Object.defineProperty(renderTarget_RenderTarget.prototype, 'isRenderTarget', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderTarget/renderTargetFramebuffer.js








class _Attachment {}

(function prepEnums() {
    {
        const value = webglContext.NONE;
        Object.defineProperty(_Attachment, 'NONE', { value, writeable: false });
    }

    for (let i = 0; i < 16; i++) {
        const value = webglContext.COLOR_ATTACHMENT0 + i;
        Object.defineProperty(_Attachment, `COLOR_ATTACHMENT${i}`, { value, writeable: false });
    }

    {
        const value = webglContext.DEPTH_ATTACHMENT;
        Object.defineProperty(_Attachment, 'DEPTH_ATTACHMENT', { value, writeable: false });
    }

    {
        const value = webglContext.STENCIL_ATTACHMENT;
        Object.defineProperty(_Attachment, 'STENCIL_ATTACHMENT', { value, writeable: false });
    }

    {
        const value = webglContext.DEPTH_STENCIL_ATTACHMENT || 33306;
        Object.defineProperty(_Attachment, 'DEPTH_STENCIL_ATTACHMENT', { value, writeable: false });
    }
}());

/**
 * @class module:@webgears-app/engine-core.RenderTargetFramebuffer
 * @extends module:@webgears-app/engine-core.RenderTarget
 * @summary Class presents a webgl framebuffer as render target.
 * @param {object} [parameters] Parameters.
 * @param {number} [parameters.width] Width.
 * @param {number} [parameters.height] Height.
 */
class renderTargetFramebuffer_RenderTargetFramebuffer extends renderTarget_RenderTarget {
    static get Attachment() {
        return _Attachment;
    }

    constructor({ width, height }) {
        super();

        // TODO:: makes em readonly
        this.width = width;
        this.height = height;

        this._lastFrameNumber = 0;

        this._colorAttachments = new Map();
        this._properties = new Map();
        this._depthStencilAttachments = new Map();

        this._needsUpdateAttachments = true;

        this._webGLFramebufferSystem = null;
        this._webGLFramebuffer = null;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCanvas#width
     * @type {number}
     * @readonly
     * @summary Width
     */

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCanvas#height
     * @type {number}
     * @readonly
     * @summary Height
     */

    get needsUpdate() {
        return this._needsUpdateAttachments || this._needsUpdate;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetFramebuffer#colorAttachmentCount
     * @type {number}
     * @readonly
     * @summary Count of color attachments.
     */
    get colorAttachmentCount() {
        return this._colorAttachments.size;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#hasColorAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Tests if render target has color attachment in layout position.
     * @returns {boolean}
     */
    hasColorAttachment(layoutPosition) {
        return this._colorAttachments.has(layoutPosition);
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#hasDepthStencilAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Tests if render target has depth or stencil attachment in layout position.
     * @returns {boolean}
     */
    hasDepthStencilAttachment(layoutPosition) {
        return this._depthStencilAttachments.has(layoutPosition);
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#setColorAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @param {module:@webgears-app/engine-core.Texture|module:@webgears-app/engine-core.RenderBuffer} attachment Attachment.
     * @param {number} level Specifies the mipmap level of the texture to attach.
     * @param {module:@webgears-app/engine-core.Texture.BindingPoint} target Specifies the texture target.
     * @param {number} layer Specifies the layer of the texture to attach.
     * @summary Sets color attachment into definite layout position.
     */
    setColorAttachment(layoutPosition, attachment, level = 0, target, layer = 0) {
        console.assert(
            attachment instanceof texture_Texture || attachment instanceof renderBuffer_RenderBuffer,
            `RenderTarget.setColorAttachment: 2nd argument type ${typeof attachment}, expects Texture or RenderBuffer`
        );

        const { _colorAttachments, _properties } = this;

        const prevAttachment = _colorAttachments.get(layoutPosition);

        if (prevAttachment === attachment) {
            if (prevAttachment instanceof texture_Texture) {
                const props = _properties.get(prevAttachment);

                let target_ = target;

                if (target_ === undefined) {
                    target_ = props.target;
                }

                if (props.target !== target_ || props.level !== level || props.layer !== layer) {
                    this._needsUpdateAttachments = true;
                    props.needsUpdate = true;

                    if (props.level !== level) {
                        this._needsUpdate = true;
                    }

                    props.target = target_;
                    props.level = level;
                    props.layer = layer;
                }
            }

            return;
        }

        if (prevAttachment !== undefined) {
            if (_properties.has(prevAttachment)) {
                _properties.delete(prevAttachment);
            }

            prevAttachment.release();
        } else {
            this._needsUpdate = true;
        }

        _colorAttachments.set(layoutPosition, attachment);

        {
            const props = { needsUpdate: true, level, target, layer };

            if (target === undefined) {
                if (attachment instanceof texture_Texture
                    && attachment.bindingPoint === texture_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
                    props.target = texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
                } else if (attachment instanceof texture_Texture) {
                    props.target = attachment.bindingPoint;
                }
            }

            _properties.set(attachment, props);

            attachment.retain();

            this._needsUpdateAttachments = true;
        }
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#setDepthStencilAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @param {module:@webgears-app/engine-core.Texture|module:@webgears-app/engine-core.RenderBuffer} attachment Attachment.
     * @param {module:@webgears-app/engine-core.Texture.BindingPoint} [target=undefined] Specifies the texture target.
     * @param {number} [layer=0] Specifies the layer of the texture to attach.
     * @summary Sets depth or stencil attachment into definite layout position.
     */
    setDepthStencilAttachment(layoutPosition, attachment, target, layer = 0) {
        console.assert(
            attachment instanceof texture_Texture || attachment instanceof renderBuffer_RenderBuffer,
            `RenderTarget.setDepthStencilAttachment: 2nd argument type ${typeof attachment}, expects Texture or RenderBuffer`
        );

        const { _depthStencilAttachments, _properties } = this;

        const prevAttachment = _depthStencilAttachments.get(layoutPosition);

        if (prevAttachment === attachment) {
            if (prevAttachment instanceof texture_Texture) {
                const props = _properties.get(prevAttachment);

                let target_ = target;

                if (target_ === undefined) {
                    target_ = props.target;
                }

                if (props.target !== target_ || props.layer !== layer) {
                    this._needsUpdateAttachments = true;
                    props.needsUpdate = true;
                }

                props.target = target_;
                props.layer = layer;
            }

            return;
        }

        if (prevAttachment !== undefined) {
            if (_properties.has(prevAttachment)) {
                _properties.delete(prevAttachment);
            }

            prevAttachment.release();
        } else {
            this._needsUpdate = true;
        }

        _depthStencilAttachments.set(layoutPosition, attachment);

        const props = { needsUpdate: true, layer, target };

        if (target === undefined) {
            if (attachment instanceof texture_Texture
                && attachment.bindingPoint === texture_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
                props.target = texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
            } else if (attachment instanceof texture_Texture) {
                props.target = attachment.bindingPoint;
            }
        }

        _properties.set(attachment, props);

        attachment.retain();

        this._needsUpdateAttachments = true;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#getColorAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Returns color attachment corresponded to layout position.
     */
    getColorAttachment(layoutPosition) {
        const { _colorAttachments, _properties } = this;

        const attachment = _colorAttachments.get(layoutPosition);

        const properties = _properties.get(attachment);

        return { attachment, properties };
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#getDepthStencilAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Returns depth/stencil attachment corresponded to layout position.
     */
    getDepthStencilAttachment(layoutPosition) {
        const { _depthStencilAttachments, _properties } = this;

        const attachment = _depthStencilAttachments.get(layoutPosition);

        const properties = _properties.get(attachment);

        return { attachment, properties };
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#removeColorAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Removes color attachment from layout position.
     */
    removeColorAttachment(layoutPosition) {
        const { _colorAttachments, _properties } = this;

        const attachment = _colorAttachments.get(layoutPosition);

        if (attachment !== undefined) {
            attachment.release();

            _colorAttachments.delete(layoutPosition);

            if (_properties.has(attachment)) {
                _properties.delete(attachment);
            }

            this._needsUpdate = true;
        }
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#removeDepthStencilAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @summary Removes depth/stencil attachment from layout position.
     */
    removeDepthStencilAttachment(layoutPosition) {
        const { _depthStencilAttachments } = this;

        const attachment = _depthStencilAttachments.get(layoutPosition);

        if (attachment !== undefined) {
            attachment.release();

            _depthStencilAttachments.delete(layoutPosition);

            this._needsUpdate = true;
        }
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#resize
     * @param {number} width Width.
     * @param {number} height Height.
     * @summary Resizes all render target attachments.
     */
    resize(width, height) {
        this.width = width;
        this.height = height;

        const { _colorAttachments, _depthStencilAttachments } = this;

        for (const colorAttachment of _colorAttachments.values()) {
            colorAttachment.width = width;
            colorAttachment.height = height;
            colorAttachment.needsUpdate = true;
        }

        for (const depthStencilAttachment of _depthStencilAttachments.values()) {
            depthStencilAttachment.width = width;
            depthStencilAttachment.height = height;
            depthStencilAttachment.needsUpdate = true;
        }

        this._needsUpdate = true;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#clone
     * @summary Makes a clone of the render target.
     */
    clone(cloneGPUData = false) {
        const {
            width,
            height,
            _colorAttachments,
            _depthStencilAttachments,
            _properties
        } = this;

        const cloned = new renderTargetFramebuffer_RenderTargetFramebuffer({ width, height });

        for (const [layout, attachment] of _colorAttachments.entries()) {
            let level = 0;
            let target;

            if (_properties.has(attachment)) {
                ({ level, target } = _properties.get(attachment));
            }

            cloned.setColorAttachment(layout, attachment, level, target);
        }

        for (const [layout, attachment] of _depthStencilAttachments.entries()) {
            cloned.setDepthStencilAttachment(layout, attachment);
        }

        if (cloneGPUData) {
            throw new Error('not implemented yet');
        }

        return cloned;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetFramebuffer#webGLFramebuffer
     * @readonly
     * @type {?WebGLFramebuffer}
     * @summary [The webgl framebuffer object]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer}.
     */
    get webGLFramebuffer() {
        return this._webGLFramebuffer;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetFramebuffer#_dispose
     * @protected
     * @summary Releases all render target attachments.
     */
    _dispose() {
        const { _webGLFramebufferSystem, _colorAttachments, _depthStencilAttachments, _properties } = this;

        if (_webGLFramebufferSystem !== null) {
            _webGLFramebufferSystem._sync();

            for (const attachment of _colorAttachments.values()) {
                attachment.release();
            }

            _colorAttachments.clear();

            for (const attachment of _depthStencilAttachments.values()) {
                attachment.release();
            }

            _depthStencilAttachments.clear();

            _properties.clear();

            _webGLFramebufferSystem.deleteFramebuffer(this);

            this._webGLFramebufferSystem = null;
        }

        super._dispose();
    }

    unload() {
        const { _webGLFramebufferSystem, _colorAttachments, _depthStencilAttachments } = this;

        if (_webGLFramebufferSystem !== null) {
            _webGLFramebufferSystem._sync();
        }

        for (const attachment of _colorAttachments.values()) {
            attachment.unload();
        }

        for (const attachment of _depthStencilAttachments.values()) {
            attachment.unload();
        }

        super.unload();
    }
}

Object.defineProperty(renderTargetFramebuffer_RenderTargetFramebuffer.prototype, 'isRenderTargetFramebuffer', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderTarget/renderTargetCube.js





/**
 * @class module:@webgears-app/engine-core.RenderTargetCube
 * @extends module:@webgears-app/engine-core.RenderTargetFramebuffer
 * @param {object} parameters Parameters.
 * @param {number} parameters.width Width of cube render target attachments.
 * @param {number} parameters.height Height of cube render target attachments.
 * @summary The cube render target class.
 */
class renderTargetCube_RenderTargetCube extends renderTargetFramebuffer_RenderTargetFramebuffer {
    constructor({ width, height }) {
        super({ width, height });

        this._target = texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetCube#setColorAttachment
     * @param {module:@webgears-app/engine-core.RenderTargetAttachment} layoutPosition Layout position.
     * @param {module:@webgears-app/engine-core.Texture|module:@webgears-app/engine-core.RenderBuffer} attachment Attachment.
     * @param {number} [level=0] Specifies the mipmap level of the texture to attach.
     * @summary Sets color attachment to specified layout position.
     */
    setColorAttachment(layoutPosition, attachment, level = 0) {
        console.assert(
            attachment instanceof texture_Texture || attachment.bindingPoint === texture_Texture.BindingPoint.TEXTURE_CUBE_MAP,
            `RenderTargetCube.setColorAttachment: 2nd argument type ${typeof attachment}, expects cube map texture`
        );

        super.setColorAttachment(layoutPosition, attachment, level, texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X);

        this._target = texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCube#target
     * @type {module:@webgears-app/engine-core.Texture.BindingPoint}
     * @summary The current start binding point of the cube render target.
     */
    set target(target) {
        this._target = target;

        const { _properties, _colorAttachments, _depthStencilAttachments } = this;

        for (const attachment of _colorAttachments.values()) {
            const props = _properties.get(attachment);

            props.target = target;
            props.needsUpdate = true;
        }

        for (const attachment of _depthStencilAttachments.values()) {
            if (attachment.bindingPoint === texture_Texture.BindingPoint.TEXTURE_CUBE_MAP) {
                const props = _properties.get(attachment);

                props.target = target;
                props.needsUpdate = true;
            }
        }

        this._needsUpdateAttachments = true;
    }

    get target() {
        return this._target;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCube#targetIndex
     * @type {number}
     * @readonly
     * @summary The current start binding point of the cube render target numerically expressed.
     */
    get targetIndex() {
        return this._target - texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X;
    }
}

Object.defineProperty(renderTargetCube_RenderTargetCube.prototype, 'isRenderTargetCube', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/index.js



















const identityMatrix = new AffineMatrix3().fromNumber(1.0);

const lightComponentClasses = [light_Light];

const lateUpdateComponentClasses = [transform_Transform, lightShadowCaster_LightShadowCaster];

const zeroTranslation = new Vector3(0, 0, 0);

function _hasLight(entityManager, entity) {
    const [light] = entityManager.getEntityComponents(entity, lightComponentClasses);
    return light !== null;
}

function _initializeSpotShadowCasterData(light, shadowCaster) {
    const { name } = shadowCaster;

    const camera = new camera_Camera({
        name: `spot-shadow-camera-${name}`,
        znear: 0.1,
        zfar: lights_Lights.spotDirectionalCastersZFar,
        perspectiveProjection: {
            aspect: 1.0,
            yfov: light.outerCone * 2
        }
    });

    camera.projectionType = camera_Camera.ProjectionTypes.PERSPECTIVE;

    camera.needsUpdateProjection = true;

    shadowCaster._spotShadowCasterData = {
        renderTarget: null,
        depthTexture: null,
        depthBuffer: null,
        camera
    };
}

function _initializeOmniShadowCasterData(shadowCaster) {
    const { name } = shadowCaster;

    const cubeCamera = new cubeCamera_CubeCamera({
        name: `omni-shadow-cube-camera-${name}`,
        znear: 0.1,
        zfar: lights_Lights.omniDirectionalCastersZFar
    });

    cubeCamera.needsUpdateProjection = true;

    shadowCaster._omniShadowCasterData = {
        depthTexture: null,
        depthBuffers: [],
        renderTarget: null,
        renderTargets: [],
        cubeCamera,
        invertedWorldMatrix: new HomogeneousMatrix3()
    };
}

function _onAddLightShadowCaster(entityManager, entity, shadowCaster) {
    const [light] = entityManager.getEntityComponents(entity, lightComponentClasses);

    console.assert(light !== null, 'shadow caster must have light on the same entity');

    if (light.isDirectionalLight) {
        shadowCaster._cascades = [];
    } else if (light.isSpotLight) {
        _initializeSpotShadowCasterData(light, shadowCaster);
    } else if (light.isPointLight) {
        _initializeOmniShadowCasterData(shadowCaster);
    }
}

function _onDeleteShadowCaster(entityManager, entity, shadowCaster) {
    const [ light ] = entityManager.getEntityComponents(entity, lightComponentClasses);

    console.assert(light !== null, 'shadow caster must have light on the same entity');

    if (light.isDirectionalLight) {
        for (const cascade of shadowCaster._cascades) {
            if (cascade.renderTarget) {
                cascade.renderTarget.release();
                cascade.renderTarget = null;
            }

            if (cascade.texture) {
                cascade.texture.release();
                cascade.texture = null;
            }

            if (cascade.depthTexture) {
                cascade.depthTexture.release();
                cascade.depthTexture = null;
            }
        }
    } else if (light.isSpotLight) {
        const { _spotShadowCasterData } = shadowCaster;

        if (_spotShadowCasterData.renderTarget) {
            _spotShadowCasterData.renderTarget.release();
            _spotShadowCasterData.renderTarget = null;
        }

        if (_spotShadowCasterData.depthTexture) {
            _spotShadowCasterData.depthTexture.release();
            _spotShadowCasterData.depthTexture = null;
        }

        if (_spotShadowCasterData.depthBuffer) {
            _spotShadowCasterData.depthBuffer.release();
            _spotShadowCasterData.depthBuffer = null;
        }
    } else if (light.isPointLight) {
        const { _omniShadowCasterData } = shadowCaster;

        if (_omniShadowCasterData.renderTarget) {
            _omniShadowCasterData.renderTarget.release();
            _omniShadowCasterData.renderTarget = null;
        }

        for (let renderTarget of _omniShadowCasterData.renderTargets) {
            renderTarget.release();
            renderTarget = null;
        }

        _omniShadowCasterData.renderTargets.length = 0;

        if (_omniShadowCasterData.depthTexture) {
            _omniShadowCasterData.depthTexture.release();
            _omniShadowCasterData.depthTexture = null;
        }

        for (let depthBuffer of _omniShadowCasterData.depthBuffers) {
            depthBuffer.release();
            depthBuffer = null;
        }

        _omniShadowCasterData.depthBuffers.length = 0;
    }
}


/**
 * @class module:@webgears-app/engine-core.Lights
 * @extends module:@webgears-app/engine-core.System
 * @summary The light system class.
 */
class lights_Lights extends System {
    constructor() {
        super();

        this.renderer = null;

        this.splitLambda = 0.64;

        this._shadowMapSize = 2048;
        this._shadowMapSizeChanged = true;

        this._cascadesCount = 4;
        this._cascadesCountChanged = true;
    }

    init(renderer) {
        this.renderer = renderer;

        EntityManager.onAttach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            if (index === lightShadowCaster_LightShadowCaster.index) {
                _onAddLightShadowCaster(entityManager, entity, component);

                const storage = entityManager.getComponentStorage(mesh_Mesh);

                for (const mesh of storage.components()) {
                    for (const subMesh of mesh.subMeshes()) {
                        if (subMesh.material.lit) subMesh.material.needsUpdate = true;
                    }
                }
            }
        });

        EntityManager.onDetach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            const storage = entityManager.getComponentStorage(mesh_Mesh);

            switch (index) {
                case lightShadowCaster_LightShadowCaster.index:
                    _onDeleteShadowCaster(entityManager, entity, component);

                    for (const mesh of storage.components()) {
                        for (const subMesh of mesh.subMeshes()) {
                            if (subMesh.material.lit) subMesh.material.needsUpdate = true;
                        }
                    }

                    break;
                case light_Light.index:
                    console.assert(!_hasLight(entityManager, entity),
                        'detach shadow caster before detach light');
                    break;
                default:
            }
        });

        super.init();
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                this._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _earlyUpdate(renderPass) {
        const { scene } = renderPass;
        const { entityManager } = scene;

        scene._shadowMapSize = this._shadowMapSize;
        scene._cascadesCount = this._cascadesCount;

        if (!entityManager.isComponent(light_Light) || !entityManager.isComponent(lightShadowCaster_LightShadowCaster)) return;

        const storage = entityManager.getComponentStorage(light_Light);

        let maxIlluminance = -1;

        for (const light of storage.components()) {
            const { needsUpdate } = light;

            if (needsUpdate) {
                computeLightProperties(light);
                light.makeUpdated();
            }

            maxIlluminance = Math.max(maxIlluminance, light._illuminance);
        }

        scene._maxIlluminance = Math.max(scene._maxEnvIlluminance, maxIlluminance);

        const { camera } = renderPass;
        const { _perCameraData } = scene;

        if (_perCameraData.has(camera)) {
            _perCameraData.get(camera).cameraDataNeedsUpdate = true;
        }
    }

    _lateUpdate(renderPass) {
        const { renderer } = this;
        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;
        const { scene, camera } = renderPass;
        const { entityManager } = scene;
        const { viewMatrix } = camera;

        if (!entityManager.isComponent(light_Light) || !entityManager.isComponent(lightShadowCaster_LightShadowCaster)) return;

        this._preUpdateShadowCasters(scene, entityManager, camera, webgl2Support);

        const storage = entityManager.getComponentStorage(light_Light);

        for (const [entity, light] of storage.entries()) {
            const [ transform, lightShadowCaster ] = entityManager.getEntityComponents(
                entity, lateUpdateComponentClasses
            );

            const worldMatrix  = transform !== null ? transform.worldMatrix : identityMatrix;

            updateLightPositionAndDirection(light, worldMatrix, viewMatrix);

            this._updateShadowCaster(renderPass, light, worldMatrix, lightShadowCaster);
        }

        this._shadowMapSizeChanged = false;
        this._cascadesCountChanged = false;

        scene._directShadowCastersCountChanged = false;
    }

    /**
     * @var module:@webgears-app/engine-core.Lights#cascadesCount
     * @type {number}
     * @summary The maximum number of cascades for CSM technique.
     */
    get cascadesCount() {
        return this._cascadesCount;
    }

    set cascadesCount(value) {
        this._cascadesCount = value;
        this._cascadesCountChanged = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Lights#shadowMapSize
     * @type {number}
     * @summary The shadow map size.
     */
    get shadowMapSize() {
        return this._shadowMapSize;
    }

    set shadowMapSize(value) {
        this._shadowMapSize = value;
        this._shadowMapSizeChanged = true;
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                this._copyFromScene(data);
                break;
            default:
        }
    }

    /**
     * @function module:@webgears-app/engine-core.Lights#_copyFromScene
     * @param {object} copyContext={} It contains maps with objects from source scene to the destination scene.
     * @param {Map} copyContext.nodeToNode
     * Nodes of source scene to nodes of destination scene.
     * @param {Map} copyContext.skeletonToSkeleton
     * Skeleton indices of source scene to skeleton indices of destination scene.
     * @param {Map} copyContext.animationToAnimation
     * Animation indices of source scene to animation indices of destination scene.
     * @summary Copies Light components when source scene is merged into the destination scene.
     * @protected
     */
    _copyFromScene({ copyContext }) {
        const { nodeToNode } = copyContext;

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcLight] = srcNode.getComponents([light_Light]);

            if (srcLight === null) continue;

            const dstLight = srcLight.clone();

            dstNode.attach(dstLight);
        }
    }

    _preUpdateShadowCasters(scene, entityManager, camera, webgl2Support) {
        const { _directShadowCastersMask, spotCastersDepthTextureArray } = scene;
        const { _spotShadowCasters, _spotShadowCastersMask } = scene;
        const { _omniShadowCasters, _omniShadowCastersMask } = scene;

        _directShadowCastersMask.length = 0;

        _spotShadowCasters.length = 0;
        _spotShadowCastersMask.length = 0;

        _omniShadowCasters.length = 0;
        _omniShadowCastersMask.length = 0;

        {
            const {
                enabledDirectShadowCastersCount, enabledSpotShadowCastersCount, enabledOmniShadowCastersCount
            } = lights_Lights._countEnabledShadowCasters(entityManager);

            scene._directShadowCastersCountChanged =
                scene._enabledDirectShadowCastersCount !== enabledDirectShadowCastersCount;

            scene._enabledDirectShadowCastersCount = enabledDirectShadowCastersCount;
            scene._enabledSpotShadowCastersCount = enabledSpotShadowCastersCount;
            scene._enabledOmniShadowCastersCount = enabledOmniShadowCastersCount;
        }

        const { _enabledDirectShadowCastersCount, _perCameraData } = scene;

        if (_enabledDirectShadowCastersCount > 0) {
            const has = _perCameraData.has(camera);

            if (!has) {
                _perCameraData.set(camera, {
                    cameraDataNeedsUpdate: true,
                    directShadowCasters: [],
                    frustumSplits: [],
                    cascadesPlanes: []
                });
            }
        } else {
            _perCameraData.delete(camera);
        }

        const perCameraData = _perCameraData.get(camera);

        if (perCameraData) {
            if (webgl2Support) {
                const { _cascadesCountChanged, _shadowMapSizeChanged } = this;
                const { _directShadowCastersCountChanged } = scene;

                if (_directShadowCastersCountChanged || _cascadesCountChanged || _shadowMapSizeChanged) {
                    this._disposeResources(scene);
                    this._updateDepthTextureArray(scene);
                }
            }

            if (perCameraData.cameraDataNeedsUpdate) {
                this._calculateFrustumSplits(camera, perCameraData);
                this._calculateCameraAABBs(camera, perCameraData);

                perCameraData.cameraDataNeedsUpdate = false;
            }

            perCameraData.directShadowCasters.length = 0;
        }

        const { _shadowMapSizeChanged } = this;

        if (webgl2Support
            && (_shadowMapSizeChanged || (spotCastersDepthTextureArray === null && scene._enabledSpotShadowCastersCount !== 0))) {
            this._updateSpotShadowCasterAttachments(scene);
        }
    }

    _updateShadowCaster(renderPass, light, worldMatrix, shadowCaster) {
        const { scene } = renderPass;
        const {
            _enabledDirectShadowCastersCount, _enabledSpotShadowCastersCount, _enabledOmniShadowCastersCount
        } = scene;
        const { _directShadowCastersMask, _spotShadowCastersMask, _omniShadowCastersMask } = scene;

        if (_enabledDirectShadowCastersCount === 0
            && _enabledOmniShadowCastersCount === 0
            && _enabledSpotShadowCastersCount === 0) {
                return;
        }

        if (light.isDirectionalLight) {
            if (shadowCaster !== null) {
                this._updateDirectShadowCaster(renderPass, light, worldMatrix, shadowCaster);
            } else {
                _directShadowCastersMask.push(-1);
            }
        } else if (light.isSpotLight) {
            if (shadowCaster !== null) {
                this._updateSpotShadowCaster(renderPass, light, worldMatrix, shadowCaster);
            } else {
                _spotShadowCastersMask.push(-1);
            }
        } else if (light.isPointLight) {
            if (shadowCaster !== null) {
                this._updateOmniShadowCaster(renderPass, light, worldMatrix, shadowCaster);
            } else {
                _omniShadowCastersMask.push(-1);
            }
        }
    }

    _updateDirectShadowCaster(renderPass, light, worldMatrix, shadowCaster) {
        const { renderer, cascadesCount } = this;
        const { scene } = renderPass;

        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;

        if (renderPass.camera.isCamera && shadowCaster.castShadow) {
            const perCameraData = scene._perCameraData.get(renderPass.camera);
            const { cascadesPlanes, directShadowCasters } = perCameraData;

            const directShadowCastersIndex = directShadowCasters.length;

            shadowCaster._casterIndex = directShadowCastersIndex;

            const { _directShadowCastersMask, _directShadowCastersCountChanged } = scene;
            const { _cascadesCountChanged, _shadowMapSizeChanged } = this;

            if (_directShadowCastersCountChanged || _cascadesCountChanged || _shadowMapSizeChanged) {
                shadowCaster._cascades = new Array(cascadesCount).fill(0).map(() => ({}));

                if (!webgl2Support) {
                    this._updateDepthTextures(shadowCaster, light.name);
                }

                this._updateRenderTargets(scene, shadowCaster);
                lights_Lights._createCascadeCameras(shadowCaster, light.name);
            }

            const { _cascades } = shadowCaster;

            for (const [ i, { camera } ] of _cascades.entries()) {
                camera.worldMatrix.copy(worldMatrix);
                camera.worldMatrix.translationCopy(zeroTranslation);

                camera.viewMatrix.copy(camera.worldMatrix).invert();

                this._calculateCascadeCameraProjection(camera, cascadesPlanes[i]);
            }

            directShadowCasters.push({ light, _cascades });

            _directShadowCastersMask.push(directShadowCastersIndex);
        } else {
            const { _directShadowCastersMask } = scene;

            _directShadowCastersMask.push(-1);
        }
    }

    _updateDepthTextures(shadowCaster, name) {
        const { shadowMapSize } = this;
        const { _cascades } = shadowCaster;

        for (const [ i, cascade ] of _cascades.entries()) {
            cascade.texture = new texture_Texture({
                name: `shadow-map-${name}-cascade${i}`,

                width: shadowMapSize,
                height: shadowMapSize,

                bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D,

                magFilter: texture_Texture.Filter.NEAREST,
                minFilter: texture_Texture.Filter.NEAREST,

                wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
                wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

                // format: PixelDataFormat.DEPTH_COMPONENT,
                // internalFormat: InternalFormat.DEPTH_COMPONENT,
                // componentType: DataType.UNSIGNED_INT,

                format: PixelDataFormat.RGBA,
                internalFormat: InternalFormat.RGBA,
                componentType: DataType.UNSIGNED_BYTE,

                levels: 1
            });

            cascade.depthTexture = new texture_Texture({
                name: `shadow-map-${name}-cascade${i}`,

                width: shadowMapSize,
                height: shadowMapSize,

                bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D,

                magFilter: texture_Texture.Filter.NEAREST,
                minFilter: texture_Texture.Filter.NEAREST,

                wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
                wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

                format: PixelDataFormat.DEPTH_COMPONENT,
                internalFormat: InternalFormat.DEPTH_COMPONENT,
                componentType: DataType.UNSIGNED_INT,

                levels: 1
            });
        }
    }

    _updateDepthTextureArray(scene) {
        const { cascadesCount, shadowMapSize } = this;

        scene._updateDepthTextureArray(cascadesCount, shadowMapSize);
    }

    _updateRenderTargets(scene, shadowCaster) {
        const { renderer, cascadesCount } = this;
        const { capabilities } = renderer;

        const { _cascades, _casterIndex } = shadowCaster;

        if (capabilities.webgl2Support) {
            const { _shadowTextureArray } = scene;
            const { width, height } = _shadowTextureArray;

            for (const [ cascadeIndex, cascade ] of _cascades.entries()) {
                const offsetIndex = _casterIndex * cascadesCount + cascadeIndex;

                cascade.renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({ width, height });
                cascade.renderTarget.setDepthStencilAttachment(
                    renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, _shadowTextureArray, texture_Texture.BindingPoint.TEXTURE_2D, offsetIndex
                );
            }
        } else {
            for (const cascade of _cascades) {
                const { texture, depthTexture } = cascade;
                const { width, height } = texture;

                cascade.renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({ width, height });
                cascade.renderTarget.setColorAttachment(
                    renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0, texture
                );
                cascade.renderTarget.setDepthStencilAttachment(
                    renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthTexture, texture_Texture.BindingPoint.TEXTURE_2D
                );
            }
        }
    }

    _calculateFrustumSplits(camera, perCameraData) {
        const { cascadesCount, splitLambda = 0.47 } = this;

        const { znear, zfar } = camera;
        const { frustumSplits } = perCameraData;

        frustumSplits.length = 0;

        // https://github.com/SaschaWillems/Vulkan/blob/master/examples/shadowmappingcascade/shadowmappingcascade.cpp#L748
        const clipRange = zfar - znear;

        const minZ = znear;
        const maxZ = znear + clipRange;

        const range = maxZ - minZ;
        const ratio = maxZ / minZ;

        for (let i = 0; i < cascadesCount; ++i) {
            const p = (i + 1) / cascadesCount;

            const log = minZ * Math.pow(ratio, p);
            const uniform = minZ + range * p;
            const d = splitLambda * (log - uniform) + uniform;

            frustumSplits.push((d - znear) / clipRange);
        }
    }

    _updateSpotShadowCaster(renderPass, light, worldMatrix, shadowCaster) {
        const { scene } = renderPass;
        const { _spotShadowCastersMask, spotCastersDepthTextureArray } = scene;

        if (shadowCaster.castShadow) {
            const { renderer, _shadowMapSizeChanged } = this;
            const { _spotShadowCasters } = scene;

            const { capabilities } = renderer;
            const { webgl2Support } = capabilities;

            shadowCaster._casterIndex = _spotShadowCasters.length;

            if (_shadowMapSizeChanged || spotCastersDepthTextureArray === null) {
                if (!webgl2Support) {
                    this._updateSpotShadowCasterAttachments(scene, shadowCaster);
                }

                this._updateSpotShadowCasterRenderTarget(scene, shadowCaster);
            } else if (shadowCaster._spotShadowCasterData.renderTarget === null) {
                this._updateSpotShadowCasterRenderTarget(scene, shadowCaster);
            }

            this._updateSpotShadowCasterCamera(shadowCaster, worldMatrix);

            shadowCaster._casterIndex = _spotShadowCasters.length;

            _spotShadowCasters.push({ light, shadowCaster });

            _spotShadowCastersMask.push(shadowCaster._casterIndex);
        } else {
            _spotShadowCastersMask.push(-1);
        }
    }

    _updateSpotShadowCasterAttachments(scene, shadowCaster) {
        const { renderer, shadowMapSize } = this;

        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;

        if (webgl2Support) {
            scene._updateSpotCastersDepthTextureArray(shadowMapSize);
        } else {
            const { name, _spotShadowCasterData } = shadowCaster;

            if (_spotShadowCasterData.depthTexture) {
                _spotShadowCasterData.depthTexture.release();
                _spotShadowCasterData.depthTexture = null;
            }

            if (_spotShadowCasterData.depthBuffer) {
                _spotShadowCasterData.depthBuffer.release();
                _spotShadowCasterData.depthBuffer = null;
            }

            const depthTexture = new texture_Texture({
                name: `spot-shadow-map-${name}`,

                width: shadowMapSize,
                height: shadowMapSize,

                bindingPoint: texture_Texture.BindingPoint.TEXTURE_2D,

                magFilter: texture_Texture.Filter.NEAREST,
                minFilter: texture_Texture.Filter.NEAREST,

                wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
                wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

                format: PixelDataFormat.RGBA,
                internalFormat: InternalFormat.RGBA,
                componentType: DataType.UNSIGNED_BYTE,

                levels: 1
            });

            const depthBuffer = new renderBuffer_RenderBuffer({
                width: shadowMapSize,
                height: shadowMapSize,

                internalFormat: InternalFormat.DEPTH_COMPONENT16
            });

            _spotShadowCasterData.depthTexture = depthTexture;
            _spotShadowCasterData.depthBuffer = depthBuffer;
        }
    }

    _updateSpotShadowCasterRenderTarget(scene, shadowCaster) {
        const { renderer, shadowMapSize } = this;

        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;

        const { _casterIndex, _spotShadowCasterData } = shadowCaster;

        if (_spotShadowCasterData.renderTarget) {
            _spotShadowCasterData.renderTarget.release();
            _spotShadowCasterData.renderTarget = null;
        }

        const renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({ width: shadowMapSize, height: shadowMapSize });

        if (webgl2Support) {
            const { spotCastersDepthTextureArray } = scene;

            renderTarget.setDepthStencilAttachment(
                renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT,
                spotCastersDepthTextureArray,
                texture_Texture.BindingPoint.TEXTURE_2D,
                _casterIndex
            );
        } else {
            const { depthTexture, depthBuffer } = _spotShadowCasterData;

            renderTarget.setColorAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0, depthTexture);
            renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthBuffer);
        }

        _spotShadowCasterData.renderTarget = renderTarget;
    }

    _updateOmniShadowCaster(renderPass, light, worldMatrix, shadowCaster) {
        const { scene } = renderPass;

        if (shadowCaster.castShadow) {
            const { _shadowMapSizeChanged } = this;
            const { _omniShadowCasters, _omniShadowCastersMask } = scene;

            const { _omniShadowCasterData } = shadowCaster;
            const { depthTexture } = _omniShadowCasterData;

            if (_shadowMapSizeChanged || depthTexture === null) {
                this._updateOmniShadowCasterAttachments(shadowCaster);
                this._updateOmniShadowCasterRenderTarget(shadowCaster);
            }

            this._updateOmniShadowCasterCamera(shadowCaster, worldMatrix);

            shadowCaster._casterIndex = _omniShadowCasters.length;

            _omniShadowCasters.push({ light, shadowCaster });

            _omniShadowCastersMask.push(shadowCaster._casterIndex);
        } else {
            const { _omniShadowCastersMask } = scene;

            _omniShadowCastersMask.push(-1);
        }
    }

    _updateOmniShadowCasterAttachments(shadowCaster) {
        const { renderer, shadowMapSize } = this;
        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;

        const { name, _omniShadowCasterData } = shadowCaster;
        const { depthBuffers } = _omniShadowCasterData;

        if (_omniShadowCasterData.depthTexture) {
            _omniShadowCasterData.depthTexture.release();
            _omniShadowCasterData.depthTexture = null;
        }

        _omniShadowCasterData.depthTexture = new texture_Texture({
            name: `omni-shadow-depth-cube-map-${name}`,

            width: shadowMapSize,
            height: shadowMapSize,

            bindingPoint: texture_Texture.BindingPoint.TEXTURE_CUBE_MAP,

            magFilter: webgl2Support ? texture_Texture.Filter.LINEAR : texture_Texture.Filter.NEAREST,
            minFilter: webgl2Support ? texture_Texture.Filter.LINEAR : texture_Texture.Filter.NEAREST,

            wrapS: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            wrapT: texture_Texture.WrappingMode.CLAMP_TO_EDGE,
            wrapR: texture_Texture.WrappingMode.CLAMP_TO_EDGE,

            format: webgl2Support ? PixelDataFormat.DEPTH_COMPONENT : PixelDataFormat.RGBA,
            internalFormat: webgl2Support ? InternalFormat.DEPTH_COMPONENT32F : InternalFormat.RGBA,
            componentType: webgl2Support ? DataType.FLOAT : DataType.UNSIGNED_BYTE,

            levels: 1
        });

        if (webgl2Support) {
            _omniShadowCasterData.depthTexture.compareFunc = texture_Texture.CompareFunc.LESS;
            _omniShadowCasterData.depthTexture.compareMode = texture_Texture.CompareMode.COMPARE_REF_TO_TEXTURE;
        } else {
            for (let depthBuffer of depthBuffers) {
                depthBuffer.release();
                depthBuffer = null;
            }

            depthBuffers.length = 0;

            for (let face = 0; face < 6; ++face) {
                const depthBuffer = new renderBuffer_RenderBuffer({
                    width: shadowMapSize,
                    height: shadowMapSize,

                    internalFormat: InternalFormat.DEPTH_COMPONENT16
                });

                depthBuffers.push(depthBuffer);
            }
        }
    }

    _updateOmniShadowCasterRenderTarget(shadowCaster) {
        const { renderer } = this;
        const { capabilities } = renderer;
        const { webgl2Support } = capabilities;

        const { _omniShadowCasterData } = shadowCaster;
        const { depthTexture } = _omniShadowCasterData;
        const { width, height } = depthTexture;

        if (webgl2Support) {
            if (_omniShadowCasterData.renderTarget) {
                _omniShadowCasterData.renderTarget.release();
                _omniShadowCasterData.renderTarget = null;
            }

            const renderTarget = new renderTargetCube_RenderTargetCube({ width, height });

            renderTarget.setDepthStencilAttachment(
                renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT,
                depthTexture,
                texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X
            );

            _omniShadowCasterData.renderTarget = renderTarget;
        } else {
            const { depthBuffers, renderTargets } = _omniShadowCasterData;

            for (let renderTarget of renderTargets) {
                renderTarget.release();
                renderTarget = null;
            }

            renderTargets.length = 0;

            for (const [ face, depthBuffer ] of depthBuffers.entries()) {
                const renderTarget = new renderTargetFramebuffer_RenderTargetFramebuffer({ width, height });

                renderTarget.setDepthStencilAttachment(renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.DEPTH_ATTACHMENT, depthBuffer);

                renderTarget.setColorAttachment(
                    renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0,
                    depthTexture,
                    0,
                    texture_Texture.BindingPoint.TEXTURE_CUBE_MAP_POSITIVE_X + face
                );

                renderTargets.push(renderTarget);
            }
        }
    }

    _disposeResources(scene) {
        scene._disposeShadowTextureArray();
        scene._disposePerCameraData();

        scene._disposeSpotCastersDepthTextureArray();
    }

    /**
     * @function module:@webgears-app/engine-core.Lights#dispose
     * @summary Disposes all resources of the system.
     */
    dispose() { }

    _updateSpotShadowCasterCamera(shadowCaster, worldMatrix) {
        const { _spotShadowCasterData } = shadowCaster;
        const { camera } = _spotShadowCasterData;

        console.assert(camera.isCamera, 'unsupported camera type');

        const { viewMatrix, viewProjectionMatrix } = camera;

        camera.worldMatrix.copy(worldMatrix);
        viewMatrix.copy(worldMatrix).invert();

        const { needsUpdateProjection, projectionMatrix } = camera;

        if (needsUpdateProjection) {
            projectionMatrix.fromWebGLPerspectiveProjection(
                camera.aspect, camera.yfov, camera.znear, camera.zfar
            );

            camera.needsUpdateProjection = false;
        }

        viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);
    }

    static _createCascadeCameras(shadowCaster, name) {
        const { _cascades } = shadowCaster;

        for (const [ i, cascade ] of _cascades.entries()) {
            cascade.camera = new camera_Camera({
                name: `shadow-caster-camera-${name}-cascade${i}`,
                znear: -1,
                zfar: 1,
                orthographicProjection: { xmag: 1, ymag: 1 }
            });

            cascade.camera.projectionType = camera_Camera.ProjectionTypes.ORTHOGRAPHIC;
        }
    }

    static _countEnabledShadowCasters(entityManager) {
        let enabledDirectShadowCastersCount = 0;
        let enabledSpotShadowCastersCount = 0;
        let enabledOmniShadowCastersCount = 0;

        const storage = entityManager.getComponentStorage(lightShadowCaster_LightShadowCaster);

        for (const [entity, lightShadowCaster] of storage.entries()) {
            const [ light ] = entityManager.getEntityComponents(entity, lightComponentClasses);

            if (!lightShadowCaster.castShadow) { continue; }

            if (light.isDirectionalLight) {
                ++enabledDirectShadowCastersCount;
            } else if (light.isSpotLight) {
                ++enabledSpotShadowCastersCount;
            } else if (light.isPointLight) {
                ++enabledOmniShadowCastersCount;
            }
        }

        return {
            enabledDirectShadowCastersCount,
            enabledSpotShadowCastersCount,
            enabledOmniShadowCastersCount
        };
    }

    static get spotDirectionalCastersZFar() {
        return 100;
    }

    static get omniDirectionalCastersZFar() {
        return 100;
    }
}

Object.assign(lights_Lights.prototype, {
    _calculateCameraAABBs: (function __calculateCameraAABBs() {
        const multipliers = [
            new Vector3(+1, +1, -1),
            new Vector3(-1, +1, -1),
            new Vector3(-1, -1, -1),
            new Vector3(+1, -1, -1)
        ];

        const frustumNearCorner = new Vector3();
        const frustumFarCorner = new Vector3();

        return function _calculateCameraAABBs(camera, perCameraData) {
            console.assert(camera.isCamera, 'unsupported camera type');

            const { aspect, yfov, worldMatrix } = camera;

            const range = camera.zfar - camera.znear;

            let { znear } = camera;

            const halfFovY = Math.tan(yfov * 0.5);
            const halfFovX = halfFovY * aspect;

            const { frustumSplits, cascadesPlanes } = perCameraData;

            cascadesPlanes.length = 0;

            for (const depth of frustumSplits) {
                const zfar = Math.ceil(range * depth) * 1.1;

                const xnear = znear * halfFovX;
                const xfar = zfar * halfFovX;

                const ynear = znear * halfFovY;
                const yfar = zfar * halfFovY;

                frustumNearCorner.set(xnear, ynear, znear);
                frustumFarCorner.set(xfar, yfar, zfar);

                const planes = [];

                for (const multiplier of multipliers) {
                    const cascadeNearPoint = new Vector3();
                    const cascadeFarPoint = new Vector3();

                    cascadeNearPoint.copy(frustumNearCorner);

                    cascadeNearPoint.multiplyVector(multiplier);
                    cascadeNearPoint.applyAffineMatrix(worldMatrix);

                    cascadeFarPoint.copy(frustumFarCorner);

                    cascadeFarPoint.multiplyVector(multiplier);
                    cascadeFarPoint.applyAffineMatrix(worldMatrix);

                    planes.push([ cascadeNearPoint, cascadeFarPoint ]);
                }

                znear = Math.floor(range * depth);//zfar - 1;

                cascadesPlanes.push(planes);
            }
        };
    }()),

    _calculateCascadeCameraProjection: (function __calculateCascadeCameraProjection() {
        const positiveInf = new Vector3().fromNumber(+Infinity);
        const negativeInf = new Vector3().fromNumber(-Infinity);

        const bbox = new rectangle_and_box_Box();

        const zInverter = new Vector3(1, 1, -1);

        let minZ = +Infinity;

        return function _calculateCascadeCameraProjection(camera, cascadePlanes) {
            console.assert(camera.isCamera, 'unsupported camera type');

            bbox.set(positiveInf, negativeInf);

            const { viewMatrix, projectionMatrix, viewProjectionMatrix } = camera;

            for (const [ nearPoint, farPoint ] of cascadePlanes) {
                {
                    const clone = nearPoint.clone();

                    clone.applyAffineMatrix(viewMatrix);
                    clone.multiplyVector(zInverter);

                    bbox.consumePoint(clone);
                }

                {
                    const clone = farPoint.clone();

                    clone.applyAffineMatrix(viewMatrix);
                    clone.multiplyVector(zInverter);

                    bbox.consumePoint(clone);
                }
            }

            const { min, max } = bbox;

            minZ = min.z < minZ ? min.z : minZ;

            const w = Math.max(Math.abs(min.x), Math.abs(max.x));
            const h = Math.max(Math.abs(min.y), Math.abs(max.y));

            projectionMatrix.fromWebGLOrthographicProjection(w * 2, h * 2, minZ, max.z);
            // projectionMatrix.fromWebGLOrthographicAsymmetricProjection(min.x, max.x, min.y, max.y, minZ, max.z);

            viewProjectionMatrix.fromAffine(viewMatrix).multiply(projectionMatrix);

            camera.needsUpdateProjection = false;
        };
    }()),

    _updateOmniShadowCasterCamera: (function __updateOmniShadowCasterCamera() {
        const tempMatrix = new AffineMatrix3();
        const tempVector = new Vector3();

        const perCubeFaceMatrices = [
            new AffineMatrix3().fromLookDirection(new Vector3(+1, 0, 0), new Vector3(0, -1, 0)), // +x
            new AffineMatrix3().fromLookDirection(new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -x
            new AffineMatrix3().fromLookDirection(new Vector3(0, -1, 0), new Vector3(0, 0, -1)), // +y
            new AffineMatrix3().fromLookDirection(new Vector3(0, +1, 0), new Vector3(0, 0, +1)), // -y
            new AffineMatrix3().fromLookDirection(new Vector3(0, 0, +1), new Vector3(0, -1, 0)), // +z
            new AffineMatrix3().fromLookDirection(new Vector3(0, 0, -1), new Vector3(0, -1, 0))  // -z
        ];

        return function _updateOmniShadowCasterCamera(shadowCaster, worldMatrix) {
            const { _omniShadowCasterData } = shadowCaster;
            const { cubeCamera } = _omniShadowCasterData;

            console.assert(cubeCamera.isCubeCamera, 'unsupported camera type');

            worldMatrix.translationPaste(tempVector);

            tempMatrix.translationCopy(tempVector);
            tempMatrix.invert();

            const { viewMatrices, viewProjectionMatrices } = cubeCamera;

            for (const [ i, viewMatrix ] of viewMatrices.entries()) {
                viewMatrix.copy(tempMatrix).multiply(perCubeFaceMatrices[i]);
            }

            const { needsUpdateProjection, projectionMatrix } = cubeCamera;

            if (needsUpdateProjection) {
                cubeCamera.projectionMatrix.fromWebGLPerspectiveProjection(
                    cubeCamera.aspect, cubeCamera.yfov, cubeCamera.znear, cubeCamera.zfar
                );

                cubeCamera.needsUpdateProjection = false;
            }

            for (const [ i, viewProjectionMatrix ] of viewProjectionMatrices.entries()) {
                viewProjectionMatrix.fromAffine(viewMatrices[i]).multiply(projectionMatrix);
            }
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/meshes/index.js









const lateUpdateComponents = [mesh_Mesh];

const meshes_worldBoundingBox = new rectangle_and_box_Box();
const meshes_center = new Vector3();

function _onLightCountChanged(entityManager) {
    const storage = entityManager.getComponentStorage(mesh_Mesh);

    for (const mesh of storage.components()) {
        for (const subMesh of mesh.subMeshes()) {
            if (subMesh.material.lit) subMesh.material.needsUpdate = true;
        }
    }
}

function _onDetachMesh(entityManager, mesh) {
    const { _scene } = entityManager;
    const { instanceDataManager, _instanceKeys, spatialIndex } = _scene;
    const { subMeshCount } = mesh;

    for (let i = 0; i < subMeshCount; i++) {
        const subMesh = mesh.getSubMesh(i);

        if (subMesh.instanceId !== null) {
            instanceDataManager.deleteInstance(subMesh);
        }

        const instanceKey = _instanceKeys.get(subMesh);
        _instanceKeys.delete(subMesh);
        spatialIndex.remove(instanceKey);
    }

    _scene._forceUpdateRenderQueue = true;
}

class meshes_Meshes extends System {
    constructor() {
        super();
        this._depthMaterials = new WeakMap();

        this.renderer = null;
    }

    init(renderer) {
        this.renderer = renderer;

        EntityManager.onAttach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            if (light_Light.index === index) {
                _onLightCountChanged(entityManager);
            }
        });

        EntityManager.onDetach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            switch (index) {
                case light_Light.index:
                    _onLightCountChanged(entityManager);
                    break;
                case mesh_Mesh.index:
                    _onDetachMesh(entityManager, component);
                    break;
                default:
            }
        });

        super.init();
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                this._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                meshes_Meshes._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ srcScene, dstScene, copyContext }) {
        const {
            nodeToNode = new Map(),
            skeletonToSkeleton = new Map(),
            cloneMaterials = false
        } = copyContext;

        const materialToMaterial = new Map();

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcMesh] = srcNode.getComponents([mesh_Mesh]);

            if (srcMesh === null) continue;

            const dstMesh = srcMesh.clone();

            if (cloneMaterials) {
                const { subMeshCount } = srcMesh;

                for (let i = 0; i < subMeshCount; i++) {
                    const srcSubMesh = srcMesh.getSubMesh(i);

                    const srcMaterial = srcSubMesh.material;

                    const dstSubMesh = dstMesh.getSubMesh(i);

                    let dstMaterial = materialToMaterial.get(srcMaterial);

                    if (dstMaterial === undefined) {
                        dstMaterial = srcMaterial.clone();
                        materialToMaterial.set(srcMaterial, dstMaterial);
                    }

                    dstSubMesh.material = dstMaterial;
                }
            }

            const srcSkeleton = srcMesh.skeleton;

            const srcSkeletonIndex = srcScene.getSkeletonIndex(srcSkeleton);
            const dstSkeletonIndex = skeletonToSkeleton.get(srcSkeletonIndex);

            const dstSkeleton = dstSkeletonIndex !== undefined ? dstScene.getSkeleton(dstSkeletonIndex) : null;

            dstMesh.skeleton = dstSkeleton;

            dstNode.attach(dstMesh);
        }
    }

    static _validateInstanceKey(instanceDataManager, scene, renderable, instanceKey) {
        const { instanceId, instanceIndex } = renderable;

        const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

        if (batchRenderable === undefined) {
            scene._instanceKeys.delete(renderable);
            scene.spatialIndex.remove(instanceKey);
        } else if (instanceKey !== undefined) {
            const { batchIdx } = batchRenderable;

            const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

            instanceKey.batchSetIdx = 0;
            instanceKey.globalIndex = globalIndex;
        }
    }

    static _validateInstanceKeys(instanceDataManager, scene) {
        for (const [r, ik] of scene._instanceKeys.entries()) {
            meshes_Meshes._validateInstanceKey(instanceDataManager, scene, r, ik);
        }
    }

    _earlyUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;

        const { entityManager, instanceDataManager, _instanceKeys, _forceUpdateRenderQueue } = scene;

        if (_forceUpdateRenderQueue) {
            scene._lastFrameSceneGraphUpdate = frameNumber;
            scene._forceUpdateRenderQueue = false;
        }

        if (!entityManager.isComponent(mesh_Mesh)) return;

        const storage = entityManager.getComponentStorage(mesh_Mesh);

        let needsValidateInstanceKeys = false;

        for (const mesh of storage.components()) {
            const { subMeshCount } = mesh;

            for (let i = 0; i < subMeshCount; i++) {
                const subMesh = mesh.getSubMesh(i);
                if (subMesh.unloaded) continue;

                if (subMesh.instanceId === null || subMesh._instanceIdentifierExpired) {
                    instanceDataManager.addInstance(subMesh);

                    subMesh._lastUpdateFrameNumber = frameNumber;
                    mesh._lastUpdateFrameNumber = frameNumber;

                    if (subMesh._instanceIdentifierExpired) {
                        meshes_Meshes._validateInstanceKey(
                            instanceDataManager, scene, subMesh, _instanceKeys.get(subMesh)
                        );
                    } else {
                        needsValidateInstanceKeys = true;
                    }

                    instanceDataManager.setInstanceVisibility(subMesh, true, true);

                    scene._lastFrameSceneGraphUpdate = frameNumber;
                }

                if (subMesh.geometry.needsUpdateBoundingBox) {
                    subMesh.geometry.updateBoundingBox();
                }

                const { _customAttributesToWrite, _customAttributesToRead } = subMesh;

                for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
                    const { semantic, inVal } = _customAttributesToWrite.shift();

                    instanceDataManager.setInstancedAttribute(subMesh, semantic, inVal);

                    scene._lastFrameSceneGraphUpdate = frameNumber;
                }

                for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
                    const { resolve, semantic, outVal } = _customAttributesToRead.pop();

                    resolve(instanceDataManager.getInstancedAttribute(subMesh, semantic, outVal));
                }

                this._updateDepthMaterial(instanceDataManager, subMesh);
            } // subMesh cycle
        }

        if (needsValidateInstanceKeys) {
            meshes_Meshes._validateInstanceKeys(instanceDataManager, scene);
        }
    }

    _lateUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;
        const { instanceDataManager, _instanceKeys, entityManager, spatialIndex } = scene;

        if (!entityManager.isComponent(transform_Transform)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(transform_Transform);

        for (const [entity, transform] of storage.entries()) {
            const [ mesh ] = entityManager.getEntityComponents(entity, lateUpdateComponents, components);

            if (mesh === null) continue;

            const { skeleton, _lastUpdateFrameNumber } = mesh;

            const { state, worldMatrix } = skeleton !== null ? skeleton.root : transform;
            const needsUpdateWorldMatrix = (state & transform_Transform.StateMask.UPDATE_WORLD) !== 0;

            if (!needsUpdateWorldMatrix && _lastUpdateFrameNumber < frameNumber) continue;

            mesh._lastUpdateFrameNumber = frameNumber;

            const { subMeshCount } = mesh;

            for (let i = 0; i < subMeshCount; i++) {
                const subMesh = mesh.getSubMesh(i);
                if (subMesh.unloaded) continue;

                const { instanceId, instanceIndex, geometry, id } = subMesh;
                const { boundingBox } = geometry;
                const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

                const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

                instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
                instanceDataManager.storeRenderableIdentifier(globalIndex, id);

                let instanceKey = _instanceKeys.get(subMesh);
                if (instanceKey === undefined) {
                    instanceKey = {
                        node: scene._entityToNode.get(entity),
                        renderable: subMesh,
                        batchSetIdx: 0,
                        globalIndex
                    };

                    _instanceKeys.set(subMesh, instanceKey);
                }

                meshes_worldBoundingBox.copy(boundingBox).applyAffineMatrix(worldMatrix);
                spatialIndex.insert(instanceKey, meshes_worldBoundingBox);

                meshes_worldBoundingBox.centerPaste(meshes_center);
                instanceDataManager.storeCenter(meshes_center, globalIndex);

                scene._lastFrameSceneGraphUpdate = frameNumber;
            }
        }
    }

    _updateDepthMaterial(instanceDataManager, subMesh) {
        const { material } = subMesh;
        const { castShadow } = material;

        if (castShadow) {
            for (const [ i, _depthMaterial ] of subMesh._depthMaterials.entries()) {
                if (_depthMaterial === null) {
                    const { renderer } = this;
                    const { _depthMaterials } = renderer;
                    const { skeleton = null, instanceId, depthMaterials } = subMesh;

                    const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);
                    const { morphWeights } = batchRenderable;

                    if (skeleton === null && morphWeights === null) {
                        depthMaterials[i] = _depthMaterials[i];
                    } else {
                        let depthMaterials_ = this._depthMaterials.get(material);

                        if (depthMaterials_ === undefined) {
                            depthMaterials_ = [null, null];
                            this._depthMaterials.set(material, depthMaterials_);
                        }

                        if (depthMaterials_[i] !== null) {
                            depthMaterials[i] = depthMaterials_[i];
                        } else {
                            const depthMaterial = _depthMaterials[i].clone();

                            depthMaterial.name = `${subMesh.name}_depthmat${i}`;

                            depthMaterials[i] = depthMaterial;

                            depthMaterials_[i] = depthMaterial;
                        }
                    }

                    batchRenderable.depthMaterials[i] = depthMaterials[i];
                }
            }
        } else {
            for (const [ i, _depthMaterial ] of subMesh._depthMaterials.entries()) {
                if (_depthMaterial !== null) {
                    const { instanceId } = subMesh;

                    const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

                    subMesh._depthMaterials[i] = null;
                    batchRenderable.depthMaterials[i] = null;
                }
            }
        }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lines/line.js





class line_LineRenderable extends renderable_Renderable {
    /**
     * @var module:@webgears-app/engine-core.LineRenderable#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether the lines systems should update bounding sphere.
     */
    get needsUpdate() {
        return this.geometry !== null ? this.geometry.needsUpdateBoundingBox : false;
    }
}

/**
 * @class module:wg-engine-core.Line
 * @extends module:wg-engine-core.Component
 * @summary The class encapsulates data about 3D line renderable.
 * @param {string} [name=''] The name of the line component.
 * @param {module:@webgears-app/engine-core.Geometry} geometry The geometry of the line component.
 * @param {module:@webgears-app/engine-core.Material} material The material of the line component.
 */
class line_Line extends component_Component {
    constructor({ geometry, material, name = '' }) {
        super();

        this._name = name;

        this._lineRenderable = new line_LineRenderable(geometry, material);
    }

    /**
     * @function module:@webgears-app/engine-core.Line#getInstancedAttribute
     * @summary Returns value of the instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {?Vector2|Vector3|RGBColor|Array|Float32Array} outVal The output value.
     * @returns {Promise<number|Vector2|Vector3|RGBColor|Array|Float32Array>}
     */
    getInstancedAttribute(semantic, outVal) {
        return this._lineRenderable.getInstancedAttribute(semantic, outVal);
    }

    /**
     * @function module:@webgears-app/engine-core.Line#setInstancedAttribute
     * @summary Sets value of instanced attribute.
     * @param {module:@webgears-app/engine-core.AttributeSemantic} semantic Semantic of the attribute.
     * @param {number|Vector2|Vector3|RGBColor|Array|Float32Array} inVal The value of the attribute.
     */
    setInstancedAttribute(semantic, inVal) {
        this._lineRenderable.setInstancedAttribute(semantic, inVal);
    }

    /**
     * @var module:wg-engine-core.Line#material
     * @readonly
     * @type {string}
     * @summary The material of the line renderable.
     */
    get material() {
        return this._lineRenderable.material;
    }

    /**
     * @var module:wg-engine-core.Line#name
     * @readonly
     * @type {string}
     * @summary The name of the line component.
     */
    get name() {
        return this._name;
    }

    clone(newName) {
        const { name, _lineRenderable } = this;
        const { geometry, material } = _lineRenderable;

        return new line_Line({ geometry, material, name: newName || name });
    }

    unload() {
        this._lineRenderable.unload();
        super.unload();
    }

    _dispose() {
        this._lineRenderable.dispose();
        this._lineRenderable = null;

        super._dispose();
    }
}

Object.defineProperty(line_Line.prototype, 'isLine', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/visibilities/index.js









const updateComponemts1 = [mesh_Mesh];
const updateComponemts2 = [sprite_Sprite];
const updateComponemts3 = [line_Line];

class visibilities_Visibilities extends System {
    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                visibilities_Visibilities._earlyUpdate(renderPass);
                break;
            default:
        }
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                visibilities_Visibilities._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ copyContext }) {
        const { nodeToNode = new Map() } = copyContext;
        const classes = [visibility_Visibility];

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcVisibility] = srcNode.getComponents(classes);
            let [dstVisibility] = dstNode.getComponents(classes);

            if (srcVisibility === null) continue;

            dstVisibility = srcVisibility.clone();

            dstNode.attach(dstVisibility);
        }
    }

    static _earlyUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;

        const { entityManager, instanceDataManager } = scene;

        if (!entityManager.isComponent(visibility_Visibility)) return;

        const hasMeshes = entityManager.isComponent(mesh_Mesh);
        const hasSprites = entityManager.isComponent(sprite_Sprite);
        const hasLines = entityManager.isComponent(line_Line);

        const components = [];
        const storage = entityManager.getComponentStorage(visibility_Visibility);

        for (const [entity, visibility] of storage.entries()) {
            const { needsUpdate } = visibility;

            if (needsUpdate) scene._lastFrameSceneGraphUpdate = frameNumber;

            if (hasMeshes) {
                const [mesh] = entityManager.getEntityComponents(entity, updateComponemts1, components);

                if (mesh !== null) { // tests SubMesh only
                    const { subMeshCount } = mesh;

                    for (let i = 0; i < subMeshCount; i++) {
                        const subMesh = mesh.getSubMesh(i);
                        const { lastUpdateFrameNumber, unloaded } = subMesh;

                        if (unloaded) continue;

                        if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
                            const {visible, enableCulling: enabled} = visibility;
                            instanceDataManager.setInstanceVisibility(subMesh, visible, enabled);
                        }
                    }
                }
            }

            if (hasSprites) {
                const [sprite] = entityManager.getEntityComponents(entity, updateComponemts2, components);

                if (sprite !== null && !sprite.unloaded) {
                    const { _spriteRenderable } = sprite;
                    const { lastUpdateFrameNumber } = _spriteRenderable;

                    if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
                        const { visible } = visibility;
                        instanceDataManager.setInstanceVisibility(_spriteRenderable, visible, false);
                    }
                }
            }

            if (hasLines) {
                const [line] = entityManager.getEntityComponents(entity, updateComponemts3, components);

                if (line !== null && !line.unloaded) {
                    const { _lineRenderable } = line;
                    const { lastUpdateFrameNumber } = _lineRenderable;

                    if (needsUpdate || lastUpdateFrameNumber === frameNumber) {
                        const {visible, enableCulling: enabled} = visibility;
                        instanceDataManager.setInstanceVisibility(_lineRenderable, visible, enabled);
                    }
                }
            }

            visibility._needsUpdate = false;
        } // components
    }
}




// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/sprites/index.js








const sprites_lateUpdateComponents = [transform_Transform];

const sprites_position = new Vector3();

class sprites_Sprites extends System {
    constructor() {
        super();

        this.renderer = null;
    }

    init(renderer) {
        EntityManager.onDetach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            if (sprite_Sprite.index === index) {
                const { _scene } = entityManager;
                const { instanceDataManager } = _scene;
                const { _spriteRenderable } = component;

                if (_spriteRenderable.instanceId !== null) {
                    instanceDataManager.deleteInstance(_spriteRenderable);
                }

                _scene._forceUpdateRenderQueue = true;
            }
        });

        this.renderer = renderer;

        super.init();
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                sprites_Sprites._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _earlyUpdate(renderPass) {
        const { renderer } = this;
        const { screenSquare } = renderer;
        const { scene, frameNumber } = renderPass;
        const { instanceDataManager, entityManager, _forceUpdateRenderQueue } = scene;

        if (_forceUpdateRenderQueue) {
            scene._lastFrameSceneGraphUpdate = frameNumber;
            scene._forceUpdateRenderQueue = false;
        }

        if (!entityManager.isComponent(sprite_Sprite)) return;

        const storage = entityManager.getComponentStorage(sprite_Sprite);

        for (const sprite of storage.components()) {
            if (sprite.unloaded) continue;

            const { _spriteRenderable } = sprite;

            const { needsUpdate } = _spriteRenderable;

            if (needsUpdate) {
                _spriteRenderable.geometry = screenSquare;
                _spriteRenderable.needsUpdate = false;
            }

            if (_spriteRenderable.instanceId === null || _spriteRenderable._instanceIdentifierExpired) {
                instanceDataManager.addInstance(_spriteRenderable);
                instanceDataManager.setInstanceVisibility(_spriteRenderable, true, false);
                _spriteRenderable._lastUpdateFrameNumber = frameNumber;
                scene._lastFrameSceneGraphUpdate = frameNumber;
            }

            const { _customAttributesToWrite, _customAttributesToRead } = _spriteRenderable;

            for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
                const { semantic, inVal } = _customAttributesToWrite.pop();
                instanceDataManager.setInstancedAttribute(_spriteRenderable, semantic, inVal);
                scene._lastFrameSceneGraphUpdate = frameNumber;
            }

            for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
                const { resolve, semantic, outVal } = _customAttributesToRead.pop();
                resolve(instanceDataManager.getInstancedAttribute(_spriteRenderable, semantic, outVal));
            }
        }
    }

    static _lateUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;
        const { instanceDataManager, entityManager } = scene;

        if (!entityManager.isComponent(sprite_Sprite)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(sprite_Sprite);

        for (const [entity, sprite] of storage.entries()) {
            if (sprite.unloaded) continue;

            const [transform] = entityManager.getEntityComponents(entity, sprites_lateUpdateComponents, components);

            const { state, worldMatrix } = transform;

            const { _spriteRenderable } = sprite;

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0
                || _spriteRenderable.lastUpdateFrameNumber === frameNumber) {
                const {instanceId, instanceIndex, id} = _spriteRenderable;

                const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

                const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

                instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
                instanceDataManager.storeRenderableIdentifier(globalIndex, id);

                worldMatrix.translationPaste(sprites_position);
                instanceDataManager.storeCenter(sprites_position, globalIndex);

                scene._lastFrameSceneGraphUpdate = frameNumber;
            }
        } // components
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                sprites_Sprites._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ copyContext }) {
        const {
            nodeToNode = new Map(),
            cloneMaterials = false
        } = copyContext;

        const materialToMaterial = new Map();

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcSprite] = srcNode.getComponents([sprite_Sprite]);

            if (srcSprite === null) continue;

            const dstSprite = srcSprite.clone();

            if (cloneMaterials) {
                const srcMaterial = srcSprite.material;

                let dstMaterial = materialToMaterial.get(srcMaterial);

                if (dstMaterial === undefined) {
                    dstMaterial = srcMaterial.clone();
                    materialToMaterial.set(srcMaterial, dstMaterial);
                }

                dstSprite._spriteRenderable.material = dstMaterial;
            }

            dstNode.attach(dstSprite);
        }
    }

    dispose() { }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/transforms/index.js









const transforms_splitTransform = new AffineSplitTransform3();
const reverseTransform = new AffineMatrix3();

class transforms_Visitor {
    constructor(visitCallback) {
        this._visit = visitCallback;
        this._classes = [transform_Transform];
        this._renderableClasses = [mesh_Mesh, sprite_Sprite];
        this._components = [];
        this._renderables = [];
        this._matrix = new AffineMatrix3();
    }

    _apply(node, entities, instances) {
        const { _classes, _components, _visit, _matrix } = this;
        const { entity, children, parent } = node;
        const [ xfrm = null ] = entities.getEntityComponents(entity, _classes, _components);

        if (xfrm === null) return;

        const [ parentXfrm ] = parent !== null
            ? entities.getEntityComponents(parent.entity, _classes, _components)
            : (_components[0] = null, _components);

        if (xfrm.state === transform_Transform.StateMask.UPDATE_ALL) {
            const { _renderableClasses, _renderables } = this;

            const [mesh, sprite] = entities.getEntityComponents(entity, _renderableClasses, _renderables);

            if (mesh !== null) {
                const sm = mesh.getSubMesh(0);
                const { instanceId, instanceIdentifierExpired, instanceIndex } = sm;

                transforms_Visitor._readWorldMatrix(_matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex);
            } else if (sprite !== null) {
                const { renderable } = sprite;
                const { instanceId, instanceIdentifierExpired, instanceIndex } = renderable;

                transforms_Visitor._readWorldMatrix(_matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex);
            } else {
                transforms_Visitor._readWorldMatrix(_matrix, instances, null, false, 0);
            }
        }

        _visit(xfrm, parentXfrm, _matrix);

        for (const child of children) this._apply(child, entities, instances);
    }

    apply(scene) {
        const { root, entityManager, instanceDataManager } = scene;
        this._apply(root, entityManager, instanceDataManager);
    }

    static _readWorldMatrix(matrix, instances, instanceId, instanceIdentifierExpired, instanceIndex) {
        if (instanceId === null || instanceIdentifierExpired) {
            matrix.fromNumber(1.0);
        } else {
            const { batchIdx } = instances.getInstanceRenderable(instanceId);
            const globalIndex = instances.getInstanceGlobalIndex(batchIdx, instanceIndex);

            instances.readWorldTransform(matrix, globalIndex);
        }
    }
}

const visitor = new transforms_Visitor(function _callback(xfrm, xfrmParent, _matrix) {
    if (xfrm.state === transform_Transform.StateMask.UPDATE_ALL) {
        xfrm.worldMatrix.copy(_matrix);
        xfrm.state = transform_Transform.StateMask.UPDATE_LOCAL | transform_Transform.StateMask.UPDATE_COMPONENTS;
    }

    if ((xfrm.state & transform_Transform.StateMask.UPDATE_LOCAL) !== 0
        && (xfrm.state & transform_Transform.StateMask.UPDATE_COMPONENTS) === 0) {
        const { position, scale, orientation, matrix } = xfrm;

        transforms_splitTransform.translation.copy(position);
        transforms_splitTransform.scaling.copy(scale);
        transforms_splitTransform.quaternion.copy(orientation);

        matrix.fromSplitTransform(transforms_splitTransform);

        xfrm.state = transform_Transform.StateMask.UPDATE_WORLD;
    } else if ((xfrm.state & transform_Transform.StateMask.UPDATE_LOCAL) === 0
        && (xfrm.state & transform_Transform.StateMask.UPDATE_COMPONENTS) !== 0) {
        const { position, scale, orientation, matrix } = xfrm;
        transforms_splitTransform.fromMatrix(matrix);

        position.copy(transforms_splitTransform.translation);
        scale.copy(transforms_splitTransform.scaling);
        orientation.copy(transforms_splitTransform.quaternion);

        xfrm.state = transform_Transform.StateMask.UPDATE_WORLD;
    } else if ((xfrm.state & transform_Transform.StateMask.UPDATE_LOCAL) !== 0
        && (xfrm.state & transform_Transform.StateMask.UPDATE_COMPONENTS) !== 0
        && (xfrm.state & transform_Transform.StateMask.UPDATE_WORLD) === 0) {
        const { position, scale, orientation, matrix, worldMatrix } = xfrm;

        if (xfrmParent === null) {
            matrix.copy(worldMatrix);
        } else {
            reverseTransform.copy(xfrmParent.worldMatrix).invert();
            matrix.copy(worldMatrix);
            matrix.preMultiply(reverseTransform);
        }

        transforms_splitTransform.fromMatrix(matrix);

        position.copy(transforms_splitTransform.translation);
        scale.copy(transforms_splitTransform.scaling);
        orientation.copy(transforms_splitTransform.quaternion);

        // in case transform restored back from instanced data
        xfrm.state = transform_Transform.StateMask.UPDATE_NOTHING;
    }

    const parentUpdated = xfrmParent === null ? false : (xfrmParent.state & transform_Transform.StateMask.UPDATE_WORLD) !== 0;

    if (xfrm.state === transform_Transform.StateMask.UPDATE_WORLD || parentUpdated) {
        const { matrix, worldMatrix } = xfrm;

        if (xfrmParent === null) worldMatrix.copy(matrix);
        else worldMatrix.copy(matrix).multiply(xfrmParent.worldMatrix);

        xfrm.state = transform_Transform.StateMask.UPDATE_WORLD;
    }
});

class transforms_Transforms extends System {
    init() {
        super.init();
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                transforms_Transforms._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                transforms_Transforms._lateUpdate(renderPass);
                break;
            default:
        }
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                transforms_Transforms._copyFromScene(data);
                break;
            default:
        }
    }


    static _copyFromScene({ copyContext }) {
        const { nodeToNode } = copyContext;

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcTransform] = srcNode.getComponents([transform_Transform]);
            const [dstTransform] = dstNode.getComponents([transform_Transform]);

            if (dstTransform === null && srcTransform !== null) {
                dstNode.attach(srcTransform.clone());
            } else if (dstTransform !== null && srcTransform !== null) {
                dstTransform.position.copy(srcTransform.position);
                dstTransform.scale.copy(srcTransform.scale);
                dstTransform.orientation.copy(srcTransform.orientation);
                dstTransform.matrix.copy(srcTransform.matrix);
                dstTransform.state = srcTransform.state | transform_Transform.StateMask.UPDATE_WORLD;
            }
        }
    }

    static _earlyUpdate(renderPass) {
        const { scene } = renderPass;
        visitor.apply(scene);
    }

    static _lateUpdate(renderPass) {
        const { scene } = renderPass;
        const { entityManager } = scene;

        const storage = entityManager.getComponentStorage(transform_Transform);

        for (const transform of storage.components()) {
            transform.state = transform_Transform.StateMask.UPDATE_NOTHING;
        }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/morphs/index.js









const _lateUpdateClasses = [mesh_Mesh];

const _positionMorphTargets = [
    AttributeSemantic.POSITION_MORPH_0,
    AttributeSemantic.POSITION_MORPH_1,
    AttributeSemantic.POSITION_MORPH_2,
    AttributeSemantic.POSITION_MORPH_3,
    AttributeSemantic.POSITION_MORPH_4,
    AttributeSemantic.POSITION_MORPH_5,
    AttributeSemantic.POSITION_MORPH_6,
    AttributeSemantic.POSITION_MORPH_7
];

const _normalMorphTargets = [
    AttributeSemantic.NORMAL_MORPH_0,
    AttributeSemantic.NORMAL_MORPH_1,
    AttributeSemantic.NORMAL_MORPH_2,
    AttributeSemantic.NORMAL_MORPH_3,
    AttributeSemantic.NORMAL_MORPH_4,
    AttributeSemantic.NORMAL_MORPH_5,
    AttributeSemantic.NORMAL_MORPH_6,
    AttributeSemantic.NORMAL_MORPH_7
];

class _WeightImportance {
    constructor(weights) {
        this.sortedIndices = new Int8Array(weights.length);
        this.importantIndices = new Int8Array(3);
        this.importantWeights = new Float32Array(3);
        this.prevImportantIndices = new Int8Array(3);
    }

    update(weights) {
        // save importance of previous time frame
        this.importantIndices.forEach((value, index) => this.prevImportantIndices[index] = value );
        // sort indices of morph targets by provided weights
        this.sortedIndices.forEach( (value,index) => this.sortedIndices[index] = index );
        this.sortedIndices.sort( (a,b) => Math.abs(weights[b]) - Math.abs(weights[a]) );
        // save subset of most important indices
        this.importantIndices.forEach( (value,index) => this.importantIndices[index] = this.sortedIndices[index] );
        // sort this subset to provide easy consistency check
        this.importantIndices.sort( (a,b) => a-b );
        // save subset of most important weights
        this.importantWeights.forEach( (value,index) => this.importantWeights[index] = weights[this.importantIndices[index]] );
    }

    get isConsistent() {
        // consistency of important indices between sequential time frames
        return this.importantIndices.every( (value,index) => value == this.prevImportantIndices[index] );
    }
}

class _WeightImportanceMap {
    constructor() {
        this._map = new Map();
    }

    has(morph) {
        return this._map.has(morph);
    }

    add(morph) {
        this._map.set(morph, new _WeightImportance(morph.weights));
    }

    get(morph) {
        return this._map.get(morph);
    }
}

class morphs_Morphs extends System  {
    constructor() {
        super();
        this.renderer = null;
        this.weightImportanceMap = new _WeightImportanceMap();
    }

    init(renderer) {
        this.renderer = renderer;

        EntityManager.onDetach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            if (index === morph_Morph.index) {
                const { _scene } = entityManager;
                const { instanceDataManager } = _scene;
                const [mesh] = entityManager.getEntityComponents(entity, _lateUpdateClasses);

                for (const subMesh of mesh.subMeshes()) {
                    const { instanceId, material } = subMesh;

                    const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

                    batchRenderable.positionMorphTargetCount = 0;
                    batchRenderable.normalMorphTargetCount = 0;
                    batchRenderable.morphWeights = null;

                    material.needsUpdate = true;
                }
            }
        });

        super.init();
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                morphs_Morphs._copyFromScene(data);
                break;
            default:
        }
    }

    static _copyFromScene({ copyContext }) {
        const { nodeToNode } = copyContext;

        for (const [srcNode, dstNode] of nodeToNode.entries()) {
            const [srcMorph] = srcNode.getComponents([morph_Morph]);

            if (srcMorph === null) continue;

            const dstMorph = srcMorph.clone();

            dstNode.attach(dstMorph);
        }
    }

    _update(stage, renderPass) {
        if (stage === systemManager_SystemManager.EARLY_UPDATE_STAGE) {
            morphs_Morphs._earlyUpdate(renderPass, this.renderer, this.weightImportanceMap);
        }
    }

    static _copyMorphTargetToMorphAttribute(morphTarget, morphAttribute, vertexStaging) {
        const {view: attrView, stride, countComponents, countElements} = morphAttribute;

        if (stride === countComponents * Float32Array.BYTES_PER_ELEMENT) {
            attrView.set(morphTarget.view);
        } else {
            for(let elementIdx = 0; elementIdx < countElements; elementIdx++) {
                let dstArrayIdx = elementIdx * stride / Float32Array.BYTES_PER_ELEMENT;
                let srcArrayIdx = elementIdx * countComponents;

                for(let componentIdx = 0; componentIdx < countComponents; componentIdx++) {
                    attrView[dstArrayIdx + componentIdx] = morphTarget.view[srcArrayIdx + componentIdx];
                }
            }
        }

        vertexStaging.subdatas.push({
            offset: attrView.byteOffset,
            size: attrView.byteLength
        });
    }

    static _earlyUpdate(renderPass, renderer, weightImportanceMap) {
        const { scene } = renderPass;
        const { entityManager, instanceDataManager } = scene;

        if (!entityManager.isComponent(morph_Morph)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(morph_Morph);

        for (const [entity, morph] of storage.entries()) {
            if (!morph.needsUpdate) continue;

            const { weights } = morph;

            if( weights.length > 3 ) {
                if( !weightImportanceMap.has(morph) ) {
                    weightImportanceMap.add(morph);
                }

                let weightImportance = weightImportanceMap.get( morph );
                weightImportance.update( weights );
            }

            const [mesh] = entityManager.getEntityComponents(entity, _lateUpdateClasses, components);

            for (const subMesh of mesh.subMeshes()) {
                const { instanceId, material } = subMesh;
                const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

                if (batchRenderable.morphWeights === null) {
                    material.needsUpdate = true;

                    const { geometry } = batchRenderable;
                    const { attributes } = geometry;

                    let positionMorphTargetCount = 0;
                    let normalMorphTargetCount = 0;

                    for (const semantic of attributes.keys()) {
                        if (_positionMorphTargets.includes(semantic)) {
                            positionMorphTargetCount++;
                        } else if (_normalMorphTargets.includes(semantic)) {
                            normalMorphTargetCount++;
                        }
                    }

                    console.assert(positionMorphTargetCount <= weights.length,
                        `subMesh: ${subMesh.name} has ${positionMorphTargetCount} position morph targets and only ${weights.length} weights`);

                    console.assert(normalMorphTargetCount <= weights.length,
                        `subMesh: ${subMesh.name} has ${normalMorphTargetCount} normal morph targets and only ${weights.length} weights`);

                    if(weights.length > 3) {
                        const weightImportance = weightImportanceMap.get( morph );
                        batchRenderable.morphWeights = weightImportance.importantWeights;
                    }
                    else {
                        batchRenderable.morphWeights = weights;
                    }
                    batchRenderable.positionMorphTargetCount = positionMorphTargetCount;
                    batchRenderable.normalMorphTargetCount = normalMorphTargetCount;
                }

                if(weights.length > 3 ) {
                    const weightImportance = weightImportanceMap.get( morph );
                    if( !weightImportance.isConsistent ) {
                        const { geometry } = batchRenderable;
                        const { attributes, morphTargets } = geometry;
                        const { vertexStaging } = renderer;
                        const { importantIndices } = weightImportance;

                        for(let idx=0; idx<3; idx++) {
                            const positionMorphAttribute = attributes.get(AttributeSemantic.POSITION_MORPH_0 + idx);
                            const positionMorphTarget = morphTargets.get(AttributeSemantic.POSITION_MORPH_0 + importantIndices[idx]);
                            const normalMorphAttribute = attributes.get(AttributeSemantic.NORMAL_MORPH_0 + idx);
                            const normalMorphTarget = morphTargets.get(AttributeSemantic.NORMAL_MORPH_0 + importantIndices[idx]);
                            this._copyMorphTargetToMorphAttribute( positionMorphTarget, positionMorphAttribute, vertexStaging );
                            this._copyMorphTargetToMorphAttribute( normalMorphTarget, normalMorphAttribute, vertexStaging );
                        }
                    }
                }
            }

            morph.needsUpdate = false;
        }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/ECS/systemManager.js














let _defaultUpdateStages = null;

const _earlyUpdateStage = 100;
const _lateUpdateStage = 200;

/**
 * @function module:@webgears-app/engine-core.setupSystemUpdateStages
 * @param stagesEnum
 * @returns {module:@webgears-app/enum.Enum}
 * @summary creates enum of update stages.
 */
function setupSystemUpdateStages(stagesEnum) {
    const entries = [];

    entries.push(
        ['EARLY_UPDATE', _earlyUpdateStage],
        ['LATE_UPDATE', _lateUpdateStage]
    );

    if (stagesEnum !== undefined) {
        for (const [name, value] of stagesEnum.entries()) {
            if (name === 'EARLY_UPDATE' || name === 'LATE_UPDATE') continue;

            console.assert(value !== 100 && value !== 200);
            // `system update stage value ${value} of stage ${name} is reserved for internal use.`);

            entries.push([name, value]);
        }
    }

    entries.sort((a, b) => {
        return a[1] - b[1];
    });

    return makeEnum(entries);
}

/**
 * @class module:@webgears-app/engine-core.SystemManager
 * @param {Set} systems A set of system classes.
 * @param {module:@webgears-app/enum.Enum} [stages=null] Stages' enum. If null it creates default update stages enum,
 * use setupSystemUpdateStages function to create enum with custom stages if necessary.
 * @summary Systems' management class.
 */
class systemManager_SystemManager {
    static get EARLY_UPDATE_STAGE() {
        return _earlyUpdateStage;
    }

    static get LATE_UPDATE_STAGE() {
        return _lateUpdateStage;
    }

    constructor(
        systems = new Set([
            animations_Animations,
            cameras_Cameras,
            cubeCameras_CubeCameras,
            lights_Lights,
            meshes_Meshes,
            sprites_Sprites,
            visibilities_Visibilities,
            transforms_Transforms,
            morphs_Morphs
        ]),
        stages = null
    ) {
        this._stages = stages === null // eslint-disable-line
            ? _defaultUpdateStages === null
                ? (_defaultUpdateStages = setupSystemUpdateStages(), _defaultUpdateStages)
                : _defaultUpdateStages
            : stages;

        this._systems = new Map();

        for (const system of systems.values()) {
            this._systems.set(system, new system()); // eslint-disable-line
        }
    }

    _updateScene(scene) {
        const { _systems } = this;
        const { _deferredTasks } = scene;

        while (_deferredTasks.length > 0) {
            const task = _deferredTasks.pop();

            if (task.type === scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY) {
                const { data } = task;
                const { srcScene, dstNode, copyContext } = data;

                const { root } = srcScene;
                const { children } = root;

                for (const child of children) {
                    dstNode._adoptForeignNode(child, copyContext);
                }
            }

            for (const system of _systems.values()) {
                system._updateScene(task);
            }

            const { resolve, output } = task;

            resolve(output);
        }
    }

    _updateRenderPass(renderPass) {
        const { _stages, _systems } = this;

        for (const stage of _stages.values()) {
            for (const system of _systems.values()) {
                if (!system.enabled) continue;
                system._update(stage, renderPass);
            }

            renderPass.onStageEnd(stage).emit();
        }
    }

    /**
     * @function module:@webgears-app/engine-core.SystemManager#update
     * @param {module:@webgears-app/engine-core.RenderPass} renderPass Render pass.
     * @summary Runs update.
     */
    update(renderPass) {
        const { scene } = renderPass;

        this._updateScene(scene);

        this._updateRenderPass(renderPass);
    }


    /**
     * @function module:@webgears-app/engine-core.SystemManager#getSystems
     * @param {class[]} [systemClasses = []] Array of system types
     * @summary Returns system instances by system types
     * @returns {Array.<module:@webgears-app/engine-core.System|null>}
     * @example
     * const [animationSystem, camerasSystem, myOtherSystem]
     *      = systemManager.getSystems([Animations, Cameras, OtherSystem]);
     *
     * console.log(animationSystem instanceof Animations); // true
     * console.log(camerasSystem instanceof Cameras); // true
     *
     * // OtherSystem - for example, this system is not existed
     * console.log(myOtherSystem instanceof OtherSystem); // false
     * console.log(myOtherSystem === null); // true
     */
    getSystems(systemClasses = []) {
        const { _systems } = this;
        let systems = null;

        if (systemClasses.length === 0) {
            systems = [..._systems.values()];
        } else {
            systems = systemClasses.map((sc) => {
                const system = _systems.get(sc);
                return system !== undefined ? system : null;
            });
        }

        return systems;
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/morphs/morphTargetData.js



/**
 * @class module:@webgears-app/engine-core.MorphTargetData
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary Class encapsulates morph target data.
 * @param {object} parameters Parameters.
 * @param {module:@webgears-app/engine-core.AttributeSemantic} parameters.semantic A morph target attribute's semantic.
 * @param {number} parameters.elementCounts The number of elements referenced by this morph target.
 * @param {number} parameters.componentCount The number of components in each element.
 * @param {type} parameters.type Type of the typed array of the morph target data.
 */
class morphTargetData_MorphTargetData extends disposeableUsageCounter_DisposableUsageCounter {
    constructor({ elementCount, componentCount, semantic, type }) {
        super();

        this.semantic = semantic;
        this.view = new type(elementCount * componentCount); // eslint-disable-line
    }

    _dispose() {
        this.view = null;
        super._dispose();
    }

    _actuallyUnload() {
        this.view = null;
        super._actuallyUnload();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lines/index.js








const lines_lateUpdateComponents = [ transform_Transform ];

const lines_worldBoundingBox = new rectangle_and_box_Box();
const lines_center = new Vector3();

/**
 * @class module:wg-engine-core.Lines
 * @extends module:wg-engine-core.System
 * @param {module:wg-engine-core.ECS} ecs Instance of entity component system class.
 * @summary The line system class.
 */
class lines_Lines extends System {
    constructor() {
        super();
        this.renderer = null;
    }

    init(renderer) {
        EntityManager.onDetach.subscribe((entityManager, entity, component) => {
            const { index } = component;

            if (line_Line.index === index) {
                const { _scene } = entityManager;
                const { instanceDataManager, _instanceKeys, spatialIndex } = _scene;
                const { _lineRenderable } = component;

                if (_lineRenderable.instanceId !== null) {
                    instanceDataManager.deleteInstance(_lineRenderable);
                }

                const instanceKey = _instanceKeys.get(_lineRenderable);
                _instanceKeys.delete(_lineRenderable);
                spatialIndex.remove(instanceKey);

                _scene._forceUpdateRenderQueue = true;
            }
        });

        this.renderer = renderer;

        super.init();
    }

    static _validateInstanceKey(instanceDataManager, scene, renderable, instanceKey) {
        const { instanceId, instanceIndex } = renderable;

        const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

        if (batchRenderable === undefined) {
            scene._instanceKeys.delete(renderable);
            scene.spatialIndex.remove(instanceKey);
        } else if (instanceKey !== undefined) {
            const { batchIdx } = batchRenderable;

            const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

            instanceKey.batchSetIdx = 0;
            instanceKey.globalIndex = globalIndex;
        }
    }

    static _validateInstanceKeys(instanceDataManager, scene) {
        for (const [r, ik] of scene._instanceKeys.entries()) {
            lines_Lines._validateInstanceKey(instanceDataManager, scene, r, ik);
        }
    }

    _update(stage, renderPass) {
        switch (stage) {
            case systemManager_SystemManager.EARLY_UPDATE_STAGE:
                this._earlyUpdate(renderPass);
                break;
            case systemManager_SystemManager.LATE_UPDATE_STAGE:
                lines_Lines._lateUpdate(renderPass);
                break;
            default:
        }
    }

    /**
     * @function module:wg-engine-core.Lines#earlyUpdate
     * @param {module:wg-engine-core.RenderPassInfo} renderPass Current render pass.
     */
    _earlyUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;
        const { entityManager, instanceDataManager, _instanceKeys, _forceUpdateRenderQueue } = scene;

        if (_forceUpdateRenderQueue) {
            scene._lastFrameSceneGraphUpdate = frameNumber;
            scene._forceUpdateRenderQueue = false;
        }

        if (!entityManager.isComponent(line_Line)) return;

        const storage = entityManager.getComponentStorage(line_Line);

        let needsValidateInstanceKeys = false;

        for (const line of storage.components()) {
            if (line.unloaded) continue;

            const { _lineRenderable } = line;

            if (_lineRenderable.instanceId === null || _lineRenderable._instanceIdentifierExpired) {
                instanceDataManager.addInstance(_lineRenderable);
                _lineRenderable._lastUpdateFrameNumber = frameNumber;

                if (_lineRenderable._instanceIdentifierExpired) {
                    lines_Lines._validateInstanceKey(
                        instanceDataManager, scene, _lineRenderable, _instanceKeys.get(_lineRenderable)
                    );
                } else {
                    needsValidateInstanceKeys = false;
                }

                instanceDataManager.setInstanceVisibility(_lineRenderable, true, true);

                scene._lastFrameSceneGraphUpdate = frameNumber;
            }

            if (_lineRenderable.geometry.needsUpdateBoundingBox) {
                _lineRenderable.geometry.updateBoundingBox();
            }

            const { _customAttributesToWrite, _customAttributesToRead } = _lineRenderable;

            for (let j = 0, count = _customAttributesToWrite.length; j < count; j++) {
                const { semantic, inVal } = _customAttributesToWrite.pop();
                instanceDataManager.setInstancedAttribute(_lineRenderable, semantic, inVal);

                scene._lastFrameSceneGraphUpdate = frameNumber;
            }

            for (let j = 0, count = _customAttributesToRead.length; j < count; j++) {
                const { resolve, semantic, outVal } = _customAttributesToRead.pop();
                resolve(instanceDataManager.getInstancedAttribute(_lineRenderable, semantic, outVal));
            }
        }

        if (needsValidateInstanceKeys) {
            lines_Lines._validateInstanceKeys(instanceDataManager, scene);
        }
    }

    /**
     * @function module:wg-engine-core.Lines#lateUpdate
     * @param {module:wg-engine-core.RenderPassInfo} renderPass Current render pass.
     * @summary Updates transform and batching data for all [Line]{@link module:wg-engine-core.Line} components.
     */
    static _lateUpdate(renderPass) {
        const { scene, frameNumber } = renderPass;
        const { instanceDataManager, _instanceKeys, entityManager, spatialIndex } = scene;

        if (!entityManager.isComponent(line_Line)) return;

        const components = [];
        const storage = entityManager.getComponentStorage(line_Line);

        for (const [ entity, line ] of storage.entries()) {
            if (line.unloaded) continue;

            const [ transform ] = entityManager.getEntityComponents(entity, lines_lateUpdateComponents, components);

            const { state, worldMatrix } = transform;

            const { _lineRenderable } = line;

            if ((state & transform_Transform.StateMask.UPDATE_WORLD) !== 0
                || _lineRenderable.lastUpdateFrameNumber === frameNumber) {
                const { instanceId, instanceIndex, geometry, id } = _lineRenderable;
                const { boundingBox } = geometry;

                const { batchIdx } = instanceDataManager.getInstanceRenderable(instanceId);

                const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);

                instanceDataManager.storeWorldTransform(worldMatrix, globalIndex);
                instanceDataManager.storeRenderableIdentifier(globalIndex, id);

                let instanceKey = _instanceKeys.get(_lineRenderable);
                if (instanceKey === undefined) {
                    instanceKey = {
                        node: scene._entityToNode.get(entity),
                        renderable: _lineRenderable,
                        batchSetIdx: 0,
                        globalIndex
                    };
                    _instanceKeys.set(_lineRenderable, instanceKey);
                }

                lines_worldBoundingBox.copy(boundingBox).applyAffineMatrix(worldMatrix);
                spatialIndex.insert(instanceKey, lines_worldBoundingBox);

                lines_worldBoundingBox.centerPaste(lines_center);
                instanceDataManager.storeCenter(lines_center, globalIndex);

                scene._lastFrameSceneGraphUpdate = frameNumber;
            }
        } // components
    }

    _updateScene(task) {
        const { type, data } = task;

        switch (type) {
            case scene_Scene._SceneManagementDeferredTask.TaskType.MERGE_COPY:
            case scene_Scene._SceneManagementDeferredTask.TaskType.SPLIT_COPY:
                lines_Lines._copyFromScene(data);
                break;
            default:
        }
    }

    /**
     * @function module:wg-engine-core.Lines#_copyFromScene
     * @param {module:wg-engine-core.Scene} srcScene The source scene
     * @param {object} copyContext={ } It contains maps with objects from source scene to the destination scene.
     * @param {Map} [copyContext.nodeToNode = new Map()]
     * @param {boolean} [cloneMaterials=false] Whether to clone materials or just keep references.
     * Nodes of source scene to nodes of destination scene.
     * @summary Copies [Line]{@link module:wg-engine-core.Line} components when source scene is merged into the destination scene.
     * @protected
     */
    static _copyFromScene({ copyContext }) {
        const {
            nodeToNode = new Map(),
            cloneMaterials = false
        } = copyContext;

        const materialToMaterial = new Map();

        for (const [ srcNode, dstNode ] of nodeToNode.entries()) {
            const [ srcLine ] = srcNode.getComponents([ line_Line ]);

            if (srcLine === null) continue;

            const dstLine = srcLine.clone();

            if (cloneMaterials) {
                const { _lineRenderable } = srcLine;
                const srcMaterial = _lineRenderable.material;

                let dstMaterial = materialToMaterial.get(srcMaterial);

                if (dstMaterial === undefined) {
                    dstMaterial = srcMaterial.clone();
                    materialToMaterial.set(srcMaterial, dstMaterial);
                }

                dstLine._lineRenderable.material = dstMaterial;
            }

            dstNode.attach(dstLine);
        }
    }

    dispose() { }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/ambientLight.js




/**
 * @class module:@webgears-app/engine-core.AmbientLight
 * @extends module:@webgears-app/engine-core.Light
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A light's name
 * @param {number} parameters.temperature A light's temperature, K.
 * @param {number} parameters.illuminance A light's luminous power per squared meter, Lx (lm / m^2).
 * @param {module:@webgears-app/math.RGBColor} parameters.colorFilter A light's color filter.
 * @summary The ambient light class.
 */
class ambientLight_AmbientLight extends light_Light {
    constructor({ name, temperature, illuminance, colorFilter = new rgb_color_RGBColor(1, 1, 1) }) {
        super({ name, temperature, colorFilter });

        this._illuminanceUpdated = true;
        this._illuminance = illuminance;    // lx (lm / m^2)
        this._luminance = new Vector3();    // nt (cd / m^2)
    }

    makeUpdated() {
        super.markUpdated();
        this._illuminanceUpdated = false;
    }

    /**
     * @var module:@webgears-app/engine-core.AmbientLight#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether light system should update the ambient light.
     * @desc Any time base light properties or light's illuminance takes a change, needsUpdate property is gotten true.
     */
    get needsUpdate() {
        return super.needsUpdate || this._illuminanceUpdated;
    }

    /**
     * @var module:@webgears-app/engine-core.AmbientLight#illuminance
     * @type {number}
     * @summary A light's luminous power per squared meter, Lx (lm / m^2).
     */
    set illuminance(value) {
        this._illuminance = value;
        this._illuminanceUpdated = true;
    }

    get illuminance() {
        return this._illuminance;
    }

    getLuminance(dst) {
        dst.copy(this._luminance);
    }

    /**
     * @function module:@webgears-app/engine-core.AmbientLight#clone
     * @summary Makes a clone of the light.
     * @returns {module:@webgears-app/engine-core.AmbientLight}
     */
    clone() {
        const { name, temperature, illuminance } = this;
        return new ambientLight_AmbientLight({ name, temperature, illuminance });
    }
}

Object.defineProperty(ambientLight_AmbientLight.prototype, 'isAmbientLight', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/directionalLight.js




/**
 * @class module:@webgears-app/engine-core.DirectionalLight
 * @extends module:@webgears-app/engine-core.Light
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A light's name
 * @param {number} parameters.temperature A light's temperature, K.
 * @param {number} parameters.illuminance A light's luminous power per squared meter, Lx (lm / m^2).
 * @param {module:@webgears-app/math.RGBColor} parameters.colorFilter A light's color filter.
 * @summary The directional light class.
 */
class directionalLight_DirectionalLight extends light_Light {
    constructor({ name, temperature, illuminance, colorFilter = new rgb_color_RGBColor(1, 1, 1) }) {
        super({ name, temperature, colorFilter });
        this._direction = new Vector3();
        this._illuminanceUpdated = true;
        this._illuminance = illuminance;    // lx (lm / m^2)
        this._luminance = new Vector3();    // nt (cd / m^2)
    }

    makeUpdated() {
        super.markUpdated();
        this._illuminanceUpdated = false;
    }

    /**
     * @var module:@webgears-app/engine-core.DirectionalLight#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether light system should update this directional light.
     * @desc Any time base light properties or light's illuminance takes a change, needsUpdate property is gotten true.
     */
    get needsUpdate() {
        return super.needsUpdate || this._illuminanceUpdated;
    }

    /**
     * @var module:@webgears-app/engine-core.DirectionalLight#illuminance
     * @type {number}
     * @summary A light's luminous power per squared meter, Lx (lm / m^2).
     */
    set illuminance(value) {
        this._illuminance = value;
        this._illuminanceUpdated = true;
    }

    get illuminance() {
        return this._illuminance;
    }

    // TODO:: rename to directionCopy
    /**
     * @function module:@webgears-app/engine-core.DirectionalLight#getDirection
     * @param {module:@webgears-app/math.Vector3} dst Destination vector.
     * @summary Copies light's direction into the destination vector.
     */
    getDirection(dst) {
        const { _direction } = this;
        dst.copy(_direction);
    }

    // TODO:: rename to luminanceCopy
    /**
     * @function module:@webgears-app/engine-core.DirectionalLight#getLuminance
     * @param {module:@webgears-app/math.RGBColor} dst Destination color.
     * @summary Copies light's luminance into the destination color.
     */
    getLuminance(dst) {
        dst.copy(this._luminance);
    }

    /**
     * @function module:@webgears-app/engine-core.DirectionalLight#clone
     * @summary Makes a clone of the light.
     * @returns {module:@webgears-app/engine-core.DirectionalLight}
     */
    clone() {
        const { name, temperature, illuminance, _colorFilter } = this;
        return new directionalLight_DirectionalLight({ name, temperature, illuminance, colorFilter: _colorFilter });
    }
}

Object.defineProperty(directionalLight_DirectionalLight.prototype, 'isDirectionalLight', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/pointLight.js




/**
 * @class module:@webgears-app/engine-core.PointLight
 * @extends module:@webgears-app/engine-core.Light
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A light's name
 * @param {number} parameters.temperature A light's temperature, K.
 * @param {number} parameters.luminousPower A light's luminous power, Lm.
 * @param {module:@webgears-app/math.RGBColor} parameters.colorFilter A light's color filter.
 * @param {number} parameters.size A light's size in meters.
 * @param {number} parameters.attenuationRadius A light's attenuation radius in meters.
 * @summary The point light class.
 */
class pointLight_PointLight extends light_Light  {
    constructor({
        name,
        temperature,
        luminousPower,
        colorFilter = new rgb_color_RGBColor(1, 1, 1),
        size = 0.1,
        attenuationRadius = 5.0
    }) {
        super({ name, temperature, colorFilter });

        console.assert(size > 0); // , 'light size must be greater then zero');
        console.assert(attenuationRadius > size); // , 'attenuation radius must be greater then light size');

        this._size = size;

        this._radius = attenuationRadius;
        this._invAttenRadius = 1.0 / (attenuationRadius * attenuationRadius);

        this._position = new Vector3();

        this._luminousPowerUpdated = true;
        this._luminousPower = luminousPower; // lm

        this._luminousIntensity = new Vector3(); // cd (lm/sr) for components R,G,B
    }

    makeUpdated() {
        super.markUpdated();
        this._luminousPowerUpdated = false;
    }

    /**
     * @var module:@webgears-app/engine-core.PointLight#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether light system should update this point light.
     * @desc
     * Any time base light properties or light's luminous power takes a change, needsUpdate property is gotten true.
     */
    get needsUpdate() {
        return super.needsUpdate || this._luminousPowerUpdated;
    }

    /**
     * @var module:@webgears-app/engine-core.PointLight#luminousPower
     * @type {number}
     * @summary  A light's luminous power, Lm.
     */
    get luminousPower() {
        return this._luminousPower;
    }

    set luminousPower(value) {
        this._luminousPower = value;
        this._luminousPowerUpdated = true;
    }

    /**
     * @var module:@webgears-app/engine-core.PointLight#size
     * @type {number}
     * @summary  A light's size in meters.
     */
    get size() {
        return this._size;
    }

    set size(value) {
        console.assert(value > 0); // , 'light size must be greater then zero');
        this._size = value;
    }

    /**
     * @var module:@webgears-app/engine-core.PointLight#invAttenRadius
     * @type {number}
     * @readonly
     * @summary  Inverted square of the light attenuation radius.
     * @desc invAttenRadius = 1.0 / (attenuation radius)^2
     */
    get invAttenRadius() {
        return this._invAttenRadius;
    }

    /**
     * @var module:@webgears-app/engine-core.PointLight#attenuationRadius
     * @type {number}
     * @summary A light's attenuation radius in meters.
     */
    get attenuationRadius() {
        return this._radius;
    }

    set attenuationRadius(value) {
        console.assert(value > this._size); // , 'attenuation radius must be greater then light size');

        this._radius = value;
        this._invAttenRadius = 1.0 / (value * value);
    }

    //TODO:: rename to positionCopy
    /**
     * @function module:@webgears-app/engine-core.PointLight#getPosition
     * @param {module:@webgears-app/math.Vector3} dst Destination vector.
     * @summary Copies light's position into the destination vector.
     */
    getPosition(dst) {
        const { _position } = this;
        dst.copy(_position);
    }

    //TODO:: rename to luminousIntensityCopy
    /**
     * @function module:@webgears-app/engine-core.PointLight#getLuminousIntensity
     * @param {module:@webgears-app/math.RGBColor} dst Destination color.
     * @summary Copies light's luminous intensity into the destination color.
     */
    getLuminousIntensity(dst) {
        dst.copy(this._luminousIntensity);
    }

    /**
     * @function module:@webgears-app/engine-core.PointLight#clone
     * @summary Makes a clone of the light.
     * @returns {module:@webgears-app/engine-core.PointLight}
     */
    clone() {
        const { name, temperature, luminousPower, size, attenuationRadius, _colorFilter } = this;
        return new pointLight_PointLight({ name, temperature, luminousPower, colorFilter: _colorFilter, size, attenuationRadius });
    }
}

Object.defineProperty(pointLight_PointLight.prototype, 'isPointLight', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/lights/spotLight.js




/**
 * @class module:@webgears-app/engine-core.SpotLight
 * @extends module:@webgears-app/engine-core.Light
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A light's name
 * @param {number} parameters.temperature A light's temperature, K.
 * @param {number} parameters.luminousPower A light's luminous power, Lm.
 * @param {module:@webgears-app/math.RGBColor} parameters.colorFilter A light's color filter.
 * @param {number} parameters.size A light's size in meters.
 * @param {number} parameters.attenuationRadius A light's attenuation radius in meters.
 * @param {number} parameters.innerCone A light's inner cone.
 * @param {number} parameters.outerCone A light's outer cone.
 * @summary The spot light class.
 */
class spotLight_SpotLight extends light_Light {
    constructor({
            name,
            temperature,
            luminousPower,
            colorFilter = new rgb_color_RGBColor(1, 1, 1),
            size = 0.1,
            attenuationRadius = 5.0,
            innerCone = 0.0174533,
            outerCone = 0.436332
    }) {
        super({ name, temperature, colorFilter });

        console.assert(size > 0); // , 'light size must be greater then zero');
        console.assert(attenuationRadius > size); // , 'attenuation radius must be greater then light size');

        this._size = size;

        this._radius = attenuationRadius;
        this._invAttenRadius = 1.0 / (attenuationRadius * attenuationRadius);

        this._innerCone = innerCone;
        this._outerCone = outerCone;

        const innerConeCos = Math.cos(innerCone);
        const outerConeCos = Math.cos(outerCone);

        const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
        const lightAngleOffset = -outerConeCos * lightAngleScale;

        this._lightAngleScale = lightAngleScale;
        this._lightAngleOffset = lightAngleOffset;

        this._direction = new Vector3();
        this._position = new Vector3();

        this._luminousPowerUpdated = true;
        this._luminousPower = luminousPower; // lm

        this._luminousIntensity = new Vector3(); // cd (lm/sr) for components R,G,B
    }

    makeUpdated() {
        super.markUpdated();
        this._luminousPowerUpdated = false;
    }


    /**
     * @var module:@webgears-app/engine-core.SpotLight#needsUpdate
     * @type {boolean}
     * @readonly
     * @summary Whether light system should update this spot light.
     * @desc
     * Any time base light properties or light's luminous power takes a change, needsUpdate property is gotten true.
     */
    get needsUpdate() {
        return super.needsUpdate || this._luminousPowerUpdated;
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#luminousPower
     * @type {number}
     * @summary  A light's luminous power, Lm.
     */
    get luminousPower() {
        return this._luminousPower;
    }

    set luminousPower(value) {
        this._luminousPower = value;
        this._luminousPowerUpdated = true;
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#size
     * @type {number}
     * @summary  A light's size in meters.
     */
    get size() {
        return this._size;
    }

    set size(value) {
        console.assert(value > 0); // , 'light size must be greater then zero');
        this._size = value;
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#invAttenRadius
     * @type {number}
     * @readonly
     * @summary  Inverted square of the light attenuation radius.
     * @desc invAttenRadius = 1.0 / (attenuation radius)^2
     */
    get invAttenRadius() {
        return this._invAttenRadius;
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#attenuationRadius
     * @type {number}
     * @summary A light's attenuation radius in meters.
     */
    get attenuationRadius() {
        return this._radius;
    }

    set attenuationRadius(value) {
        console.assert(value > this._size, 'attenuation radius must be greater then light size');

        this._radius = value;
        this._invAttenRadius = 1.0 / (value * value);
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#innerCone
     * @type {number}
     * @summary A light's inner cone.
     */
    get innerCone() {
        return this._innerCone;
    }

    /**
     * @var module:@webgears-app/engine-core.SpotLight#outerCone
     * @type {number}
     * @summary A light's outer cone.
     */
    get outerCone() {
        return this._outerCone;
    }

    set innerCone(value) {
        this._innerCone = value;

        const innerConeCos = Math.cos(this._innerCone);
        const outerConeCos = Math.cos(this._outerCone);

        const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
        const lightAngleOffset = -outerConeCos * lightAngleScale;

        this._lightAngleScale = lightAngleScale;
        this._lightAngleOffset = lightAngleOffset;
    }

    set outerCone(value) {
        this._outerCone = value;

        const innerConeCos = Math.cos(this._innerCone);
        const outerConeCos = Math.cos(this._outerCone);

        const lightAngleScale = 1.0 / Math.max(0.001, innerConeCos - outerConeCos);
        const lightAngleOffset = -outerConeCos * lightAngleScale;

        this._lightAngleScale = lightAngleScale;
        this._lightAngleOffset = lightAngleOffset;
    }

    get lightAngleScale() {
        return this._lightAngleScale;
    }

    get lightAngleOffset() {
        return this._lightAngleOffset;
    }

    // TODO:: rename all get methods to <property>Copy.
    /**
     * @function module:@webgears-app/engine-core.SpotLight#getDirection
     * @param {module:@webgears-app/math.Vector3} dst Destination vector.
     * @summary Copies light's direction into the destination vector.
     */
    getDirection(dst) {
        const { _direction } = this;

        dst.copy(_direction);
    }

    /**
     * @function module:@webgears-app/engine-core.SpotLight#getPosition
     * @param {module:@webgears-app/math.Vector3} dst Destination vector.
     * @summary Copies light's position into the destination vector.
     */
    getPosition(dst) {
        const { _position } = this;
        dst.copy(_position);
    }

    /**
     * @function module:@webgears-app/engine-core.SpotLight#getLuminousIntensity
     * @param {module:@webgears-app/math.RGBColor} dst Destination color.
     * @summary Copies light's luminous intensity into the destination color.
     */
    getLuminousIntensity(dst) {
        dst.copy(this._luminousIntensity);
    }

    /**
     * @function module:@webgears-app/engine-core.SpotLight#clone
     * @summary Makes a clone of the light.
     * @returns {module:@webgears-app/engine-core.PointLight}
     */
    clone() {
        const { name, temperature, luminousPower, size, attenuationRadius, innerCone, outerCone, _colorFilter } = this;

        return new spotLight_SpotLight({
            name,
            temperature,
            luminousPower,
            size,
            attenuationRadius,
            innerCone,
            outerCone,
            colorFilter: _colorFilter
        });
    }
}

Object.defineProperty(spotLight_SpotLight.prototype, 'isSpotLight', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/blendEquation.js



/**
 * @namespace module:@webgears-app/engine-core.BlendEquation
 * @desc Enums possible equations to combine source and destination.
 * @property {number} FUNC_ADD
 * @property {number} FUNC_SUBTRACT
 * @property {number} FUNC_REVERSE_SUBTRACT
 */
class BlendEquation {}

(function prepEnum() {
    const blendEquations = [
        'FUNC_ADD',
        'FUNC_SUBTRACT',
        'FUNC_REVERSE_SUBTRACT'
    ];

    for (const blendEquation of blendEquations) {
        const value = webglContext[blendEquation];

        Object.defineProperty(BlendEquation, blendEquation, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/blendFactor.js



/**
 * @namespace module:@webgears-app/engine-core.BlendFactor
 * @desc Enums blend function factors.
 * @property {number} ZERO
 * @property {number} ONE
 * @property {number} SRC_COLOR
 * @property {number} ONE_MINUS_SRC_COLOR
 * @property {number} DST_COLOR
 * @property {number} ONE_MINUS_DST_COLOR
 * @property {number} SRC_ALPHA
 * @property {number} ONE_MINUS_SRC_ALPHA
 * @property {number} DST_ALPHA
 * @property {number} ONE_MINUS_DST_ALPHA
 * @property {number} CONSTANT_COLOR
 * @property {number} ONE_MINUS_CONSTANT_COLOR
 * @property {number} CONSTANT_ALPHA
 * @property {number} ONE_MINUS_CONSTANT_ALPHA
 * @property {number} SRC_ALPHA_SATURATE
 */
class BlendFactor {}

(function prepEnum() {
    const blendFactors = [
        'ZERO',
        'ONE',
        'SRC_COLOR',
        'ONE_MINUS_SRC_COLOR',
        'DST_COLOR',
        'ONE_MINUS_DST_COLOR',
        'SRC_ALPHA',
        'ONE_MINUS_SRC_ALPHA',
        'DST_ALPHA',
        'ONE_MINUS_DST_ALPHA',
        'CONSTANT_COLOR',
        'ONE_MINUS_CONSTANT_COLOR',
        'CONSTANT_ALPHA',
        'ONE_MINUS_CONSTANT_ALPHA',
        'SRC_ALPHA_SATURATE'
    ];

    for (const blendFactor of blendFactors) {
        const value = webglContext[blendFactor];

        Object.defineProperty(BlendFactor, blendFactor, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/material.js








let _lastMaterialId = 0;

class _AlphaMode {
    static get OPAQUE() { return 1; }
    static get MASK() { return 2; }
    static get BLEND() { return 3; }
    static get ADDITIVE_BLEND() { return 4; }
    static get SUBTRACTIVE_BLEND() { return 5; }
    static get MULTIPLY_BLEND() { return 6; }
    static get CUSTOM_BLEND() { return 7; }
}

function getAlphaModeName(alphaMode) {
    for (const name of Object.getOwnPropertyNames(_AlphaMode)) {
        if (name === 'length') { continue; }
        if (_AlphaMode[name] === alphaMode) { return name; }
    }
}

class material_CullFace {
    static get NONE() { return 0; }
    static get FRONT() { return webglContext.FRONT; }
    static get BACK() { return webglContext.BACK; }
    static get BOTH() { return webglContext.FRONT_AND_BACK; }
}

class material_TextureProperties {
    constructor(texture, transform, channel = 0) {
        this._channel = channel;

        this._texture = texture;
        this.transform = transform instanceof AffineMatrix2 ? transform.clone() : new AffineMatrix2();
        this.material = null;
    }

    clone() {
        const { _channel, _texture, transform } = this;
        return new material_TextureProperties(_texture, transform, _channel);
    }

    retain() {
        return this._texture.retain();
    }

    release() {
        this._texture.release();
    }

    get unloaded() {
        return this._texture.unloaded;
    }

    get loading() {
        return this._texture.loading;
    }

    load() {
        return this._texture.load();
    }

    unload() {
        this._texture.unload();
    }

    get channel() { return this._channel; }

    set channel(value) {
        this._channel = value;

        if (this.material !== null) {
            this.material.needsUpdate = true;
        }
    }

    get texture() { return this._texture; }

    set texture(value) {
        console.assert(value === null || value.unloaded === this.unloaded,
            'texture must have the same .unloaded value as textureProperties');

        if (this._texture === value) { return; }

        if (this._texture.gammaDecode !== value.gammaDecode) {
            this.material.needsUpdate = true;
        }

        value.retain();

        this._texture.release();
        this._texture = value;
    }

    get name() { return this._texture.name; }

    get width() { return this._texture.width; }

    get height() { return this._texture.height; }

    get depth() { return this._texture.depth; }

    get bindingPoint() { return this._texture.bindingPoint; }

    get wrapS() { return this._texture.wrapS; }

    get wrapT() { return this._texture.wrapT; }

    get magFilter() { return this._texture.magFilter; }

    get minFilter() { return this._texture.minFilter; }

    get componentType() { return this._texture.componentType; }

    get format() { return this._texture.format; }

    get internalFormat() { return this._texture.internalFormat; }

    get levelsData() { return this._texture._levelsData; }

    get levels() { return this._texture.levels; }
}

class _TextureArrayProperties extends material_TextureProperties {
    constructor(texture, transform, channel = 0, index = 0) {
        super(texture, transform, channel);
        this.index = index;
    }

    clone() {
        const { _channel, _texture, transform, index } = this;
        return new _TextureArrayProperties(_texture, transform, _channel, index);
    }
}

class _NormalMapProperties extends material_TextureProperties {
    constructor(texture, transform, channel = 0, scale = 1) {
        super(texture, transform, channel);
        this.scale = scale;
    }

    clone() {
        const { _channel, _texture, transform, scale } = this;
        return new _NormalMapProperties(_texture, transform, _channel, scale);
    }
}

class _NormalMapFromArrayProperties extends _TextureArrayProperties {
    constructor(texture, transform, channel = 0, index = 0, scale = 1) {
        super(texture, transform, channel, index);
        this.scale = scale;
    }

    clone() {
        const { _channel, _texture, transform, index, scale } = this;
        return new _NormalMapFromArrayProperties(_texture, transform, _channel, index, scale);
    }
}

class _AOMapProperties extends material_TextureProperties {
    constructor(texture, transform, channel = 0, strength = 1) {
        super(texture, transform, channel);

        this._strength = Math.max(Math.min(strength, 1), 0);
    }

    get strength() {
        return this._strength;
    }

    set strength(value) {
        this._strength = Math.max(Math.min(value, 1), 0);
    }

    clone() {
        const { _channel, _texture, transform, _strength } = this;
        return new _AOMapProperties(_texture, transform, _channel, _strength);
    }
}

class _AOMapFromArrayProperties extends _TextureArrayProperties {
    constructor(texture, transform, channel = 0, index = 0, strength = 1) {
        super(texture, transform, channel, index);

        this._strength = Math.max(Math.min(strength, 1), 0);
    }

    get strength() {
        return this._strength;
    }

    set strength(value) {
        this._strength = Math.max(Math.min(value, 1), 0);
    }

    clone() {
        const { _channel, _texture, transform, index, _strength } = this;
        return new _AOMapFromArrayProperties(_texture, transform, _channel, index, _strength);
    }
}

class material_EnvironmentMapProperties extends material_TextureProperties {
    constructor(luminance, maxEnvLuminance, texture, projectionType = 'equirectangular') {
        super(texture, new AffineMatrix2(1));

        this.luminance = luminance;
        this.maxEnvLuminance = maxEnvLuminance;
        this.projectionType = projectionType;
    }

    clone() {
        const { luminance, maxEnvLuminance, _texture, projectionType } = this;
        return new material_EnvironmentMapProperties(luminance, maxEnvLuminance, _texture, projectionType);
    }
}

class _EmissiveMapProperties extends material_TextureProperties {
    constructor(luminance, texture, transform, channel = 0) {
        super(texture, transform, channel);

        this.luminance = luminance;
    }

    clone() {
        const { luminance, _texture, transform, _channel } = this;
        return new _EmissiveMapProperties(luminance, _texture, transform, _channel);
    }
}

class _EmissiveMapFromArrayProperties extends _TextureArrayProperties {
    constructor(luminance, texture, transform, channel = 0, index = 0) {
        super(texture, transform, channel, index, index);

        this.luminance = luminance;
    }

    clone() {
        const { luminance, _texture, transform, _channel, index } = this;
        return new _EmissiveMapFromArrayProperties(luminance, _texture, transform, _channel, index);
    }
}

/**
 * @class module:@webgears-app/engine-core.Material
 * @abstract
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @param {object} parameters Parameters.
 * @param {string} parameters.name A material's name.
 * @param {module:@webgears-app/engine-core.Material.AlphaMode} parameters.alphaMode The alpha rendering mode of the material.
 * @param {number} parameters.alphaCutoff=0.0
 * Specifies the cutoff threshold when in `MASK` mode.
 * If the alpha value is greater than or equal to this value then it is rendered as fully opaque,
 * otherwise, it is rendered as fully transparent. This value has no sense for other modes.
 * @param {module:@webgears-app/engine-core.Material.CullFace} parameters.cullFace
 * Specifies if renderer should cull back, front or both sides of the material.
 * @summary The abstract material class.
 * @desc Class encapsulates rendering properties of a renderable object.
 */
class material_Material extends disposeableUsageCounter_DisposableUsageCounter {
    /**
     * @namespace module:@webgears-app/engine-core.Material.AlphaMode
     * @property {number} OPAQUE
     * @property {number} MASK
     * @property {number} BLEND
     * @summary Possible alpha modes.
     */
    static get AlphaMode() {
        return _AlphaMode;
    }

    /**
     * @namespace module:@webgears-app/engine-core.Material.CullFace
     * @property {number} NONE
     * @property {number} BACK
     * @property {number} FRONT
     * @property {number} BOTH
     * @summary This enum specifies whether a renderer should cull back, front or both sides of this material.
     */
    static get CullFace() {
        return material_CullFace;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.TextureProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @summary Class encapsulates a texture that can be shared among many materials
     * and specifies properties which are unique for the texture in context of the one material.
     */
    static get TextureProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.TextureProperties#texture
         * @type {module:@webgears-app/engine-core.Texture}
         * @summary A texture.
         */

        /**
         * @var module:@webgears-app/engine-core.Material.TextureProperties#channel
         * @type {number}
         * @summary UV-channel.
         * @desc Every time the channel property takes a change it sets needsUpdate property of the material to true.
         */

        /**
         * @var module:@webgears-app/engine-core.Material.TextureProperties#transform
         * @type {module:@webgears-app/math.AffineMatrix2}
         * @summary Transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
         */

        /**
         * @var module:@webgears-app/engine-core.Material.TextureProperties#material
         * @type {module:@webgears-app/engine-core.Material}
         * @summary The material that owns texture property.
         */

        /**
         * @function module:@webgears-app/engine-core.Material.TextureProperties#clone
         * @summary Makes a clone of TextureProperties object
         * @returns {module:@webgears-app/engine-core.Material.TextureProperties}
         */
        return material_TextureProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.TextureArrayProperties
     * @extends module:@webgears-app/engine-core.Material.TextureProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [index=0] The index of the slice of the array material's shader is going to read from.
     * @summary The texture properties class extended to handle 2D texture arrays.
     */
    static get TextureArrayProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.TextureArrayProperties#index
         * @type {number}
         * @summary The index of the slice of the array material's shader is going to read from.
         */
        return _TextureArrayProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.NormalMapProperties
     * @extends module:@webgears-app/engine-core.Material.TextureProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [scale=1.0] The scalar multiplier applied to each normal vector of the normal texture.
     * @summary The texture properties class extended for normal maps.
     */
    static get NormalMapProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.NormalMapProperties#scale
         * @type {number}
         * @summary The scalar multiplier applied to each normal vector of the normal texture.
         */
        return _NormalMapProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.NormalMapFromArrayProperties
     * @extends module:@webgears-app/engine-core.Material.TextureArrayProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [index=0] The index of the slice of the array material's shader is going to read from.
     * @param {number} [strength=1.0] A scalar multiplier applied to each normal vector of the normal texture.
     * @summary The texture properties class extended to use normal maps from 2D texture arrays.
     */
    static get NormalMapFromArrayProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.NormalMapFromArrayProperties#scale
         * @type {number}
         * @summary A scalar multiplier applied to each normal vector of the normal texture.
         */
        return _NormalMapFromArrayProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.AOMapProperties
     * @extends module:@webgears-app/engine-core.Material.TextureProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [strength=1.0] A scalar multiplier controlling the amount of occlusion applied.
     * @summary The texture properties class extended for ambient occlusion maps.
     */
    static get AOMapProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.AOMapProperties#strength
         * @type {number}
         * @summary A scalar multiplier controlling the amount of occlusion applied.
         */
        return _AOMapProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.AOMapFromArrayProperties
     * @extends module:@webgears-app/engine-core.Material.TextureArrayProperties
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [index=0] The index of the slice of the array material's shader is going to read from.
     * @param {number} [strength=1.0] A scalar multiplier controlling the amount of occlusion applied.
     * @summary The texture properties class extended to use ambient occlusion maps from 2D texture arrays.
     */
    static get AOMapFromArrayProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.AOMapFromArrayProperties#strength
         * @type {number}
         * @summary A scalar multiplier controlling the amount of occlusion applied.
         */
        return _AOMapFromArrayProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.EnvironmentMapProperties
     * @extends module:@webgears-app/engine-core.Material.TextureProperties
     * @param {number} luminance Environment map maximum scene luminance value in cd / m^2.
     * @param {number} maxEnvLuminance The environment map brightest texel value in cd / m^2.
     * @param {module:@webgears-app/engine-core.Texture} texture The environment texture.
     * @param {string} [projectionType='equirectangular'] How to sample the map. See
     *     {@link module:@webgears-app/engine-core.Material.EnvironmentMapProperties#projectionType}
     * @summary The texture properties class extended for environment maps.
     */
    static get EnvironmentMapProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.EnvironmentMapProperties#projectionType
         * @type {string}
         * @summary How to sample the map. Possible values:
         * - 'equirectangular'
         */
        return material_EnvironmentMapProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.EmissiveMapProperties
     * @extends module:@webgears-app/engine-core.Material.TextureProperties
     * @param {number} luminance The emissive map luminance value.
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @summary The texture properties class extended for emissive maps.
     */
    static get EmissiveMapProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.EmissiveMapProperties#luminance
         * @type {number}
         * @summary The emissive map luminance value.
         */
        return _EmissiveMapProperties;
    }

    /**
     * @class module:@webgears-app/engine-core.Material.EmissiveMapFromArrayProperties
     * @extends module:@webgears-app/engine-core.Material.TextureArrayProperties
     * @param {number} luminance The emissive map luminance value.
     * @param {module:@webgears-app/engine-core.Texture} texture A texture.
     * @param {module:@webgears-app/math.AffineMatrix2} [transform=new AffineMatrix2(1.0)]
     * Contains transform for shifting, scaling and rotating UV coordinates on a per-texture basis.
     * @param {number} [channel=0] UV-channel.
     * @param {number} [index=0] The index of the slice of the array material's shader is going to read from.
     * @summary The texture properties class extended to use emissive maps from 2D texture arrays.
     */
    static get EmissiveMapFromArrayProperties() {
        /**
         * @var module:@webgears-app/engine-core.Material.EmissiveMapFromArrayProperties#luminance
         * @type {number}
         * @summary The emissive map luminance value.
         */
        return _EmissiveMapFromArrayProperties;
    }

    constructor({ name, alphaMode = material_Material.AlphaMode.OPAQUE, alphaCutoff = 0.0, cullFace = material_Material.CullFace.NONE }) {
        super();

        this.id = ++_lastMaterialId;
        this.name = name;
        this.alphaMode = alphaMode;
        this.cullFace = cullFace;
        this.depthTest = true;
        this.depthWrite = true;
        this.visible = true;
        this.lit = false; // TODO:: make this  property private

        this._alphaCutoff = alphaCutoff;

        this._blendEq = BlendEquation.FUNC_ADD;
        this._blendEqAlpha = BlendEquation.FUNC_ADD;
        this._srcRGB = BlendFactor.ONE;
        this._dstRGB = BlendFactor.ZERO;
        this._srcAlpha = BlendFactor.ONE;
        this._dstAlpha = BlendFactor.ZERO;

        this.extras = undefined;
    }

    /**
     * @function module:@webgears-app/engine-core.Material#setCustomAlphaMode
     * @param {object} [parameters={}] Custom alpha mode parameters.
     * @param {module:@webgears-app/engine-core.BlendEquation} [parameters.blendEquation=BlendEquation.FUNC_ADD]
     * Specifying how source and destination colors are combined.
     * @param {module:@webgears-app/engine-core.BlendEquation} [parameters.blendAlphaEquation=undefined]
     * If specified then separately defines source and destination alpha are combined.
     * @param {module:@webgears-app/engine-core.BlendFactor} [parameters.srcColor=BlendFactor.ONE]
     * Specifies multiplier for source (fragment) color.
     * @param {module:@webgears-app/engine-core.BlendFactor} [parameters.dstColor=BlendFactor.ZERO]
     * Specifies multiplier for destination(back buffer) color.
     * @param {module:@webgears-app/engine-core.BlendFactor} [parameters.srcAlpha=undefined]
     * If specified, separately defines multiplier for source (fragment) alpha.
     * @param {module:@webgears-app/engine-core.BlendFactor} [parameters.dstAlpha=undefined]
     * If specified, separately defines multiplier for destination (back buffer) alpha.
     * @summary Sets user defined alpha mode.
     */
    setCustomAlphaMode(parameters = {}) {
        const {
            blendEquation = BlendEquation.FUNC_ADD,
            blendAlphaEquation,
            srcColor = BlendFactor.ONE,
            dstColor = BlendFactor.ZERO,
            srcAlpha,
            dstAlpha
        } = parameters;

        this._blendEq = blendEquation;
        this._blendEqAlpha = blendAlphaEquation || blendEquation;
        this._srcRGB = srcColor;
        this._dstRGB = dstColor;
        this._srcAlpha = srcAlpha || srcColor;
        this._dstAlpha = dstAlpha || dstColor;

        this.alphaMode = _AlphaMode.CUSTOM_BLEND;
    }

    /**
     * @var module:@webgears-app/engine-core.Material#name
     * @type {string}
     * @summary The name of the material.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#visible
     * @type {boolean}
     * @summary Specifies whether material is visible or not.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#id
     * @type {number}
     * @summary The unique identifier of the material.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#alphaMode
     * @type {module:@webgears-app/engine-core.Material.AlphaMode}
     * @summary The alpha rendering mode of the material.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#alphaCutoff
     * @type {number}
     * @summary Specifies the cutoff threshold for the `MASK` mode.
     */
    get alphaCutoff() {
        return this._alphaCutoff;
    }

    set alphaCutoff(value) {
        this._alphaCutoff = value;
        this.needsUpdate = true;
    }

    /**
     * @var module:@webgears-app/engine-core.Material#cullFace
     * @type {module:@webgears-app/engine-core.Material.CullFace}
     * @summary Specifies sides of the material that renderer is going to cull.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#depthTest
     * @type {boolean}
     * @summary Specifies whether the renderer is going to enable depth test for this material.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#depthWrite
     * @type {boolean}
     * @summary Specifies whether the renderer is going to write depth for this material.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#extras
     * @type {any}
     * @summary Unstructred application-specific imported/exported data.
     * @desc Must be {@link JSON.stringify}-able.
     */

    /**
     * @var module:@webgears-app/engine-core.Material#needsUpdate
     * @type {boolean}
     * @summary Whether the renderer should update material before rendering.
     */
    get needsUpdate() {
        return false;
    }

    set needsUpdate(value) {
        console.assert('can not update abstract material');
    }

    // TODO:: make a class for shader sources
    get shaders() {
        throw new Error('abstract material has no shaders');
    }

    /**
     * @function module:@webgears-app/engine-core.Material#apply
     * @abstract
     * @summary Applies material's properties
     */
    apply() { }

    /**
     * @function module:@webgears-app/engine-core.Material#clone
     * @abstract
     * @summary Makes a clone of the material
     * @returns {module:@webgears-app/engine-core.Material}
     */
    clone() {
        throw new Error(`${this.constructor.name}.clone() is not implemented`);
    }

    /**
     * @function module:@webgears-app/engine-core.Material#getTextures
     * @abstract
     * @returns {Set}
     * @summary Returns set of textures that material use.
     */
    getTextures() {
        return new Set();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/clearMask.js



/**
 * @namespace module:@webgears-app/engine-core.ClearMask
 * @desc Possible clear mask bit values.
 * @property {number} NONE
 * @property {number} COLOR_BUFFER_BIT
 * @property {number} DEPTH_BUFFER_BIT
 * @property {number} STENCIL_BUFFER_BIT
 */
class ClearMask {}

(function prepEnum() {
    const clearMaskBits = [
        'NONE',
        'COLOR_BUFFER_BIT',
        'DEPTH_BUFFER_BIT',
        'STENCIL_BUFFER_BIT'
    ];

    for (const clearMaskBit of clearMaskBits) {
        const value = clearMaskBit === 'NONE' ? 0 : webglContext[clearMaskBit];

        Object.defineProperty(ClearMask, clearMaskBit, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/primitiveType.js


/**
 * @namespace module:@webgears-app/engine-core.PrimitiveType
 * @desc All valid values for type of primitives to render.
 * All values correspond to WebGL enums.
 * @property {number} POINTS
 * @property {number} LINES
 * @property {number} LINE_LOOPS
 * @property {number} LINE_STRIP
 * @property {number} TRIANGLES
 * @property {number} TRIANGLE_STRIP
 * @property {number} TRIANGLE_FAN
 */
class PrimitiveType {}

(function prepEnum() {
    const primitiveTypes = [
        'POINTS',
        'LINES',
        'LINE_LOOP',
        'LINE_STRIP',
        'TRIANGLES',
        'TRIANGLE_STRIP',
        'TRIANGLE_FAN'
    ];

    for (const primitiveType of primitiveTypes) {
        const value = webglContext[primitiveType];

        Object.defineProperty(PrimitiveType, primitiveType, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/vertexBufferView.js



/**
 * @class module:@webgears-app/engine-core.VertexBufferView
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @param {@webgears-app/host-memory-manager.RangeBasedMemoryManager} [staging=null] Memory staging.
 * @param {number} [byteLength] Byte length.
 * @summary The view class to represent vertex data in the staging buffer.
 */
class vertexBufferView_VertexBufferView extends disposeableUsageCounter_DisposableUsageCounter {
    constructor(staging = null, byteLength) {
        super();

        this.empty = staging === null ? true : staging.empty;

        this._staging = staging;

        let view = null;

        if (staging !== null) {
            view = staging.allocMemory(Uint8Array, byteLength);
        }

        this._view = view;
    }

    get view() {
        return this._view;
    }

    _actuallyUnload() {
        const { _staging, _view } = this;

        if (_staging !== null && _view !== null) {
            _staging.releaseMemory(_view);
        }

        this._view = null;

        super._actuallyUnload();
    }

    _dispose() {
        const { _staging, _view } = this;

        if (_staging !== null && _view !== null) {
            _staging.releaseMemory(_view);
        }

        this._staging = null;
        this._view = null;

        super._dispose();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/vertexAttribute.js



/**
 * @class module:@webgears-app/engine-core.VertexAttribute
 * @extends module:@webgears-app/engine-core.DisposableUsageCounter
 * @summary Class encapsulates vertex attribute data.
 * @param {object} parameters Parameters.
 * @param {@webgears-app/engine-core.VertexBufferView} parameters.vertexData An attribute's staging buffer.
 * @param {number} parameters.offset The offset into the staging buffer in bytes.
 * @param {number} parameters.stride The stride, in bytes, between vertex attributes.
 * @param {module:@webgears-app/engine-core.AttributeSemantic} parameters.semantic An attribute's semantic.
 * @param {boolean} parameters.normalized Specifies whether an attribute should be normalized.
 * @param {number} parameters.countElements The number of elements referenced by this attribute.
 * @param {number} parameters.countComponents The number of components in the each attribute's value.
 * @param {module:@webgears-app/engine-core.DataType} parameters.componentType The datatype of components in the attribute.
 * @param {module:@webgears-app/engine-core.VertexAttributeType} parameters.elementType
 * @param {type} parameters.type Type of the typed array of the attribute view.
 * Specifies if the attribute is a scalar, vector, or matrix.
 */
class vertexAttribute_VertexAttribute extends disposeableUsageCounter_DisposableUsageCounter {
    constructor({
            vertexData,
            offset,
            stride,
            semantic,
            normalized = false,
            countComponents,
            countElements,
            componentType,
            elementType,
            type
    }) {
        super();

        this._vertexData = vertexData.retain();
        this.offset = offset;
        this.stride = stride;
        this.semantic = semantic;
        this.normalized = normalized;
        this.countElements = countElements;
        this.countComponents = countComponents;
        this.componentType = componentType;
        this.elementType = elementType;
        this.type = type;

        let view = null;

        if (vertexData.view !== null) {
            view = vertexData.empty
                ? { byteOffset: vertexData.view.byteOffset + offset }
                : new type( // eslint-disable-line
                    vertexData.view.buffer,
                    vertexData.view.byteOffset + offset,
                    Math.max(0, (countElements - 1) * stride / type.BYTES_PER_ELEMENT + countComponents)
                );
        }

        this.view = view;
    }

    get vertexData() {
        return this._vertexData;
    }

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#offset
     * @type {number}
     * @summary The offset into the staging buffer in bytes.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#stride
     * @type {number}
     * @summary The stride, in bytes, between vertex attributes.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#semantic
     * @type {module:@webgears-app/engine-core.AttributeSemantic}
     * @summary An attribute's semantic.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#normalized
     * @type {boolean}
     * @summary whether an attribute should be normalized.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#vertexData
     * @type {@webgears-app/engine-core.VertexBufferView}
     * @readonly
     * @summary Vertex data in the staging buffer.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#countElements
     * @type {number}
     * @summary The number of elements referenced by this attribute.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#countComponents
     * @type {number}
     * @summary The number of components in the each attribute's value.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#componentType
     * @type {module:@webgears-app/engine-core.DataType}
     * @summary The datatype of components in the attribute.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#elementType
     * @type {module:@webgears-app/engine-core.VertexAttributeType}
     * @summary Specifies if the attribute is a scalar, vector, or matrix.
     */

    /**
     * @var module:@webgears-app/engine-core.VertexAttribute#view
     * @type {TypedArray}
     * @summary Data view of the attribute.
     */

    _dispose() {
        this.view = null;

        this._vertexData.release();
        this._vertexData = null;

        super._dispose();
    }

    async _loadDependencies() {
        await Promise.all([
            super._loadDependencies(),
            this._vertexData.load(),
        ]);
    }

    _actuallyUnload() {
        this.view = null;

        this._vertexData.unload();

        super._actuallyUnload();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/vertexAttributeType.js

/**
 * @namespace module:@webgears-app/engine-core.VertexAttributeType
 * @desc Vertex attribute type enum.
 * @property {number} SCALAR
 * @property {number} VEC2
 * @property {number} VEC3
 * @property {number} VEC4
 * @property {number} MAT2
 * @property {number} MAT3
 * @property {number} MAT4
 */
class VertexAttributeType {
    static get SCALAR() { return 0; }
    static get VEC2() { return 1; }
    static get VEC3() { return 2; }
    static get VEC4() { return 4; }
    static get MAT2() { return 5; }
    static get MAT3() { return 6; }
    static get MAT4() { return 7; }
}

function getVertexAttributeCountComponents(attributeType) {
    switch (attributeType) {
        case VertexAttributeType.SCALAR:
            return 1;
        case VertexAttributeType.VEC2:
            return 2;
        case VertexAttributeType.VEC3:
            return 3;
        case VertexAttributeType.VEC4:
        case VertexAttributeType.MAT2:
            return 4;
        case VertexAttributeType.MAT3:
            return 9;
        case VertexAttributeType.MAT4:
            return 16;
        default:
            throw new Error('Unknown attribute type');
    }
}

function getVertexAttributeTypeName(vertexAttributeType) {
    for (const name of Object.getOwnPropertyNames(VertexAttributeType)) {
        if (name === 'length') { continue; }
        if (VertexAttributeType[name] === vertexAttributeType) { return name; }
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderTarget/renderTargetCanvas.js



/**
 * @class module:@webgears-app/engine-core.RenderTargetCanvas
 * @extends module:@webgears-app/engine-core.RenderTarget
 * @summary Canvas render target.
 * @param {object} [properties = {}] Properties.
 * @param {HTMLCanvasElement} [properties.canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')] Canvas.
 * @param {number} [properties.width = canvas.width] The width of the render target.
 * @param {number} [properties.height = canvas.height] The height of the render target.
 * @param {boolean} [properties.updateStyle = true] Specifies if necessary to update canvas style.
 */
class renderTargetCanvas_RenderTargetCanvas extends renderTarget_RenderTarget {
    constructor(properties = {}) {
        super();

        let canvas = null;

        ({ canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas') } = properties);

        console.assert(canvas instanceof HTMLCanvasElement,
            `${this.constructor.name}.ctor: canvas property: ${typeof canvas}, expects HTMLCanvasElement or undefined`);

        this._canvas = canvas;

        const { width, height, updateStyle = true } = properties;

        canvas.width = width || canvas.width;
        canvas.height = height || canvas.height;

        if (updateStyle !== false) {
            canvas.style.width = `${canvas.width}px`;
            canvas.style.height = `${canvas.height}px`;
        }
    }

    /**
     * @function module:@webgears-app/engine-core.RenderTargetCanvas#resize
     * @param {number} width Width
     * @param {number} height Height
     * @param {boolean} updateStyle Specifies if necessary to update canvas style.
     * @summary Resizes render target.
     */
    resize(width, height, pixelRatio = 1, updateStyle = true) {
        const { _canvas } = this;

        _canvas.width = Math.floor(width * pixelRatio);
        _canvas.height = Math.floor(height * pixelRatio);

        if (updateStyle !== false) {
            _canvas.style.width = `${width}px`;
            _canvas.style.height = `${height}px`;
        }
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCanvas#width
     * @type {number}
     * @readonly
     * @summary Width
     */
    get width() {
        return this._canvas.width;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCanvas#height
     * @type {number}
     * @readonly
     * @summary Height
     */
    get height() {
        return this._canvas.height;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderTargetCanvas#canvas
     * @type {HTMLCanvasElement}
     * @readonly
     * @summary Canvas
     */
    get canvas() {
        return this._canvas;
    }
}

Object.defineProperty(renderTargetCanvas_RenderTargetCanvas.prototype, 'isRenderTargetCanvas', { value: true });



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/spatialIndexFrustumCull.js

 // eslint-disable-line

const spatialIndexFrustumCull_batch_ = new instancedBatch();

const spatialIndexFrustumCull_currentFrameVisibilityFlag = 0x02;
const uncullableFlag = 0x08;
const spatialIndexFrustumCull_survivedCullingFlag = 0x20;

const visibleInstanceKeys = [];

/**
 * @function module:@webgears-app/engine-core.spatialIndexFrustumCull
 * @summary Frustum culler based on {@link module:@webgears-app/engine-core.SpatialIndex#webGLFrustumFind}.
 * @param {module:@webgears-app/engine-core.Scene} scene The scene.
 * @param {module:@webgears-app/engine-core.Camera} camera The camera.
 * @param {number} frameNumber Number of the current frame.
 * @returns {boolean}
 */
function spatialIndexFrustumCull(scene, camera, frameNumber) {
    const { instanceDataManager, spatialIndex } = scene;
    const { _flagBuffers, _instancedBatches } = instanceDataManager;

    {
        const { batchCount } = _instancedBatches;
        const flagBuffer = _flagBuffers;

        for (let batchIdx = 0; batchIdx < batchCount; batchIdx++) {
            _instancedBatches.unpackBatch(batchIdx, spatialIndexFrustumCull_batch_);

            if (spatialIndexFrustumCull_batch_.excluded) continue;

            for (let j = 0, len = spatialIndexFrustumCull_batch_.instanceCount; j < len; j++) {
                const instanceIdx = spatialIndexFrustumCull_batch_.firstInstance + j;
                const flags = flagBuffer[instanceIdx];

                if (flags & spatialIndexFrustumCull_currentFrameVisibilityFlag) {
                    const uncullable = !!(flags & uncullableFlag);
                    flagBuffer[instanceIdx] = flags ^ ((flags ^ -uncullable) & spatialIndexFrustumCull_survivedCullingFlag);
                }
            }
        }
    }

    spatialIndex.webGLFrustumFind(camera.viewProjectionMatrix, visibleInstanceKeys);

    const visibleInstanceCount = visibleInstanceKeys.length;

    for (let i = 0; i < visibleInstanceCount; ++i) {
        const { globalIndex } = visibleInstanceKeys[i];
        const flagBuffer = _flagBuffers;
        const flags = flagBuffer[globalIndex];

        if (flags & spatialIndexFrustumCull_currentFrameVisibilityFlag) {
            flagBuffer[globalIndex] = flags | spatialIndexFrustumCull_survivedCullingFlag;
        }
    }

    return true;
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderQueueSort.js



function _sortFunction(lhs, rhs) {
    const lRQG = lhs.renderQueueGroup;
    const rRQG = rhs.renderQueueGroup;

    const lMode = lhs.material.alphaMode;
    const rMode = rhs.material.alphaMode;

    let cmp = 0;

    if (lRQG !== rRQG) {
        cmp = lRQG - rRQG; // less value group goes first
    } else if (lMode !== material_Material.AlphaMode.BLEND && rMode === material_Material.AlphaMode.BLEND) {
        cmp = -1; // lhs goes first
    } else if (lMode === material_Material.AlphaMode.BLEND && rMode !== material_Material.AlphaMode.BLEND) {
        cmp = 1;  // no matter anything, lhs gotta go end
    } else if (lMode === material_Material.AlphaMode.BLEND && rMode === material_Material.AlphaMode.BLEND) {
        const d = lhs.viewZ - rhs.viewZ; // blends from far to close
        cmp = d !== 0 ? d : lhs.material.id - rhs.material.id;
    } else if (lMode !== material_Material.AlphaMode.BLEND && rMode !== material_Material.AlphaMode.BLEND) {
        cmp = lhs.material.id - rhs.material.id;
    }

    return cmp;
}

function renderQueueSort(queue) {
    queue.sort(_sortFunction);
    return queue;
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderPass.js











/**
 * @class module:@webgears-app/engine-core.RenderPassStatistics
 * @summary Render pass statistics.
 */
class RenderPassStatistics {
    constructor() {
        this.subpassCount = 0;
        this.drawCallCount = 0;
        this.instanceCount = 0;
        this.vertexCount = 0;
        this.materialCount = 0;
        this.programCount = 0;
    }

    reset() {
        this.subpassCount = 0;
        this.drawCallCount = 0;
        this.instanceCount = 0;
        this.vertexCount = 0;
        this.materialCount = 0;
        this.programCount = 0;
    }

    add(statistics) {
        this.subpassCount += statistics.subpassCount;
        this.drawCallCount += statistics.drawCallCount;
        this.instanceCount += statistics.instanceCount;
        this.vertexCount += statistics.vertexCount;
        this.materialCount += statistics.materialCount;
        this.programCount += statistics.programCount;
    }
}

const _OutputLayoutSemantic = makeEnum([
    ['DEFAULT', 1 << 0],
    ['COLOR_0', 1 << 1],
    ['COLOR_1', 1 << 2],
    ['COLOR_2', 1 << 3],
    ['COLOR_3', 1 << 4],
    ['TM_DIFFUSE', 1 << 5],
    ['TM_SPECULAR', 1 << 6],
    ['NORMALS', 1 << 7],
    ['EMISSIVE', 1 << 8],
    ['SPECULAR', 1 << 9],
    ['DIFFUSE', 1 << 10],
    ['DIRECT_SPECULAR', 1 << 11],
    ['INDIRECT_SPECULAR', 1 << 12],
    ['DIRECT_DIFFUSE', 1 << 13],
    ['INDIRECT_DIFFUSE', 1 << 14],
    ['VIEW_POSITION', 1 << 15],
    ['HYPERBOLIC_DEPTH_RGBA', 1 << 16],
    ['INSTANCE_COLOR', 1 << 17],
    ['CIE_xyY_COLOR', 1 << 18],
    ['CIE_LUV_COLOR', 1 << 19],
    ['LINEAR_HDR_COLOR', 1 << 20]
]);

let _lastRenderPassId = 0;

/**
 * @class module:@webgears-app/engine-core.RenderPass
 * @param {object} parameters Parameters.
 * @param {module:@webgears-app/engine-core.Scene} parameters.scene Scene to render.
 * @param {module:@webgears-app/engine-core.Camera} parameters.camera Camera to render through.
 * @param {?module:@webgears-app/engine-core.RenderTarget} [parameters.renderTarget=null] Render target to render to.
 * @param {boolean} [parameters.srgbOutput] Whether the renderer should apply sRGB correction.
 * @summary Class encapsulates render pass parameters.
 */
class renderPass_RenderPass {
    /**
     * @namespace module:@webgears-app/engine-core.RenderPass.OutputLayoutSemantic
     * @desc The render pass output's semantic.
     * @property {number} DEFAULT
     * @property {number} COLOR_0
     * @property {number} COLOR_1
     * @property {number} COLOR_3
     * @property {number} TM_DIFFUSE
     * @property {number} TM_SPECULAR
     * @property {number} NORMALS
     * @property {number} SPECULAR
     * @property {number} DIFFUSE
     * @property {number} DIRECT_SPECULAR
     * @property {number} INDIRECT_SPECULAR
     * @property {number} DIRECT_DIFFUSE
     * @property {number} INDIRECT_DIFFUSE
     * @property {number} VIEW_POSITION
     * @property {number} HYPERBOLIC_DEPTH_RGBA Use this output in case there is no ability to read depth directly
     * form depth buffer (WebGL 1 case only).
     * @property {number} INSTANCE_COLOR
     * @property {number} CIE_xyY_COLOR
     * @property {number} CIE_LUV_COLOR
     * @property {number} LINEAR_HDR_COLOR
     */
    static get OutputLayoutSemantic() {
        return _OutputLayoutSemantic;
    }

    constructor({ scene, camera, renderTarget = null, srgbOutput = false }) {
        this.id = ++_lastRenderPassId;

        this.scene = scene;
        this.camera = camera;
        this.frameNumber = 0;
        this.renderTarget = renderTarget;
        this.srgbOutput = srgbOutput;
        this.dt = 0;

        this.clearMask = ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT | ClearMask.STENCIL_BUFFER_BIT;

        this.statistics = new RenderPassStatistics();

        this._outputLayout = new Map();
        this._output = 0;

        this.frustumCull = spatialIndexFrustumCull;
        this.renderQueueSort = renderQueueSort;
        this.queueRangeSize = 0;
        this._queueRangeIndex = 0;
        this._queueRangeOffset = 0;

        this._premultipliedAlpha = false;

        this._viewport = null;
        this._multiplyPixelRatio = true;

        this._events = new Map();

        const stages = setupSystemUpdateStages();

        for (const stage of stages.values()) {
            this._events.set(stage, new Event());
        }

        Object.defineProperties(this, {
            /**
             * @callback module:@webgears-app/engine-core.RenderPass.StartEventSignature
             */
            /**
             * @var module:@webgears-app/engine-core.RenderPass#onStart
             * @summary Render pass started (after ESC update).
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.StartEventSignature>}
             * @readonly
             */
            onStart: { value: new Event() },

            /**
             * @callback module:@webgears-app/engine-core.RenderPass.SubpassStartEventSignature
             * @param {number} index Subpass index.
             */
            /**
             * @var module:@webgears-app/engine-core.RenderPass#onSubpassStart
             * @summary Render subpass started.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.SubpassStartEventSignature>}
             * @readonly
             */
            onSubpassStart: { value: new Event() },

            /**
             * @callback module:@webgears-app/engine-core.RenderPass.SubpassEndEventSignature
             * @param {number} index Subpass index.
             */
            /**
             * @var module:@webgears-app/engine-core.RenderPass#onSubpassEnd
             * @summary Render subpass ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.SubpassEndEventSignature>}
             * @readonly
             */
            onSubpassEnd: { value: new Event() },

            /**
             * @callback module:@webgears-app/engine-core.RenderPass.EndEventSignature
             */
            /**
             * @var module:@webgears-app/engine-core.RenderPass#onEnd
             * @summary Render pass ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.EndEventSignature>}
             * @readonly
             */
            onEnd: { value: new Event() },


            /**
             * @callback module:@webgears-app/engine-core.RenderPass.RangeStartEventSignature
             */
            /**
             * @var module:@webgears-app/engine-core.RenderPass#onRangeStart
             * @summary Render pass range rendering is about to start
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.RangeStartEventSignature>}
             * @readonly
             */
            onRangeStart: { value: new Event() }
        });

        this.computeViewZ = true;
        this.testSurvivedCullingFlag = true;
        this.renderQueue = [];
    }

    /**
     * @var module:@webgears-app/engine-core.RenderPass#testSurvivedCullingFlag
     * @summary Specifies whether survivedCullingFlag must affect of render queue or not.
     * @type {boolean}
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#computeViewZ
     * @summary Specifies whether render queue preparation should update viewZ value as well.
     * @type {boolean}
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#queueRangeIndex
     * @type {number}
     * @summary Current render pass range index. Has sense only in case render pass is ranged.
     */
    get queueRangeIndex() {
        return this._queueRangeIndex;
    }

    set queueRangeIndex(value) {
        this._queueRangeIndex = value;
        this._queueRangeOffset = this.queueRangeSize * value;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderPass#rangedPass
     * @type {boolean}
     * @summary Specifies whether render pass is ranged or not.
     * @readonly
     */
    get rangedPass() {
        return this.queueRangeSize > 0;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderPass#queueRangeSize
     * @type {number}
     * @summary Specifies number of batches the renderer can render per frame in case of ranged renderer.
     * @readonly
     */

    runFrustumCull(subPassIndex) {
        const { scene, camera, frameNumber, frustumCull } = this;

        if (camera.isCubeCamera) camera.cubeSideIndex = subPassIndex;

        if (frustumCull(scene, camera, frameNumber)) { // returns true if frustum cull affects on queue
            this.updateRenderQueue();
        }

        return this.renderQueue;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderPass#setOutputLayoutPosition
     * @summary Binds output with defined semantic with number of  color attachment in the render target.
     * @desc The binding between canvas and output's semantic is also possible,
     * but layout position must be always zero in this case.
     * @param {module:@webgears-app/engine-core.RenderPass.OutputLayoutSemantic} layoutSemantic An output's semantic.
     * @param {number} layoutPosition The number of color attachment.
     */
    setOutputLayoutPosition(layoutSemantic, layoutPosition) {
        const { _outputLayout, renderTarget } = this;

        console.assert(layoutPosition === 0
            || (renderTarget instanceof renderTargetFramebuffer_RenderTargetFramebuffer
                && renderTarget.hasColorAttachment(
                    renderTargetFramebuffer_RenderTargetFramebuffer.Attachment.COLOR_ATTACHMENT0 + layoutPosition
                ))); // ,`renderTarget has not layout position ${layoutPosition}`);

        _outputLayout.set(layoutSemantic, layoutPosition);

        this._output |= layoutSemantic;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderPass#getOutputLayoutPosition
     * @summary Returns number of color attachment the output's semantic is bound with
     * or null if the binding does not exist.
     * @param {module:@webgears-app/engine-core.RenderPass.OutputLayoutSemantic} layoutSemantic An output's semantic.
     * @returns {?number}
     */
    getOutputLayoutPosition(layoutSemantic) {
        const layoutPos = this._outputLayout.get(layoutSemantic);
        return layoutPos !== undefined ? layoutPos : null;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderPass#removeOutputLayout
     * @summary Removes the binding between output's semantic and color attachment.
     * @param {module:@webgears-app/engine-core.RenderPass.OutputLayoutSemantic} layoutSemantic An output's semantic.
     */
    removeOutputLayout(layoutSemantic) {
        this._outputLayout.delete(layoutSemantic);
        this._output &= ~layoutSemantic;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderPass#scene
     * @type {module:@webgears-app/engine-core.Scene}
     * @summary Scene to render.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#renderTarget
     * @type {module:@webgears-app/engine-core.RenderTarget}
     * @summary The render target to render to.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#camera
     * @type {module:@webgears-app/engine-core.Camera}
     * @summary Camera to render through.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#output
     * @summary Render pass output mask.
     * @readonly
     * @returns {number}
     */
    get output() {
        return this._output === 0 ? _OutputLayoutSemantic.DEFAULT : this._output;
    }

    /**
     * @var module:@webgears-app/engine-core.RenderPass#frameNumber
     * @type {number}
     * @summary The number of previous frame.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#srgbOutput
     * @type {boolean}
     * @summary Whether the renderer should apply sRGB correction.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#clearMask
     * @type {module:@webgears-app/engine-core.ClearMask}
     * @summary Mask that indicates the render target buffers to be cleared.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#dt
     * @type {number}
     * @summary Time since last frame.
     */

    /**
     * @var module:@webgears-app/engine-core.RenderPass#statistics
     * @type {module:@webgears-app/engine-core.Statistics}
     * @summary The last frame statistics.
     */

    copy(src) {
        this.scene = src.scene;
        this.camera = src.camera;
        this.frameNumber = src.frameNumber;
        this.renderTarget = src.renderTarget;
        this.srgbOutput = src.srgbOutput;
        this.dt = src.dt;
    }

    /**
     * @function module:@webgears-app/engine-core.RenderPass#setViewport
     * @param x {number} Viewport left.
     * @param y {number} Viewport top
     * @param width {number} Viewport with.
     * @param height {number} Viewport height.
     * @param multiplyPixelRatio {boolean} Whether the renderer should multiply viewport with pixel ratio or not.
     * @summary Setups custom viewport value.
     */
    setViewport(x, y, width, height, multiplyPixelRatio = true) {
        this._multiplyPixelRatio = multiplyPixelRatio;
        this._viewport = { x, y, width, height };
    }

    /**
     * @function module:@webgears-app/engine-core.RenderPass#onStageEnd
     * @param {enum} stage Stage.
     * @summary Provides access to the stage end event.
     */
    onStageEnd(stage) {
        console.assert(this._events.has(stage)); // `renderPass has no event for stage ${stage}`
        return this._events.get(stage);
    }
}

Object.assign(renderPass_RenderPass.prototype, {
    updateRenderQueue: (function _updateRenderQueue() {
        const prevFrameVisibilityFlag = 0x01;
        const currentFrameVisibilityFlag = 0x02;
        const transformUpdateFlag = 0x04;
        const customAttributeUpdateFlag = 0x10;
        const survivedCullingFlag = 0x20;

        const batch_ = new instancedBatch();

        const cameraBack = new Vector3();
        const cameraPosition = new Vector3();
        const renderableDirection = new Vector3();

        const _computeViewZ = function(centers, idx, dir, back, pos) {
            dir.fromArrayAt(idx * 3, centers).subtract(pos);

            return dir.dot(back);
        };

        return function updateRenderQueue() {
            const {
                computeViewZ,
                testSurvivedCullingFlag,
                renderQueue,
                scene,
                camera,
                renderQueueSort: queueSort
            } = this;

            const { instanceDataManager } = scene;

            const {
                _worldTransformsBack,
                _worldTransformsFront,
                _centers,
                _flagBuffers,
                _instancedBatches,
                elementsPerInstance,
                bytesPerInstance,
            } = instanceDataManager;

            let flushRangeFrom = Infinity;
            let flushRangeTo = 0;

            if (computeViewZ && camera.worldMatrix !== undefined) {
                camera.worldMatrix.axisZPaste(cameraBack);
                camera.worldMatrix.translationPaste(cameraPosition);
            }

            renderQueue.length = 0;

            {
                const { batchCount } = _instancedBatches;
                const flagBuffer = _flagBuffers;
                const centers = _centers;

                let prevBatchChanged = false;

                for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
                    _instancedBatches.unpackBatch(batchIndex, batch_);

                    let visibleInstanceCount = 0;
                    let viewZ = 0;
                    let needsUpdate = false;

                    const excluded = batch_.excluded; // eslint-disable-line

                    for (let j = 0, len = batch_.instanceCount; j < len; j++) {
                        const instanceIdx = batch_.firstInstance + j;

                        let flags = flagBuffer[instanceIdx];

                        const survivedCulling = !!(flags & survivedCullingFlag) || !testSurvivedCullingFlag;

                        const inFrame = !!(flags & currentFrameVisibilityFlag);

                        const isVisible = inFrame && survivedCulling && !excluded;

                        const prevFrameVisibilityStatus = (flags & prevFrameVisibilityFlag) !== 0;

                        if (isVisible !== prevFrameVisibilityStatus) {
                            needsUpdate = true;
                            flags = isVisible ? flags | prevFrameVisibilityFlag : flags & ~prevFrameVisibilityFlag;
                        }

                        const needsUpdateTransform = (flags & transformUpdateFlag) !== 0;

                        if (needsUpdateTransform) {
                            needsUpdate = true;
                            flags &= ~transformUpdateFlag;
                        }

                        const needsUpdateCustomAttributes = (flags & customAttributeUpdateFlag) !== 0;

                        if (needsUpdateCustomAttributes) {
                            needsUpdate = true;
                            flags &= ~customAttributeUpdateFlag;
                        }

                        flagBuffer[instanceIdx] = flags;

                        if (isVisible) {
                            viewZ = computeViewZ
                                ? _computeViewZ(centers, instanceIdx, renderableDirection, cameraBack, cameraPosition)
                                : 0;

                            const srcElementOffset = instanceIdx * elementsPerInstance;
                            const srcByteOffset = srcElementOffset * Float32Array.BYTES_PER_ELEMENT;
                            const dstElementOffset = (batch_.firstInstance + visibleInstanceCount++) * elementsPerInstance;

                            _worldTransformsFront.set(
                                new Float32Array(_worldTransformsBack.buffer, srcByteOffset, elementsPerInstance),
                                dstElementOffset
                            );

                            _worldTransformsFront[dstElementOffset + 12] = j;
                        }
                    } // batch done

                    // if prev batch changed
                    if (prevBatchChanged) {
                        needsUpdate = true;
                    }

                    if (!prevBatchChanged && needsUpdate) {
                        prevBatchChanged = true;
                    }

                    if (needsUpdate) {
                        flushRangeFrom = Math.min(flushRangeFrom, batch_.firstInstance * bytesPerInstance);
                        flushRangeTo =
                            Math.max(flushRangeTo, (batch_.firstInstance + visibleInstanceCount) * bytesPerInstance);
                    }

                    if (visibleInstanceCount > 0) {
                        const { instanceId, firstInstance } = batch_;
                        const batchRenderable = instanceDataManager.getInstanceRenderable(instanceId);

                        batchRenderable.firstInstance = firstInstance;
                        batchRenderable.visibleInstanceCount = visibleInstanceCount;
                        batchRenderable.viewZ = viewZ;

                        renderQueue.push(batchRenderable);
                    }
                } // queue done
            }

            // sort queue
            queueSort(renderQueue);

            flushRangeFrom = isFinite(flushRangeFrom) ? flushRangeFrom : 0; // in case nothing to update

            instanceDataManager.setInstancedMemoryFlushRange(flushRangeFrom, flushRangeTo);
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/renderTarget/renderTargetAttachment.js


/**
 * @namespace module:@webgears-app/engine-core.RenderTargetAttachment
 * @desc Render target attachment enum.
 * @property NONE
 * @property COLOR_ATTACHMENT0
 * @property DEPTH_ATTACHMENT
 * @property DEPTH_STENCIL_ATTACHMENT
 * @property STENCIL_ATTACHMENT
 */
class RenderTargetAttachment {}

(function prepEnum() {
    const attachments = [
        'NONE',
        'COLOR_ATTACHMENT0',
        'DEPTH_ATTACHMENT',
        'DEPTH_STENCIL_ATTACHMENT',
        'STENCIL_ATTACHMENT'
    ];

    for (const attachment of attachments) {
        const value = webglContext[attachment];

        Object.defineProperty(RenderTargetAttachment, attachment, { value, writeable: false });
    }
}());



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/geometry.js






let _lastGeometryId = 0;

const geometry_positionMorphTargets = [
    AttributeSemantic.POSITION_MORPH_0,
    AttributeSemantic.POSITION_MORPH_1,
    AttributeSemantic.POSITION_MORPH_2,
    AttributeSemantic.POSITION_MORPH_3,
    AttributeSemantic.POSITION_MORPH_4,
    AttributeSemantic.POSITION_MORPH_5,
    AttributeSemantic.POSITION_MORPH_6,
    AttributeSemantic.POSITION_MORPH_7
];

const geometry_normalMorphTargets = [
    AttributeSemantic.NORMAL_MORPH_0,
    AttributeSemantic.NORMAL_MORPH_1,
    AttributeSemantic.NORMAL_MORPH_2,
    AttributeSemantic.NORMAL_MORPH_3,
    AttributeSemantic.NORMAL_MORPH_4,
    AttributeSemantic.NORMAL_MORPH_5,
    AttributeSemantic.NORMAL_MORPH_6,
    AttributeSemantic.NORMAL_MORPH_7
];

class _AttributesProxy {
    constructor() {
        this._attributes = new Map();
    }

    get size() {
        return this._attributes.size;
    }

    has(semantic) {
        return this._attributes.has(semantic);
    }

    set(semantic, attribute) {
        attribute.retain();

        if (this._attributes.has(semantic)) {
            this._attributes.get(semantic).release();
        }

        this._attributes.set(semantic, attribute);
    }

    get(semantic) {
        return this._attributes.get(semantic);
    }

    delete(semantic) {
        const { _attributes } = this;

        const a = _attributes.get(semantic);

        if (a !== undefined)
            a.release();

        _attributes.delete(semantic);
    }

    clear() {
        const {_attributes} = this;

        for (const a of _attributes.values()) {
            a.release();
        }

        _attributes.clear();
    }

    entries() {
        return this._attributes.entries();
    }

    values() {
        return this._attributes.values();
    }

    keys() {
        return this._attributes.keys();
    }
}

/**
 *  @class module:@webgears-app/engine-core.Geometry
 *  @extends module:@webgears-app/engine-core.DisposableUsageCounter
 *  @param {object} [parameters] Parameters.
 *  @param {module:@webgears-app/engine-core.PrimitiveType} [parameters.primitiveType=PrimitiveType.TRIANGLES]
 *  Primitive type.
 *  @summary Class represents mesh vertices.
 */
class geometry_Geometry extends disposeableUsageCounter_DisposableUsageCounter {
    constructor(parameters = {}) {
        super();

        const { primitiveType = PrimitiveType.TRIANGLES } = parameters;

        this._id = ++_lastGeometryId;
        this.attributes = new _AttributesProxy();
        this.morphTargets = new _AttributesProxy();
        this.primitiveType = primitiveType;

        this.boundingBox = new rectangle_and_box_Box();
        this.needsUpdateBoundingBox = true;

        this._indices = null;
    }

    /**
     * @var module:@webgears-app/engine-core.Geometry#boundingBox
     * @type {module:@webgears-app/math.Box3}
     * @summary Geometry bounding box
     */

    /**
     * @var module:@webgears-app/engine-core.Geometry#needsUpdateBoundingBox
     * @type {Boolean}
     * @summary Whether needs to update bounding box or not
     */

    /**
     * @var module:@webgears-app/engine-core.Geometry#primitiveType
     * @type {module:@webgears-app/engine-core.PrimitiveType}
     * @summary The type of primitives to render.
     * @default module:@webgears-app/engine-core.PrimitiveType.TRIANGLES
     */

    /**
     * @var module:@webgears-app/engine-core.Geometry#attributes
     * @type {Map}
     * @summary
     * A map object, where each key corresponds to mesh attribute semantic
     * and each value is the vertex attribute.
     */

    /**
     * @var module:@webgears-app/engine-core.Geometry#indices
     * @type {?module:@webgears-app/engine-core.VertexAttribute}
     * @summary Vertex indices.
     */

    /**
     * @var module:@webgears-app/engine-core.Geometry#id
     * @type {number}
     * @readonly
     * @summary Geometry unique identifier.
     */
    get id() {
        return this._id;
    }

    get indices() {
        return this._indices;
    }

    set indices(value) {
        if (value !== null) {
            value.retain();
        }

        if (this._indices !== null) {
            this._indices.release();
        }

        this._indices = value;
    }

    async _loadDependencies() {
        await Promise.all([
            super._loadDependencies(),
            ...(function*() {
                if (this._indices !== null) {
                    yield this._indices.load();
                }

                for (const a of this.attributes.values()) {
                    yield a.load();
                }

                for (const m of this.morphTargets.values()) {
                    yield m.load();
                }
            }).call(this),
        ]);
    }

    _actuallyUnload() {
        if (this._indices !== null) {
            this._indices.unload();
        }

        for (const a of this.attributes.values()) {
            a.unload();
        }

        super._actuallyUnload();
    }

    _dispose() {
        if (this._indices !== null) {
            this._indices.release();
        }

        this.attributes.clear();
        this.morphTargets.clear();

        super._dispose();
    }

    /**
     * @function module:@webgears-app/engine-core.Geometry#updateBoundingBox
     * @param {module:@webgears-app/engine-core.AttributeSemantic} [semantic = AttributeSemantic.POSITION]
     * Semantic to select attribute to compute bounding box from.
     * @summary Updates geometry bounding box.
     */
    updateBoundingBox(semantic = AttributeSemantic.POSITION) {
        const { attributes, boundingBox } = this;

        if (!attributes.has(semantic)) return;

        const attribute = attributes.get(semantic);

        console.assert(attribute.countComponents >= 3);

        const array = attribute.view;

        const stride = attribute.stride / attribute.type.BYTES_PER_ELEMENT;
        console.assert(Number.isInteger(stride));

        boundingBox.min.fromNumber(+Infinity);
        boundingBox.max.fromNumber(-Infinity);

        const value = new Vector3();

        for (let i = 0, count = attribute.countElements; i < count; i++) {
            value.fromArrayAt(i * stride, array);
            boundingBox.consumePoint(value);
        }

        this.needsUpdateBoundingBox = false;
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/resourceStreamer.js

class ResourceStreamer {
    constructor({
        scene,
        renderer,
    }) {
        this.scene = scene;
        this.renderer = renderer;
    }

    async load(geometry, material) {
        const { instanceDataManager } = this.scene;
        const instanceId = instanceDataManager.getInstanceIdentifier(geometry.id, material.id);
        const instanceCount = instanceDataManager.getInstanceCount(instanceId);
        await Promise.all((function*() {
            for (let i = 0; i < instanceCount; ++i) {
                yield geometry.load();
                yield material.load();
            }
        }).call(this));
        await new Promise((resolve, reject) => {
            this.renderer.onFrameEnd.subscribe(() => {
                try {
                    instanceDataManager.enableBatches({geometry, material});
                    resolve();
                } catch (error) {
                    reject(error);
                }
            }, { once: true });
        })
    }

    unload(geometry, material) {
        return new Promise((resolve, reject) => {
            this.renderer.onFrameEnd.subscribe(() => {
                try {
                    const { instanceDataManager } = this.scene;
                    const instanceId = instanceDataManager.getInstanceIdentifier(geometry.id, material.id);
                    const instanceCount = instanceDataManager.getInstanceCount(instanceId);

                    instanceDataManager.disableBatches({geometry, material});
                    for (let i = 0; i < instanceCount; ++i) {
                        geometry.unload();
                        material.unload();
                    }

                    resolve();
                } catch (error) {
                    reject(error);
                }
            }, { once: true });
        });
    }
}

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/engine-core/src/index.js
/**
 * @module @webgears-app/engine-core
 */








































































// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/platform/src/index.js

let src_mobile = false;
let src_tablet = false;
let src_ios = false;
let src_mac = false;
let src_android = false;
let src_windows = false;
let src_cocoonjs = false;
let src_xbox = false;
let src_gamepads = false;
let src_touch = false;

(function getPlatform() {
    const ua = navigator.userAgent;

    if (/(windows|mac os|linux|cros)/i.test(ua)) {
        src_mobile = false;
    }

    if (/(mac os)/i.test(ua)) {
        src_mac = true;
    }

    if (/xbox/i.test(ua)) {
        src_xbox = false;
    }

    if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
        src_mobile = true;
        src_windows = true;
    } else if (/android/i.test(ua)) {
        src_mobile = true;
        src_android = true;
    } else if (/ip([ao]d|hone)/i.test(ua)) {
        src_mobile = true;
        src_ios = true;
    }

    if(/(ipad|tablet)/.test(ua)) {
        src_mobile = false;
        src_tablet = true;
    }

    if (navigator.isCocoonJS) {
        src_cocoonjs = true;
    }

    src_touch = 'ontouchstart' in window;

    src_gamepads = 'getGamepads' in navigator;
}());

class src_Platform {
    static get mobile() { return src_mobile; }
    static get tablet() { return src_tablet; }
    static get desktop() { return !src_mobile && !src_tablet; }
    static get ios() { return src_ios; }
    static get android() { return src_android; }
    static get windows() { return src_windows; }
    static get mac() { return src_mac; }
    static get cocoonjs() { return src_cocoonjs; }
    static get xbox() { return src_xbox; }
    static get gamepads() { return src_gamepads; }
    static get touchscreen() { return src_touch; }
}

/* harmony default export */ var platform_src = (src_Platform);

// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/camera-controller/src/orbitController/inputHandlers/mouseHandler.js





class mouseHandler_MouseHandler {
    constructor(controller, input) {
        console.assert(controller instanceof orbitController_OrbitController);
        // , `${this.constructor.name}: argument type ${typeof controller}, expects OrbitController`);

        const delta = new Vector2(0, 0);

        const dollyDirection = new Vector2(0, -1);

        let onMouseMoveHandler = () => { };

        const onMouseWheel = deltaVector => controller.dolly(Math.sign(-deltaVector.y) * 0.8);
        input.onScroll.subscribe(onMouseWheel);

        const onMouseDown = () => {
            const left = input.isButtonPressed(mouse_Mouse.Buttons.LEFT);
            const right = input.isButtonPressed(mouse_Mouse.Buttons.RIGHT);
            const middle = input.isButtonPressed(mouse_Mouse.Buttons.MIDDLE);

            controller._inputInterrupt = left || middle || right;

            const { y: clientHeight } = input.surfaceSize;

            if (left && right) {
                onMouseMoveHandler = () => controller.dolly(delta.length * delta.dot(dollyDirection) * 0.005);
            } else if (right || middle) {
                onMouseMoveHandler = () => controller.pan(-delta.x, -delta.y, clientHeight);
            } else if (left) {
                onMouseMoveHandler = () => controller.rotate(-delta.x, -delta.y, clientHeight);
            } else {
                onMouseMoveHandler = () => { };
            }
        };

        const onMouseUp = () => {
            controller._inputInterrupt = false;

            onMouseMoveHandler = () => { };
        };

        for (const button of mouse_Mouse.Buttons) {
            input.onButtonPress(button).subscribe(onMouseDown);
            input.onButtonRelease(button).subscribe(onMouseUp);
        }

        const onMouseMove = (deltaVector) => {
            delta.copy(deltaVector);

            onMouseMoveHandler();
        };
        input.onMove.subscribe(onMouseMove);

        this._removeListeners = () => {
            input.onScroll.unsubscribe(onMouseWheel);

            for (const button of mouse_Mouse.Buttons) {
                input.onButtonPress(button).unsubscribe(onMouseDown);
                input.onButtonRelease(button).unsubscribe(onMouseUp);
            }

            input.onMove.unsubscribe(onMouseMove);
        };
    }

    dispose() {
        this._removeListeners();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/camera-controller/src/orbitController/inputHandlers/touchHandler.js




class touchHandler_TouchHandler {
    constructor(controller, input) {
        console.assert(controller instanceof orbitController_OrbitController);
        // `${this.constructor.name}: argument type ${typeof controller}, expects OrbitController`);

        const delta0 = new Vector2(0, 0);
        const delta1 = new Vector2(0, 0);

        const pointerLastPosition0 = new Vector2(0, 0);
        const pointerLastPosition1 = new Vector2(0, 0);

        let pointerLastDelta = 0;

        let onTouchMoveHandler = () => { };

        const onOneTouch = (delta) => {
            const { y: clientHeight } = input.surfaceSize;

            controller.rotate(-delta.x, -delta.y, clientHeight);
        };

        const onTwoTouches = () => {
            const [ touch0, touch1 ] = [ ...input.touches() ];

            delta0.copy(touch0.position);
            delta0.subtractVector(pointerLastPosition0);

            delta1.copy(touch1.position);
            delta1.subtractVector(pointerLastPosition1);

            const delta0sqLength = delta0.sqLength;
            const delta1sqLength = delta1.sqLength;

            const { y: clientHeight } = input.surfaceSize;

            if (Math.abs(delta0sqLength * delta1sqLength) > 2) {
                if (delta0.dot(delta1) > 0.1) {
                    controller.pan(-delta0.x, -delta0.y, clientHeight);
                } else {
                    delta0.copy(touch0.position);
                    delta1.copy(touch1.position);

                    const delta = delta0.distance(delta1);

                    controller.dolly((delta - pointerLastDelta) * 0.1);
                    // controller.dolly(Math.sign(delta - pointerLastDelta) * pointerLastDelta / delta * 0.5);

                    pointerLastDelta = delta;
                }

                pointerLastPosition0.copy(touch0.position);
                pointerLastPosition1.copy(touch1.position);
            }
        };

        const onTouchMove = (delta) => {
            onTouchMoveHandler(delta);
        };

        const onTouchEnd = () => {
            controller._inputInterrupt = false;

            onTouchMoveHandler = () => { };
        };

        input.onTouchStart.subscribe((touch) => {
            const touches = [ ...input.touches() ];

            controller._inputInterrupt = touches.length === 1 || touches.length === 2;

            switch (touches.length) {
                case 1:
                    onTouchMoveHandler = onOneTouch;
                    break;

                case 2:
                    {
                        const [ touch0, touch1 ] = touches;

                        pointerLastPosition0.copy(touch0.position);
                        pointerLastPosition1.copy(touch1.position);

                        pointerLastDelta = pointerLastPosition0.distance(pointerLastPosition1);

                        onTouchMoveHandler = onTwoTouches;
                    }
                    break;

                default:
                    onTouchMoveHandler = () => { };
                    break;
            }

            touch.onEnd.subscribe(onTouchEnd);

            touch.onMove.subscribe(onTouchMove);
        });
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/camera-controller/src/orbitController/inputHandlers/keyboardHandler.js



class keyboardHandler_KeyboardHandler {
    constructor(controller, input) {
        console.assert(controller instanceof orbitController_OrbitController);
            // `${this.constructor.name}: argument type ${typeof controller}, expects OrbitController`);

        const direction = { x: 0, y: 0, z: 0 };

        const callbacks = [
            {
                button: keyboard_Keyboard.Keys.KEY_W,
                onPress: () => { direction.z = 1; controller.move(direction); },
                onUp: () => { direction.z = 0; controller.move(direction); }
            },
            {
                button: keyboard_Keyboard.Keys.KEY_S,
                onPress: () => { direction.z = -1; controller.move(direction); },
                onUp: () => { direction.z = 0; controller.move(direction); }
            },
            {
                button: keyboard_Keyboard.Keys.KEY_A,
                onPress: () => { direction.x = -1; controller.move(direction); },
                onUp: () => { direction.x = 0; controller.move(direction); }
            },
            {
                button: keyboard_Keyboard.Keys.KEY_D,
                onPress: () => { direction.x = 1; controller.move(direction); },
                onUp: () => { direction.x = 0; controller.move(direction); }
            },
            {
                button: keyboard_Keyboard.Keys.KEY_E,
                onPress: () => { direction.y = 1; controller.move(direction); },
                onUp: () => { direction.y = 0; controller.move(direction); }
            },
            {
                button: keyboard_Keyboard.Keys.KEY_Q,
                onPress: () => { direction.y = -1; controller.move(direction); },
                onUp: () => { direction.y = 0; controller.move(direction); }
            }
        ];

        for (const { button, onPress, onUp } of callbacks) {
            input.onKeyPress(button).subscribe(onPress);
            input.onKeyRelease(button).subscribe(onUp);
        }

        this._removeListeners = () => {
            for (const { button, onPress, onUp } of callbacks) {
                input.onKeyPress(button).unsubscribe(onPress);
                input.onKeyRelease(button).unsubscribe(onUp);
            }
        };
    }

    dispose() {
        this._removeListeners();
    }
}



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/camera-controller/src/orbitController/index.js












class _CameraStateFlags {
    static get IDLE() { return 0; }
    static get DUMPING() { return 1; }
    static get ROTATION() { return 2; }
    static get PAN() { return 3; }
    static get DOLLY() { return 4; }
}


/**
 * @class module:@webgears-app/camera-controller.OrbitController
 * @summary Camera orbit controller.
 * @param {Object} arguments
 *
 * @param {Object} [arguments.config={}]
 *
 * @param {boolean} [arguments.config.enableControls=true] Whether enable or disable input from attached controls.
 *
 * @param {boolean} [arguments.config.enableRotation=true] Enable or disable vertical and horizontal camera rotation.
 * @param {number} [arguments.config.rotationSpeed=1] Speed of the camera rotation.
 * @param {boolean} [arguments.config.restrictRotation=false] Restrict the camera rotation.
 * @param {number} [arguments.config.maxLatitude=0] How far the camera can orbit vertically, lower limit. Range is from 0 to PI.
 * @param {number} [arguments.config.minLatitude=PI] How far the camera can orbit vertically, upper limit. Range is from 0 to PI.
 * @param {number} [arguments.config.minLongitude=-PI] How far the camera can orbit horizontally, lower limit. Range is from -PI to +PI.
 * @param {number} [arguments.config.maxLongitude=+PI] How far the camera can orbit horizontally, upper limit. Range is from -PI to +PI.
 *
 * @param {boolean} [arguments.config.enablePanning=true] Enable or disable camera panning.
 * @param {number} [arguments.config.dollyingSpeed=1] Speed of the camera dollying (zooming).
 * @param {boolean} [arguments.config.restrictDollying=false] Restrict the camera dollying.
 * @param {number} [arguments.config.minDistance=0.25] How far the camera can dolly in.
 * @param {number} [arguments.config.maxDistance=1000] How far the camera can dolly out.
 *
 * @param {boolean} [arguments.config.enableDollying=true] Enable or disable camera dollying (zooming).
 * @param {number} [arguments.config.panningSpeed=1] Speed of the camera panning.
 *
 * @param {boolean} [arguments.config.enableDamping=true] Enable or disable damping (inertia) of the camera movements.
 * @param {number} [arguments.config.dampingFactor=0.64] The damping inertia value.
 *
 * @param {boolean} arguments.config.enableMoving Enable or disable camera movement by keyboard.
 *                  If set to true the keyboard argument must be instance of 'Keyboard' interface implementation.
 * @param {number} [arguments.config.movingSpeed=1] Speed of the camera movement.
 *
 * @param {boolean} [arguments.autoRotate=false] Whether rotate camera automatically or not.
 * @param {number} [arguments.autoRotationSpeed=2] The camera rotation speed in automatic mode.
 *
 * @param {module:@webgears-app/engine-core.SceneNode|module:@webgears-app/engine-core.Transform} arguments.nodeOrCameraTransformPair
 *        Instance of scene node class that must contain
 *        [Camera]{@link module:@webgears-app/engine-core.Camera} and [Transform]{@link module:@webgears-app/engine-core.Transform} components
 *        or [camera, transform] pair.
 *
 * @param {module:@webgears-app/input.Mouse} arguments.mouse Instance of 'Mouse' interface implementation.
 * @param {module:@webgears-app/input.Keyboard} arguments.keyboard Instance of 'Keyboard' interface implementation.
 * @param {module:@webgears-app/input.Touchscreen} arguments.touchscreen Instance of 'Touchscreen' interface implementation.
 *
 * @param {boolean} [arguments.enabled=true] Enabled or disabled by default.
 *
 * @param {boolean} [arguments.internalCameraUpdate=false] Specifies whether controller must update camera matrices
 * or not.
 *
 * @example
 * const mouse = Platform.desktop ? new DOMMouse(canvas) : undefined;
 * const touchscreen = Platform.touch ? new DOMTouchscreen(canvas) : undefined;
 * const keyboard = Platform.desktop ? new DOMKeyboard(document) : undefined;
 *
 * const cameraController = new OrbitController({
 *     nodeOrCameraTransformPair,
 *     mouse,
 *     touchscreen,
 *     keyboard,
 *     config: {
 *         target: new Vector3(0, 0, 0)
 *     }
 * });
 *
 * // Somewhere in update loop
 * ...
 * cameraController.update(deltaTime);
 * ...
 */
class orbitController_OrbitController {
    constructor({
            config = { },
            nodeOrCameraTransformPair,
            mouse,
            keyboard,
            touchscreen,
            enabled = true,
            internalCameraUpdate = false
        }) {
        this._internalCameraUpdate = internalCameraUpdate;

        this._node =  Array.isArray(nodeOrCameraTransformPair) ? null : nodeOrCameraTransformPair;

        const [ camera, transform ] = Array.isArray(nodeOrCameraTransformPair)
            ? nodeOrCameraTransformPair
            : nodeOrCameraTransformPair.getComponents([ camera_Camera, transform_Transform ]);

        this._camera = camera;
        this._transform = transform;
        this._parentTransform = null;

        if (!Array.isArray(nodeOrCameraTransformPair) && nodeOrCameraTransformPair.parent !== null) {
            const [parentTransform] = nodeOrCameraTransformPair.parent.getComponents([transform_Transform]);
            this._parentTransform = parentTransform;
        } else {
            this._parentTransform = new transform_Transform();
        }

        this._state = _CameraStateFlags.IDLE;

        this._target = config.target || new Vector3(0, 0, 0);
        this._offset = new Vector3(0, 0, 0);

        this._scale = 1;

        this._sphericalDelta = new spherical_coords_SphericalCoords(1, 0, 0);
        this._spherical = new spherical_coords_SphericalCoords(1, 0, 0);

        this._panOffset = new Vector3(0, 0, 0);
        this._panDelta = new Vector2(0, 0);

        this._direction = new Vector3(0, 0, 0);
        this._lerpedDirection = new Vector3(0, 0, 0);

        this._splitTransform = new AffineSplitTransform3();

        const { autoRotate = false, autoRotationSpeed = 2 } = config;

        this.autoRotate = autoRotate;
        this.autoRotationSpeed = autoRotationSpeed;

        const { enableControls = true } = config;
        this.enableControls = enableControls;

        const { enableDamping = true, dampingFactor = 0.64 } = config;

        this.dampingFactor = dampingFactor;
        this.enableDamping = enableDamping;

        const { enableRotation = true, rotationSpeed = 1 } = config;

        this.rotationSpeed = rotationSpeed;
        this.enableRotation = enableRotation;

        const { restrictRotation = false } = config;

        if (restrictRotation) {
            const { maxLatitude = 0, minLatitude = Math.PI } = config;
            const { minLongitude = -Math.PI, maxLongitude = Math.PI } = config;

            this.enableVerticalRotationRestriction(maxLatitude, minLatitude);
            this.enableHorizontalRotationRestriction(minLongitude, maxLongitude);
        } else {
            this.disableVerticalRotationRestriction();
            this.disableHorizontalRotationRestriction();
        }

        this._restrictRotation = () => {
            this._restrictVerticalRotation();
            this._restrictHorizontalRotation();
        };

        const { enableMoving = keyboard instanceof keyboard_Keyboard, movingSpeed = 1 } = config;

        this.movingSpeed = movingSpeed;
        this.enableMoving = enableMoving;

        const { enablePanning = true, panningSpeed = 1 } = config;

        this.panningSpeed = panningSpeed;
        this.enablePanning = enablePanning;

        const { enableDollying = true, dollyingSpeed = 1 } = config;

        this.dollyingSpeed = dollyingSpeed;
        this.enableDollying = enableDollying;

        const { restrictDollying = false } = config;

        if (restrictDollying) {
            const { minDistance = 0.25, maxDistance = 1000 } = config;

            this.enableDollyingRestriction(minDistance, maxDistance);
        } else {
            this.disableDollyingRestriction();
        }

        if (mouse instanceof mouse_Mouse) {
            this._mouseHandler = new mouseHandler_MouseHandler(this, mouse);
        }

        if (keyboard instanceof keyboard_Keyboard) {
            this._keyboardHandler = new keyboardHandler_KeyboardHandler(this, keyboard);
        }

        if (touchscreen instanceof touchscreen_Touchscreen) {
            this._touchscreenHandler = new touchHandler_TouchHandler(this, touchscreen);
        }

        this.enabled = enabled;

        this._inputInterrupt = false;

        Object.defineProperties(this,{
            /**
             * @callback module:@webgears-app/engine-core.RenderPass.MovementStartEventSignature
             */
            /**
             * @var module:@webgears-app/camera-controller.OrbitController#onMovementStart
             * @summary On any camera movement take a place.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.MovementStartEventSignature>}
             * @readonly
             */
            onMovementStart: { value: new Event() },

            /**
             * @callback module:@webgears-app/engine-core.RenderPass.MovementEndEventSignature
             */
            /**
             * @var module:@webgears-app/camera-controller.OrbitController#onMovementStart
             * @summary If all camera movements ended.
             * @type {module:@webgears-app/event.Event.<module:@webgears-app/engine-core.RenderPass.MovementEndEventSignature>}
             * @readonly
             */
            onMovementEnd: { value: new Event() }
        });
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#autoRotate
     * @type {boolean}
     * @summary Whether rotate camera automatically or not.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#autoRotationSpeed
     * @type {number}
     * @summary The camera rotation speed in automatic mode.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#movingSpeed
     * @type {number}
     * @summary Speed of the camera movement.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#panningSpeed
     * @type {number}
     * @summary Speed of the camera panning.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#dollyingSpeed
     * @type {number}
     * @summary Speed of the camera dollying.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#rotationSpeed
     * @type {number}
     * @summary Speed of the camera rotation.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableControls
     * @type {boolean}
     * @summary Whether enable or disable input from attached controls.
     */

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableDamping
     * @summary Whether damping of the camera movements is enabled or disabled.
     * @type {boolean}
     */
    set enableDamping(value) {
        this._enableDamping = value;

        if (value) {
            if (this._lerper == null) { this._lerper = new Vector3Lerper(); }

            const { _lerper } = this;

            this._damping = () => {
                const { _dampingFactor = 0.64, _sphericalDelta, _panDelta, _lerpedDirection, _direction } = this;

                _sphericalDelta.longitude *= _dampingFactor;
                _sphericalDelta.colatitude *= _dampingFactor;

                _panDelta.multiplyNumber(_dampingFactor);

                this._scale += (1 - this._scale) * (1 - _dampingFactor);

                _lerper.set(_lerpedDirection, _direction);
                _lerper.evaluate(1 - _dampingFactor, _lerpedDirection);

                if (this._state === _CameraStateFlags.DUMPING) {
                    this._state = _CameraStateFlags.IDLE;
                    this.onMovementEnd.emit();
                } else if (this._state > _CameraStateFlags.DUMPING) {
                    if (_sphericalDelta.x < 0.1e-2 && _sphericalDelta.y < 0.1e-2) {
                        this._state = this._state & ~_CameraStateFlags.ROTATION;
                    }

                    if (_panDelta.sqLength < 0.1e-4) {
                        this._state = this._state & ~_CameraStateFlags.PAN;
                    }

                    if (Math.abs(this._scale - 1.0) < 0.1e-2) {
                        this._state = this._state & ~_CameraStateFlags.DOLLY;
                    }

                    if (this._state === _CameraStateFlags.IDLE) {
                        this._state = _CameraStateFlags.DUMPING;
                    }
                }
            };
        } else {
            this._dampingFactor = 0;

            this._damping = () => {
                const { _sphericalDelta, _panDelta, _lerpedDirection, _direction } = this;

                _sphericalDelta.set(0, 0, 0);
                _panDelta.set(0, 0);

                this._scale = 1;

                _lerpedDirection.copy(_direction);

                if (this._state === _CameraStateFlags.DUMPING) {
                    this._state = _CameraStateFlags.IDLE;
                    this.onMovementEnd.emit();
                } else if (this._state > _CameraStateFlags.DUMPING) {
                    this._state = _CameraStateFlags.DUMPING;
                }
            };
        }
    }

    get enableDamping() {
        return this._enableDamping;
    }

    /**
     * @member module:@webgears-app/camera-controller.OrbitController#dampingFactor
     * @summary Current damping factor.
     * @type {number}
     */
    set dampingFactor(value) {
        const { _enableDamping = true } = this;

        this._dampingFactor = clamp(value, 0, 1) * Number(_enableDamping);
    }

    get dampingFactor() {
        return this._dampingFactor;
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableRotation
     * @summary Enable or disable vertical and horizontal rotation.
     */
    set enableRotation(value) {
        if (value) {
            this.rotate = (longitude, colatitude, clientHeight) => {
                const { _sphericalDelta, _enabled, enableControls, rotationSpeed = 1, dampingFactor } = this;

                const speed = rotationSpeed * Number(_enabled && enableControls) * 5 * (1 - dampingFactor) / clientHeight;

                _sphericalDelta.longitude += longitude * speed;
                _sphericalDelta.colatitude += colatitude * speed;

                if (this._state === _CameraStateFlags.IDLE) {
                    this.onMovementStart.emit();
                }

                this._state |= _CameraStateFlags.ROTATION;
            };

            this._autoRotateFunc = () => {
                const { _sphericalDelta, _enabled, _inputInterrupt } = this;
                const { dampingFactor, autoRotate, autoRotationSpeed } = this;

                const speed = autoRotationSpeed * Number(_enabled && autoRotate) * 0.004 * (1 - dampingFactor);

                _sphericalDelta.longitude += speed * Number(!_inputInterrupt);
            };
        } else {
            this.rotate = () => { };
            this._autoRotateFunc = () => { };
        }
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableVerticalRotationRestriction
     * @summary Restrict vertical rotation.
     * @param {number} [maxLatitude] How far the camera can orbit vertically, lower limit. Range is from 0 to PI.
     * @param {number} [minLatitude] How far the camera can orbit vertically, upper limit. Range is from 0 to PI.
     */
    enableVerticalRotationRestriction(maxLatitude, minLatitude) {
        this._restrictVerticalRotation = () => {
            this._spherical.colatitude = clamp(this._spherical.colatitude, maxLatitude, minLatitude);
        };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#disableVerticalRotationRestriction
     * @summary Disable restriction of vertical rotation.
     */
    disableVerticalRotationRestriction() {
        this._restrictVerticalRotation = () => { };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableHorizontalRotationRestriction
     * @summary Restrict horizontal rotation.
     * @param {number} [minLongitude] How far the camera can orbit horizontally, lower limit. Range is from -PI to +PI.
     * @param {number} [maxLongitude] How far the camera can orbit horizontally, upper limit. Range is from -PI to +PI.
     */
    enableHorizontalRotationRestriction(minLongitude, maxLongitude) {
        this._restrictHorizontalRotation = () => {
            this._spherical.longitude = clamp(this._spherical.longitude, minLongitude, maxLongitude);
        };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#disableHorizontalRotationRestriction
     * @summary Disable restriction of horizontal rotation.
     */
    disableHorizontalRotationRestriction() {
        this._restrictHorizontalRotation = () => { };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableMoving
     * @summary Whether camera moving is enabled or disabled.
     * @type {boolean}
     */
    set enableMoving(value) {
        this._enableMoving = value;

        if (value) {
            this.move = (direction) => {
                const { _enabled, enableControls, movingSpeed = 1 } = this;

                const speed = movingSpeed * Number(_enabled && enableControls) * 40;

                this._direction.copy(direction);
                this._direction.multiplyNumber(speed);
            };
        } else {
            this.move = () => { };
        }
    }

    get enableMoving() {
        return this._enableMoving;
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enablePanning
     * @summary Whether camera panning is enabled or disabled.
     * @type {boolean}
     */
    set enablePanning(value) {
        this._enablePanning = value;

        if (value) {
            this.pan = (x, y, clientHeight) => {
                const { _enabled, _panDelta, enableControls, dampingFactor, panningSpeed = 1 } = this;

                const speed = panningSpeed * Number(_enabled && enableControls) * 60 * (1 - dampingFactor) / clientHeight;

                _panDelta.x += x * speed;
                _panDelta.y -= y * speed;

                if (this._state === _CameraStateFlags.IDLE) {
                    this.onMovementStart.emit();
                }

                this._state |= _CameraStateFlags.PAN;
            };
        } else {
            this.pan = () => { };
        }
    }

    get enablePanning() {
        return this._enablePanning;
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableDollying
     * @summary Whether camera dollying is enabled or disabled.
     * @type {boolean}
     */
    set enableDollying(value) {
        this._enableDollying = value;

        if (value) {
            this.dolly = (dollyingValue) => {
                const { _enabled, enableControls, dampingFactor, dollyingSpeed = 1 } = this;

                {
                    const speed = dollyingSpeed * Number(_enabled && enableControls) * (1 - dampingFactor) * (platform_src.mac ? 1 : 2);

                    const scale = Math.pow(0.95, Math.abs(dollyingValue) * speed);

                    if (Math.sign(dollyingValue) === 1) {
                        this._scale = scale;
                    } else {
                        this._scale = Math.sign(dollyingValue) === -1 ? 1 / scale : 1;
                    }
                }

                if (this._state === _CameraStateFlags.IDLE) {
                    this.onMovementStart.emit();
                }

                this._state |= _CameraStateFlags.DOLLY;
            };
        } else {
            this.dolly = () => { };
        }
    }

    get enableDollying() {
        return this._enableDollying;
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enableDollyingRestriction
     * @summary Restrict camera dollying.
     * @param {number} [minDistance] How far the camera can dolly in.
     * @param {number} [maxDistance] How far the camera can dolly out.
     */
    enableDollyingRestriction(minDistance, maxDistance) {
        this._restrictDollying = () => {
            this._spherical.radius = clamp(this._spherical.radius, minDistance, maxDistance);
        };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#disableDollyingRestriction
     * @summary Disable restriction of camera dollying.
     */
    disableDollyingRestriction() {
        this._restrictDollying = () => { };
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#enabled
     * @summary Whether controller is enabled or disabled.
     */
    set enabled(value) {
        this._enabled = value;
        this.update = value ? this._update : () => { };
    }

    get enabled() {
        return this._enabled;
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#update
     * @summary Controller update function.
     * @param {number} deltaTime The difference between previous and current frames time in seconds.
     */
    update(deltaTime) { }

    /**
     * @member module:@webgears-app/camera-controller.OrbitController#target
     * @summary Current target position.
     * @type {module:@webgears-app/math.Vector3}
     */
    set target(value) {
        this._target = value instanceof Vector3 ? value : this._target;
    }

    get target() {
        return this._target;
    }

    _updateTransform(transform, parentTransform) {
        if ((transform.state & transform_Transform.StateMask.UPDATE_LOCAL) !== 0) {
            this._splitTransform.set({
                scale: transform.scale,
                quaternion: transform.orientation,
                translation: transform.position
            });

            transform.matrix.fromAffineSplitTransform(this._splitTransform);

            transform.state &= (~transform_Transform.StateMask.UPDATE_LOCAL & transform_Transform.StateMask.UPDATE_ALL);
        }

        if ((transform.state & transform_Transform.StateMask.UPDATE_WORLD) !== 0) {
            if (parentTransform === null) {
                transform.worldMatrix.copy(transform.matrix);
            } else {
                transform.worldMatrix.copy(transform.matrix).multiply(parentTransform.worldMatrix);
            }

            transform.state = transform_Transform.StateMask.UPDATE_NOTHING;
        }
    }

    /**
     * @function module:@webgears-app/camera-controller.OrbitController#dispose
     * @summary Release all input handlers.
     */
    dispose() {
        if (this._mouseHandler instanceof mouseHandler_MouseHandler) this._mouseHandler.dispose();
        if (this._keyboardHandler instanceof keyboardHandler_KeyboardHandler) this._keyboardHandler.dispose();
    }
}

Object.assign(orbitController_OrbitController.prototype, {
    _update: (function __update() {
        const kEPSILON = 1e-6;

        const yAxis = new Vector3(0, 1, 0);

        const kZero = new Vector3().fromNumber(0);

        const tempA = new Vector3(0, 0, 0);
        const tempB = new Vector3(0, 0, 0);
        const tempC = new Vector3(0, 0, 0);
        // const tempD = new Vector3(0, 0, 0);

        const localMatrix = new AffineMatrix3();
        const worldMatrix = new AffineMatrix3();

        const position = new Vector3();
        const orientation = new quaternion_Quaternion();

        return function _update(deltaTime) {
            const { _transform, _parentTransform, _offset, _target, _panOffset, _panDelta } = this;

            this._updateTransform(_parentTransform, null);
            this._updateTransform(_transform, _parentTransform);

            position.copy(_transform.position);
            position.applyAffineMatrix(_parentTransform.worldMatrix);

            _offset.copy(position);
            _offset.subtract(_target);

            if (_offset.distance(kZero) <= kEPSILON) {
                position.copy(_target);
                position.add(new Vector3(0, 0, kEPSILON));

                _offset.copy(position);
                _offset.subtract(_target);
            }

            // const up = this._node !== null ? (this._node.up || yAxis) : yAxis;
            // setFromUnitVectors(orientation, up, yAxis);

            _transform.matrixPaste(localMatrix);

            localMatrix.axisXPaste(tempA);
            localMatrix.axisYPaste(tempB);
            localMatrix.axisZPaste(tempC);

            tempA.normalize();
            tempB.normalize();
            tempC.normalize();

            let distance = _offset.length;

            const { _camera } = this;

            if (_camera.projectionType === camera_Camera.ProjectionTypes.ORTHOGRAPHIC) {
                const { xmag, ymag } = _camera;
                distance *= Math.max(xmag, ymag) * 0.1;
            }

            distance *= 2 * Math.tan(_camera.yfov * 0.5 * Math.PI / 180.0);

            tempA.multiplyNumber(_panDelta.x * distance);
            tempB.multiplyNumber(_panDelta.y * distance);

            _panOffset.copy(tempA);
            _panOffset.add(tempB);

            // this._offset.applyQuaternion(orientation);

            this._spherical.fromVector(_offset);

            this._autoRotateFunc();

            this._spherical.longitude += this._sphericalDelta.longitude;
            this._spherical.colatitude += this._sphericalDelta.colatitude;

            this._restrictRotation();
            this._spherical.colatitude = clamp(this._spherical.colatitude, kEPSILON, Math.PI - kEPSILON);

            // changes from: https://youtrack.webgears3d.com/issue/3ES-254
            this._spherical.radius *= this._scale;
            this._restrictDollying();

            const mag = Math.tan(_camera.yfov / 2) * this._spherical.radius * 2;
            _camera.ymag = mag;
            _camera.xmag = mag * _camera.aspect;
            // ...

            this._spherical.toVector(_offset);

            // this._offset.applyQuaternion(orientation.invert());

            this._damping();

            const yaw = Math.atan2(tempC.x, tempC.z);

            orientation.fromRotation(yaw, yAxis);

            tempC.set(this._lerpedDirection.x, this._lerpedDirection.y, -this._lerpedDirection.z);
            tempC.applyQuaternion(orientation);

            distance = Math.max(0.1, Math.log(Math.abs(distance) + 1));

            _panOffset.add(tempC.multiplyNumber(distance * deltaTime));

            _target.add(_panOffset);

            position.copy(_target);
            position.add(_offset);

            worldMatrix.fromLookTarget(position, _target, yAxis);

            _transform.worldMatrix.copy(worldMatrix);

            _parentTransform.worldMatrixPaste(localMatrix);
            localMatrix.invert();
            localMatrix.preApplyAffine(worldMatrix);

            _transform.matrixCopy(localMatrix);

            if (this._internalCameraUpdate) {
                const { _camera: camera } = this;
                const { projectionType } = camera;

                camera.viewMatrix.copy(worldMatrix).invert();

                if (camera.needsUpdateProjection) {
                    if (projectionType === camera_Camera.ProjectionTypes.PERSPECTIVE) {
                        camera.projectionMatrix.fromWebGLPerspectiveProjection(
                            camera.aspect, camera.yfov, camera.znear, camera.zfar
                        );
                    } else if (projectionType === camera_Camera.ProjectionTypes.ORTHOGRAPHIC) {
                        camera.projectionMatrix.fromWebGLOrthographicProjection(
                            camera.xmag, camera.ymag, camera.znear, camera.zfar
                        );
                    }

                    camera.viewProjectionMatrix.fromAffine(camera.viewMatrix).multiply(camera.projectionMatrix);
                }

                _transform.position.copy(position);
            }
        };
    }())
});



// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@webgears-app/camera-controller/src/index.js
/**
 * @module module:@webgears-app/camera-controller
 */



// CONCATENATED MODULE: ./src/features/move-camera/utils/camera-look-at.ts



const upVector = new math_lib["n" /* Vector3 */](0, 1, 0);

function getBoxCorners(box) {
  return [0, 1, 2, 3, 4, 5, 6, 7].map(i => {
    const x = i & 4 ? box.min.x : box.max.x;
    const y = i & 2 ? box.min.y : box.max.y;
    const z = i & 1 ? box.min.z : box.max.z;
    return new math_lib["n" /* Vector3 */](x, y, z);
  });
}

function getZMetrics(box, cameraNode) {
  const [cameraTransform, camera] = cameraNode.getComponents([lib["jb" /* Transform */], lib["f" /* Camera */]]);

  if (!cameraTransform || !camera) {
    throw new Error(`node "${cameraNode.name}" have no camera or transform component`);
  }

  const cameraWorldTransform = cameraTransform.splitWorldTransformPaste();
  const targetNdcRectSize = 1; // 0..1 (1 = entire screen)

  const cotanHalfYFov = 1 / Math.tan(camera.yfov / 2);
  const targetYCotan = targetNdcRectSize * cotanHalfYFov;
  const targetXCotan = targetYCotan / camera.aspect;
  const boxCenter = box.centerPaste(new math_lib["n" /* Vector3 */]());
  const endViewMatrix = camera.worldMatrix.clone().fromLookTarget(cameraWorldTransform.translation, boxCenter, upVector).invert();
  const viewSpaceCenter = boxCenter.clone().applyAffineMatrix(endViewMatrix);
  return getBoxCorners(box).reduce((result, corner) => {
    const viewSpaceCorner = corner.clone().applyAffineMatrix(endViewMatrix);
    const zOffset = viewSpaceCorner.z - viewSpaceCenter.z;
    const targetXDistance = Math.abs(viewSpaceCorner.x * targetXCotan) + zOffset;
    const targetYDistance = Math.abs(viewSpaceCorner.y * targetYCotan) + zOffset;
    return {
      minZOffset: Math.min(result.minZOffset, zOffset),
      maxZOffset: Math.max(result.maxZOffset, zOffset),
      cameraDistance: Math.max(result.cameraDistance, targetXDistance, targetYDistance)
    };
  }, {
    minZOffset: Infinity,
    maxZOffset: -Infinity,
    cameraDistance: 0
  });
}
function calculateZNearFar(cameraNode, box) {
  const [cameraTransform, camera] = cameraNode.getComponents([lib["jb" /* Transform */], lib["f" /* Camera */]]);

  if (!cameraTransform || !camera) {
    throw new Error(`node "${cameraNode.name}" have no camera or transform component`);
  }

  const cameraWorldTransform = cameraTransform.splitWorldTransformPaste();
  const boxCenter = box.centerPaste(new math_lib["n" /* Vector3 */]());
  const viewMatrix = camera.worldMatrix.clone().fromLookTarget(cameraWorldTransform.translation, boxCenter, upVector).invert();
  let znear = Infinity;
  let zfar = -Infinity;
  getBoxCorners(box).forEach(corner => {
    const viewSpaceCorner = corner.clone().applyAffineMatrix(viewMatrix);
    const z = -viewSpaceCorner.z;
    znear = Math.min(znear, z);
    zfar = Math.max(zfar, z);
  });
  return {
    znear,
    zfar
  };
}
function cameraLookAt({
  cameraNode,
  cameraTarget,
  renderables,
  filterRenderable
}) {
  const [cameraTransform] = cameraNode.getComponents([lib["jb" /* Transform */]]);

  if (!cameraTransform) {
    throw new Error(`node "${cameraNode.name}" have not transform component`);
  }

  const cameraWorldTransform = cameraTransform.splitWorldTransformPaste();
  const oldPosition = cameraWorldTransform.translation;
  const box = Object(global_helpers["e" /* computeBBox */])(renderables, filterRenderable);
  const boxCenter = box.centerPaste(new math_lib["n" /* Vector3 */]());
  const isSinglePoint = box.min.equals(box.max);
  const oldOffset = cameraWorldTransform.translation.clone().subtract(cameraTarget);
  const zMetrics = !isSinglePoint ? getZMetrics(box, cameraNode) : {
    minZOffset: 0,
    maxZOffset: 0,
    cameraDistance: oldOffset.length // if we are looking at single point do not change viewing distance

  };
  const newPosition = oldPosition.clone().subtract(boxCenter).normalize().multiply(zMetrics.cameraDistance).add(boxCenter);
  return {
    position: newPosition,
    target: boxCenter
  };
}
// CONCATENATED MODULE: ./src/core/controls/index.ts
function core_controls_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







const {
  UPDATE_LOCAL,
  UPDATE_WORLD
} = lib["jb" /* Transform */].StateMask;
const $rendererTag = Symbol('controls');
const ADAPTIVE_DEPTH_MULTIPLIER = 1.5;
class controls_Controls {
  constructor(options) {
    core_controls_defineProperty(this, "cameraNode", void 0);

    core_controls_defineProperty(this, "cameraTransform", void 0);

    core_controls_defineProperty(this, "camera", void 0);

    core_controls_defineProperty(this, "onActiveChange", new global_helpers["b" /* Event */]());

    core_controls_defineProperty(this, "onFovChange", new global_helpers["b" /* Event */]());

    core_controls_defineProperty(this, "onAfterUpdate", new global_helpers["b" /* Event */]());

    core_controls_defineProperty(this, "_time", void 0);

    core_controls_defineProperty(this, "_orbitController", void 0);

    core_controls_defineProperty(this, "_store", void 0);

    core_controls_defineProperty(this, "_isActive", void 0);

    core_controls_defineProperty(this, "_bbox", void 0);

    core_controls_defineProperty(this, "update", (() => {
      const MIN_ACTIVITY_DISTANCE = 0.0001;
      const MIN_ACTIVITY_ANGLE = 0.0001;
      const splitTransform = new math_lib["d" /* AffineSplitTransform3 */]();
      const quaternionBefore = new math_lib["i" /* Quaternion */]();
      const positionBefore = new math_lib["n" /* Vector3 */]();
      const prevFrameTarget = new math_lib["n" /* Vector3 */]();
      const prevFrameCamera = new math_lib["n" /* Vector3 */]();
      const targetBefore = new math_lib["n" /* Vector3 */]();
      let magBefore = 0;
      let projectionBefore = 0;
      let transform = null;
      let targetDelta = 0;
      let positionDelta = 0;
      let distanceDelta = 0;
      let angleDelta = 0;
      let magDelta = 0;
      let distance = 0;
      let distanceBefore = 0;
      let zooming = false;
      let rotating = false;
      let panning = false;
      let isChanged = false;
      let isActive = false;
      return () => {
        isActive = false;
        transform = this.cameraTransform;
        positionBefore.copy(transform.position);
        quaternionBefore.copy(transform.orientation);
        distanceBefore = positionBefore.distance(this.target);

        this._orbitController.update(this._time.deltaTime); // Angle


        splitTransform.fromMatrix(transform.matrix);
        transform.orientation.copy(splitTransform.quaternion);
        angleDelta = quaternionBefore.invert().multiply(transform.orientation).rotationAngle;

        if (angleDelta >= MIN_ACTIVITY_ANGLE) {
          isActive = true;
        } // Distance


        transform.matrix.translationPaste(transform.position);
        positionDelta = transform.position.distance(positionBefore);

        if (positionDelta >= MIN_ACTIVITY_DISTANCE) {
          isActive = true;
        } // Projection type


        if (this.camera.projectionType !== projectionBefore) {
          isActive = true;
        }

        projectionBefore = this.camera.projectionType; // Orthographic mag

        magDelta = Math.abs(this.camera.ymag - magBefore);

        if (magDelta >= MIN_ACTIVITY_DISTANCE) {
          isActive = true;
        }

        magBefore = this.camera.ymag;

        if (isActive !== this._isActive) {
          this.onActiveChange.emit(isActive);
        }

        this._isActive = isActive; // actions

        distance = splitTransform.translation.distance(this.target);
        distanceDelta = Math.abs(distance - distanceBefore);
        targetDelta = this.target.distance(targetBefore);
        rotating = angleDelta >= MIN_ACTIVITY_ANGLE;
        zooming = distanceDelta >= MIN_ACTIVITY_DISTANCE;
        panning = targetDelta >= MIN_ACTIVITY_ANGLE;

        this._store.controls.setActions(zooming, rotating, panning);

        targetBefore.copy(this.target); // checkout changing of camera and target positions

        isChanged = !Object(global_helpers["K" /* vectors3Equal */])(this.target, prevFrameTarget) || !Object(global_helpers["K" /* vectors3Equal */])(transform.position, prevFrameCamera);
        prevFrameTarget.copy(this.target);
        prevFrameCamera.copy(transform.position);
        this.updateDepthParams();
        this.onAfterUpdate.emit(isChanged);
      };
    })());

    const {
      input,
      node,
      canvas,
      time,
      store
    } = options;
    const {
      mouse,
      touchscreen,
      keyboard
    } = input.sources;
    const {
      zfar,
      znear,
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType
    } = store.camera.options;
    const aspect = canvas.width / canvas.height;
    const cameraTransform = new lib["jb" /* Transform */]();
    const camera = new lib["f" /* Camera */]({
      name: 'default',
      zfar,
      znear,
      aperture,
      shutterSpeed,
      ISO,
      expComp,
      projectionType,
      perspectiveProjection: {
        aspect,
        yfov: store.camera.yfov
      }
    });
    node.attach(camera);
    node.attach(cameraTransform);
    const orbitController = new orbitController_OrbitController({
      nodeOrCameraTransformPair: [camera, cameraTransform],
      mouse,
      keyboard,
      touchscreen,
      domElement: canvas,
      config: { ...store.controls.defaultControllerConfig,
        target: undefined
      }
    });
    this.cameraNode = node;
    this.cameraTransform = cameraTransform;
    this.camera = camera;
    this._time = time;
    this._orbitController = orbitController;
    this._store = store;
    this._isActive = false;
    this._bbox = new math_lib["e" /* Box */]();
    this.setDefaultOptions();

    this._addListeners();
  }

  get cameraPosition() {
    return this.cameraTransform.position;
  }

  get target() {
    return this._orbitController.target;
  }

  get enabled() {
    return this._store.controls.enabled;
  }

  setBBox(bbox) {
    this._bbox = bbox;
  }

  setDefaultOptions() {
    const {
      camera,
      controls
    } = this._store;
    const {
      position: cameraPosition
    } = camera.getInitialProp('options');
    const targetPosition = controls.getInitialProp('target');
    this.cameraTransform.position.copy(cameraPosition);
    this.cameraTransform.state = UPDATE_LOCAL | UPDATE_WORLD;

    this._orbitController.target.copy(targetPosition);

    this.update();
  }

  _addListeners() {
    this.camera.onEarlyUpdateStart.subscribe(this.update);
    const {
      controls,
      camera
    } = this._store;
    const controller = this._orbitController;
    Object(mobx_module["h" /* reaction */])(() => controls.enabled, enabled => {
      controller.enableControls = enabled;
    });
    Object(mobx_module["h" /* reaction */])(() => controls.target, target => {
      controller.target.copy(target);
    });
    Object(mobx_module["h" /* reaction */])(() => controls.zoom, zoom => {
      controller.enableDollying = zoom.enabled;
      controller.dollyingSpeed = zoom.speed;
      controller.enableDollyingRestriction(zoom.minDistance, zoom.maxDistance);
    });
    Object(mobx_module["h" /* reaction */])(() => controls.rotation, rotation => {
      controller.enableRotation = rotation.enabled;
      controller.rotationSpeed = rotation.speed;
      let {
        minPolarAngle,
        maxPolarAngle
      } = rotation;

      if (minPolarAngle === 0) {
        minPolarAngle = 0.5 * global_helpers["f" /* degToRad */];
      }

      if (maxPolarAngle === Math.PI) {
        maxPolarAngle = 179.5 * global_helpers["f" /* degToRad */];
      }

      controller.enableVerticalRotationRestriction(minPolarAngle, maxPolarAngle);
    });
    Object(mobx_module["h" /* reaction */])(() => controls.panning, panning => {
      controller.enablePanning = panning.enabled;
      controller.panningSpeed = panning.speed;
    });
    Object(mobx_module["h" /* reaction */])(() => controls.damping, damping => {
      controller.enableDamping = damping.enabled;
      controller.dampingFactor = damping.factor;
    });
    Object(mobx_module["h" /* reaction */])(() => controls.keyboard, keyboard => {
      this._orbitController.enableMoving = keyboard;
    });
    Object(mobx_module["h" /* reaction */])(() => camera.options, options => {
      this.camera.znear = options.znear;
      this.camera.zfar = options.zfar;
      this.camera.projectionType = options.projectionType;
      this.camera.setEV100({
        aperture: options.aperture,
        ISO: options.ISO,
        expComp: options.expComp,
        shutterSpeed: options.shutterSpeed
      });
    });
    Object(mobx_module["h" /* reaction */])(() => camera.yfov, yfov => {
      this.camera.yfov = yfov;
      this.camera.needsUpdateProjection = true;
      this.onFovChange.emit(yfov);
    });
    Object(mobx_module["h" /* reaction */])(() => camera.position, position => {
      this.cameraTransform.position.copy(position);
      this.cameraTransform.state = UPDATE_LOCAL | UPDATE_WORLD;
    });
  }

  disable() {
    this._orbitController.enableControls = false;
  }

  enable() {
    this._orbitController.enableControls = true;
  }

  updateDeviceSize(width, height) {
    if (this.camera) {
      this.camera.aspect = width / height;
      this.camera.needsUpdateProjection = true;
    }
  }

  updateDepthParams() {
    if (!this._isActive) {
      return;
    }

    if (!this._bbox) {
      return;
    }

    let {
      znear,
      zfar
    } = calculateZNearFar(this.cameraNode, this._bbox);
    znear /= ADAPTIVE_DEPTH_MULTIPLIER;
    zfar *= ADAPTIVE_DEPTH_MULTIPLIER;
    this.camera.znear = Math.max(znear, zfar / 10000);
    this.camera.zfar = Math.abs(zfar);
  }

  dispose() {
    // dispose engine objects there...
    Object(global_helpers["h" /* dispose */])(this);
  }

}

core_controls_defineProperty(controls_Controls, "tag", $rendererTag);
// EXTERNAL MODULE: ./src/global-helpers/instance-data-manager.ts
var instance_data_manager = __webpack_require__(64);

// EXTERNAL MODULE: ./src/core/resources/index.ts + 22 modules
var core_resources = __webpack_require__(45);

// CONCATENATED MODULE: ./src/core/structure.ts
function structure_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function setInstanceId(instanceDataManager, instance, id) {
  const globalIndex = Object(instance_data_manager["b" /* getInstanceGlobalIndex */])(instanceDataManager, instance);
  instanceDataManager.storeRenderableIdentifier(globalIndex, id);
  instance.externalId = id;
}

class structure_Structure {
  constructor() {
    structure_defineProperty(this, "_elementIdsByGroup", new Map());

    structure_defineProperty(this, "_elementsById", new Map());

    structure_defineProperty(this, "_bbox", new math_lib["e" /* Box */]());

    structure_defineProperty(this, "_consumeRenderableBBox", (() => {
      const box = new math_lib["e" /* Box */]();
      const center = new math_lib["n" /* Vector3 */]();
      return renderable => {
        const scene = renderable.getScene();
        Object(instance_data_manager["c" /* getInstanceWorldBBox */])(scene.instanceDataManager, renderable, box);
        const globalIndex = Object(instance_data_manager["b" /* getInstanceGlobalIndex */])(scene.instanceDataManager, renderable);
        box.centerPaste(center);
        scene.instanceDataManager.storeCenter(center, globalIndex);

        this._bbox.consumeBox(box);
      };
    })());

    structure_defineProperty(this, "get", id => {
      if (id === undefined) {
        return this.getAllElements();
      }

      if (typeof id === 'number') {
        return this.getElementsById(id);
      }

      return this.getElementsByIds(id);
    });

    structure_defineProperty(this, "getElementsById", id => {
      const elements = this._elementsById.get(id);

      if (!elements) {
        throw new Error(`Element with id "${id}" doesn't exist`);
      }

      return elements;
    });
  }

  getBBox() {
    return this._bbox;
  }

  reset() {
    for (const renderable of this.getAllElements()) {
      this._release(renderable);
    }

    this._elementsById.clear();

    this.clearGroups();

    this._bbox.min.fromNumber(Infinity);

    this._bbox.max.fromNumber(-Infinity);
  }

  has(id) {
    return this._elementsById.has(id);
  }

  getElementId(renderable) {
    return renderable.externalId;
  }

  getAllIds() {
    return this._elementsById.keys();
  }

  *getElementsByIds(ids) {
    for (const id of ids) {
      const renderablesForId = this.getElementsById(id);

      for (const renderable of renderablesForId) {
        yield renderable;
      }
    }
  }

  *getAllElements() {
    for (const elements of this._elementsById.values()) {
      for (const element of elements) {
        yield element;
      }
    }
  }

  addElement(id, renderable, updateBBox = false) {
    const scene = renderable.getScene();
    const idElements = this._elementsById.get(id) || new Set();
    idElements.add(renderable);

    this._elementsById.set(id, idElements); // Auto sync id with instance data manager


    setInstanceId(scene.instanceDataManager, renderable, id);

    if (renderable.geometry.unloaded && updateBBox) {
      renderable.geometry.onLoad.subscribe(() => {
        this._consumeRenderableBBox(renderable);
      });
    } else if (updateBBox) {
      this._consumeRenderableBBox(renderable);
    }
  }

  removeElement(renderable) {
    const {
      externalId: id
    } = renderable;

    const idElements = this._elementsById.get(id);

    if (!idElements) {
      return;
    }

    idElements.delete(renderable);
    this.removeFromGroups(renderable);

    this._release(renderable);
  }

  removeElementsById(id) {
    const elements = this._elementsById.get(id);

    if (!elements) {
      return;
    }

    this.removeFromGroups(elements);

    this._elementsById.delete(id);

    for (const element of elements) {
      this._release(element);
    }
  }

  _release(renderable) {
    const scene = renderable.getScene();
    scene.deleteInstance(renderable);
    renderable.geometry.release();
    renderable.material.release();
  } // Groups


  addGroup(name, groupElements = new Set()) {
    if (this._elementIdsByGroup.has(name)) {
      throw new Error(`Group "${name}" is already exists`);
    }

    this._elementIdsByGroup.set(name, groupElements);

    return groupElements;
  }

  removeGroup(name) {
    this._elementIdsByGroup.delete(name);
  }

  getGroup(name) {
    const group = this._elementIdsByGroup.get(name);

    return group !== undefined ? group : null;
  }

  getGroupStrict(name) {
    const group = this._elementIdsByGroup.get(name);

    if (!group) {
      throw new Error(`Group "${name}" is not exists`);
    }

    return group;
  }

  hasGroup(name) {
    return this._elementIdsByGroup.has(name);
  }

  removeGroups() {
    this._elementIdsByGroup.clear();
  }

  clearGroup(group) {
    this.getGroupStrict(group).clear();
  }

  clearGroups() {
    this._elementIdsByGroup.forEach(group => group.clear());
  }

  addToGroup(group, elements) {
    const groupSet = this.getGroupStrict(group);

    if (elements instanceof core_resources["b" /* IndustrialRenderable */]) {
      groupSet.add(elements);
      return;
    }

    for (const element of elements) {
      groupSet.add(element);
    }
  }

  hasInGroup(group, element) {
    return this.getGroupStrict(group).has(element);
  }

  removeFromGroup(group, element) {
    this.getGroupStrict(group).delete(element);
  }

  removeFromGroups(elements) {
    this._elementIdsByGroup.forEach(group => {
      if (elements instanceof core_resources["b" /* IndustrialRenderable */]) {
        group.delete(elements);
        return;
      }

      for (const element of elements) {
        group.delete(element);
      }
    });
  }

  popGroup(name) {
    const group = this.getGroupStrict(name);

    this._elementIdsByGroup.set(name, new Set());

    return group;
  }

  changeRenderableMaterial(renderable, material) {
    const scene = renderable.getScene();
    scene.changeInstanceMaterial(renderable, material);
    setInstanceId(scene.instanceDataManager, renderable, renderable.externalId);
  }

}
// CONCATENATED MODULE: ./src/core/layers/utils/index.ts

function createDepthAttachment(renderer) {
  const {
    width,
    height,
    capabilities
  } = renderer;
  const {
    webgl2Support
  } = capabilities;
  return new lib["gb" /* Texture */]({
    name: 'depth-attachment',
    width,
    height,
    bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
    magFilter: lib["gb" /* Texture */].Filter.NEAREST,
    minFilter: lib["gb" /* Texture */].Filter.NEAREST,
    wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
    wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
    format: lib["N" /* PixelDataFormat */].DEPTH_COMPONENT,
    internalFormat: webgl2Support ? lib["v" /* InternalFormat */].DEPTH_COMPONENT32F : lib["v" /* InternalFormat */].DEPTH_COMPONENT,
    componentType: lib["n" /* DataType */].UNSIGNED_INT,
    levels: 1,
    dynamic: true
  });
}
function createColorAttachment(renderer) {
  const {
    width,
    height,
    capabilities
  } = renderer;
  const {
    webgl2Support
  } = capabilities;
  return new lib["gb" /* Texture */]({
    name: 'color-attachment',
    width,
    height,
    bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
    magFilter: lib["gb" /* Texture */].Filter.LINEAR,
    minFilter: lib["gb" /* Texture */].Filter.LINEAR,
    wrapS: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
    wrapT: lib["gb" /* Texture */].WrappingMode.CLAMP_TO_EDGE,
    format: lib["N" /* PixelDataFormat */].RGBA,
    internalFormat: webgl2Support ? lib["v" /* InternalFormat */].RGBA8 : lib["v" /* InternalFormat */].RGBA,
    componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
    levels: 1,
    dynamic: true
  });
}
// CONCATENATED MODULE: ./src/core/layers/layer/index.ts
function layer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable @typescript-eslint/no-unused-vars */

class layer_Layer {
  constructor() {
    layer_defineProperty(this, "_needsDrawList", new Set());

    layer_defineProperty(this, "_needsDrawOnceList", new Set());

    layer_defineProperty(this, "onDrawStart", new global_helpers["b" /* Event */]());

    layer_defineProperty(this, "onDrawEnd", new global_helpers["b" /* Event */]());
  }

  _draw() {
    throw new Error('Method "_draw" must be implemented');
  }

  draw() {
    this.onDrawStart.emit();

    this._draw();

    this._needsDrawOnceList.clear();

    this.onDrawEnd.emit();
  }

  get needsDraw() {
    return Boolean(this._needsDrawList.size || this._needsDrawOnceList.size);
  }

  _setNeedsDrawOnce(tag) {
    this._needsDrawOnceList.add(tag);
  }

  _setNeedsDrawPermanent(tag, enabled) {
    if (enabled) {
      this._needsDrawList.add(tag);
    } else {
      this._needsDrawList.delete(tag);
    }
  }

  updateTextureSize(width, height) {
    throw new Error('not implemented');
  }

  setNeedsDrawOnce(tag = Symbol('generated-update-once-tag')) {
    this._setNeedsDrawOnce(tag);
  }

  setNeedsDrawPermanent(tag, enabled = true) {
    this._setNeedsDrawPermanent(tag, enabled);
  }

  pick(device) {
    throw new Error('not implemented');
  }

}
// EXTERNAL MODULE: ./src/core/resources/materials/index.ts + 1 modules
var resources_materials = __webpack_require__(23);

// CONCATENATED MODULE: ./src/core/layers/layer/layer3d.ts
function layer3d_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






let DrawingState;

(function (DrawingState) {
  DrawingState[DrawingState["DRAWING"] = 0] = "DRAWING";
  DrawingState[DrawingState["FINISHING"] = 1] = "FINISHING";
  DrawingState[DrawingState["IDLE"] = 2] = "IDLE";
})(DrawingState || (DrawingState = {}));

class RenderQueueUnloadProtected extends Array {
  push(...batchRenderables) {
    for (const batchRenderable of batchRenderables) {
      if (!batchRenderable.geometry.unloaded) {
        super.push(batchRenderable);
      }
    }

    return this.length;
  }

}
class layer3d_Layer3D extends layer_Layer {
  // TODO: depthFunc enum is stored at the Texture as static property
  constructor(options) {
    super();

    layer3d_defineProperty(this, "viewport", void 0);

    layer3d_defineProperty(this, "name", '');

    layer3d_defineProperty(this, "_core", void 0);

    layer3d_defineProperty(this, "_gl", void 0);

    layer3d_defineProperty(this, "_scene", void 0);

    layer3d_defineProperty(this, "_culler", void 0);

    layer3d_defineProperty(this, "_sorter", void 0);

    layer3d_defineProperty(this, "_look", void 0);

    layer3d_defineProperty(this, "_raycaster", void 0);

    layer3d_defineProperty(this, "_renderPass", void 0);

    layer3d_defineProperty(this, "_renderTarget", void 0);

    layer3d_defineProperty(this, "_progressiveEnabled", false);

    layer3d_defineProperty(this, "_progressiveRangeSize", 0);

    layer3d_defineProperty(this, "_progressiveAuto", true);

    layer3d_defineProperty(this, "_drawingState", DrawingState.IDLE);

    layer3d_defineProperty(this, "_rangesOverflowed", false);

    layer3d_defineProperty(this, "_queueLength", 0);

    layer3d_defineProperty(this, "_drawn", false);

    layer3d_defineProperty(this, "_clear", void 0);

    layer3d_defineProperty(this, "_cleared", false);

    layer3d_defineProperty(this, "_clearMask", void 0);

    layer3d_defineProperty(this, "_onApplyMaterial", void 0);

    layer3d_defineProperty(this, "_onUpdateSize", void 0);

    layer3d_defineProperty(this, "_statistics", new lib["Q" /* RenderPassStatistics */]());

    layer3d_defineProperty(this, "raycastLayer", (() => {
      const viewportNdc = new math_lib["m" /* Vector2 */]();
      return ndc => {
        if (this.viewport) {
          // Custom viewport
          const {
            x,
            y,
            width,
            height,
            fullWidth,
            fullHeight
          } = this.viewport;
          const viewportNdcX0 = x / fullWidth * 2 - 1;
          const viewportNdcY0 = y / fullHeight * 2 - 1;
          const viewportNdcX1 = (x + width) / fullWidth * 2 - 1;
          const viewportNdcY1 = (y + height) / fullHeight * 2 - 1;
          viewportNdc.x = (ndc.x - viewportNdcX0) / (viewportNdcX1 - viewportNdcX0) * 2 - 1;
          viewportNdc.y = (ndc.y - viewportNdcY0) / (viewportNdcY1 - viewportNdcY0) * 2 - 1;
        } else {
          // Whole screen viewport
          viewportNdc.copy(ndc);
        }

        return this._raycaster.raycast(this._renderPass, viewportNdc);
      };
    })());

    const {
      core,
      gl,
      scene,
      name = '',
      look,
      raycaster,
      renderPassSettings = {},
      progressiveRendering = {
        enabled: this._progressiveEnabled,
        rangeSize: this._progressiveRangeSize,
        auto: true
      },
      clear = {
        color: new math_lib["k" /* RGBColor */](0, 0, 0),
        alpha: 0
      },
      sorter,
      culler,
      onBeforeRender = () => undefined,
      onApplyMaterial = () => undefined,
      renderQueue = new RenderQueueUnloadProtected()
    } = options;
    const {
      srgbOutput = true,
      viewport = null,
      outputSemantic = lib["S" /* RenderRequest */].OutputLayoutSemantic.DEFAULT,
      clearMask = lib["h" /* ClearMask */].COLOR_BUFFER_BIT | lib["h" /* ClearMask */].DEPTH_BUFFER_BIT,
      depthAttachment = createDepthAttachment(gl.renderer)
    } = renderPassSettings;
    this._core = core;
    this._gl = gl;
    this._raycaster = raycaster;
    this._culler = culler;
    this._sorter = sorter;
    this._scene = scene;
    this._look = look;
    this._clear = clear;
    this._clearMask = clearMask;
    this._onApplyMaterial = onApplyMaterial.bind(this);

    this._onUpdateSize = () => undefined;

    this.name = name;
    this.viewport = viewport || null;
    const renderTarget = new lib["U" /* RenderTargetFramebuffer */]({
      width: 2,
      height: 2
    });
    renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, createColorAttachment(gl.renderer));
    renderTarget.setDepthStencilAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_ATTACHMENT, depthAttachment);
    this._renderTarget = renderTarget;
    this._renderPass = new lib["S" /* RenderRequest */]({
      scene,
      look,
      renderTarget,
      srgbOutput,
      systems: new Set(['layer'])
    });
    this._renderPass.computeViewZ = this._sorter.computeViewZ;
    this._renderPass.testSurvivedCullingFlag = false;
    this._renderPass.frustumCull = culler.renderQueueCull;
    this._renderPass.renderQueueSort = sorter.renderQueueSort;

    this._renderPass.setOutputLayoutPosition(outputSemantic, 0);

    this._renderPass.clearMask = clearMask;

    this._renderPass.onSubpassStart.subscribe(onBeforeRender); // TODO 3ES-267


    this._renderPass.renderQueue = renderQueue;
    this.setProgressiveRendering(progressiveRendering);
  }

  get culler() {
    return this._culler;
  }

  get sorter() {
    return this._sorter;
  }

  get raycaster() {
    return this._raycaster;
  }

  get renderQueue() {
    return this._renderPass.renderQueue;
  }

  get drawingState() {
    return this._drawingState;
  }

  get queueLength() {
    return this._queueLength;
  }

  get onStagingsRecreated() {
    return this._gl.onStagingsRecreated;
  }

  get renderer() {
    return this._gl.renderer;
  }

  get scene() {
    return this._scene;
  }

  set scene(newScene) {
    this._renderPass.scene = newScene;
    this._scene = newScene;
  }

  get look() {
    return this._look;
  }

  get statistics() {
    return this._statistics;
  }

  get renderPass() {
    return this._renderPass;
  }

  get renderTarget() {
    return this._renderTarget;
  }

  get width() {
    return this._renderTarget.width;
  }

  get height() {
    return this._renderTarget.height;
  }

  get progressiveEnabled() {
    return this._progressiveEnabled;
  }

  _setDrawingState(drawingState) {
    // console.log('change state', this._drawingState, '->', drawingState);
    this._drawingState = drawingState;
  }

  setProgressiveRendering({
    enabled,
    rangeSize,
    auto = true
  }) {
    this._progressiveEnabled = enabled;
    this._progressiveRangeSize = rangeSize;
    this._progressiveAuto = auto;
  }

  getProgressiveRendering() {
    return {
      enabled: this._progressiveEnabled,
      rangeSize: this._progressiveRangeSize,
      auto: this._progressiveAuto
    };
  }

  getColorAttachment() {
    const {
      attachment
    } = this._renderTarget.getColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0);

    attachment.retain();
    return attachment;
  }

  getDepthAttachment() {
    const {
      attachment
    } = this._renderTarget.getDepthStencilAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.DEPTH_ATTACHMENT);

    attachment.retain();
    return attachment;
  }

  pick(device) {
    const eventsByTarget = new Map();

    if (!this._scene || !this._drawn) {
      return eventsByTarget;
    }

    if (!device.ndc || !device.position) {
      return eventsByTarget;
    }

    const hits = this.raycastLayer(device.ndc);

    if (!hits.length) {
      return eventsByTarget;
    }

    const proceededHits = this._raycaster.filterHit(hits);

    const events = proceededHits.map(hit => ({
      device,
      target: null,
      hitTarget: null,
      hitPosition: hit.position,
      hitNormal: hit.normal,
      hitId: hit.id
    }));
    eventsByTarget.set(null, events);
    return eventsByTarget;
  }

  onUpdateSize(handler) {
    this._onUpdateSize = handler;
  }

  updateTextureSize(width, height) {
    if (this._renderTarget.width !== width || this._renderTarget.height !== height) {
      this._renderTarget.resize(width, height);

      this._renderPass.width = width;
      this._renderPass.height = height;
    }

    this._onUpdateSize(width, height);
  }

  forceSetFinishingState() {
    if (!this._progressiveEnabled) {
      return;
    }

    this._setDrawingState(DrawingState.FINISHING);

    this._rangesOverflowed = false;
  }

  updateDrawingState() {
    if (this._needsDrawList.size || this._needsDrawOnceList.size) {
      this._setDrawingState(DrawingState.DRAWING);

      this._rangesOverflowed = false;
      return;
    } // Progressive. First no need to draw frame


    if (this._progressiveEnabled && this._drawingState === DrawingState.DRAWING && !this._rangesOverflowed) {
      this._setDrawingState(DrawingState.FINISHING);

      return;
    } // Progressive. All ranges drown


    if (this._rangesOverflowed) {
      this._setDrawingState(DrawingState.IDLE);

      this._rangesOverflowed = false;
      return;
    } // No progressive. First no need to draw frame


    if (!this._progressiveEnabled && this._drawingState !== DrawingState.IDLE) {
      this._setDrawingState(DrawingState.IDLE);
    }
  }

  _updateProgressive() {
    if (!this._progressiveAuto) {
      return;
    }

    if (!this._progressiveEnabled) {
      this._renderPass.queueRangeSize = 0;
      this._renderPass.queueRangeIndex = 0;
      this._renderPass.clearMask = this._clearMask;
      return;
    }

    this._renderPass.queueRangeSize = this._progressiveRangeSize;

    if (this._drawingState === DrawingState.DRAWING) {
      this._renderPass.queueRangeIndex = 0;
      this._renderPass.clearMask = this._clearMask;
      return;
    }

    if (this._drawingState === DrawingState.FINISHING) {
      this._renderPass.clearMask = lib["h" /* ClearMask */].NONE;
    }
  }

  _draw() {
    const {
      renderer
    } = this._gl;

    this._updateProgressive();

    if (this.viewport) {
      const {
        x,
        y,
        width,
        height
      } = this.viewport;

      this._renderPass.setViewport(x, y, width, height);
    }

    resources_materials["a" /* IndustrialMaterialFactory */].onApplyMaterial(this._onApplyMaterial);
    this._renderPass.dt = this._gl.time.deltaTime; // @ts-ignore this setter is valid

    renderer.state.clearColor = this._clear;
    renderer.render(this._renderPass);

    if (this._drawingState === DrawingState.DRAWING) {
      this._statistics.reset();

      this._statistics.add(this._renderPass.statistics);
    }

    if (this._drawingState === DrawingState.FINISHING) {
      this._statistics.add(this._renderPass.statistics);
    } // Check all ranges drown


    if (this.renderPass._queueRangeOffset > this.renderPass.renderQueue.length - 1) {
      this.renderPass._queueRangeOffset = this.renderPass.renderQueue.length;
      this._rangesOverflowed = true;
    }

    resources_materials["a" /* IndustrialMaterialFactory */].onApplyMaterial(null);
    this._drawn = true;
    this._cleared = false;
  }

  clear() {
    if (this._cleared) {
      return;
    }

    this._gl.clear(this._renderTarget, this._clear);

    this._drawn = false;
    this._cleared = true;
  }

  draw() {
    if (!this._renderPass.scene) {
      return;
    }

    super.draw();
  }

  get canvas() {
    return this._gl.canvas;
  }

  get ctx() {
    return this._gl.renderer.context;
  }

}

layer3d_defineProperty(layer3d_Layer3D, "DrawingState", DrawingState);

layer3d_defineProperty(layer3d_Layer3D, "DepthFunction", lib["gb" /* Texture */].CompareFunc);
// CONCATENATED MODULE: ./src/core/layers/layer/layer3d-ecs.ts
function layer3d_ecs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const DEFAULT_EVENTS = ['onStart', 'onUpdate', 'onLateUpdate', 'onDraw', 'onEnd'];
class layer3d_ecs_Layer3DECS extends layer3d_Layer3D {
  constructor(options) {
    super(options);

    layer3d_ecs_defineProperty(this, "_needsFullSystemUpdateList", void 0);

    this._needsFullSystemUpdateList = new Set();
  }

  get needsFullSystemUpdate() {
    return Boolean(this._needsFullSystemUpdateList.size);
  }

  setNeedsFullSystemUpdate(tag = Symbol('generated-full-systems-update-tag')) {
    this._needsFullSystemUpdateList.add(tag);
  }

  _updateSystemsFromList(systemsToUpdate) {
    this._core.currentRequest = this.renderPass;
    const systemsIds = new Set();

    for (const systemType of systemsToUpdate) {
      systemsIds.add(systemType.ID);
    }

    for (const event of DEFAULT_EVENTS) {
      this._core.fireSystemEvent(event, systemsIds);
    }
  }

  updateSystems(systemsToUpdate) {
    if (!this._renderPass.scene) {
      return;
    }

    this._updateSystemsFromList(systemsToUpdate);

    this._needsFullSystemUpdateList.clear();
  }

  pick(device) {
    const eventsByTarget = new Map();

    if (!this._scene) {
      return eventsByTarget;
    }

    if (!device.ndc || !device.position) {
      return eventsByTarget;
    }

    const hits = this.raycastLayer(device.ndc);

    if (hits.length) {
      const proceededHits = this._raycaster.filterHit(hits);

      for (const hit of proceededHits) {
        // Bubbling
        let node = hit.node;

        while (node) {
          let eventByNode = eventsByTarget.get(node);

          if (!eventByNode) {
            eventByNode = [];
            eventsByTarget.set(node, eventByNode);
          }

          eventByNode.push({
            device,
            target: node,
            hitTarget: hit.node || null,
            hitPosition: hit.position,
            hitNormal: hit.normal
          });
          node = node.parent;
        }
      }
    }

    return eventsByTarget;
  }

}
// EXTERNAL MODULE: ./src/core/layers/composer/material/shaders/screen.vert
var screen = __webpack_require__(89);
var screen_default = /*#__PURE__*/__webpack_require__.n(screen);

// EXTERNAL MODULE: ./src/core/layers/composer/material/shaders/anti-aliasing.frag
var anti_aliasing = __webpack_require__(238);
var anti_aliasing_default = /*#__PURE__*/__webpack_require__.n(anti_aliasing);

// CONCATENATED MODULE: ./src/core/layers/composer/material/anti-aliasing.ts
function anti_aliasing_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







class anti_aliasing_AntiAliasingMaterial extends lib["sb" /* WebGLBaseMaterial */] {
  constructor(options) {
    super({
      name: 'anti-aliasing-material',
      alphaMode: lib["D" /* Material */].AlphaMode.OPAQUE,
      cullFace: lib["D" /* Material */].CullFace.NONE
    });

    anti_aliasing_defineProperty(this, "_colorMap", void 0);

    anti_aliasing_defineProperty(this, "_resolution", void 0);

    anti_aliasing_defineProperty(this, "_aaPixelRatio", void 0);

    anti_aliasing_defineProperty(this, "_aaMode", void 0);

    anti_aliasing_defineProperty(this, "_shaders", void 0);

    this._shaders = {
      name: 'anti-aliasing-shader',
      vertexShader: screen_default.a,
      fragmentShader: anti_aliasing_default.a,
      defines: {},
      extensions: {}
    };
    this._aaPixelRatio = options.aaPixelRatio;
    this._aaMode = options.aaMode;
    this._colorMap = options.colorMap;
    this._resolution = new math_lib["m" /* Vector2 */](1, 1);
    this.depthTest = false;
    this.depthWrite = true;
    this.needsUpdate = true;
  }

  get shaders() {
    return this._shaders;
  }

  setAA(mode, pixelRatio) {
    this._aaMode = mode;
    this._aaPixelRatio = pixelRatio;
    this.needsUpdate = true;
  }

  setResolution(width, height) {
    this._resolution.set(width, height);
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const {
      capabilities
    } = programs;
    const {
      webgl2Support
    } = capabilities;
    const {
      id: renderPassId
    } = renderPass;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const {
      program
    } = technique;
    const {
      layout
    } = program;
    const {
      uniforms
    } = layout;
    const uniform = uniforms.get('_colorMap');
    console.assert(uniform !== undefined, 'uniform "_colorMap" is undefined');

    if (uniform) {
      this._setTexture(gl, uniform, this._colorMap, textures);
    }

    Object(global_helpers["F" /* setUniform */])(uniforms, 'resolution', this._resolution, false);

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    this._resetTechniqueProgram(technique);

    const {
      defines
    } = technique;

    if (this._aaMode === AAMode.NONE) {
      delete defines.FXAA;
      delete defines.SSAA;
    } else if (this._aaMode === AAMode.FXAA) {
      defines.FXAA = 1;
      delete defines.SSAA;
    } else {
      delete defines.FXAA;
      defines.SSAA = this._aaPixelRatio;
    }

    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

}
// EXTERNAL MODULE: ./src/core/layers/composer/material/shaders/composing.frag
var composing = __webpack_require__(239);
var composing_default = /*#__PURE__*/__webpack_require__.n(composing);

// CONCATENATED MODULE: ./src/core/layers/composer/material/composing.ts
function composing_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const composing_defaultColor = new math_lib["k" /* RGBColor */](1, 1, 1);
class composing_ComposingMaterial extends lib["sb" /* WebGLBaseMaterial */] {
  constructor() {
    super({
      name: 'full-screen-material',
      alphaMode: lib["D" /* Material */].AlphaMode.OPAQUE,
      cullFace: lib["D" /* Material */].CullFace.NONE
    });

    composing_defineProperty(this, "hoverAnimationProgress", 0);

    composing_defineProperty(this, "hoverIdColor", composing_defaultColor);

    composing_defineProperty(this, "_colorMaps", void 0);

    composing_defineProperty(this, "_debugLayers", void 0);

    composing_defineProperty(this, "_shaders", void 0);

    this._shaders = {
      name: 'full-screen-shader',
      vertexShader: screen_default.a,
      fragmentShader: composing_default.a,
      defines: {},
      extensions: {}
    };
    this._colorMaps = new Map();
    this._debugLayers = false;
    this.depthTest = false;
    this.depthWrite = true;
  }

  get shaders() {
    return this._shaders;
  }

  setDebugLayers(value) {
    this._debugLayers = value;
    this.needsUpdate = true;
  }

  setColorMap(name, newColorMap) {
    const currentColorMap = this._colorMaps.get(name) || null;

    if (currentColorMap === newColorMap) {
      return;
    }

    this.needsUpdate = lib["sb" /* WebGLBaseMaterial */]._testIfNewTextureRequireUpdate(currentColorMap, newColorMap);

    if (newColorMap === null) {
      this._colorMaps.set(name, null);

      return;
    }

    console.assert(newColorMap instanceof lib["gb" /* Texture */], `${this.constructor.name}.set: value type is ${typeof newColorMap}, expects Texture`);
    console.assert(newColorMap.bindingPoint === lib["gb" /* Texture */].BindingPoint.TEXTURE_2D, `${this.constructor.name}.set: color map binding point is ${typeof newColorMap}, expects TEXTURE_2D`);

    this._colorMaps.set(name, newColorMap);
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const {
      capabilities
    } = programs;
    const {
      webgl2Support
    } = capabilities;
    const {
      id: renderPassId
    } = renderPass;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const {
      program
    } = technique;
    const {
      layout
    } = program;
    const {
      uniforms
    } = layout;
    const {
      _colorMaps
    } = this;

    _colorMaps.forEach((_colorMap, name) => {
      if (!(_colorMap instanceof lib["gb" /* Texture */])) {
        return;
      }

      const uniform = uniforms.get(name);
      console.assert(uniform !== undefined, `uniform "${name}" is undefined`);

      if (uniform) {
        this._setTexture(gl, uniform, _colorMap, textures);
      }
    });

    Object(global_helpers["F" /* setUniform */])(uniforms, 'hoverIdColor', this.hoverIdColor);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'hoverAnimationProgress', this.hoverAnimationProgress);

    this._bindTextures(gl);
  }

  _update(renderable, renderPass, technique, webgl2Support) {
    if (!this._needsUpdate(renderable, renderPass, technique, webgl2Support)) {
      return;
    }

    super._resetTechniqueProgram(technique);

    const {
      defines
    } = technique;

    if (this._debugLayers) {
      defines.DEBUG_LAYERS = '';
    } else {
      delete defines.DEBUG_LAYERS;
    }

    technique.cacheKey = `${JSON.stringify(defines)}`;
    technique.needsUpdate = false;
  }

}
// CONCATENATED MODULE: ./src/core/layers/composer/material/index.ts


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/null-frustum-cull/index.js
function nullFrustumCull(scene, camera, frameNumber) {
  const _lastFrameSceneGraphUpdate = scene._lastFrameSceneGraphUpdate,
        _lastCullingFrameNumber = scene._lastCullingFrameNumber;
  return _lastFrameSceneGraphUpdate < _lastCullingFrameNumber && _lastCullingFrameNumber !== -1 ? false : (scene._lastCullingFrameNumber = frameNumber, true);
}


// CONCATENATED MODULE: ./src/core/layers/composer/screen-quad.ts
function screen_quad_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class screen_quad_ScreenQuad {
  constructor(gl) {
    screen_quad_defineProperty(this, "_renderer", void 0);

    screen_quad_defineProperty(this, "_batchRenderable", void 0);

    screen_quad_defineProperty(this, "_renderPass", void 0);

    const material = new lib["lb" /* UnlitMeshMaterial */]({
      color: new math_lib["k" /* RGBColor */](1, 0, 1)
    });
    const {
      screenTriangle
    } = gl.renderer;
    const scene = new lib["q" /* DotScene */]({
      config: {
        componentClasses: []
      },
      maxSceneNodes: 4
    });
    const look = new lib["C" /* Look */]();
    const subMesh = new lib["fb" /* SubMesh */]({
      name: 'screen-quad-submesh',
      geometry: screenTriangle,
      material
    });
    scene.addInstance(subMesh);
    const renderPass = new lib["S" /* RenderRequest */]({
      scene,
      look,
      srgbOutput: false
    });
    renderPass.frustumCull = nullFrustumCull;
    renderPass.testSurvivedCullingFlag = false;
    const {
      instanceDataManager
    } = scene;
    const batchRenderable = instanceDataManager.getInstanceRenderable(subMesh.instanceId);
    this._renderer = gl.renderer;
    this._batchRenderable = batchRenderable;
    this._renderPass = renderPass;
  }

  get material() {
    return this._batchRenderable.material;
  }

  get renderPass() {
    return this._renderPass;
  }

  draw(material, renderTarget) {
    this._batchRenderable.material = material;
    this._renderPass.renderTarget = renderTarget;

    this._renderer.render(this._renderPass);

    this._renderPass.renderTarget = null;
  }

}
// CONCATENATED MODULE: ./src/core/layers/composer/custom-render-pass.ts
function custom_render_pass_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class custom_render_pass_CustomRenderPass {
  constructor(options) {
    custom_render_pass_defineProperty(this, "_screenQuad", void 0);

    custom_render_pass_defineProperty(this, "_material", void 0);

    custom_render_pass_defineProperty(this, "_renderTarget", void 0);

    const {
      width,
      height,
      material,
      screenQuad,
      outputMap
    } = options;
    let renderTarget = null;

    if (outputMap) {
      renderTarget = new lib["U" /* RenderTargetFramebuffer */]({
        width,
        height
      });
      renderTarget.setColorAttachment(lib["U" /* RenderTargetFramebuffer */].Attachment.COLOR_ATTACHMENT0, outputMap);
    }

    this._screenQuad = screenQuad;
    this._material = material;
    this._renderTarget = renderTarget;
  }

  get material() {
    return this._material;
  }

  get renderTarget() {
    return this._renderTarget;
  }

  updateTextureSize(width, height) {
    if (!this._renderTarget) {
      return;
    }

    if (this._renderTarget.width !== width || this._renderTarget.height !== height) {
      this._renderTarget.resize(width, height);
    }
  }

  draw() {
    this._screenQuad.draw(this._material, this._renderTarget);
  }

}
// CONCATENATED MODULE: ./src/core/layers/composer/index.ts
function composer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class composer_Composer {
  constructor(options) {
    composer_defineProperty(this, "_debuggingTextures", void 0);

    composer_defineProperty(this, "_composingPass", void 0);

    composer_defineProperty(this, "_antialiasingPass", void 0);

    const {
      gl,
      textures,
      pointsTextureVisible,
      pointsTextureHidden,
      coloredTextureVisible,
      coloredTextureHidden,
      debuggingTextures,
      idMap,
      aaMode,
      aaPixelRatio
    } = options;
    const outputMap = createColorAttachment(gl.renderer);
    const composingMaterial = new composing_ComposingMaterial();
    const antiAliasingMaterial = new anti_aliasing_AntiAliasingMaterial({
      aaMode,
      aaPixelRatio,
      colorMap: outputMap
    });
    textures.forEach((texture, index) => composingMaterial.setColorMap(`_colorMap${index}`, texture));
    composingMaterial.setColorMap('_pointsTextureVisible', pointsTextureVisible);
    composingMaterial.setColorMap('_pointsTextureHidden', pointsTextureHidden);
    composingMaterial.setColorMap('_coloredTextureVisible', coloredTextureVisible);
    composingMaterial.setColorMap('_coloredTextureHidden', coloredTextureHidden);
    composingMaterial.setColorMap('_idMap', idMap);
    const screenQuad = new screen_quad_ScreenQuad(gl);
    this._debuggingTextures = new Map(Object.entries(debuggingTextures));
    this._composingPass = new custom_render_pass_CustomRenderPass({
      screenQuad,
      width: 1,
      height: 1,
      material: composingMaterial,
      outputMap
    });
    this._antialiasingPass = new custom_render_pass_CustomRenderPass({
      screenQuad,
      width: 1,
      height: 1,
      material: antiAliasingMaterial
    });
  }

  setAA(mode, aaPixelRatio) {
    this._antialiasingPass.material.setAA(mode, aaPixelRatio);
  }

  setHoverId(id) {
    this._composingPass.material.hoverIdColor.set((id >> 16 & 0xff) / 255, (id >> 8 & 0xff) / 255, (id & 0xff) / 255);
  }

  setHoverAnimationProgress(progress) {
    this._composingPass.material.hoverAnimationProgress = progress;
  }

  setDebugLayers(value) {
    const {
      material
    } = this._composingPass;

    for (const [name, texture] of this._debuggingTextures) {
      material.setColorMap('_' + name, texture);
    }

    material.setDebugLayers(value);
    this.draw();
  }

  updateTextureSize(width, height) {
    this._antialiasingPass.material.setResolution(width, height);

    this._composingPass.updateTextureSize(width, height);
  }

  draw() {
    this._composingPass.draw();

    this._antialiasingPass.draw();
  }

}
// CONCATENATED MODULE: ./src/core/layers/raycasters/raycaster.ts
function raycaster_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const takeFirstHit = hits => [hits[0]];

const approveAll = () => true;

class LayerRaycaster {
  constructor(options = {}) {
    raycaster_defineProperty(this, "filterHit", void 0);

    raycaster_defineProperty(this, "filterNode", void 0);

    const {
      filterHit = takeFirstHit,
      filterNode = approveAll
    } = options;
    this.filterHit = filterHit;
    this.filterNode = filterNode;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  raycast(renderPass, ndc) {
    throw new Error('not implemented');
  }

}
// CONCATENATED MODULE: ./src/core/layers/raycasters/utils.ts



// http://ray-tracing.ru/articles213.html
const edge1Vector = new math_lib["n" /* Vector3 */]();
const edge2Vector = new math_lib["n" /* Vector3 */]();
const tVector = new math_lib["n" /* Vector3 */]();
const pVector = new math_lib["n" /* Vector3 */]();
const qVector = new math_lib["n" /* Vector3 */]();

function raycastTriangle(result, ray, vertex0, vertex1, vertex2) {
  edge1Vector.copy(vertex1).subtract(vertex0);
  edge2Vector.copy(vertex2).subtract(vertex0);
  pVector.copy(ray.direction).cross(edge2Vector);
  let factor = pVector.dot(edge1Vector);

  if (Math.abs(factor) < 0.0000001) {
    return;
  }

  factor = 1 / factor;
  tVector.copy(ray.origin).subtract(vertex0);
  result.u = factor * pVector.dot(tVector);

  if (result.u < 0) {
    return;
  }

  qVector.copy(tVector).cross(edge1Vector);
  result.v = factor * qVector.dot(ray.direction);

  if (result.v < 0) {
    return;
  }

  if (result.u + result.v > 1) {
    return;
  }

  result.t = factor * qVector.dot(edge2Vector);
}

function getRaycast(ray, pos, idx, matrix, cullFace, filter) {
  const result = {
    position: new math_lib["n" /* Vector3 */](),
    normal: new math_lib["n" /* Vector3 */]()
  };
  const triangleResult = {
    t: Infinity,
    u: 0,
    v: 0
  };
  const vertex0 = new math_lib["n" /* Vector3 */]();
  const vertex1 = new math_lib["n" /* Vector3 */]();
  const vertex2 = new math_lib["n" /* Vector3 */]();
  const edge1 = new math_lib["n" /* Vector3 */]();
  const edge2 = new math_lib["n" /* Vector3 */]();
  const position = new math_lib["n" /* Vector3 */]();
  const normal = new math_lib["n" /* Vector3 */]();
  let distance = Infinity;

  for (let it = 0; it < idx.length; it += 3) {
    vertex0.set(pos[idx[it + 0] * 3], pos[idx[it + 0] * 3 + 1], pos[idx[it + 0] * 3 + 2]).applyAffineMatrix(matrix);
    vertex1.set(pos[idx[it + 1] * 3], pos[idx[it + 1] * 3 + 1], pos[idx[it + 1] * 3 + 2]).applyAffineMatrix(matrix);
    vertex2.set(pos[idx[it + 2] * 3], pos[idx[it + 2] * 3 + 1], pos[idx[it + 2] * 3 + 2]).applyAffineMatrix(matrix);
    raycastTriangle(triangleResult, ray, vertex0, vertex1, vertex2);

    if (distance > triangleResult.t && triangleResult.t >= 0) {
      edge1.copy(vertex1).subtract(vertex0);
      edge2.copy(vertex2).subtract(vertex0);
      normal.copy(edge1).cross(edge2).normalize();

      if ( // BackFace
      cullFace === lib["D" /* Material */].CullFace.FRONT || // DoublSide and we choosed wrong side for normal
      cullFace === lib["D" /* Material */].CullFace.NONE && Math.acos(ray.direction.dot(normal)) < Math.PI / 2) {
        normal.negate();
      }

      vertex0.multiplyNumber(1 - triangleResult.u - triangleResult.v);
      vertex1.multiplyNumber(triangleResult.u);
      vertex2.multiplyNumber(triangleResult.v);
      position.copy(vertex0).add(vertex1).add(vertex2);

      if (!filter(position)) {
        continue;
      }

      distance = triangleResult.t;
      result.position.copy(position);
      result.normal.copy(normal);
    }
  } // No hit


  if (distance === Infinity) {
    return null;
  }

  return result;
}

function raycastGeometry(ray, geometry, matrix, cullFace, filter) {
  if (geometry.unloaded) {
    return null;
  }

  if (geometry.primitiveType !== lib["O" /* PrimitiveType */].TRIANGLES) {
    return null;
  }

  const indicesAttribute = geometry.indices;
  const positionAttribute = geometry.attributes.get(lib["d" /* AttributeSemantic */].POSITION);

  if (!positionAttribute || !indicesAttribute) {
    throw new Error('Geometry does not have the required attributes');
  }

  return getRaycast(ray, positionAttribute.view, indicesAttribute.view, matrix, cullFace, filter);
}
function raycastGeometryFromCamera(look, ndc, geometry, matrix, cullFace, filter) {
  const invertedProjectionMatrix = look.projectionMatrix.clone().invert();
  const viewRay = new math_lib["l" /* Ray3 */]();
  viewRay.origin.set(ndc.x, ndc.y, -1);
  viewRay.direction.set(0, 0, 1);
  viewRay.applyHomogeneousMatrix(invertedProjectionMatrix);
  const worldRay = viewRay.clone().applyAffineMatrix(look.worldMatrix);
  worldRay.direction.normalize();
  return raycastGeometry(worldRay, geometry, matrix, cullFace, filter);
}
const positionMatrixVector = new math_lib["n" /* Vector3 */]();
const positionExplodeVector = new math_lib["n" /* Vector3 */]();
function applyExplosionToMatrix(renderable, instanceDataManager, matrix) {
  matrix.translationPaste(positionMatrixVector);
  instanceDataManager.getInstancedAttribute(renderable, lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_1, positionExplodeVector);
  positionMatrixVector.add(positionExplodeVector);
  matrix.translationCopy(positionMatrixVector);
}
const tempWorldMatrix = new math_lib["b" /* AffineMatrix3 */]();
function raycastRenderablesFromCamera(look, ndc, renderables, filter) {
  let finalResult = null;
  const cameraPosition = look.worldMatrix.translationPaste(new math_lib["n" /* Vector3 */]());

  for (const renderable of renderables) {
    const scene = renderable.getScene();
    const {
      instanceDataManager
    } = scene;
    Object(global_helpers["r" /* getWorldMatrixByRenderable */])(renderable, instanceDataManager, tempWorldMatrix); // Apply additional translation (explosion) to the object's matrix

    applyExplosionToMatrix(renderable, instanceDataManager, tempWorldMatrix);
    let result;

    if (renderable.isSprite) {
      // For sprites return center all the time
      result = {
        position: tempWorldMatrix.translationPaste(new math_lib["n" /* Vector3 */]()),
        normal: look.worldMatrix.axisZPaste(new math_lib["n" /* Vector3 */]()).negate()
      };
    } else {
      result = raycastGeometryFromCamera(look, ndc, renderable.geometry, tempWorldMatrix, renderable.material.cullFace, filter);
    }

    if (!result) {
      continue;
    } // If first result or this result better


    if (!finalResult || result.position.distance(cameraPosition) < finalResult.position.distance(cameraPosition)) {
      finalResult = { ...result,
        renderable
      };
    }
  }

  return finalResult;
}
const decodeIdFromRGB = rgb => rgb[2] + rgb[1] * 256 + rgb[0] * 256 ** 2;
// CONCATENATED MODULE: ./src/core/layers/raycasters/color-raycaster.ts
function color_raycaster_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class color_raycaster_ColorRaycaster extends LayerRaycaster {
  constructor(options) {
    const {
      filterHit,
      renderer,
      renderTarget,
      structure,
      filter = () => true
    } = options;
    super({
      filterHit
    });

    color_raycaster_defineProperty(this, "_renderer", void 0);

    color_raycaster_defineProperty(this, "_renderTarget", void 0);

    color_raycaster_defineProperty(this, "_buffer", void 0);

    color_raycaster_defineProperty(this, "_structure", void 0);

    color_raycaster_defineProperty(this, "_filter", void 0);

    this._renderer = renderer;
    this._structure = structure;
    this._filter = filter;
    this._renderTarget = renderTarget;
    this._buffer = new Uint8Array(4);
  }

  raycast(renderPass, ndc) {
    const {
      scene,
      look
    } = renderPass;

    if (!this._renderTarget) {
      throw new Error('no renderTarget');
    }

    if (!scene) {
      throw new Error('no scene');
    }

    if (!look) {
      throw new Error('no look');
    }

    const {
      width,
      height
    } = this._renderTarget;
    const x = (ndc.x + 1) / 2 * (width - 1);
    const y = (ndc.y + 1) / 2 * (height - 1);

    this._renderer.readPixels(this._renderTarget, x, y, 1, 1, this._buffer);

    const id = decodeIdFromRGB(this._buffer);

    if (id === 0xffffff) {
      return [];
    } // Miss click


    const renderables = this._structure.get(id);

    const hit = raycastRenderablesFromCamera(look, ndc, renderables, this._filter);

    if (!hit) {
      return [];
    } // Sometimes it's possible that pixel was picked but geometry raycasting failed


    return [{ ...hit,
      id
    }];
  }

}
// CONCATENATED MODULE: ./src/core/layers/raycasters/empty-raycaster.ts

class empty_raycaster_EmptyLayerRaycaster extends LayerRaycaster {
  raycast() {
    return [];
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/raycaster/index.js + 1 modules
var _wgetemp_raycaster = __webpack_require__(77);

// CONCATENATED MODULE: ./src/core/layers/raycasters/engine-raycaster.ts
function engine_raycaster_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const defaultEngineRaycasterOptions = {
  order: true,
  nearestOnly: false,
  outputNormals: true,
  outputPositions: true
};
class engine_raycaster_EngineRaycaster extends LayerRaycaster {
  constructor(options = {}) {
    const {
      filterHit,
      filterNode,
      ...engineRaycasterOptions
    } = options;
    super({
      filterHit,
      filterNode
    });

    engine_raycaster_defineProperty(this, "_raycaster", void 0);

    this._raycaster = new _wgetemp_raycaster["a" /* Raycaster */]({ ...defaultEngineRaycasterOptions,
      ...engineRaycasterOptions,
      filterNode: Object(global_helpers["G" /* toRaycastFilterNode */])(this.filterNode)
    });
  }

  raycast(renderPass, ndc) {
    const {
      scene,
      look
    } = renderPass;

    if (!(scene instanceof lib["Y" /* Scene */])) {
      throw new Error('no scene or wrong type');
    } // "As" needs to force ts to understand that there are normals and positions in the RaycasterHit thanks to enabled params "outputNormals", "outputPositions"


    const hits = this._raycaster.castFromCamera([scene.root], ndc, look);

    return hits;
  }

}
// CONCATENATED MODULE: ./src/core/layers/raycasters/index.ts




// CONCATENATED MODULE: ./src/core/layers/sorters/sorter.ts
function sorter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BaseSorter {
  constructor({
    computeViewZ = true
  } = {}) {
    sorter_defineProperty(this, "computeViewZ", void 0);

    sorter_defineProperty(this, "renderQueueSort", () => {
      throw new Error('"renderQueueSort" method must be overrided');
    });

    this.computeViewZ = computeViewZ;
    this._sort = this._sort.bind(this);
    this.renderQueueSort = this.renderQueueSort.bind(this);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _sort(lhs, rhs) {
    throw new Error('"_sort" method must be overrided');
  }

}
// CONCATENATED MODULE: ./src/core/layers/sorters/empty-sorter.ts
function empty_sorter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class empty_sorter_EmptySorter extends BaseSorter {
  constructor(...args) {
    super(...args);

    empty_sorter_defineProperty(this, "renderQueueSort", queue => {
      return queue;
    });
  }

  _sort() {
    return 0;
  }

}
// CONCATENATED MODULE: ./src/core/layers/sorters/main-sorter.ts
function main_sorter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function checkLinedSubmesh(renderable) {
  return renderable.geometry.primitiveType === lib["O" /* PrimitiveType */].LINES;
}

class main_sorter_MainSorter extends BaseSorter {
  constructor(...args) {
    super(...args);

    main_sorter_defineProperty(this, "_isNeedsUpdateQueue", true);

    main_sorter_defineProperty(this, "_isNeedsRevertOrder", true);

    main_sorter_defineProperty(this, "_sortMap", null);

    main_sorter_defineProperty(this, "_sortIdCache", new Map());

    main_sorter_defineProperty(this, "_sortFromCache", (lhs, rhs) => {
      const lIndex = this._sortIdCache.get(lhs.instanceId);

      const rIndex = this._sortIdCache.get(rhs.instanceId);

      if (lIndex === undefined) {
        return 1;
      }

      if (rIndex === undefined) {
        return -1;
      }

      return lIndex - rIndex;
    });

    main_sorter_defineProperty(this, "renderQueueSort", queue => {
      if (this._isNeedsRevertOrder && this._sortIdCache.size > 0) {
        queue.sort(this._sortFromCache);

        this._saveSortingCache(queue);
      } else if (this._isNeedsUpdateQueue) {
        queue.sort(this._sort);

        this._saveSortingCache(queue);
      }

      this._isNeedsRevertOrder = false;
      this._isNeedsUpdateQueue = false;
    });
  }

  createSortMap(renderables) {
    const max = new math_lib["n" /* Vector3 */]();
    const min = new math_lib["n" /* Vector3 */]();
    const sortMap = new Map();
    const worldMatrix = new math_lib["b" /* AffineMatrix3 */]();

    for (const renderable of renderables) {
      const scene = renderable.getScene();

      if (renderable.instanceId === null) {
        continue;
      }

      if (renderable.unloaded) {
        continue;
      }

      if (!renderable.material.visible) {
        continue;
      }

      if (!scene.getInstanceVisibility(renderable)) {
        continue;
      }

      if (checkLinedSubmesh(renderable)) {
        continue;
      }

      const {
        boundingBox
      } = renderable.geometry;
      scene.getWorldMatrix(renderable, worldMatrix);
      max.copy(boundingBox.max).applyAffineMatrix(worldMatrix);
      min.copy(boundingBox.min).applyAffineMatrix(worldMatrix);
      const size = min.distance(max);
      sortMap.set(renderable.instanceId, Math.max(sortMap.get(renderable.instanceId) || 0, size));
    }

    this._sortMap = sortMap;
    this._isNeedsUpdateQueue = true;

    this._sortIdCache.clear();
  }

  setNeedsRevertOrder() {
    this._isNeedsRevertOrder = true;
  }

  setNeedsUpdate() {
    this._isNeedsUpdateQueue = true;
  }

  _sort(lhs, rhs) {
    const lMode = lhs.material.alphaMode;
    const rMode = rhs.material.alphaMode;
    /*
    // renderQueueGroup support
    const lRQG = lhs.renderQueueGroup;
    const rRQG = rhs.renderQueueGroup;
     if (lRQG !== rRQG) {
        return lRQG - rRQG; // less value group goes first
    }
    */

    if (lMode !== lib["D" /* Material */].AlphaMode.BLEND && rMode === lib["D" /* Material */].AlphaMode.BLEND) {
      return -1; // lhs goes first
    }

    if (lMode === lib["D" /* Material */].AlphaMode.BLEND && rMode !== lib["D" /* Material */].AlphaMode.BLEND) {
      return 1; // no matter anything, lhs gotta go end
    }

    if (lMode === lib["D" /* Material */].AlphaMode.BLEND && rMode === lib["D" /* Material */].AlphaMode.BLEND) {
      return lhs.viewZ - rhs.viewZ; // blends from far to close
    }

    if (this._sortMap) {
      const lValue = this._sortMap.get(lhs.instanceId) || 0;
      const rValue = this._sortMap.get(rhs.instanceId) || 0;
      return rValue - lValue;
    }

    return 0;
  }

  /* Save sorting order and check if there are transaprent objects. */
  _saveSortingCache(queue) {
    this._sortIdCache.clear();

    for (let i = 0; i < queue.length; i++) {
      this._sortIdCache.set(queue[i].instanceId, i);
    }
  }

}
// CONCATENATED MODULE: ./src/core/layers/sorters/engine-sorter.ts
function engine_sorter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class engine_sorter_EngineSorter extends BaseSorter {
  constructor(...args) {
    super(...args);

    engine_sorter_defineProperty(this, "renderQueueSort", lib["vb" /* renderQueueSort */]);
  }

  _sort() {
    // no need, implemented by engine
    return 0;
  }

}
// CONCATENATED MODULE: ./src/core/layers/sorters/index.ts




// CONCATENATED MODULE: ./src/core/layers/cullers/culler.ts
function culler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BaseCuller {
  constructor() {
    culler_defineProperty(this, "renderQueueCull", () => {
      throw new Error('Not implemented');
    });
  }

}
// CONCATENATED MODULE: ./src/core/layers/cullers/engine-null-culler.ts
function engine_null_culler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class engine_null_culler_EngineNullCuller extends BaseCuller {
  constructor(...args) {
    super(...args);

    engine_null_culler_defineProperty(this, "renderQueueCull", (scene, look, frameNumber) => {
      return nullFrustumCull(scene, look, frameNumber);
    });
  }

}
// CONCATENATED MODULE: ./src/core/layers/cullers/manual-null-culler.ts
function manual_null_culler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class manual_null_culler_ManualNullCuller extends BaseCuller {
  constructor(...args) {
    super(...args);

    manual_null_culler_defineProperty(this, "_needsUpdate", false);

    manual_null_culler_defineProperty(this, "renderQueueCull", (scene, camera, frameNumber) => {
      if (!this._needsUpdate) {
        return false;
      }

      this._needsUpdate = false; // @ts-expect-error private property, need to force culling

      scene._lastCullingFrameNumber = -1;
      return nullFrustumCull(scene, camera, frameNumber);
    });
  }

  setNeedsUpdate() {
    this._needsUpdate = true;
  }

}
// CONCATENATED MODULE: ./src/core/layers/cullers/false-culler.ts
function false_culler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class false_culler_FalseCuller extends BaseCuller {
  constructor(...args) {
    super(...args);

    false_culler_defineProperty(this, "renderQueueCull", () => {
      return false;
    });
  }

}
// CONCATENATED MODULE: ./src/core/layers/cullers/true-culler.ts
function true_culler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class true_culler_TrueCuller extends BaseCuller {
  constructor(...args) {
    super(...args);

    true_culler_defineProperty(this, "renderQueueCull", () => {
      return true;
    });
  }

}
// CONCATENATED MODULE: ./src/core/layers/cullers/index.ts





// CONCATENATED MODULE: ./src/core/layers/layer/overlay.ts
function overlay_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






let SubLayer;

(function (SubLayer) {
  SubLayer[SubLayer["VISIBLE"] = 1] = "VISIBLE";
  SubLayer[SubLayer["HIDDEN"] = 2] = "HIDDEN";
  SubLayer[SubLayer["BOTH"] = 3] = "BOTH";
})(SubLayer || (SubLayer = {}));

class overlay_Overlay {
  constructor(options) {
    overlay_defineProperty(this, "_gl", void 0);

    overlay_defineProperty(this, "_visibleLayer", void 0);

    overlay_defineProperty(this, "_hiddenLayer", void 0);

    const {
      scene = new lib["q" /* DotScene */]({
        name: 'Empty scene',
        config: {
          componentClasses: []
        }
      }),
      core,
      name,
      gl,
      look,
      culler,
      sorter,
      raycaster,
      depthAttachment,
      renderQueue,
      srgbOutput,
      outputSemantic,
      onBeforeRender
    } = options;
    this._gl = gl;
    this._visibleLayer = new layer3d_Layer3D({
      scene,
      core,
      name: name + '_visible',
      gl,
      look,
      sorter,
      culler,
      raycaster,
      renderQueue,
      onBeforeRender,
      renderPassSettings: {
        srgbOutput,
        clearMask: lib["h" /* ClearMask */].COLOR_BUFFER_BIT,
        depthAttachment,
        outputSemantic
      },
      onApplyMaterial: state => {
        state.depthFunc = layer3d_Layer3D.DepthFunction.LEQUAL;
        state.depthMask = false;
      }
    }); // 1. we need to sort, cull and raycast only one time at visible layer
    // 2. both layer must use common renderQueue

    this._hiddenLayer = new layer3d_Layer3D({
      scene,
      core,
      name: name + '_hidden',
      gl,
      look,
      sorter: new empty_sorter_EmptySorter({
        computeViewZ: false
      }),
      culler: new manual_null_culler_ManualNullCuller(),
      raycaster: new empty_raycaster_EmptyLayerRaycaster(),
      renderQueue: this._visibleLayer.renderQueue,
      renderPassSettings: {
        srgbOutput,
        outputSemantic
      }
    });
    this.scene = scene || null;
  }

  get subLayer() {
    return this._visibleLayer;
  } // for debugging


  get visibleLayer() {
    return this._visibleLayer;
  } // for debugging


  get hiddenLayer() {
    return this._hiddenLayer;
  }

  get drawingState() {
    return this._visibleLayer.drawingState;
  }

  get scene() {
    return this._visibleLayer.scene;
  }

  set scene(scene) {
    this._visibleLayer.scene = scene;
    this._hiddenLayer.scene = scene;
  }

  get renderQueue() {
    return this._visibleLayer.renderQueue;
  }

  getColorAttachmentVisible() {
    return this._visibleLayer.getColorAttachment();
  }

  getColorAttachmentHidden() {
    return this._hiddenLayer.getColorAttachment();
  }

  updateTextureSize(width, height) {
    this._visibleLayer.updateTextureSize(width, height);

    this._hiddenLayer.updateTextureSize(width, height);
  }

  updateDrawingState() {
    this._visibleLayer.updateDrawingState();
  }

  setNeedsDrawOnce(tag) {
    this._visibleLayer.setNeedsDrawOnce(tag);
  }

  draw(subLayer = SubLayer.BOTH) {
    if (subLayer & SubLayer.VISIBLE) {
      const gl = this._gl.renderer.context;
      gl.enable(gl.POLYGON_OFFSET_FILL);
      gl.polygonOffset(-2, 0);

      this._visibleLayer.draw();

      gl.disable(gl.POLYGON_OFFSET_FILL);
    }

    if (subLayer & SubLayer.HIDDEN) {
      this._hiddenLayer.draw();
    }
  }

}

overlay_defineProperty(overlay_Overlay, "SubLayer", SubLayer);
// CONCATENATED MODULE: ./src/core/layers/index.ts
function layers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













 // @ts-ignore - Create output layout semantic doesn't exist in engine

lib["S" /* RenderRequest */].OutputLayoutSemantic.CUSTOM_COLOR = 1 << 21;
let NeedsUpdate;

(function (NeedsUpdate) {
  NeedsUpdate[NeedsUpdate["NONE"] = 1] = "NONE";
  NeedsUpdate[NeedsUpdate["COMPOSER"] = 2] = "COMPOSER";
  NeedsUpdate[NeedsUpdate["SORT_MAP"] = 4] = "SORT_MAP";
  NeedsUpdate[NeedsUpdate["LOADED_CHUNK"] = 8] = "LOADED_CHUNK";
})(NeedsUpdate || (NeedsUpdate = {}));

const $loadedChunkLayerTag = Symbol('onLoadChunk');
class layers_Layers {
  constructor({
    core,
    gl,
    store,
    controls,
    serviceScene,
    pointScene,
    structure,
    apiEvents
  }) {
    layers_defineProperty(this, "onDrawStart", new global_helpers["b" /* Event */]());

    layers_defineProperty(this, "onDrawEnd", new global_helpers["b" /* Event */]());

    layers_defineProperty(this, "componentClasses", void 0);

    layers_defineProperty(this, "layer3dMain", void 0);

    layers_defineProperty(this, "layer3dId", void 0);

    layers_defineProperty(this, "layer3dService", void 0);

    layers_defineProperty(this, "layer3dNavigationCube", void 0);

    layers_defineProperty(this, "layer3dColored", void 0);

    layers_defineProperty(this, "layer3dPoints", void 0);

    layers_defineProperty(this, "_store", void 0);

    layers_defineProperty(this, "_gl", void 0);

    layers_defineProperty(this, "_composer", void 0);

    layers_defineProperty(this, "_structure", void 0);

    layers_defineProperty(this, "_needsUpdate", void 0);

    layers_defineProperty(this, "_controls", void 0);

    layers_defineProperty(this, "_apiEventEmitter", void 0);

    layers_defineProperty(this, "_updateColoredRenderQueue", (() => {
      const batchIds = new Set();

      const collectGroupBatchIds = groupName => {
        const group = this._structure.getGroup(groupName);

        if (!group) {
          return;
        }

        for (const renderable of group) {
          batchIds.add(renderable.instanceId);
        }
      };

      return () => {
        const mainRenderQueue = this.layer3dMain.renderQueue;
        const coloredRenderQueue = this.layer3dColored.renderQueue;
        batchIds.clear();
        collectGroupBatchIds('color');
        collectGroupBatchIds('select');
        coloredRenderQueue.length = 0;

        for (const batchRenderable of mainRenderQueue) {
          if (!batchIds.has(batchRenderable.instanceId)) {
            continue;
          }

          coloredRenderQueue.push(batchRenderable);
        }
      };
    })());

    layers_defineProperty(this, "draw", (() => {
      const {
        CameraSystem,
        MeshSystem,
        AnimationSystem,
        TransformSystem,
        LineSystem,
        VisibilitySystem
      } = gl_GL.systemsByName;
      const systemsServiceSoft = new Set([CameraSystem, TransformSystem, AnimationSystem]);
      const systemsServiceAll = new Set([...systemsServiceSoft, MeshSystem, LineSystem, VisibilitySystem]);
      const systemsNavCubeAll = new Set([CameraSystem, MeshSystem, TransformSystem, VisibilitySystem]);
      let prevState = DrawingState.IDLE;
      return time => {
        if (this._store.load.isNone || this._store.load.isLoading) {
          return;
        }

        prevState = this.layer3dMain.drawingState;
        this.layer3dService.updateDrawingState();
        this.layer3dMain.updateDrawingState();
        this.layer3dNavigationCube.updateDrawingState();
        this.layer3dColored.updateDrawingState();
        this.layer3dPoints.updateDrawingState(); // Check for special case on chunk load

        if (this._needsUpdate.has(NeedsUpdate.LOADED_CHUNK)) {
          if (this.layer3dMain.drawingState !== DrawingState.DRAWING) {
            this.layer3dMain.culler.setNeedsUpdate(); // If culling scheduled we lose current queue order after updating render queue. Needs to revert previous queue order.

            this.layer3dMain.sorter.setNeedsRevertOrder(); // Finish drawing without blinking

            this.layer3dMain.forceSetFinishingState();
          } else {
            // Implement default behavior with drawing
            this.layer3dMain.setNeedsDrawOnce($loadedChunkLayerTag);
            this.layer3dMain.updateDrawingState();
          }
        } else {
          // Default behavior
          this.layer3dMain.updateDrawingState();
        }

        this.onDrawStart.emit(time); // Draw service

        if (this.layer3dService.drawingState === DrawingState.DRAWING) {
          this._controls.camera.needsUpdateProjection = true;
          this.layer3dService.updateSystems(systemsServiceAll);
          this.layer3dService.draw();

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } else {
          this._controls.camera.needsUpdateProjection = true; // Need camera updating every frame

          this.layer3dService.updateSystems(systemsServiceSoft);
        } // Draw points


        if (this.layer3dPoints.drawingState === DrawingState.DRAWING) {
          this.layer3dPoints.draw();

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } // Draw ids
        // Order matters. Point layer shoud be already drawn, but main not because 1 frame delay for it.


        if (this.layer3dMain.drawingState === DrawingState.DRAWING) {
          this.layer3dId.clear();
        } else if (this.layer3dPoints.drawingState === DrawingState.DRAWING) {
          this.layer3dId.clear();

          this._drawLayersIds([this.layer3dMain, this.layer3dPoints.subLayer], true);
        } else if (this.layer3dMain.drawingState === DrawingState.FINISHING || prevState !== DrawingState.IDLE && this.layer3dMain.drawingState === DrawingState.IDLE) {
          this._drawLayersIds([this.layer3dMain, this.layer3dPoints.subLayer]);

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } // Draw main


        if (this.layer3dMain.drawingState === DrawingState.DRAWING) {
          if (this._needsUpdate.has(NeedsUpdate.SORT_MAP) && this.layer3dMain.scene) {
            this.layer3dMain.sorter.createSortMap(this._structure.getAllElements());
            this.layer3dMain.sorter.setNeedsUpdate();
            this.layer3dMain.culler.setNeedsUpdate();

            this._needsUpdate.remove(NeedsUpdate.SORT_MAP);
          }

          this.layer3dMain.draw();
          this.layer3dColored.draw(overlay_Overlay.SubLayer.VISIBLE);

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } else if (this.layer3dMain.drawingState === DrawingState.FINISHING) {
          this.layer3dMain.draw();
          this.layer3dColored.draw(overlay_Overlay.SubLayer.VISIBLE);

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } // Draw colored


        if (this.layer3dColored.drawingState === DrawingState.DRAWING) {
          this.layer3dColored.draw();

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        } // Draw navcube


        if (this.layer3dNavigationCube.drawingState === DrawingState.DRAWING) {
          this.layer3dNavigationCube.updateSystems(systemsNavCubeAll);
          this.layer3dNavigationCube.draw();

          this._needsUpdate.add(NeedsUpdate.COMPOSER);
        }

        if (this._needsUpdate.has(NeedsUpdate.COMPOSER)) {
          this._composer.draw();

          this._needsUpdate.remove(NeedsUpdate.COMPOSER);
        }

        this._needsUpdate.remove(NeedsUpdate.LOADED_CHUNK);

        this.onDrawEnd.emit(time);
      };
    })());

    this._controls = controls;
    this._structure = structure;
    this._store = store;
    this._gl = gl;
    this._apiEventEmitter = apiEvents;
    this._needsUpdate = new global_helpers["c" /* Mask */](NeedsUpdate.NONE);
    const look = new lib["C" /* Look */]();
    const componentClasses = [...core.getComponentClassList()];
    this.componentClasses = componentClasses;
    /*
        Navigation cube layer
    */

    this.layer3dNavigationCube = new layer3d_ecs_Layer3DECS({
      core,
      scene: new lib["Y" /* Scene */]({
        config: {
          componentClasses
        }
      }),
      gl,
      look: new lib["C" /* Look */](),
      renderPassSettings: {
        srgbOutput: true,
        viewport: {
          x: 0,
          y: 0,
          width: 256,
          height: 256,
          fullWidth: 256,
          fullHeight: 256
        }
      },
      raycaster: new engine_raycaster_EngineRaycaster(),
      sorter: new empty_sorter_EmptySorter(),
      culler: new engine_null_culler_EngineNullCuller()
    });
    /*
        Service layer
    */

    this.layer3dService = new layer3d_ecs_Layer3DECS({
      core,
      gl,
      look,
      scene: serviceScene,
      raycaster: new engine_raycaster_EngineRaycaster({
        filterNode: node => !Object(global_helpers["x" /* isIgnoreRaycastNode */])(node),
        ignoreInvisibility: true,
        filterHit: hits => {
          const resultHits = [];

          for (const hit of hits) {
            resultHits.push(hit);

            if (hit.node && !Object(global_helpers["y" /* isNodeRaycastTransparent */])(hit.node)) {
              break;
            }
          }

          return resultHits;
        }
      }),
      sorter: new empty_sorter_EmptySorter(),
      culler: new engine_null_culler_EngineNullCuller()
    });
    /*
        Id layer
    */

    this.layer3dId = new layer3d_Layer3D({
      core,
      scene: new lib["q" /* DotScene */]({
        config: {
          componentClasses: []
        }
      }),
      name: 'ids',
      gl,
      look,
      raycaster: new empty_raycaster_EmptyLayerRaycaster(),
      sorter: new empty_sorter_EmptySorter(),
      culler: new false_culler_FalseCuller(),
      renderPassSettings: {
        srgbOutput: false,
        outputSemantic: lib["S" /* RenderRequest */].OutputLayoutSemantic.INSTANCE_COLOR
      },
      clear: {
        color: new math_lib["k" /* RGBColor */](1, 1, 1),
        alpha: 1
      }
    });
    /*
        Main layer
    */

    const colorRaycaster = new color_raycaster_ColorRaycaster({
      renderer: gl.renderer,
      renderTarget: this.layer3dId.renderTarget,
      structure,
      filter: position => {
        const {
          min,
          max
        } = this._store.sectionBox;

        if (min === null || max === null) {
          return true;
        }

        return position.x >= min.x && position.x <= max.x && position.y >= min.y && position.y <= max.y && position.z >= min.z && position.z <= max.z;
      }
    });
    this.layer3dMain = new layer3d_Layer3D({
      core,
      name: 'main',
      scene: new lib["q" /* DotScene */]({
        config: {
          componentClasses: []
        }
      }),
      gl,
      look,
      raycaster: colorRaycaster,
      progressiveRendering: {
        enabled: store.renderer.progressiveRenderer.enabled,
        rangeSize: store.renderer.progressiveRenderer.maxDrawcalls
      },
      sorter: new main_sorter_MainSorter({
        computeViewZ: false
      }),
      culler: new manual_null_culler_ManualNullCuller()
    });
    /*
        Selection layer
    */

    const customColorQueue = new RenderQueueUnloadProtected();
    this.layer3dColored = new overlay_Overlay({
      core,
      name: 'colored',
      gl,
      look,
      culler: new manual_null_culler_ManualNullCuller(),
      sorter: new empty_sorter_EmptySorter({
        computeViewZ: false
      }),
      raycaster: new empty_raycaster_EmptyLayerRaycaster(),
      renderQueue: customColorQueue,
      srgbOutput: false,
      // @ts-ignore
      outputSemantic: lib["S" /* RenderRequest */].OutputLayoutSemantic.CUSTOM_COLOR,
      depthAttachment: this.layer3dMain.getDepthAttachment(),
      onBeforeRender: () => {
        // Set only colored batches just before render
        this._updateColoredRenderQueue();
      }
    });
    /*
        Points layer
    */

    this.layer3dPoints = new overlay_Overlay({
      core,
      name: 'points',
      gl,
      look,
      scene: pointScene,
      culler: new true_culler_TrueCuller(),
      srgbOutput: false,
      sorter: new engine_sorter_EngineSorter({
        computeViewZ: true
      }),
      raycaster: colorRaycaster,
      depthAttachment: this.layer3dMain.getDepthAttachment()
    });
    this._composer = new composer_Composer({
      gl,
      textures: [this.layer3dMain.getColorAttachment(), this.layer3dService.getColorAttachment(), this.layer3dNavigationCube.getColorAttachment()],
      debuggingTextures: {
        mainDepthTexture: this.layer3dMain.getDepthAttachment()
      },
      pointsTextureVisible: this.layer3dPoints.getColorAttachmentVisible(),
      pointsTextureHidden: this.layer3dPoints.getColorAttachmentHidden(),
      coloredTextureVisible: this.layer3dColored.getColorAttachmentVisible(),
      coloredTextureHidden: this.layer3dColored.getColorAttachmentHidden(),
      idMap: this.layer3dId.getColorAttachment(),
      aaMode: store.renderer.antialiasing.mode,
      aaPixelRatio: store.renderer.antialiasing.pixelRatio
    }); // https://youtrack.webgears3d.com/issue/3de-724
    // Hack renderer to update renderQueue on range finishing

    const {
      renderer
    } = gl;
    const originalNextSubpass = renderer._nextSubPass;

    renderer._nextSubPass = (renderPass, subPassIndex) => {
      const bakQueueRangeIndex = renderPass._queueRangeIndex;

      if (this._needsUpdate.has(NeedsUpdate.LOADED_CHUNK)) {
        renderPass._queueRangeIndex = 0; // This tells _nextSubPass that wee need to cull and update render queue.
      }

      const result = originalNextSubpass.call(renderer, renderPass, subPassIndex);

      if (this._needsUpdate.has(NeedsUpdate.LOADED_CHUNK)) {
        renderPass._queueRangeIndex = bakQueueRangeIndex; // Revert back
      }

      return result;
    };

    this._addListeners();
  }

  get gl() {
    return this._gl;
  }

  _addListeners() {
    const store = this._store;
    const gl = this._gl;
    Object(mobx_module["h" /* reaction */])(() => store.window.size, () => {
      this.list.forEach(layer => layer.setNeedsDrawOnce(Symbol('resize')));
    });
    Object(mobx_module["h" /* reaction */])(() => store.load.isLoading, status => {
      if (!status) {
        return;
      }

      gl.renderer.context.clear(gl.renderer.context.COLOR_BUFFER_BIT);
    });
    Object(mobx_module["h" /* reaction */])(() => store.renderer.progressiveRenderer, ({
      enabled,
      maxDrawcalls
    }) => {
      this.layer3dMain.setProgressiveRendering({
        enabled,
        rangeSize: maxDrawcalls
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.load.isPreparing, isLoaded => {
      if (!isLoaded) {
        return;
      }

      this._needsUpdate.add(NeedsUpdate.SORT_MAP);
    }); // Reacreate visible instance batches on filter update

    Object(mobx_module["h" /* reaction */])(() => this._store.filter.isReady, async isReady => {
      if (!isReady) {
        return;
      }

      this._needsUpdate.add(NeedsUpdate.SORT_MAP);
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.renderer.antialiasing, ({
      mode: aaMode,
      pixelRatio: aaPixelRatio
    }) => {
      const {
        width,
        height
      } = this._gl.renderer;
      this.updateDeviceSize(width, height);

      this._composer.setAA(aaMode, aaPixelRatio);

      this.list.forEach(layer => layer.setNeedsDrawOnce(Symbol('antialiasing')));
    });
  }

  setMainScene(scene) {
    this.layer3dMain.scene = scene;
    this.layer3dColored.scene = scene;
  }

  setNeedsUpdate(flag) {
    this._needsUpdate.add(flag);
  }

  setHovered(hoverId, progress = 0) {
    this._composer.setHoverId(hoverId);

    this._composer.setHoverAnimationProgress(progress);

    this.setNeedsUpdate(NeedsUpdate.COMPOSER);
  }

  updateDeviceSize(deviceWidth, deviceHeight) {
    const ctx = this._gl.renderer.context;
    const glMaxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
    const maxDeviceSize = Math.max(deviceWidth, deviceHeight);
    let aaPixelRatio = this._store.renderer.antialiasing.pixelRatio;

    if (!this._gl.validateAntialiasing()) {
      aaPixelRatio = Math.floor(glMaxTextureSize / maxDeviceSize);

      this._store.renderer.setAntialiasing({ ...this._store.renderer.antialiasing,
        pixelRatio: aaPixelRatio
      });

      this._apiEventEmitter.fireEvent('antialiasing.state', {
        type: 'antialiasing.state',
        value: this._store.renderer.antialiasing
      });

      console.warn(`WARNING: Can not set this antialiasing. GL.MAX_TEXTURE_SIZE is limited up to ${glMaxTextureSize}. PixelRatio was set to ${aaPixelRatio}.`);
    }

    const width = deviceWidth * aaPixelRatio;
    const height = deviceHeight * aaPixelRatio;
    this.layer3dNavigationCube.updateTextureSize(width, height);
    this.layer3dService.updateTextureSize(width, height);
    this.layer3dColored.updateTextureSize(width, height);
    this.layer3dPoints.updateTextureSize(width, height);
    this.layer3dMain.updateTextureSize(width, height);
    this.layer3dId.updateTextureSize(width, height);

    this._composer.updateTextureSize(width, height);
  }

  get list() {
    return [this.layer3dNavigationCube, this.layer3dService, this.layer3dColored.subLayer, this.layer3dPoints.subLayer, this.layer3dMain, this.layer3dId];
  }

  async renderLayer(tag, layer, options = {}) {
    const targetLayer = layer instanceof overlay_Overlay ? layer.subLayer : layer;
    const {
      culling,
      sort
    } = options;
    const {
      culler,
      sorter
    } = targetLayer; // Special case. For loaded chunk we don't need to draw, need to continue FINISHING.

    const mainLayerChunkFinishing = layer === this.layer3dMain && this._needsUpdate.has(NeedsUpdate.LOADED_CHUNK) && this.layer3dMain.progressiveEnabled && this._checkTransparentVisibleBatch(this.layer3dMain.renderPass) === false // no transparent visible batches loaded before
    ;

    if (!mainLayerChunkFinishing) {
      targetLayer.setNeedsDrawOnce(tag);
    }

    if (culling && culler instanceof manual_null_culler_ManualNullCuller) {
      // Need this to avoid frustrumCulling cache
      culler.setNeedsUpdate();
    }

    if (sort && sorter instanceof main_sorter_MainSorter) {
      // Need this to avoid sort cache
      sorter.setNeedsUpdate();
    }

    await this.waitRenderEnd();
  }

  waitRenderEnd() {
    return new Promise(resolve => {
      this.onDrawEnd.subscribe(() => resolve(), {
        once: true
      });
    });
  }

  _checkTransparentVisibleBatch(renderRequest) {
    for (const batchRenderable of renderRequest.renderQueue) {
      if (batchRenderable.material.visible && batchRenderable.material.alphaMode === lib["D" /* Material */].AlphaMode.BLEND) {
        return true;
      }
    }

    return false;
  }

  _drawLayersIds(layers, forceDrawPreviousFrames = false) {
    const idRenderPass = this.layer3dId.renderPass;

    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      const sourceRenderPass = layer.renderPass;
      idRenderPass.scene = sourceRenderPass.scene;
      idRenderPass.look = sourceRenderPass.look;
      idRenderPass.renderQueue = sourceRenderPass.renderQueue;
      this.layer3dId.setProgressiveRendering({ ...layer.getProgressiveRendering(),
        auto: false
      });

      if (!forceDrawPreviousFrames) {
        idRenderPass.queueRangeSize = sourceRenderPass.queueRangeSize; // ID render whould go after render main layer. Order:
        // 1. render main Layer range N
        // 2. N += 1
        // 3. render id Layer range N - 1

        idRenderPass.queueRangeIndex = Math.max(sourceRenderPass.queueRangeIndex - 1, 0);
        idRenderPass._queueRangeOffset = Math.max(sourceRenderPass._queueRangeOffset - sourceRenderPass.queueRangeSize, 0);
      } else {
        idRenderPass.queueRangeSize = sourceRenderPass.queueRangeSize * sourceRenderPass.queueRangeIndex; // Draw from scrach

        idRenderPass.queueRangeIndex = 0;
      } // Clear first range for the first layer


      const needToClear = i === 0 && idRenderPass.queueRangeIndex === 0;
      idRenderPass.clearMask = needToClear ? lib["h" /* ClearMask */].COLOR_BUFFER_BIT | lib["h" /* ClearMask */].DEPTH_BUFFER_BIT : lib["h" /* ClearMask */].NONE;
      this.layer3dId.draw();
    }
  }

}

layers_defineProperty(layers_Layers, "NeedsUpdate", NeedsUpdate);

layers_defineProperty(layers_Layers, "DrawingState", DrawingState);
// CONCATENATED MODULE: ./src/core/environment.ts
function core_environment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class core_environment_Environment {
  constructor({
    core,
    store,
    container,
    layers
  }) {
    core_environment_defineProperty(this, "_core", void 0);

    core_environment_defineProperty(this, "_container", void 0);

    core_environment_defineProperty(this, "_store", void 0);

    core_environment_defineProperty(this, "_layers", void 0);

    core_environment_defineProperty(this, "_ibl", void 0);

    this._core = core;
    this._store = store;
    this._container = container;
    this._layers = layers;
    Object(mobx_module["h" /* reaction */])(() => this._store.environment.ibl, Object(global_helpers["I" /* updateStoreState */])(async () => {
      if (!this._store.load.isLoaded) {
        return;
      }

      await this._updateIBL();

      this._updateSceneMaterials();

      await this._layers.renderLayer(Symbol('environment'), this._layers.layer3dMain);
    }, this._store.environment));
    Object(mobx_module["h" /* reaction */])(() => this._store.theme.currentTheme, () => this._handleUpdateTheme());
  }

  _handleUpdateTheme() {
    this._container.style.backgroundImage = '';
    this._container.style.backgroundColor = '';
    this._container.style.background = '';
    Object.assign(this._container.style, this._store.theme.currentTheme);
  }

  async _updateIBL() {
    const envStore = this._store.environment;
    envStore.setPending();
    const ibl = await this._core.loadResource('ibl', envStore.ibl.name, envStore.ibl.src, {
      luminance: envStore.ibl.luminance
    });
    this._ibl = ibl;
  }

  async updateScene() {
    const envStore = this._store.environment;
    const {
      scene
    } = this._layers.layer3dMain;

    if (!this._ibl) {
      try {
        await this._updateIBL();
      } catch (e) {// on IBL load fail use lights
      }
    }

    if (!this._ibl) {
      console.warn('IBL was not loaded, adding lights instead'); // eslint-disable-line no-console

      this._addLightsToScene(scene);

      return;
    }

    this._updateSceneMaterials();

    envStore.setReady();
  }

  async _addLightsToScene(scene) {
    const ambientLight = new lib["a" /* AmbientLight */]({
      temperature: 5000,
      illuminance: 8480
    });
    const directrionalLight = new lib["o" /* DirectionalLight */]({
      temperature: 5778,
      illuminance: 32000
    });
    const orientation1 = new math_lib["i" /* Quaternion */]().fromRotation(-60 * Math.PI / 180, new math_lib["n" /* Vector3 */](1, 0, 0));
    const orientation2 = new math_lib["i" /* Quaternion */]().fromRotation(120 * Math.PI / 180, new math_lib["n" /* Vector3 */](0, 1, 0));
    orientation1.multiply(orientation2);
    const matrix = new math_lib["b" /* AffineMatrix3 */]().fromQuaternion(orientation1);
    scene.addLight(ambientLight);
    scene.addLight(directrionalLight, matrix); // await this._layers.renderLayer(Symbol('environment'), this._layers.layer3dMain);
  }

  _updateSceneMaterials() {
    if (!this._ibl) {
      return;
    }

    const {
      scene
    } = this._layers.layer3dMain;
    scene.maxEnvLuminance = this._ibl.environmentMaterial.environmentMap.luminance;

    const materials = this._core.getResourceMap('material').values();

    for (const material of materials) {
      if (material instanceof lib["M" /* PbrMeshMaterial */]) {
        this.applyEnvMapToMaterial(material);
      }
    }
  }

  applyEnvMapToSubmeshes(submeshes) {
    for (const submesh of submeshes) {
      if (submesh.material instanceof lib["M" /* PbrMeshMaterial */]) {
        this.applyEnvMapToMaterial(submesh.material);
      }
    }
  }

  applyEnvMapToMaterials(materials) {
    for (const material of materials) {
      this.applyEnvMapToMaterial(material);
    }
  }

  applyEnvMapToMaterial(material) {
    if (!this._ibl) {
      return;
    }

    if (material.unloaded) {
      material.onLoad.subscribe(() => {
        this.applyEnvMapToMaterial(material);
      });
      return;
    }

    const {
      preFilteredEnvMap,
      brdfLUT,
      iblSH
    } = this._ibl; // Using sphericalHarmonics instead
    // material.illuminanceMap = illuminanceMap;

    material.preFilteredEnvMap = preFilteredEnvMap;
    material.brdfLUT = brdfLUT;
    material.sphericalHarmonics = iblSH;
  }

}
// CONCATENATED MODULE: ./src/core/picker.ts
function picker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const $idle = Symbol('idle');
const $catched = Symbol('catched');
const $proceeded = Symbol('proceeded');
let PickerEventsType;

(function (PickerEventsType) {
  PickerEventsType["EVENT_PICK"] = "onPick";
  PickerEventsType["EVENT_DRAG_START"] = "onDragStart";
  PickerEventsType["EVENT_DRAG_END"] = "onDragEnd";
  PickerEventsType["EVENT_DRAG_MOVE"] = "onDragMove";
  PickerEventsType["EVENT_HOVER"] = "onHover";
  PickerEventsType["EVENT_ENTER"] = "onEnter";
  PickerEventsType["EVENT_LEAVE"] = "onLeave";
})(PickerEventsType || (PickerEventsType = {}));

class picker_Picker {
  constructor({
    input,
    layers
  }) {
    picker_defineProperty(this, "_input", void 0);

    picker_defineProperty(this, "_layers", void 0);

    picker_defineProperty(this, "_device", void 0);

    picker_defineProperty(this, "_startEvent", void 0);

    picker_defineProperty(this, "_deferredEvents", void 0);

    picker_defineProperty(this, "_pickedObjects", void 0);

    picker_defineProperty(this, "_hoveredObjects", void 0);

    picker_defineProperty(this, "onPick", void 0);

    picker_defineProperty(this, "onDragStart", void 0);

    picker_defineProperty(this, "onDragMove", void 0);

    picker_defineProperty(this, "onDragEnd", void 0);

    picker_defineProperty(this, "onMissClick", void 0);

    picker_defineProperty(this, "onMissTarget", void 0);

    picker_defineProperty(this, "onHover", void 0);

    picker_defineProperty(this, "onDeHover", void 0);

    picker_defineProperty(this, "onEnter", void 0);

    picker_defineProperty(this, "onLeave", void 0);

    this._input = input;
    this._layers = layers;
    this._device = null;
    this._startEvent = Object.seal({
      status: $idle,
      device: null,
      layer: null,
      targetEvents: new Map()
    });
    this._deferredEvents = new Map();
    this._hoveredObjects = new Map();
    this._pickedObjects = new Map();
    this.onPick = new global_helpers["b" /* Event */]();
    this.onDragStart = new global_helpers["b" /* Event */]();
    this.onDragMove = new global_helpers["b" /* Event */]();
    this.onDragEnd = new global_helpers["b" /* Event */]();
    this.onMissClick = new global_helpers["b" /* Event */]();
    this.onMissTarget = new global_helpers["b" /* Event */]();
    this.onHover = new global_helpers["b" /* Event */]();
    this.onDeHover = new global_helpers["b" /* Event */]();
    this.onEnter = new global_helpers["b" /* Event */]();
    this.onLeave = new global_helpers["b" /* Event */]();

    this._addListeners();
  }

  _addListeners() {
    this._input.onPointerStart.subscribe(device => {
      Object.assign(this._startEvent, {
        status: $catched,
        device: device.persist()
      });

      this._emitEvents(PickerEventsType.EVENT_DRAG_START, device);
    });

    this._input.onPointerDrag.subscribe(device => {
      this._emitEvents(PickerEventsType.EVENT_DRAG_MOVE, device);
    });

    this._input.onPointerEnd.subscribe(device => {
      this._emitEvents(PickerEventsType.EVENT_DRAG_END, device);
    });

    this._input.onPointerClick.subscribe(device => {
      this._emitEvents(PickerEventsType.EVENT_PICK, device);
    });

    this._input.onPointerMove.subscribe(device => {
      this._device = device;
    });
  }

  _getTargetEvents(device) {
    const targetEvents = new Map();

    for (const layer of this._layers.list) {
      const layerTargetEvents = layer.pick(device);
      layerTargetEvents.forEach((value, key) => targetEvents.set(key, value));

      if (this._hasOpaqueHit(layerTargetEvents)) {
        break;
      }
    }

    return targetEvents;
  }

  _emitEvents(eventName, device) {
    // If was no pick yet, just deffer event emiting on after pick
    if (this._startEvent.status === $catched) {
      this._deferredEvents.set(eventName, device.persist());

      return;
    }

    if (this._startEvent.status === $proceeded) {
      const {
        targetEvents
      } = this._startEvent;

      if (eventName === PickerEventsType.EVENT_PICK) {
        if (!targetEvents.size) {
          this.onMissClick.emit({
            device
          });
        }

        for (const pickedTarget of this._pickedObjects.keys()) {
          if (!targetEvents.has(pickedTarget)) {
            this.onMissTarget.emitTarget(pickedTarget, {
              device
            });
          }
        }

        this._pickedObjects = targetEvents;
      }

      this._emitTargetEvents(eventName, targetEvents, device);
    }

    if (eventName === PickerEventsType.EVENT_DRAG_END) {
      Object.assign(this._startEvent, {
        status: $idle,
        device: null,
        layer: null,
        targetEvents: new Map()
      });
    }
  }

  _emitTargetEvents(eventName, targetEvents, device) {
    for (const [target, events] of targetEvents) {
      for (const event of events) {
        this[eventName].emitTarget(target, { ...event,
          device
        });
      }
    }
  }

  pick() {
    if (this._startEvent.status !== $catched) {
      return;
    }

    if (!this._startEvent.device) {
      return;
    }

    const targetEvents = this._getTargetEvents(this._startEvent.device);

    Object.assign(this._startEvent, {
      status: $proceeded,
      targetEvents
    }); // Run deffered events

    for (const [eventName, device] of this._deferredEvents) {
      this._emitEvents(eventName, device);
    }

    this._deferredEvents.clear();
  }

  _hasOpaqueHit(targetEvents) {
    for (const hitEvents of targetEvents.values()) {
      for (const event of hitEvents) {
        if (!event.hitTarget || !Object(global_helpers["y" /* isNodeRaycastTransparent */])(event.hitTarget)) {
          return true;
        }
      }
    }

    return false;
  }

  _emitEventsByTarget(eventType, target, events) {
    const device = this._device;

    for (const event of events) {
      this[eventType].emitTarget(target, { ...event,
        device: event.device || device
      });
    }
  }

  _emitOnEnterLeave(targetEvents) {
    const device = this._device;

    if (!device) {
      this._hoveredObjects = targetEvents;
      return;
    }

    for (const lastHovered of this._hoveredObjects.keys()) {
      if (!targetEvents.has(lastHovered)) {
        this.onLeave.emitTarget(lastHovered, {
          device
        });
      }
    }

    let events;

    for (const newHovered of targetEvents.keys()) {
      if (!this._hoveredObjects.has(newHovered)) {
        events = targetEvents.get(newHovered);

        this._emitEventsByTarget(PickerEventsType.EVENT_ENTER, newHovered, events);
      }
    }

    this._hoveredObjects = targetEvents;
  }

  hover() {
    if (!this._device || !this._device.position) {
      return;
    }

    const targetEvents = this._getTargetEvents(this._device);

    this._emitOnEnterLeave(targetEvents);

    if (!this._hasOpaqueHit(targetEvents)) {
      this.onDeHover.emit({
        device: this._device
      });
    }

    this._emitTargetEvents(PickerEventsType.EVENT_HOVER, targetEvents, this._device);
  }

}
// EXTERNAL MODULE: ./package.json
var package_0 = __webpack_require__(90);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/gltf-importer/lib/index.js + 5 modules
var gltf_importer_lib = __webpack_require__(65);

// CONCATENATED MODULE: ./src/core/wg-object.ts
function wg_object_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const {
  UPDATE_LOCAL: wg_object_UPDATE_LOCAL,
  UPDATE_WORLD: wg_object_UPDATE_WORLD
} = lib["jb" /* Transform */].StateMask;
class wg_object_WgObject {
  constructor({
    parentNode,
    material,
    name = ''
  }) {
    wg_object_defineProperty(this, "node", void 0);

    wg_object_defineProperty(this, "transform", void 0);

    wg_object_defineProperty(this, "_material", void 0);

    wg_object_defineProperty(this, "_isVisible", true);

    this._material = material;
    this.transform = new lib["jb" /* Transform */]();
    this.node = parentNode.createChild({
      name
    });
    this.node.attach(this.transform);
  }

  setMaterialOpacity(opacity) {
    this._material.opacity = opacity;
  }

  recreate(stagings) {
    Object(global_helpers["i" /* disposeRenderableFromNode */])(this.node);

    for (const node of this.node.children) {
      node.destroy();
    }

    this._create(stagings);
  }

  setTransform(transform) {
    if (!this.transform) {
      return;
    }

    const {
      position = this.transform.position,
      orientation = this.transform.orientation,
      scale = this.transform.scale,
      scaleNumber
    } = transform;

    if (scaleNumber) {
      this.transform.scale.set(scaleNumber, scaleNumber, scaleNumber);
    }

    this.transform.position.copy(position);
    this.transform.orientation.copy(orientation);
    this.transform.scale.copy(scale);
    this.transform.state = wg_object_UPDATE_LOCAL | wg_object_UPDATE_WORLD;
  }

  setVisibility(isVisible, tag) {
    Object(global_helpers["E" /* setNodeVisibilityTraverse */])(this.node, isVisible, tag);
    this._isVisible = isVisible;
  }

}
// CONCATENATED MODULE: ./src/global-helpers/procedural-geometry/unlit-cylinder.ts


function getIndexComponentType(length) {
  if (length < 256) {
    return lib["n" /* DataType */].UNSIGNED_BYTE;
  }

  if (length < 65536) {
    return lib["n" /* DataType */].UNSIGNED_SHORT;
  }

  return lib["n" /* DataType */].UNSIGNED_INT;
}

function createUnlitCylinderMesh({
  material,
  vertexStaging,
  elementStaging,
  name = 'cylinder',
  height = 1,
  radiusTop = 1,
  radiusBottom = 1,
  radialSegments = 8
}) {
  // IndexesArray
  const indexesArray = [];
  const topIndex = radialSegments * 2;
  const bottomIndex = radiusTop > 0 ? topIndex + 1 : topIndex;

  for (let it = 0; it < radialSegments; it++) {
    indexesArray.push(it);
    indexesArray.push((it + 1) % radialSegments);
    indexesArray.push((it + 1) % radialSegments + radialSegments);
    indexesArray.push(it);
    indexesArray.push((it + 1) % radialSegments + radialSegments);
    indexesArray.push(it + radialSegments);

    if (radiusTop > 0) {
      indexesArray.push(it);
      indexesArray.push(topIndex);
      indexesArray.push((it + 1) % radialSegments);
    }

    if (radiusBottom > 0) {
      indexesArray.push(it + radialSegments);
      indexesArray.push((it + 1) % radialSegments + radialSegments);
      indexesArray.push(bottomIndex);
    }
  } // VerticesArray


  const verticesArray = [];
  const angle = Math.PI * 2 / radialSegments;
  const y = height * 0.5;

  for (let it = 0; it < radialSegments; it++) {
    const x = Math.cos(angle * it);
    const z = Math.sin(angle * it);
    const offset0 = it * 3;
    const offset1 = (it + radialSegments) * 3;
    verticesArray[offset0 + 0] = x * radiusTop;
    verticesArray[offset0 + 1] = y;
    verticesArray[offset0 + 2] = z * radiusTop;
    verticesArray[offset1 + 0] = x * radiusBottom;
    verticesArray[offset1 + 1] = -y;
    verticesArray[offset1 + 2] = z * radiusBottom;
  }

  if (radiusTop > 0) {
    verticesArray.push(0);
    verticesArray.push(y);
    verticesArray.push(0);
  }

  if (radiusBottom > 0) {
    verticesArray.push(0);
    verticesArray.push(-y);
    verticesArray.push(0);
  } // Indexes


  const indexComponentType = getIndexComponentType(verticesArray.length / 3);
  const IndexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexesArray.length * IndexType.BYTES_PER_ELEMENT);
  const indexView = new IndexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexesArray.length);
  indexView.set(indexesArray);
  const indices = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexesArray.length,
    normalized: false,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: IndexType
  }); // Vertixes

  const vertexBufferView = new lib["pb" /* VertexBufferView */](vertexStaging, verticesArray.length * Float32Array.BYTES_PER_ELEMENT);
  const vertexView = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, verticesArray.length);
  vertexView.set(verticesArray);
  const positionAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: lib["n" /* DataType */].FLOAT,
    countComponents: 3,
    countElements: verticesArray.length / 3,
    offset: 0,
    semantic: lib["d" /* AttributeSemantic */].POSITION,
    vertexData: vertexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].VEC3,
    stride: 12,
    type: Float32Array
  }); // Geometry, Submesh, Mesh

  const geometry = new lib["t" /* Geometry */]();
  const subMesh = new lib["fb" /* SubMesh */]({
    geometry,
    material
  });
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.indices = indices;
  const mesh = new lib["F" /* Mesh */]({
    name
  });
  mesh.addSubMesh(subMesh); // Release

  positionAttribute.release();
  indices.release();
  geometry.release();
  vertexBufferView.release();
  indexBufferView.release();
  return mesh;
}
// CONCATENATED MODULE: ./src/features/axes/axis.ts
function axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const RADIUS = 0.05;
const LENGTH = 4;
const LETTER_PAD = 1;
const CYLINDER_UP = new math_lib["n" /* Vector3 */](0, 1, 0);
class axis_Axis extends wg_object_WgObject {
  constructor(options) {
    const {
      vertexStaging,
      elementStaging,
      parentNode,
      name,
      color,
      direction = CYLINDER_UP
    } = options;
    const material = new lib["lb" /* UnlitMeshMaterial */]({
      name: `${name}-material`,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      opacity: 0.3,
      color
    });
    super({
      parentNode,
      material,
      name
    });

    axis_defineProperty(this, "_name", void 0);

    axis_defineProperty(this, "_letterNode", void 0);

    this._name = name;
    this._letterNode = null;
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);

    if (!transform) {
      throw new Error('Transform is null');
    }

    this.transform = transform;
    this.updateDirection(direction);

    this._create({
      vertexStaging,
      elementStaging
    });
  }

  _create({
    vertexStaging,
    elementStaging
  }) {
    const material = this._material;
    const line = createUnlitCylinderMesh({
      vertexStaging,
      elementStaging,
      material,
      radiusTop: RADIUS,
      radiusBottom: RADIUS,
      height: LENGTH
    });
    const lineTransform = new lib["jb" /* Transform */]({
      position: new math_lib["n" /* Vector3 */](0, LENGTH / 2, 0)
    });
    const lineNode = this.node.createChild({
      name: `${this._name}-line`
    });
    lineNode.attach(line);
    lineNode.attach(lineTransform);
  }

  setColor(color) {
    this._material.color.copy(color);
  }

  updateDirection(direction) {
    const orientation = new math_lib["i" /* Quaternion */]().rotateBetween(CYLINDER_UP, direction.normalize());
    this.setTransform({
      orientation
    });
  }

  destroyLetter() {
    if (!this._letterNode) {
      return;
    }

    this._letterNode.destroy();

    this._letterNode = null;
  }

  addLetter(node) {
    this.destroyLetter(); // Create letter dummy

    this._letterNode = this.node.createChild({
      name: `${this._name}-letter`
    });
    const letterTransform = new lib["jb" /* Transform */]({
      position: new math_lib["n" /* Vector3 */](0, LENGTH + LETTER_PAD, 0)
    });

    this._letterNode.attach(letterTransform); // Set new parent to the node (move it)


    this._letterNode.adopt(node); // Set axis's material to the letter


    const [mesh] = node.getComponents([lib["F" /* Mesh */]]);

    if (mesh) {
      for (const submesh of mesh.subMeshes()) {
        submesh.material = this._material;
      }
    }

    this.setVisibility(this._isVisible);
  }

}
// CONCATENATED MODULE: ./src/features/axes/gizmo.ts
function gizmo_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class gizmo_Gizmo {
  constructor({
    vertexStaging,
    elementStaging,
    basisMatrix,
    parentNode,
    colors,
    name
  }) {
    gizmo_defineProperty(this, "node", void 0);

    gizmo_defineProperty(this, "_axes", void 0);

    this.node = parentNode.createChild({
      name
    });
    const xAxis = new axis_Axis({
      vertexStaging,
      elementStaging,
      parentNode: this.node,
      color: colors.x,
      name: `${name}-x`
    });
    const yAxis = new axis_Axis({
      vertexStaging,
      elementStaging,
      parentNode: this.node,
      color: colors.y,
      name: `${name}-y`
    });
    const zAxis = new axis_Axis({
      vertexStaging,
      elementStaging,
      parentNode: this.node,
      color: colors.z,
      name: `${name}-z`
    });
    this._axes = [xAxis, yAxis, zAxis];
    this.setBasis(basisMatrix);
    this.setVisibility(false);
  }

  setBasis(basisMatrix) {
    // Need transpose because axisXPaste/axisYPaste/axisZPaste returns rows not columns
    const transposedBasisMatrix = basisMatrix.clone().transpose();
    const xDirection = transposedBasisMatrix.axisXPaste(new math_lib["n" /* Vector3 */]());
    const yDirection = transposedBasisMatrix.axisYPaste(new math_lib["n" /* Vector3 */]());
    const zDirection = transposedBasisMatrix.axisZPaste(new math_lib["n" /* Vector3 */]());

    this._axes[0].updateDirection(xDirection);

    this._axes[1].updateDirection(yDirection);

    this._axes[2].updateDirection(zDirection);
  }

  setColors(colors) {
    this._axes[0].setColor(colors.x);

    this._axes[1].setColor(colors.y);

    this._axes[2].setColor(colors.z);
  }

  setScale(scaleNumber) {
    this._axes[0].setTransform({
      scaleNumber
    });

    this._axes[1].setTransform({
      scaleNumber
    });

    this._axes[2].setTransform({
      scaleNumber
    });
  }

  setVisibility(isVisible) {
    this._axes.forEach(axis => axis.setVisibility(isVisible));
  }

  destroyLetters() {
    this._axes[0].destroyLetter();

    this._axes[1].destroyLetter();

    this._axes[2].destroyLetter();
  }

  addLetters(xLetter, yLetter, zLetter) {
    this._axes[0].addLetter(xLetter);

    this._axes[1].addLetter(yLetter);

    this._axes[2].addLetter(zLetter);
  }

  recreate({
    vertexStaging,
    elementStaging
  }) {
    this._axes.forEach(axis => axis.recreate({
      vertexStaging,
      elementStaging
    }));

    this.setVisibility(false);
  }

}
// CONCATENATED MODULE: ./src/features/axes/assets/xyz.glb
/* harmony default export */ var xyz = ("data:model/gltf-binary;base64,Z2xURgIAAABcFAAAyA8AAEpTT057ImFzc2V0Ijp7InZlcnNpb24iOiIyLjAifSwiZXh0ZW5zaW9uc1VzZWQiOlsiS0hSX21hdGVyaWFsc191bmxpdCIsIldHX2NsZWFyX2NvYXQiXSwiYWNjZXNzb3JzIjpbeyJidWZmZXJWaWV3IjowLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTAsInR5cGUiOiJWRUMyIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoxLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTAsInR5cGUiOiJWRUMzIiwibWluIjpbLTAuMDA5MzM4Njc0MTM1NTA2MTUzLC0wLjAwNzMxMjU2NzQzODkzMDI3MywwXSwibWF4IjpbMC4wMDkzMzg2NzQxMzU1MDYxNTMsMC4wMDczMTI1NjY5NzMyNjg5ODYsMF0sImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEwLCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MywiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjI0LCJ0eXBlIjoiU0NBTEFSIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6OSwidHlwZSI6IlZFQzIiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjUsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo5LCJ0eXBlIjoiVkVDMyIsIm1pbiI6Wy0wLjAwOTMzODY3NjkyOTQ3Mzg3NywtMC4wMDczNzQwNjczMjUxNDUwMDYsMF0sIm1heCI6WzAuMDA5MzM4Njc0MTM1NTA2MTUzLDAuMDA3Mzc0MDY5NjUzNDUxNDQzLDBdLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo5LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6NywiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIxLCJ0eXBlIjoiU0NBTEFSIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMyIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo5LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwibWluIjpbLTAuMDA5MzM4NjczMjA0MTgzNTc4LC0wLjAwNzM3NDA3MDExOTExMjczLDBdLCJtYXgiOlswLjAwOTMzODY3MzIwNDE4MzU3OCwwLjAwNzM3NDA3MDExOTExMjczLDBdLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjEwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoxMSwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMwLCJ0eXBlIjoiU0NBTEFSIiwiYnl0ZU9mZnNldCI6MH1dLCJidWZmZXJzIjpbeyJuYW1lIjoiYnVmZmVycy9tYWluIiwiYnl0ZUxlbmd0aCI6MTE0NH1dLCJidWZmZXJWaWV3cyI6W3siYnVmZmVyIjowLCJieXRlU3RyaWRlIjo4LCJieXRlTGVuZ3RoIjo4MCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxMjAsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjgwfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjEyMCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MjAwfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6NDgsInRhcmdldCI6MzQ5NjMsImJ5dGVPZmZzZXQiOjMyMH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjgsImJ5dGVMZW5ndGgiOjcyLCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjozNjh9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6MTA4LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0Ijo0NDB9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6MTA4LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0Ijo1NDh9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo0MiwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6NjU2fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6OCwiYnl0ZUxlbmd0aCI6OTYsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjcwMH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNDQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjc5Nn0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNDQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjk0MH0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjYwLCJ0YXJnZXQiOjM0OTYzLCJieXRlT2Zmc2V0IjoxMDg0fV0sIm1hdGVyaWFscyI6W3sibmFtZSI6InoiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgsMC4wMDM5MjE1Njg2Mjc0NTA5OCwwLDFdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e319LCJlbWlzc2l2ZUZhY3RvciI6WzAsMCwwXSwiYWxwaGFNb2RlIjoiT1BBUVVFIiwiZG91YmxlU2lkZWQiOmZhbHNlfSx7Im5hbWUiOiJ5IiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4wMDM5MjE1Njg2Mjc0NTA5OCwwLjAwMzkyMTU2ODYyNzQ1MDk4LDAuOCwxXSwiZXh0ZW5zaW9ucyI6eyJXR19jbGVhcl9jb2F0Ijp7fX0sIm1ldGFsbGljRmFjdG9yIjoxLCJyb3VnaG5lc3NGYWN0b3IiOjF9LCJleHRlbnNpb25zIjp7IktIUl9tYXRlcmlhbHNfdW5saXQiOnt9fSwiZW1pc3NpdmVGYWN0b3IiOlswLDAsMF0sImFscGhhTW9kZSI6Ik9QQVFVRSIsImRvdWJsZVNpZGVkIjpmYWxzZX0seyJuYW1lIjoieCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDExNzY0NzA1ODgyMzUyOTQxLDAuOCwwLjAwMzkyMTU2ODYyNzQ1MDk4LDFdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e319LCJlbWlzc2l2ZUZhY3RvciI6WzAsMCwwXSwiYWxwaGFNb2RlIjoiT1BBUVVFIiwiZG91YmxlU2lkZWQiOmZhbHNlfV0sIm1lc2hlcyI6W3sibmFtZSI6InoiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozLCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MiwiUE9TSVRJT04iOjEsIlRFWENPT1JEXzAiOjB9LCJtYXRlcmlhbCI6MCwibW9kZSI6NH1dfSx7Im5hbWUiOiJ5IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6NywiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjYsIlBPU0lUSU9OIjo1LCJURVhDT09SRF8wIjo0fSwibWF0ZXJpYWwiOjEsIm1vZGUiOjR9XX0seyJuYW1lIjoieCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjExLCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MTAsIlBPU0lUSU9OIjo5LCJURVhDT09SRF8wIjo4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX1dLCJub2RlcyI6W3sibmFtZSI6IlJvb3ROb2RlIiwidHJhbnNsYXRpb24iOlswLDAsMF0sInJvdGF0aW9uIjpbMCwwLDAsMV0sInNjYWxlIjpbMSwxLDFdLCJjaGlsZHJlbiI6WzMsMiwxXX0seyJuYW1lIjoieiIsInRyYW5zbGF0aW9uIjpbMCwwLDBdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjgyODY4OTU3NSwwLDAsMC43MDcxMDY3MDk0ODAyODZdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwibWVzaCI6MH0seyJuYW1lIjoieSIsInRyYW5zbGF0aW9uIjpbMCwwLDBdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjgyODY4OTU3NSwwLDAsMC43MDcxMDY3MDk0ODAyODZdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwibWVzaCI6MX0seyJuYW1lIjoieCIsInRyYW5zbGF0aW9uIjpbMCwwLDBdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjgyODY4OTU3NSwwLDAsMC43MDcxMDY3MDk0ODAyODZdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwibWVzaCI6Mn1dLCJzY2VuZXMiOlt7Im5hbWUiOiJSb290IFNjZW5lIiwibm9kZXMiOlswXX1dLCJzY2VuZSI6MH0gIHgEAABCSU4AAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAAAAAAAAgD8AAIA/AACAPwAAgD8AAAAAAAAAAAAAAAAO8K47Qp7vOwAAAAAO8K47ePUBuwAAAAA9ARk8Qp7vOwAAAAA9ARk8Qp7vuwAAAAAO8K67he0BOwAAAAAO8K47Q57vuwAAAAA9ARm8Qp7vuwAAAAAO8K67Qp7vuwAAAAAN8K67QJ7vOwAAAAA7ARm8QJ7vOwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAEAAgADAAIAAQABAAQABQABAAUAAwAEAAYABwAEAAEACAAJAAYABAAJAAQACAAAAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAACAPwAAgD911Oa7KaLxuwAAAAA9gGS7Y4MjMAAAAAA9ARm8/UOGuwAAAABk2iU6axIDuwAAAAB11Oa7LqLxOwAAAABAARm8/0OGOwAAAABp2iU6cRIDOwAAAAA9ARk8axIDOwAAAAA9ARk8cBIDuwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAEAAgABAAAAAwABAAQABQADAAYAAQAGAAQAAQAHAAMACAAHAAYAAwAAAEIMIj8AAIA/RK2+PgAAgD9Erb4+AACAP0Stvj4AAAAAQgwiPwAAAABCDCI/AAAAAAAAAAAAAAAARK2+PgAAAAAAAAAAAACAP0IMIj8AAIA/AACAPwAAgD8AAIA/AAAAAG/U5rssovG7AAAAADWCZLuJQcCzAAAAADwBGbz9Q4a7AAAAAHDU5jsrovE7AAAAAPuDZDuVQ4uyAAAAADwBGTz9Q4Y7AAAAAG7U5rsvovE7AAAAAEfhCrMEAiA7AAAAADwBGbwBRIY7AAAAAGZmNjPnASC7AAAAAG7U5jsvovG7AAAAADwBGTwBRIa7AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAQACAAMABAAFAAYAAQAHAAEABgAIAAEAAAAJAAcACQAEAAkABwABAAQACgALAAQAAwAHAAoABAAJAA==");
// CONCATENATED MODULE: ./src/features/axes/index.ts
function features_axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

 // @ts-ignore







const LETTER_SCALE_FACTOR = 0.5;
const $renderTag = Symbol('axes');
const coordinateCenter = new math_lib["n" /* Vector3 */](0, 0, 0);
class axes_AxesFeature {
  constructor({
    core,
    store,
    layers,
    controls,
    size = 32
  }) {
    features_axes_defineProperty(this, "_layers", void 0);

    features_axes_defineProperty(this, "_store", void 0);

    features_axes_defineProperty(this, "_core", void 0);

    features_axes_defineProperty(this, "_origin", void 0);

    features_axes_defineProperty(this, "_camera", void 0);

    features_axes_defineProperty(this, "_cameraTransform", void 0);

    features_axes_defineProperty(this, "_size", void 0);

    features_axes_defineProperty(this, "_needsLoadLetters", void 0);

    features_axes_defineProperty(this, "_handleUpdateCamera", () => {
      const scale = this._cameraTransform.position.distance(coordinateCenter) / this._size;

      this._origin.setScale(scale);
    });

    this._layers = layers;
    this._store = store;
    this._core = core;
    const {
      cameraNode
    } = controls;
    const [cameraTransform, camera] = cameraNode.getComponents([lib["jb" /* Transform */], lib["f" /* Camera */]]);

    if (!cameraTransform || !camera) {
      throw new Error('Couldn\'t create axes');
    }

    this._camera = camera;
    this._cameraTransform = cameraTransform;
    this._size = size;

    if (!layers.layer3dService.scene) {
      throw new Error('Service scene not exists');
    }

    const {
      elementStaging,
      vertexStaging
    } = layers.layer3dService.renderer;
    this._origin = new gizmo_Gizmo({
      elementStaging,
      vertexStaging,
      basisMatrix: store.axes.coordinateSystemMatrix,
      colors: store.axes.axesColors,
      parentNode: layers.layer3dService.scene.root,
      name: 'axes-origin'
    });
    Object(global_helpers["u" /* ignoreRaycastNode */])(this._origin.node, true);
    this._needsLoadLetters = true;

    this._addListeners();
  }

  _addListeners() {
    const axesStore = this._store.axes;

    this._camera.onEarlyUpdateEnd.subscribe(this._handleUpdateCamera);

    Object(mobx_module["c" /* autorun */])(() => {
      this._origin.setVisibility(axesStore.showOrigin);

      this._layers.layer3dService.setNeedsDrawOnce($renderTag);
    });
    Object(mobx_module["c" /* autorun */])(() => {
      this._origin.setColors(axesStore.axesColors);

      this._layers.layer3dService.setNeedsDrawOnce($renderTag);
    });
    Object(mobx_module["h" /* reaction */])(() => axesStore.coordinateSystemMatrix, () => {
      this._origin.setBasis(axesStore.coordinateSystemMatrix);

      if (axesStore.showOrigin) {
        this._layers.layer3dService.setNeedsDrawOnce($renderTag);
      }
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.load.isPreparing, async isPreparing => {
      if (!isPreparing) {
        return;
      }

      if (!this._needsLoadLetters) {
        return;
      }

      await this._loadLetters();

      this._origin.setVisibility(axesStore.showOrigin);

      this._layers.layer3dService.setNeedsDrawOnce($renderTag);
    });

    this._layers.layer3dService.onStagingsRecreated.subscribe(({
      elementStaging,
      vertexStaging
    }) => {
      this._origin.recreate({
        elementStaging,
        vertexStaging
      });

      this._origin.destroyLetters();

      this._needsLoadLetters = true;
    });
  }

  async _loadLetters() {
    const lettersUrl = Object(global_helpers["j" /* getBinAssetBlobUrl */])(xyz);
    this._needsLoadLetters = false;
    const {
      elementStaging,
      vertexStaging
    } = this._layers.layer3dService.renderer;
    const gltfLoader = new gltf_importer_lib["b" /* GLTFImporter */]({
      createScene: (maxSceneNodes, batchMap) => {
        const {
          componentClasses
        } = this._layers;
        return new lib["Y" /* Scene */]({
          maxSceneNodes,
          batchMap,
          config: {
            componentClasses
          }
        });
      },
      attributeMemoryManager: vertexStaging,
      indexMemoryManager: elementStaging,
      materialFactory: new lib["E" /* MaterialFactory */]()
    });
    const assets = await gltfLoader.import(lettersUrl);
    const [scene] = assets.scenes;
    scene.retain();
    assets.dispose();

    const lettersContainer = this._origin.node.createChild({
      name: 'axes-origin-letters'
    });

    Object(global_helpers["B" /* mergeCopySync */])(lettersContainer, scene, this._core);
    Object(global_helpers["E" /* setNodeVisibilityTraverse */])(lettersContainer, false);
    scene.release();
    const xLetter = Object(global_helpers["m" /* getNodeByName */])(lettersContainer, 'x');
    const yLetter = Object(global_helpers["m" /* getNodeByName */])(lettersContainer, 'y');
    const zLetter = Object(global_helpers["m" /* getNodeByName */])(lettersContainer, 'z');

    if (!xLetter || !yLetter || !zLetter) {
      console.warn('Failed to load axes letters'); // eslint-disable-line no-console

      return;
    } // Rescale letters


    [xLetter, yLetter, zLetter].forEach(letterNode => {
      const [letterTransform] = letterNode.getComponents([lib["jb" /* Transform */]]);

      if (!letterTransform) {
        return;
      }

      letterTransform.scale.multiplyNumber(LETTER_SCALE_FACTOR);
      letterTransform.state = lib["jb" /* Transform */].StateMask.UPDATE_LOCAL | lib["jb" /* Transform */].StateMask.UPDATE_WORLD;
    }); // Rotate Z letter

    const [zLetterTransform] = zLetter.getComponents([lib["jb" /* Transform */]]);

    if (zLetterTransform) {
      zLetterTransform.orientation.rotate(Math.PI / 2, new math_lib["n" /* Vector3 */](0, 1, 0));
    } // Rotate Y letter


    const [yLetterTransform] = yLetter.getComponents([lib["jb" /* Transform */]]);

    if (yLetterTransform) {
      yLetterTransform.orientation.rotate(Math.PI / 2, new math_lib["n" /* Vector3 */](0, 1, 0));
    }

    this._origin.addLetters(xLetter, yLetter, zLetter);

    lettersContainer.destroy();
  }

}
// CONCATENATED MODULE: ./src/features/color/utils.ts


const blackColor = new math_lib["k" /* RGBColor */](0, 0, 0);
function highlightRenderable(renderable, color) {
  const scene = renderable.getScene();
  scene.instanceDataManager.setInstancedAttribute(renderable, lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_0, color);
}
function convertHexStringToColor(hex) {
  return new math_lib["k" /* RGBColor */](parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255, parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255, parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255);
}
// CONCATENATED MODULE: ./src/features/color/lerper.ts
function lerper_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let Easing;

(function (Easing) {
  Easing[Easing["LINEAR"] = 0] = "LINEAR";
})(Easing || (Easing = {}));

const EasingFunctions = {
  [Easing.LINEAR]: t => t
};

class lerper_Time {
  constructor() {
    lerper_defineProperty(this, "time", performance.now());

    lerper_defineProperty(this, "delta", 0);

    lerper_defineProperty(this, "elapsed", 0);

    lerper_defineProperty(this, "scale", 1);
  }

  reset() {
    this.time = performance.now();
    this.elapsed = 0;
    this.delta = 0;
    this.scale = 1;
  }

  update() {
    const now = performance.now();
    this.delta = (now - this.time) * this.scale * 0.001;
    this.elapsed += this.delta;
    this.time = now;
  }

}

class lerper_Lerper {
  constructor(action, options = {}) {
    lerper_defineProperty(this, "_time", void 0);

    lerper_defineProperty(this, "_action", void 0);

    lerper_defineProperty(this, "_easing", void 0);

    lerper_defineProperty(this, "_promise", void 0);

    lerper_defineProperty(this, "_resolve", void 0);

    lerper_defineProperty(this, "_duration", void 0);

    lerper_defineProperty(this, "_progress", void 0);

    lerper_defineProperty(this, "_isStopped", void 0);

    lerper_defineProperty(this, "_loop", () => {
      this._time.update();

      this._update(this._time.elapsed);

      if (!this._isStopped && this._progress < 1) {
        requestAnimationFrame(this._loop);
      } else {
        this._resolve();
      }
    });

    const {
      duration = 1,
      easing = Easing.LINEAR
    } = options;
    this._time = new lerper_Time();
    this._action = action;
    this._easing = EasingFunctions[easing];
    this._promise = Promise.resolve();

    this._resolve = () => undefined;

    this._duration = duration;
    this._progress = 0;
    this._isStopped = false;
  }

  play() {
    this._isStopped = false;
    this._promise = new Promise(resolve => {
      this._resolve = resolve;
    });

    this._loop();

    return this._promise;
  }

  stop() {
    this._isStopped = true;
    return this._promise;
  }

  reset() {
    this._progress = 0;
    this._isStopped = true;

    this._time.reset();

    this._resolve();
  }

  _update(elapsed) {
    let progress = this._easing(elapsed / this._duration);

    if (progress > 1 || elapsed > this._duration) {
      progress = 1;
    }

    this._progress = progress;

    this._action(progress);
  }

}

lerper_defineProperty(lerper_Lerper, "Easing", Easing);
// CONCATENATED MODULE: ./src/features/color/index.ts
function features_color_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const $color = Symbol('color');
class color_Color {
  constructor({
    layers,
    store,
    structure
  }) {
    features_color_defineProperty(this, "_store", void 0);

    features_color_defineProperty(this, "_layers", void 0);

    features_color_defineProperty(this, "_structure", void 0);

    features_color_defineProperty(this, "_selected", void 0);

    features_color_defineProperty(this, "_colored", void 0);

    features_color_defineProperty(this, "_colorByNode", void 0);

    features_color_defineProperty(this, "_hoverLerper", void 0);

    features_color_defineProperty(this, "_handleLoaded", () => {
      this._colored.clear();

      this._selected.clear();

      this._colorByNode.clear();
    });

    features_color_defineProperty(this, "_handleHoverChanged", async () => {
      await this._hoverLerper.stop();

      this._hoverLerper.reset();

      this._hoverLerper.play();
    });

    features_color_defineProperty(this, "_playHoverAnimation", progress => {
      const {
        hoveredObject
      } = this._store.hover;
      const hoverId = hoveredObject === null ? Number.MAX_SAFE_INTEGER : hoveredObject;

      this._layers.setHovered(hoverId, progress);
    });

    features_color_defineProperty(this, "_handleSelectionChanged", () => {
      this._prepareSelected();

      this._applyColors();
    });

    features_color_defineProperty(this, "_handleColorChanged", () => {
      this._prepareColored();

      this._applyColors();
    });

    features_color_defineProperty(this, "_applyColors", () => {
      const selectionColor = convertHexStringToColor(this._store.select.color);
      let color;

      const colored = this._structure.getGroup('color');

      const selected = this._structure.getGroup('select');

      for (const renderable of colored) {
        color = this._colorByNode.get(renderable);

        if (!color) {
          continue;
        }

        highlightRenderable(renderable, color);
      }

      for (const renderable of selected) {
        highlightRenderable(renderable, selectionColor);
      }

      this._layers.renderLayer($color, this._layers.layer3dColored, {
        culling: true
      });
    });

    this._store = store;
    this._layers = layers;
    this._structure = structure;
    this._colorByNode = new Map();
    this._hoverLerper = new lerper_Lerper(this._playHoverAnimation, {
      duration: 0.25
    });
    this._selected = new Set();
    this._colored = new Set();

    this._structure.addGroup('select');

    this._structure.addGroup('color');

    this._addListeners();
  }

  _addListeners() {
    const {
      select,
      color,
      hover,
      load
    } = this._store;
    this._handleSelectionChanged = Object(global_helpers["J" /* updateStoreStateSync */])(this._handleSelectionChanged, select);
    this._handleColorChanged = Object(global_helpers["J" /* updateStoreStateSync */])(this._handleColorChanged, color);
    Object(mobx_module["h" /* reaction */])(() => load.isLoaded, this._handleLoaded);
    Object(mobx_module["h" /* reaction */])(() => hover.hoveredObject, this._handleHoverChanged);
    Object(mobx_module["h" /* reaction */])(() => select.isPending, isPending => {
      if (!isPending) {
        return;
      }

      this._handleSelectionChanged();
    });
    Object(mobx_module["h" /* reaction */])(() => color.isPending, isPending => {
      if (!isPending) {
        return;
      }

      this._handleColorChanged();
    });
  }

  _prepareSelected() {
    for (const renderable of this._selected) {
      // TODO Refactor color & select
      // Renderables in `this._selected` could be already deleted
      if (!this._structure.has(this._structure.getElementId(renderable))) {
        continue;
      }

      highlightRenderable(renderable, blackColor);
    }

    this._selected = new Set(this._structure.getGroup('select'));
  }

  _prepareColored() {
    for (const renderable of this._colored) {
      // TODO Refactor color & select
      // Renderables in `this._selected` could be already deleted
      if (!this._structure.has(this._structure.getElementId(renderable))) {
        continue;
      }

      highlightRenderable(renderable, blackColor);
    }

    this._structure.clearGroup('color');

    this._colorByNode.clear();

    const {
      coloredObjects
    } = this._store.color;

    if (Array.isArray(coloredObjects)) {
      for (const {
        color,
        ids
      } of coloredObjects) {
        this._add(color, ids);
      }
    }

    this._colored = new Set(this._structure.getGroup('color'));
  }

  _add(hexColor, ids) {
    const color = convertHexStringToColor(hexColor);
    const errorIDs = [];

    for (const id of ids) {
      if (!this._structure.has(id)) {
        errorIDs.push(id);
        continue;
      }

      const elements = this._structure.get(id);

      this._structure.addToGroup('color', elements);

      for (const element of elements) {
        this._colorByNode.set(element, color);
      }
    }

    if (errorIDs.length) {
      console.error(`Not found objects (${errorIDs.length}): "${errorIDs}"`);
    }
  }

}
// CONCATENATED MODULE: ./src/features/filter/index.ts
function features_filter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const $filter = Symbol('filter');
class filter_Filter {
  constructor(options) {
    features_filter_defineProperty(this, "_structure", void 0);

    features_filter_defineProperty(this, "_layers", void 0);

    features_filter_defineProperty(this, "_store", void 0);

    features_filter_defineProperty(this, "_ghostMaterial", void 0);

    features_filter_defineProperty(this, "_originalMaterialsMap", void 0);

    features_filter_defineProperty(this, "_handleFilterChange", async () => {
      this.filterObjects();
      await Promise.all([this._layers.renderLayer($filter, this._layers.layer3dMain, {
        culling: true,
        sort: true
      }), this._layers.renderLayer($filter, this._layers.layer3dColored, {
        culling: true
      })]);
    });

    const {
      layers,
      store,
      structure
    } = options;
    this._structure = structure;
    this._layers = layers;
    this._store = store;
    this._ghostMaterial = new resources_materials["c" /* IndustrialUnlitMeshMaterial */]({
      opacity: store.filter.ghostMode.opacity,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(parseInt(store.filter.ghostMode.color, 16))
    }); // No need to use selection/coloring for ghost objects

    this._ghostMaterial.setSelectionEnabled(false);

    this._ghostMaterial.depthWrite = false;
    this._originalMaterialsMap = new Map();

    this._addListeners();
  }

  _addListeners() {
    const filterStore = this._store.filter;
    this._handleFilterChange = Object(global_helpers["I" /* updateStoreState */])(this._handleFilterChange, filterStore);
    Object(mobx_module["h" /* reaction */])(() => filterStore.isPending, isPending => {
      if (!isPending) {
        return;
      }

      this._handleFilterChange();
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.load.isLoading, isLoading => {
      if (!isLoading) {
        return;
      }

      this._originalMaterialsMap.forEach(material => material.release());

      this._originalMaterialsMap.clear();
    });
    Object(mobx_module["h" /* reaction */])(() => filterStore.ghostMode.enabled, async enabled => {
      this._changeVisibilityMode(enabled);

      await Promise.all([this._layers.renderLayer($filter, this._layers.layer3dMain, {
        culling: true,
        sort: true
      }), this._layers.renderLayer($filter, this._layers.layer3dColored, {
        culling: true
      })]);
    });
    Object(mobx_module["h" /* reaction */])(() => filterStore.ghostMode.color, async color => {
      const colorInt = parseInt(color, 16);

      this._ghostMaterial.color.fromPackedInteger(colorInt);

      await Promise.all([this._layers.renderLayer($filter, this._layers.layer3dMain), this._layers.renderLayer($filter, this._layers.layer3dColored, {
        culling: true
      })]);
    });
    Object(mobx_module["h" /* reaction */])(() => filterStore.ghostMode.opacity, async opacity => {
      this._ghostMaterial.opacity = opacity;
      await Promise.all([this._layers.renderLayer($filter, this._layers.layer3dMain), this._layers.renderLayer($filter, this._layers.layer3dColored, {
        culling: true
      })]);
    });
  }

  _changeVisibilityMode(isGhostEnabled) {
    const filterGroup = this._structure.getGroup('filter');

    if (!filterGroup) {
      return;
    }

    for (const renderable of filterGroup) {
      this._updateVisibility(renderable, false, isGhostEnabled);
    }
  }

  _updateVisibility(renderable, isVisible, isGhostEnabled) {
    if (renderable.unloaded) {
      return;
    }

    const scene = renderable.getScene(); // Don't show ghost edges (but mb it's ok, looks well)

    if (this._structure.hasGroup('edges') && this._structure.hasInGroup('edges', renderable)) {
      scene.setInstanceVisibility(renderable, isVisible);
      return;
    }

    if (!this._originalMaterialsMap.has(renderable)) {
      this._originalMaterialsMap.set(renderable, renderable.material);

      renderable.material.retain();
    }

    const prevMaterial = renderable.material;
    const newMaterial = !isVisible && isGhostEnabled ? this._ghostMaterial : this._originalMaterialsMap.get(renderable);

    if (prevMaterial !== newMaterial) {
      this._structure.changeRenderableMaterial(renderable, newMaterial);
    }

    scene.setInstanceVisibility(renderable, isVisible || isGhostEnabled);
    scene.setInstancedAttribute(renderable, global_helpers["s" /* ignoreAttribute */], !isVisible ? 1 : 0);
  }

  _setVisibility(renderable, value) {
    if (!value) {
      this._structure.addToGroup('filter', renderable);
    } else {
      this._structure.removeFromGroup('filter', renderable);
    }

    this._updateVisibility(renderable, value, this._store.filter.ghostMode.enabled);
  }

  filterObjects() {
    const {
      filteredObjects,
      blacklist,
      iterative
    } = this._store.filter;

    let hiddenObjects = this._structure.getGroup('filter');

    if (!hiddenObjects) {
      hiddenObjects = this._structure.addGroup('filter');
    }

    let needsToBeVisible;
    let isVisible;
    let inList;

    const pointsGroup = this._structure.getGroup('points');

    for (const renderable of this._structure.getAllElements()) {
      // Skip points
      if (pointsGroup !== null && pointsGroup.has(renderable)) {
        continue;
      }

      inList = filteredObjects.has(this._structure.getElementId(renderable));

      if (iterative && !inList) {
        continue;
      }

      isVisible = !hiddenObjects.has(renderable);
      needsToBeVisible = inList && !blacklist || !inList && blacklist;

      if (isVisible === needsToBeVisible) {
        continue;
      }

      this._setVisibility(renderable, needsToBeVisible);
    }
  }

}
// EXTERNAL MODULE: ./src/features/points/material/point.vert
var material_point = __webpack_require__(240);
var point_default = /*#__PURE__*/__webpack_require__.n(material_point);

// EXTERNAL MODULE: ./src/features/points/material/point.frag
var points_material_point = __webpack_require__(241);
var material_point_default = /*#__PURE__*/__webpack_require__.n(points_material_point);

// CONCATENATED MODULE: ./src/features/points/material/index.ts
function material_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







const {
  ORTHOGRAPHIC
} = lib["f" /* Camera */].ProjectionTypes;
const {
  globalMaterialState
} = resources_materials["a" /* IndustrialMaterialFactory */];
class material_PointMaterial extends lib["db" /* SpriteMaterial */] {
  constructor(options) {
    super(options);

    material_defineProperty(this, "_canvas", void 0);

    material_defineProperty(this, "_viewportSize", void 0);

    material_defineProperty(this, "_pointSize", void 0);

    material_defineProperty(this, "_relation", void 0);

    material_defineProperty(this, "_origin", void 0);

    material_defineProperty(this, "_colorBlendingMethod", void 0);

    material_defineProperty(this, "boxOccluderMin", void 0);

    material_defineProperty(this, "boxOccluderMax", void 0);

    const {
      canvas,
      staticSize = false,
      pointSize = 1,
      origin = new math_lib["m" /* Vector2 */](0.5, 0.5),
      colorBlendingMethod = 'add'
    } = options;
    this._canvas = canvas;
    this._viewportSize = new math_lib["m" /* Vector2 */](0, 0);
    this._pointSize = pointSize;
    this.boxOccluderMin = new math_lib["n" /* Vector3 */]();
    this.boxOccluderMax = new math_lib["n" /* Vector3 */]();
    this.colorBlendingMethod = colorBlendingMethod;
    this._shaders.name = 'INDUSTRIAL_POINT_SHADER';
    this._shaders.vertexShader = point_default.a;
    this._shaders.fragmentShader = material_point_default.a;
    const {
      width,
      height
    } = this.colorMap;
    this._relation = width / height;

    if (staticSize) {
      this._shaders.defines.STATIC_SIZE = '';
    }

    if (origin instanceof math_lib["n" /* Vector3 */]) {
      this._shaders.defines.ORIGIN_3D = '';
      this._origin = new math_lib["n" /* Vector3 */]().copy(origin);
    } else {
      this._origin = new math_lib["m" /* Vector2 */]().copy(origin);
    }

    this.depthTest = false;
  }

  get colorBlendingMethod() {
    return this._colorBlendingMethod;
  }

  set colorBlendingMethod(value) {
    this._colorBlendingMethod = value;
    delete this._shaders.defines.BLENDING_METHOD_ADD;
    delete this._shaders.defines.BLENDING_METHOD_MULTIPLY;
    const defineName = `BLENDING_METHOD_${value.toUpperCase()}`;
    this._shaders.defines[defineName] = '';
    this.needsUpdate = true;
  }

  get patched() {
    return true;
  }

  get originIs3D() {
    return this._shaders.defines.ORIGIN_3D !== undefined;
  }

  set pointSize(size) {
    this._pointSize = size;
  }

  set origin(origin) {
    if (this.originIs3D && origin instanceof math_lib["m" /* Vector2 */]) {
      throw new Error('Origin must be Vector3');
    }

    if (!this.originIs3D && origin instanceof math_lib["n" /* Vector3 */]) {
      throw new Error('Origin must be Vector2');
    }

    this._origin = origin;
  }

  setColorMap(colorMap) {
    this.colorMap = colorMap;
    const {
      width,
      height
    } = colorMap;
    this._relation = width / height;
  }

  apply(gl, renderable, state, programs, textures, renderPass) {
    const {
      capabilities
    } = programs;
    const {
      webgl2Support
    } = capabilities;
    const {
      id: renderPassId
    } = renderPass;

    const technique = this._updateTechnique(renderPassId);

    this._update(renderable, renderPass, technique, webgl2Support);

    this._applyDefault(gl, state, programs, renderPass, technique);

    const {
      colorMap,
      opacity,
      color
    } = this;
    const {
      program,
      _output: output
    } = technique;

    if (!program) {
      throw new Error('Program is null');
    }

    const {
      layout
    } = program;
    const {
      uniforms,
      samplerUniformNames
    } = layout;
    globalMaterialState.onApplyMaterial(state); // default sprite uniforms

    {
      const {
        viewMatrix,
        projectionMatrix
      } = renderPass.look;
      Object(global_helpers["F" /* setUniform */])(uniforms, 'viewMatrix', viewMatrix);
      Object(global_helpers["F" /* setUniform */])(uniforms, 'projectionMatrix', projectionMatrix);
    }

    if (colorMap instanceof lib["D" /* Material */].TextureProperties) {
      Object(global_helpers["F" /* setUniform */])(uniforms, 'colorMapTransform', colorMap.transform);

      if (colorMap instanceof lib["D" /* Material */].TextureArrayProperties) {
        Object(global_helpers["F" /* setUniform */])(uniforms, '_colorMapIndex', colorMap.index);
      }

      {
        const {
          texture
        } = colorMap;
        const uniformName = samplerUniformNames.get('_colorMap');
        const uniform = uniforms.get(uniformName);
        console.assert(uniform !== undefined, 'uniform is undefined');

        this._setTexture(gl, uniform, texture, textures);
      }
    }

    if ((output & lib["S" /* RenderRequest */].OutputLayoutSemantic.DEFAULT) !== 0) {
      Object(global_helpers["F" /* setUniform */])(uniforms, 'color', color);
      Object(global_helpers["F" /* setUniform */])(uniforms, 'opacity', opacity);
    } // point uniforms


    Object(global_helpers["F" /* setUniform */])(uniforms, 'pointSize', this._pointSize);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'relation', this._relation);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'origin', this._origin);

    if (this._shaders.defines.STATIC_SIZE !== undefined) {
      const {
        projectionType
      } = renderPass.look;
      const {
        offsetWidth,
        offsetHeight
      } = this._canvas;

      this._viewportSize.set(offsetWidth, offsetHeight);

      Object(global_helpers["F" /* setUniform */])(uniforms, 'viewportSize', this._viewportSize);
      Object(global_helpers["F" /* setUniform */])(uniforms, 'isOrthoProjection', projectionType === ORTHOGRAPHIC);
    }

    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMin', this.boxOccluderMin);
    Object(global_helpers["F" /* setUniform */])(uniforms, 'boxOccluderMax', this.boxOccluderMax); // necessary for working

    this._bindTextures(gl);
  }

}
// CONCATENATED MODULE: ./src/features/points/utils.ts
function points_utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class utils_IndustrialSpriteRenderable extends core_resources["b" /* IndustrialRenderable */] {
  constructor(material) {
    // @ts-expect-error null geometry for sprite
    super(null, material);

    points_utils_defineProperty(this, "_needsUpdate", void 0);

    points_utils_defineProperty(this, "isSprite", true);

    this.renderQueueGroup = lib["R" /* RenderQueueGroup */].SPRITES;
    this._needsUpdate = true;
  }

  get needsUpdate() {
    return this._needsUpdate;
  }

  set needsUpdate(value) {
    this._needsUpdate = value;
  }

}
class utils_IndustrialSprite extends lib["cb" /* Sprite */] {
  constructor(options) {
    super(options);

    points_utils_defineProperty(this, "_spriteRenderable", void 0);

    this._spriteRenderable = new utils_IndustrialSpriteRenderable(options.material);
  } // @ts-expect-error _needsUpdate differs


  get renderable() {
    return this._spriteRenderable;
  }

}
// CONCATENATED MODULE: ./src/features/points/point.ts
function point_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const $point = Symbol('point');
class point_Point {
  constructor(parent, options) {
    point_defineProperty(this, "id", void 0);

    point_defineProperty(this, "_parent", void 0);

    point_defineProperty(this, "_image", void 0);

    point_defineProperty(this, "_material", void 0);

    point_defineProperty(this, "_sprite", void 0);

    point_defineProperty(this, "_renderable", void 0);

    point_defineProperty(this, "_origin", void 0);

    point_defineProperty(this, "_originIs3D", void 0);

    point_defineProperty(this, "_position", void 0);

    point_defineProperty(this, "_interactive", void 0);

    point_defineProperty(this, "_size", void 0);

    point_defineProperty(this, "_staticSize", void 0);

    point_defineProperty(this, "_promise", void 0);

    point_defineProperty(this, "_worldMatrix", void 0);

    point_defineProperty(this, "_isCreated", void 0);

    const {
      id
    } = options;
    this.id = id;
    this._parent = parent;
    this._image = null;
    this._sprite = null;
    this._renderable = null;
    this._origin = new math_lib["m" /* Vector2 */]();
    this._originIs3D = false;
    this._position = new math_lib["n" /* Vector3 */]();
    this._size = 1;
    this._staticSize = false;
    this._interactive = false;
    this._worldMatrix = new math_lib["b" /* AffineMatrix3 */]();
    this._isCreated = false;
    this._promise = this.setOptions(options);
  }

  get origin() {
    return this._origin;
  }

  get size() {
    return this._size;
  }

  get interactive() {
    return this._interactive;
  }

  get position() {
    return this._position;
  }

  get isReady() {
    return this._promise;
  }

  get renderable() {
    return this._renderable;
  }

  get material() {
    return this._material;
  }

  async setOptions(options) {
    const {
      position,
      image = 'default_point',
      colorBlendingMethod = 'multiply',
      interactive = true,
      size = 1,
      staticSize = false,
      origin = {
        x: 0.5,
        y: 0.5
      },
      overlap = false
    } = options;
    const color = options.color !== undefined ? new math_lib["k" /* RGBColor */]().fromPackedInteger(parseInt(options.color, 16)) : new math_lib["k" /* RGBColor */](1, 1, 1);
    const originIs3D = ('z' in origin);

    if (!this._isCreated || this._staticSize !== staticSize || this._originIs3D !== originIs3D) {
      await this._createSprite({
        image,
        origin,
        staticSize,
        size,
        color,
        colorBlendingMethod,
        overlap
      });
    } else {
      await this._updateSprite({
        image,
        origin,
        size,
        color,
        colorBlendingMethod,
        overlap
      });
    }

    this._image = image;
    this._size = size;
    this._staticSize = staticSize;
    this._origin = origin;
    this._interactive = interactive;
    this._originIs3D = originIs3D;
    const renderable = this._renderable;
    const {
      scene,
      layers,
      store
    } = this._parent;
    this.updateSectionBox(store.sectionBox.restrictions);

    this._worldMatrix.translationCopy(new math_lib["n" /* Vector3 */](position.x, position.y, position.z));

    scene.setWorldMatrix(renderable, this._worldMatrix);
    Object(global_helpers["t" /* ignoreRaycast */])(scene, renderable, !interactive);
    Object(global_helpers["H" /* updateInstanceCenter */])(scene.instanceDataManager, renderable);
    layers.renderLayer($point, layers.layer3dPoints);
  }

  updateSectionBox(restrictions) {
    this._material.boxOccluderMin = restrictions.min || new math_lib["n" /* Vector3 */]();
    this._material.boxOccluderMax = restrictions.max || new math_lib["n" /* Vector3 */]();
  }

  async _updateSprite(options) {
    const {
      image,
      size,
      origin,
      color,
      colorBlendingMethod,
      overlap
    } = options;

    if (image !== this._image) {
      const colorMap = await this._parent.getTexture(image);

      this._material.setColorMap(colorMap);
    }

    this._material.pointSize = size;
    this._material.origin = this._prepareOrigin(origin);
    this._material.color = color;
    this._material.colorBlendingMethod = colorBlendingMethod;
    this._material.depthTest = !overlap;
  }

  async _createSprite(options) {
    const {
      image,
      size,
      origin,
      staticSize,
      color,
      colorBlendingMethod,
      overlap
    } = options;
    const colorMap = await this._parent.getTexture(image);
    const material = new material_PointMaterial({
      name: 'point_material_' + this.id,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      canvas: this._parent.canvas,
      origin: this._prepareOrigin(origin),
      pointSize: size,
      staticSize,
      colorMap,
      color,
      colorBlendingMethod
    });
    material.depthTest = !overlap;
    const {
      scene,
      structure,
      renderer
    } = this._parent;
    const oldSprite = this._sprite;
    const sprite = new utils_IndustrialSprite({
      material
    });
    const {
      renderable
    } = sprite;
    renderable.geometry = renderer.screenSquare;
    scene.addInstance(renderable, this._worldMatrix);

    if (oldSprite) {
      structure.removeElementsById(this.id);
      scene.deleteInstance(oldSprite.renderable);
    }

    structure.addElement(this.id, renderable);
    structure.addToGroup('points', renderable);
    this._sprite = sprite;
    this._material = material;
    this._renderable = renderable;
    this._isCreated = true;
  }

  _prepareOrigin(origin) {
    if ('z' in origin) {
      const {
        x,
        y,
        z
      } = origin;
      return new math_lib["n" /* Vector3 */](x, y, z);
    }

    const {
      x,
      y
    } = origin;
    return new math_lib["m" /* Vector2 */](x, y);
  }

}
// CONCATENATED MODULE: ./src/features/points/index.ts
function points_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const $pointsTag = Symbol('point');
class points_Points {
  constructor(options) {
    points_defineProperty(this, "_points", void 0);

    points_defineProperty(this, "_pointIds", void 0);

    points_defineProperty(this, "_core", void 0);

    points_defineProperty(this, "scene", void 0);

    points_defineProperty(this, "store", void 0);

    points_defineProperty(this, "structure", void 0);

    points_defineProperty(this, "renderer", void 0);

    points_defineProperty(this, "layers", void 0);

    points_defineProperty(this, "controls", void 0);

    points_defineProperty(this, "canvas", void 0);

    const {
      core,
      layers,
      canvas3dElement,
      controls,
      store,
      structure,
      renderer,
      scene
    } = options;
    this.layers = layers;
    this.canvas = canvas3dElement;
    this.controls = controls;
    this.renderer = renderer;
    this.structure = structure;
    this.scene = scene;
    this.store = store;
    this._core = core;
    this._points = new Map();
    this._pointIds = new Set();
    this.structure.addGroup('points');

    this._addListeners();
  }

  _addListeners() {
    const {
      load,
      sectionBox
    } = this.store;
    Object(mobx_module["h" /* reaction */])(() => load.isLoaded, isLoaded => {
      if (isLoaded) {
        return;
      }

      this._pointIds.clear();

      this._removeExcessedPoints();

      this.layers.renderLayer($pointsTag, this.layers.layer3dPoints, {
        culling: true
      });
    });
    Object(mobx_module["h" /* reaction */])(() => sectionBox.restrictions, () => {
      this.layers.renderLayer($pointsTag, this.layers.layer3dPoints);
    });
  }

  get ids() {
    return [...this._pointIds];
  }

  _removeExcessedPoints() {
    if (!this._points.size) {
      return;
    }

    this._points.forEach(({
      id
    }) => {
      if (this._pointIds.has(id)) {
        return;
      }

      if (this.structure.has(id)) {
        this.structure.removeElementsById(id);
      }

      this._points.delete(id);
    });
  }

  async setPoints(pointsData) {
    this._pointIds.clear();

    const addingPoints = [];

    if (Array.isArray(pointsData)) {
      for (const pointData of pointsData) {
        const {
          id = this._getId()
        } = pointData;

        if (this._pointIds.has(id)) {
          throw new Error(`Point with id "${id}" is already exist`);
        }

        this._pointIds.add(id);

        addingPoints.push(this._addPoint({ ...pointData,
          id
        }));
      }
    }

    this._removeExcessedPoints();

    await Promise.all(addingPoints);
    await this.layers.renderLayer($pointsTag, this.layers.layer3dPoints, {
      culling: true
    });
  }

  _getId() {
    return 0xffffff - (this._pointIds.size + 1); // 0xffffff is reserved for miss click
  }

  _isPointElement(id) {
    if (!this.structure.has(id)) {
      return false;
    }

    const pointsGroup = this.structure.getGroup('points');

    if (!pointsGroup) {
      return false;
    }

    const elements = [...this.structure.get(id)];
    return elements.length === 1 && pointsGroup.has(elements[0]);
  }

  async _addPoint(options) {
    const {
      id
    } = options;
    const position = this.store.axes.getInternalPosition(options.position);
    const pointOptions = { ...options,
      position,
      id
    };

    const isPointElement = this._isPointElement(id);

    if (this.structure.has(id) && !isPointElement) {
      throw new Error(`Element with id "${id}" already exists`);
    }

    if (!this._points.has(id)) {
      const point = new point_Point(this, pointOptions);
      await point.isReady;

      this._points.set(id, point);
    } else {
      const point = this._points.get(id);

      await point.setOptions(pointOptions);
    }

    return id;
  }

  async getTexture(src, name) {
    const textureName = name || src;

    try {
      return this._core.getResource('texture', textureName);
    } catch (e) {
      return this._core.loadResource('texture', textureName, src);
    }
  }

}
// CONCATENATED MODULE: ./src/features/logger/utils.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
function getGlInfo(gl) {
  const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
  return {
    glVersion: gl.getParameter(gl.VERSION),
    glVendor: gl.getParameter(gl.VENDOR),
    glRenderer: gl.getParameter(gl.RENDERER),
    glDebugVendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown',
    glDebugRenderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown',
    glExtensions: gl.getSupportedExtensions() || []
  };
}

function serializeReplacer(key, value) {
  if (typeof value === 'function') {
    return '[Function]';
  }

  return value;
}

function serialize(data) {
  return String(JSON.stringify(data, serializeReplacer));
}
function isPromise(data) {
  return data !== null && typeof data === 'object' && typeof data.then === 'function';
}
function pad(value, digits) {
  return '0'.repeat(Math.max(digits - String(value).length, 0)) + value;
}
// CONCATENATED MODULE: ./src/features/logger/index.ts
function logger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types */




const packageInfo = package_0;
const MAX_MESSAGE_LENGTH = 1024;
const MAX_LOGS = 128;
/* More ideas:
- log events
- log store actions
- log store state
*/

class logger_Logger {
  constructor({
    renderer,
    store
  }) {
    logger_defineProperty(this, "_store", void 0);

    logger_defineProperty(this, "_renderer", void 0);

    logger_defineProperty(this, "_logs", void 0);

    logger_defineProperty(this, "_globalMethodId", 0);

    logger_defineProperty(this, "_logsEnabled", void 0);

    logger_defineProperty(this, "onLogMethod", new global_helpers["b" /* Event */]());

    this._renderer = renderer;
    this._store = store;
    this._logs = [];
    this._logsEnabled = this._store.debug.logsEnabled;

    this._addListeners();
  }

  _addListeners() {
    window.addEventListener('error', event => {
      this._log('unknown', event.message);
    });
    window.addEventListener('unhandledrejection', event => {
      this._log('unknown', event.reason.message);
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.debug.logsEnabled, logsEnabled => {
      this._logsEnabled = logsEnabled;

      if (!logsEnabled) {
        this._logs.length = 0;
      }
    });
  }

  getInfo() {
    const renderer = this._renderer;
    const glInfo = getGlInfo(renderer.context);
    return {
      version: `${packageInfo.version} ${ false ? undefined : ''}`,
      modelUrl: this._store.load.url,
      platform: window.navigator.platform,
      userAgent: window.navigator.userAgent,
      resolution: `${this._renderer.width}x${this._renderer.height}`,
      canvasSize: `${renderer.canvas.clientWidth}x${renderer.canvas.clientHeight}`,
      devicePixelRatio: window.devicePixelRatio,
      ...glInfo,
      logs: this._logsEnabled ? [...this._logs] : []
    };
  }

  getLogs() {
    return this._logs;
  }

  decoratePublicMethodCalls(namespace, sourceObject) {
    const proto = Object.getPrototypeOf(sourceObject);
    const logger = this; // eslint-disable-line @typescript-eslint/no-this-alias

    for (const methodName of Object.getOwnPropertyNames(proto)) {
      if (methodName.startsWith('_') || methodName === 'constructor') {
        continue;
      }

      const originalMethod = proto[methodName];

      proto[methodName] = function (...args) {
        if (!logger._logsEnabled) {
          return originalMethod.apply(this, args);
        }

        const methodId = logger._globalMethodId;
        logger._globalMethodId++;

        logger._logMethodCall('request', methodId, namespace, methodName, serialize(args));

        let result;

        try {
          result = originalMethod.apply(this, args);
        } catch (error) {
          logger._logMethodCall('failure', methodId, namespace, methodName, serialize(error.message));

          throw error;
        }

        if (Object(global_helpers["z" /* isPromise */])(result)) {
          // @ts-ignore implicitly has an 'any' type
          return result.then(output => {
            logger._logMethodCall('results', methodId, namespace, methodName, serialize(output));

            return output; // @ts-ignore implicitly has an 'any' type
          }, error => {
            logger._logMethodCall('failure', methodId, namespace, methodName, serialize(error.message));

            throw error;
          });
        }

        logger._logMethodCall('results', methodId, namespace, methodName, serialize(result));

        return result;
      };
    }
  }

  _logMethodCall(type, tag, namespace, methodName, data) {
    const limitedData = data.substring(0, MAX_MESSAGE_LENGTH);
    const message = `[${pad(tag, 3)}] ${namespace}.${methodName} ${limitedData}`;
    this.onLogMethod.emit(type, tag, `${namespace}.${methodName}`, limitedData);

    this._log(type, message);
  }

  _log(type, message) {
    const logMessage = `${Date.now()} ${type} ${message}`;

    this._logs.unshift(logMessage);

    this._logs.length = Math.min(this._logs.length, MAX_LOGS); // console.log('LOG', logMessage);
  }

}
// CONCATENATED MODULE: ./src/features/measure/index.ts
function features_measure_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const isEqualVectors3 = (v1, v2) => v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;

class measure_Measure {
  constructor({
    container,
    layers,
    store,
    input,
    apiEvents
  }) {
    features_measure_defineProperty(this, "_layer3d", void 0);

    features_measure_defineProperty(this, "_input", void 0);

    features_measure_defineProperty(this, "_measureModule", void 0);

    features_measure_defineProperty(this, "_store", void 0);

    features_measure_defineProperty(this, "_apiEventEmitter", void 0);

    this._layer3d = layers.layer3dMain;
    this._input = input;
    this._store = store;
    this._apiEventEmitter = apiEvents;
    const measureModule = new measures_src["default"]({
      container,
      throttle: 0
    });
    this._measureModule = measureModule;

    this._addListeners();
  }

  _addListeners() {
    const worldPosition = new math_lib["n" /* Vector3 */]();
    const measureModule = this._measureModule;
    const measureStore = this._store.measure;
    const clickStore = this._store.click;

    const updateSampleView = sample => {
      sample.outOfView = sample.points.some(point => Object(global_helpers["v" /* isBehindCamera */])(point, this._layer3d.look));
    };

    measureModule.transpileToScreenCoordinates = position => {
      const {
        renderer,
        look
      } = this._layer3d;
      worldPosition.copy(position);
      return Object(global_helpers["o" /* getScreenPositionFrom3d */])(worldPosition, renderer, look);
    };

    measureModule.raycastScreenCoordinates = screenCoordinates => {
      const ndc = Object(global_helpers["n" /* getPositionNdcFrom2d */])(screenCoordinates, this._layer3d.renderer);

      const hits = this._layer3d.raycastLayer(ndc);

      if (!hits.length) {
        return null;
      }

      return {
        position: hits[0].position
      };
    };

    this._layer3d.onDrawEnd.subscribe(() => {
      measureModule.updateScreenPosition();
      measureStore.samples.forEach(updateSampleView);
    });

    Object(mobx_module["h" /* reaction */])(() => clickStore.clicking, ({
      position
    }) => {
      if (!position) {
        return;
      }

      const {
        coordinateSystemMatrixInverted
      } = this._store.axes;
      const point = position.clone().multiplyLinearMatrix(coordinateSystemMatrixInverted);
      measureModule.addPoint(point);
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.mode, mode => {
      measureModule.setMode(mode);

      this._apiEventEmitter.fireEvent('measure.state', {
        type: 'measure.state',
        emitter: 'external',
        // TODO: https://youtrack.webgears3d.com/issue/IV-302 will change it
        mode
      });
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.sampleDescriptions, sampleDescriptions => {
      const {
        samples
      } = measureStore;
      const allSampleIds = new Set([...sampleDescriptions.keys(), ...samples.keys()]);
      const samplesForCreate = new Set();
      const samplesForDelete = new Set();
      const samplesForUpdate = new Set();

      for (const id of allSampleIds) {
        const description = sampleDescriptions.get(id);
        const sample = samples.get(id);

        if (!sample && description) {
          samplesForCreate.add(description);
          continue;
        }

        if (sample && !description) {
          samplesForDelete.add(sample);
          continue;
        }

        if (sample && description) {
          if (sample.type !== description.type) {
            samplesForDelete.add(sample);
            samplesForCreate.add(description);
            continue;
          }

          samplesForUpdate.add({
            sample,
            description
          });
        }
      } // delete old samples


      for (const sample of samplesForDelete) {
        measureModule.deleteSample(sample.id);
      } // create new samples


      for (const description of samplesForCreate) {
        const {
          type,
          points
        } = description;
        let sample;

        if (type === 'distance') {
          const [p1, p2] = points;
          sample = measureModule.addDistance({ ...description,
            points: [p1, p2]
          });
        } else if (type === 'angle') {
          const [p1, p2, p3] = points;
          sample = measureModule.addAngle({ ...description,
            points: [p1, p2, p3]
          });
        }

        if (!sample) {
          throw new Error(`Unknown sample type "${type}"`);
        }
      } // update samples


      for (const {
        sample,
        description
      } of samplesForUpdate) {
        const {
          points,
          color = measures_src["Sample"].DEFAULT_COLOR,
          visible = true,
          dynamic = true
        } = description;

        if (sample.visible !== visible) {
          sample.visible = visible;
        }

        if (sample.color !== color) {
          sample.color = color;
        }

        if (sample.dynamic !== dynamic) {
          sample.dynamic = dynamic;
        }

        points.forEach((point, index) => {
          const samplePoint = sample.points[index];

          if (!isEqualVectors3(point, samplePoint)) {
            measureModule.updatePointPosition(samplePoint, point);
          }
        });
      }
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.selected, selected => {
      measureModule.selectSamples([...selected]);
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.selectionMode, mode => {
      measureModule.setSelectionMode(mode);
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.defaultColor, color => {
      measureModule.setDefaultColor(color);
    });
    Object(mobx_module["h" /* reaction */])(() => measureStore.fontFamily, font => {
      measureModule.setFontFamily(font);
    });
    measureModule.on('sample.select', ({
      samples,
      emitter
    }) => {
      const selected = samples.map(sample => sample.id);
      measureStore.selectSamples(selected, true);

      this._apiEventEmitter.fireEvent('measure.select', {
        type: 'measure.select',
        emitter,
        ids: selected
      });
    });
    measureModule.on('sample.delete', ({
      sample,
      emitter
    }) => {
      measureStore.deleteSample(sample);

      this._apiEventEmitter.fireEvent('measure.delete', {
        type: 'measure.delete',
        emitter,
        id: sample.id
      });
    });
    measureModule.on('sample.add', async ({
      sample,
      emitter
    }) => {
      measureStore.addSample(sample);
      updateSampleView(sample);

      this._apiEventEmitter.fireEvent('measure.add', {
        type: 'measure.add',
        emitter,
        id: sample.id
      });
    });
    measureModule.on('sample.hover', async ({
      sample,
      emitter
    }) => {
      this._apiEventEmitter.fireEvent('measure.hover', {
        type: 'measure.hover',
        emitter,
        id: sample.id
      });
    });
    measureModule.on('sample.unhover', async ({
      emitter
    }) => {
      this._apiEventEmitter.fireEvent('measure.hover', {
        type: 'measure.hover',
        emitter,
        id: null
      });
    });
    measureModule.on('sample.update-value', ({
      sample
    }) => {// TODO: IV-989
      // this._apiEventEmitter.fireEvent('measure.update', {
      //     type: 'measure.update',
      //     id: [sample.id]
      // });
    });
    measureModule.on('sample.move', ({
      sample,
      pointIndex,
      position,
      emitter
    }) => {
      worldPosition.copy(position);
      worldPosition.multiplyLinearMatrix(this._store.axes.coordinateSystemMatrix);
      const {
        x,
        y,
        z
      } = worldPosition;

      this._apiEventEmitter.fireEvent('measure.move', {
        type: 'measure.move',
        emitter,
        id: sample.id,
        position: {
          x,
          y,
          z
        },
        pointIndex
      });
    });
    measureModule.on('sample.move-start', ({
      sample,
      pointIndex,
      emitter
    }) => {
      this._apiEventEmitter.fireEvent('measure.move-start', {
        type: 'measure.move-start',
        emitter,
        id: sample.id,
        pointIndex
      });
    });
    measureModule.on('sample.move-end', ({
      sample,
      pointIndex,
      emitter
    }) => {
      this._apiEventEmitter.fireEvent('measure.move-end', {
        type: 'measure.move-end',
        emitter,
        id: sample.id,
        pointIndex
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.load.isLoaded, isLoaded => {
      if (isLoaded) {
        return;
      }

      measureModule.clearAll();
      measureStore.clearSamples();
    });
  }

}
// CONCATENATED MODULE: ./src/features/explode.ts
function features_explode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const $explode = Symbol('explode');
const explode_position = new math_lib["n" /* Vector3 */]();
const explode_center = new math_lib["n" /* Vector3 */]();
class explode_Explode {
  constructor({
    store,
    structure,
    layers,
    apiEvents
  }) {
    features_explode_defineProperty(this, "_layers", void 0);

    features_explode_defineProperty(this, "_store", void 0);

    features_explode_defineProperty(this, "_structure", void 0);

    features_explode_defineProperty(this, "_apiEventEmitter", void 0);

    this._layers = layers;
    this._store = store;
    this._structure = structure;
    this._apiEventEmitter = apiEvents;

    this._addListeners();
  }

  _addListeners() {
    let prevConfig = this._store.explode.config;
    Object(mobx_module["h" /* reaction */])(() => this._store.explode.config, config => {
      const noNeedToUpdate = prevConfig.progress === 0 && config.progress === 0 || prevConfig.progress === config.progress && prevConfig.force === config.force && prevConfig.center === config.center;
      prevConfig = config;

      if (!noNeedToUpdate) {
        this._explode(config);
      }

      this._apiEventEmitter.fireEvent('explode.state', {
        type: 'explode.state',
        progress: config.progress,
        force: config.force
      });
    });
  }

  _updateRenderablePosition(renderable) {
    const {
      scene
    } = this._layers.layer3dMain;

    if (!scene) {
      return;
    }

    const {
      config
    } = this._store.explode;
    Object(global_helpers["k" /* getInstanceCenter */])(scene.instanceDataManager, renderable, explode_position);
    explode_position.subtract(explode_center).multiplyNumber(config.force * config.progress);
    scene.setInstancedAttribute(renderable, lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_1, explode_position);
  }

  _explode(config) {
    if (!this._store.load.isLoaded) {
      return;
    }

    const {
      scene
    } = this._layers.layer3dMain;

    if (!scene) {
      return;
    }

    if (config.center) {
      explode_center.copy(config.center);
    } else {
      const bbox = this._structure.getBBox();

      explode_center.copy(bbox.min).add(bbox.max).multiplyNumber(0.5);
    }

    const pointsGroup = this._structure.getGroup('points');

    for (const renderable of this._structure.getAllElements()) {
      // Ignore points (mb it's ok to explode points too?)
      if (pointsGroup && pointsGroup.has(renderable)) {
        continue;
      }

      if (renderable.instanceIdentifierExpired) {
        continue;
      }

      if (renderable.geometry.unloaded) {
        renderable.geometry.onLoad.subscribe(() => {
          this._updateRenderablePosition(renderable);

          this._layers.renderLayer($explode, this._layers.layer3dMain, {
            culling: true
          });

          this._layers.renderLayer($explode, this._layers.layer3dColored);
        });
        continue;
      }

      this._updateRenderablePosition(renderable);
    }

    this._layers.renderLayer($explode, this._layers.layer3dMain, {
      culling: true
    });

    this._layers.renderLayer($explode, this._layers.layer3dColored);
  }

}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wg/edge-creator/src/math.ts
function math_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class math_Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    math_defineProperty(this, "x", void 0);

    math_defineProperty(this, "y", void 0);

    math_defineProperty(this, "z", void 0);

    this.x = x;
    this.y = y;
    this.z = z;
  }

  get length() {
    const {
      x,
      y,
      z
    } = this;
    return Math.sqrt(x * x + y * y + z * z);
  }

  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  subtract(vec) {
    this.x -= vec.x;
    this.y -= vec.y;
    this.z -= vec.z;
    return this;
  }

  dot(vec) {
    const {
      x,
      y,
      z
    } = this;
    const {
      x: x1,
      y: y1,
      z: z1
    } = vec;
    return x * x1 + y * y1 + z * z1;
  }

  cross(vec) {
    const {
      x,
      y,
      z
    } = this;
    const {
      x: x2,
      y: y2,
      z: z2
    } = vec;
    this.x = y * z2 - z * y2;
    this.y = z * x2 - x * z2;
    this.z = x * y2 - y * x2;
    return this;
  }

  normalize() {
    const {
      length,
      x,
      y,
      z
    } = this;
    this.x = x / length;
    this.y = y / length;
    this.z = z / length;
    return this;
  }

}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wg/edge-creator/src/index.ts

const degToRad = Math.PI / 180;

const compareFaceNormals = (() => {
  const normal1 = new math_Vector3();
  const normal2 = new math_Vector3();
  return (facesNormals, faces, thresholdDot) => {
    normal1.set(...facesNormals[faces[0]]);
    normal2.set(...facesNormals[faces[1]]);
    return Math.abs(normal1.dot(normal2)) <= thresholdDot;
  };
})();

const setConjugateFace = (() => {
  const pref = '#';
  let v1;
  let v2;
  let idv1;
  let idv2;
  let edgeId;
  let edge;
  return (e1, e2, vertices, edges, faceIndex) => {
    v1 = e1 * 3;
    v2 = e2 * 3;
    idv1 = pref + vertices[v1] + vertices[v1 + 1] + vertices[v1 + 2];
    idv2 = pref + vertices[v2] + vertices[v2 + 1] + vertices[v2 + 2];
    edgeId = idv1 > idv2 ? idv1 + idv2 : idv2 + idv1;

    if (!edges.has(edgeId)) {
      edges.set(edgeId, {
        vertices: [e1, e2],
        faces: [faceIndex]
      });
    } else {
      edge = edges.get(edgeId);
      edge.faces.push(faceIndex);
    }
  };
})();

const getFacesNormals = (() => {
  const vec1 = new math_Vector3();
  const vec2 = new math_Vector3();
  const vec3 = new math_Vector3();
  let iv1;
  let iv2;
  let iv3;
  return (indices, vertices) => {
    const normals = [];

    for (let i = 0; i < indices.length; i += 3) {
      iv1 = indices[i] * 3;
      iv2 = indices[i + 1] * 3;
      iv3 = indices[i + 2] * 3;
      vec1.set(vertices[iv1], vertices[iv1 + 1], vertices[iv1 + 2]);
      vec2.set(vertices[iv3], vertices[iv3 + 1], vertices[iv3 + 2]);
      vec3.set(vertices[iv2], vertices[iv2 + 1], vertices[iv2 + 2]);
      vec2.subtract(vec1);
      vec3.subtract(vec1);
      vec2.cross(vec3).normalize();
      normals.push([vec2.x, vec2.y, vec2.z]);
    }

    return normals;
  };
})();

const getEdgeIndices = (() => {
  let facesNormals;
  let faceIndex;
  let edgeFaces;
  let edges;
  return (indices, vertices, thresholdDot) => {
    facesNormals = getFacesNormals(indices, vertices);
    edges = new Map();

    for (let i = 0; i < indices.length; i += 3) {
      faceIndex = i / 3;
      setConjugateFace(indices[i], indices[i + 1], vertices, edges, faceIndex);
      setConjugateFace(indices[i + 1], indices[i + 2], vertices, edges, faceIndex);
      setConjugateFace(indices[i + 2], indices[i], vertices, edges, faceIndex);
    }

    const view = [];
    let maxValue = 0;

    for (const [, edge] of edges) {
      edgeFaces = edge.faces;

      if (edgeFaces.length !== 2 || compareFaceNormals(facesNormals, edgeFaces, thresholdDot)) {
        view.push(...edge.vertices);
        maxValue = Math.max(maxValue, ...edge.vertices);
      }
    }

    return {
      view,
      maxValue
    };
  };
})();


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wg/edge-creator/browser/utils.ts



function getComponentType(maxNumber) {
  let type = lib["n" /* DataType */].UNSIGNED_BYTE;
  const MAX_BYTE = 2 ** 8;
  const MAX_SHORT = 2 ** 16;
  const MAX_UINT = 2 ** 32;

  if (maxNumber < MAX_BYTE) {
    type = lib["n" /* DataType */].UNSIGNED_BYTE;
  } else if (maxNumber < MAX_SHORT) {
    type = lib["n" /* DataType */].UNSIGNED_SHORT;
  } else if (maxNumber < MAX_UINT) {
    type = lib["n" /* DataType */].UNSIGNED_INT;
  }

  return type;
}

const skipAll = () => false;

function getWorldMatrix(submesh, instanceDataManager, matrix = new math_lib["b" /* AffineMatrix3 */]()) {
  const {
    instanceId,
    instanceIndex
  } = submesh;

  if (instanceId === null) {
    return matrix;
  }

  const {
    batchIdx
  } = instanceDataManager.getInstanceRenderable(instanceId);
  const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
  instanceDataManager.readWorldTransform(matrix, globalIndex);
  return matrix;
}

function setWorldMatrix(submesh, instanceDataManager, matrix) {
  const {
    instanceId,
    instanceIndex
  } = submesh;

  if (instanceId === null) {
    return;
  }

  const {
    batchIdx
  } = instanceDataManager.getInstanceRenderable(instanceId);
  const globalIndex = instanceDataManager.getInstanceGlobalIndex(batchIdx, instanceIndex);
  instanceDataManager.storeWorldTransform(matrix, globalIndex);
}

function addInstance(submesh, instanceDataManager, matrix) {
  instanceDataManager.addInstance(submesh);
  instanceDataManager.setInstanceVisibility(submesh, true, true);

  if (matrix) {
    setWorldMatrix(submesh, instanceDataManager, matrix);
  }
}

function deleteSubMesh(mesh, scene, condition = skipAll) {
  // @ts-ignore _instanceKeys private
  const {
    instanceDataManager,
    spatialIndex,
    _instanceKeys
  } = scene;
  const submeshes = [];

  for (const submesh of mesh.subMeshes()) {
    if (condition(submesh)) {
      const instanceKey = _instanceKeys.get(submesh);

      instanceDataManager.deleteInstance(submesh);

      _instanceKeys.delete(submesh);

      spatialIndex.remove(instanceKey);
      continue;
    }

    submeshes.push(submesh);
  } // @ts-ignore


  mesh._submeshes = submeshes;
  scene.forceUpdateRenderQueue = true;
}

function deleteSubMeshOld(mesh, meshData, instManager, condition = skipAll) {
  const newMesh = new lib["F" /* Mesh */]({
    name: mesh.name
  });

  for (const submesh of mesh.subMeshes()) {
    if (condition(submesh)) {
      continue;
    }

    const submeshClone = submesh.clone();
    newMesh.addSubMesh(submeshClone);
    setWorldMatrix(submeshClone, instManager, meshData.matrix);
  } // @ts-ignore


  const {
    node
  } = meshData;

  if (node) {
    node.detach(mesh);
    node.attach(newMesh);
  }

  return newMesh;
}

function traverseNode(node, callback) {
  if (!callback(node)) {
    return false;
  }

  for (const child of node.children) {
    if (!traverseNode(child, callback)) {
      continue;
    }
  }

  return true;
}


// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wg/edge-creator/browser/helpers.ts


let FilterDecision;

(function (FilterDecision) {
  FilterDecision[FilterDecision["APPROVE_NODE"] = 1] = "APPROVE_NODE";
  FilterDecision[FilterDecision["APPROVE_SUBTREE"] = 2] = "APPROVE_SUBTREE";
  FilterDecision[FilterDecision["SKIP_NODE"] = 4] = "SKIP_NODE";
  FilterDecision[FilterDecision["SKIP_SUBTREE"] = 8] = "SKIP_SUBTREE";
})(FilterDecision || (FilterDecision = {}));

const edgeSubmeshPrefix = 'wireframe_submesh_';
function createLineGeometry(positionAttribute, indices, elementStaging) {
  const indexElementsCount = indices.view.length;
  const indexComponentType = getComponentType(indices.maxValue);
  const IndexType = Object(lib["tb" /* getArrayTypeForDataType */])(indexComponentType);
  const indexBufferView = new lib["pb" /* VertexBufferView */](elementStaging, indexElementsCount * IndexType.BYTES_PER_ELEMENT);
  const indexView = new IndexType(indexBufferView.view.buffer, indexBufferView.view.byteOffset, indexElementsCount);
  indexView.set(indices.view, 0);
  const indicesAttribute = new lib["mb" /* VertexAttribute */]({
    componentType: indexComponentType,
    countComponents: 1,
    countElements: indexElementsCount,
    normalized: false,
    offset: 0,
    // we used `indexBufferView.view.byteOffset` in one of old engine versions
    semantic: lib["d" /* AttributeSemantic */].NONE,
    vertexData: indexBufferView,
    elementType: lib["nb" /* VertexAttributeType */].SCALAR,
    stride: Object(lib["ub" /* getDataTypeSize */])(indexComponentType) * 1,
    type: IndexType
  });
  const geometry = new lib["t" /* Geometry */]();
  geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
  geometry.indices = indicesAttribute;
  geometry.primitiveType = lib["O" /* PrimitiveType */].LINES;
  return geometry;
}
function deleteEdges(mesh, options) {
  const {
    meshesExtraData,
    material: edgeMaterial,
    scene
  } = options;
  const meshData = meshesExtraData.get(mesh);

  if (!meshData || !meshData.hasEdges) {
    return;
  }

  deleteSubMesh(mesh, scene, ({
    material
  }) => material === edgeMaterial);
  meshData.hasEdges = false;
}
function addEdges(mesh, geometry, options) {
  const {
    meshesExtraData,
    material,
    scene
  } = options;
  const {
    instanceDataManager
  } = scene;
  const meshData = meshesExtraData.get(mesh);

  if (!meshData) {
    return;
  }

  if (meshData.hasEdges) {
    deleteEdges(mesh, options);
  }

  const submesh = new lib["fb" /* SubMesh */]({
    name: edgeSubmeshPrefix + mesh.name,
    geometry,
    material
  });
  mesh.addSubMesh(submesh);

  if (meshData.unmovable) {
    addInstance(submesh, instanceDataManager, meshData.matrix);
  }
}

const prepareMeshesStores = (() => {
  const requestedComponents = [lib["F" /* Mesh */], lib["jb" /* Transform */]];
  let meshesByGeometry;
  let geometry;
  let submesh;
  let mesh;
  let transform;
  let meshes;
  let hasEdges;
  let meshData;
  return (node, options) => {
    [mesh, transform] = node.getComponents(requestedComponents);

    if (!mesh) {
      return true;
    }

    meshesByGeometry = options.meshesByGeometry;
    meshData = {
      hasEdges: false,
      matrix: getWorldMatrix(mesh.getSubMesh(0), options.instanceDataManager),
      unmovable: !transform
    };
    options.meshesExtraData.set(mesh, meshData);

    for (submesh of mesh.subMeshes()) {
      hasEdges = submesh.material === options.material;

      if (hasEdges) {
        meshData.hasEdges = true;
        continue;
      }

      geometry = submesh.geometry;
      meshes = meshesByGeometry.get(geometry);

      if (!meshes) {
        meshes = [];
        meshesByGeometry.set(geometry, meshes);
      }

      meshes.push(mesh);
    }
  };
})();

const helpers_approveAll = () => FilterDecision.APPROVE_NODE | FilterDecision.APPROVE_SUBTREE;

function getMeshesStores(targetNode, material, filter = helpers_approveAll) {
  const {
    SKIP_NODE,
    SKIP_SUBTREE,
    APPROVE_NODE,
    APPROVE_SUBTREE
  } = FilterDecision;
  const allowableDecision = SKIP_NODE | SKIP_SUBTREE | APPROVE_NODE | APPROVE_SUBTREE;
  const {
    instanceDataManager
  } = targetNode.scene;
  const meshesByGeometry = new Map();
  const meshesExtraData = new Map();
  const meshesStoresOptions = {
    material,
    meshesByGeometry,
    meshesExtraData,
    instanceDataManager
  };

  const approveSubtree = node => {
    traverseNode(node, child => {
      if (node === child) {
        return true;
      }

      prepareMeshesStores(child, meshesStoresOptions);
      return true;
    });
  };

  let decision;
  traverseNode(targetNode, node => {
    decision = filter(node);

    if (!decision || decision > allowableDecision) {
      throw new Error('Filter must returns decision from namespace FilterDecision');
    }

    if (decision & APPROVE_NODE) {
      prepareMeshesStores(node, meshesStoresOptions);
    }

    if (decision & APPROVE_SUBTREE) {
      approveSubtree(node);
      return false;
    }

    if (decision & SKIP_SUBTREE) {
      return false;
    }

    if (decision & SKIP_NODE) {
      return true;
    }

    return true;
  });
  return {
    meshesByGeometry,
    meshesExtraData
  };
}
// CONCATENATED MODULE: /home/kirill/projects/industrial/node_modules/@wg/edge-creator/browser/index.ts




const _createEdges = (() => {
  let attributes;
  let indices;
  let positionAttribute;
  let edgeIndices;
  let edgeGeometry;
  let meshes;
  let mesh;
  return (geometry, options) => {
    meshes = options.meshesByGeometry.get(geometry);
    attributes = geometry.attributes;
    indices = geometry.indices;
    positionAttribute = attributes.get(lib["d" /* AttributeSemantic */].POSITION);
    edgeIndices = getEdgeIndices(indices.view, positionAttribute.view, options.thresholdDot);

    if (!edgeIndices.view.length) {
      for (mesh of meshes) {
        deleteEdges(mesh, options);
      }

      return;
    }

    edgeGeometry = createLineGeometry(positionAttribute, edgeIndices, options.elementStaging);

    for (mesh of meshes) {
      addEdges(mesh, edgeGeometry, options);
    }

    edgeGeometry.indices.vertexData.release();
    edgeGeometry.indices.release();
    edgeGeometry.release();
  };
})();

function generateEdges(nodes, options) {
  if (Array.isArray(nodes)) {
    for (const node of nodes) {
      generateEdges(node, options);
    }

    return;
  }

  const node = nodes;
  const {
    threshold = 45,
    material,
    filter,
    elementStaging
  } = options;
  const {
    meshesByGeometry,
    meshesExtraData
  } = getMeshesStores(node, material, filter);
  const {
    scene
  } = node;
  const thresholdDot = Math.cos(degToRad * threshold);
  const creationOptions = {
    scene,
    elementStaging,
    meshesExtraData,
    meshesByGeometry,
    thresholdDot,
    material
  };

  for (const [geometry] of meshesByGeometry) {
    if (geometry.unloaded) {
      geometry.onLoad.subscribe(() => {
        // console.log('onLoad completed')
        _createEdges(geometry, creationOptions);
      });
      continue;
    } // console.log('isloaded')


    _createEdges(geometry, creationOptions);
  }
}

function removeEdges(nodes, material) {
  if (Array.isArray(nodes)) {
    for (const node of nodes) {
      removeEdges(node, material);
    }

    return;
  }

  const node = nodes;
  const {
    meshesByGeometry,
    meshesExtraData
  } = getMeshesStores(node, material);
  const {
    scene
  } = node;
  let mesh;
  const removingOptions = {
    scene,
    meshesExtraData,
    material
  };

  for (mesh of meshesExtraData.keys()) {
    deleteEdges(mesh, removingOptions);
  }

  meshesByGeometry.clear();
}

function generateEdgeGeometry(geometry, elementStaging, threshold) {
  const thresholdDot = Math.cos(degToRad * threshold);

  if (geometry.unloaded) {
    throw new Error('Impossible to create edges for unloaded geometry');
  }

  const positionAttribute = geometry.attributes.get(lib["d" /* AttributeSemantic */].POSITION);

  if (!positionAttribute) {
    throw new Error('Invalid source geometry, it must have positions');
  }

  const edgeIndices = getEdgeIndices(geometry.indices.view, positionAttribute.view, thresholdDot); // No edges for current threshold

  if (!edgeIndices.view.length) {
    return null;
  }

  const edgeGeometry = createLineGeometry(positionAttribute, edgeIndices, elementStaging);
  edgeGeometry.needsUpdateBoundingBox = false;
  return edgeGeometry;
}


// EXTERNAL MODULE: ./src/api/utils.ts
var utils = __webpack_require__(15);

// EXTERNAL MODULE: ./src/core/resources/utils.ts
var resources_utils = __webpack_require__(14);

// CONCATENATED MODULE: ./src/features/edge/index.ts
var edge_class, edge_temp;

function edge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function edge_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }









const edgesTag = 'edges';
const defaultMaterialName = 'wgt_edges_material';

const waitGeometryLoading = geometry => {
  return new Promise(resolve => geometry.onLoad.subscribe(resolve, {
    once: true
  }));
};

let edge_EdgeGeometry = (edge_class = (edge_temp = class EdgeGeometry {
  constructor(mainOptions) {
    edge_defineProperty(this, "_enabled", void 0);

    edge_defineProperty(this, "_core", void 0);

    edge_defineProperty(this, "_store", void 0);

    edge_defineProperty(this, "_layers", void 0);

    edge_defineProperty(this, "_structure", void 0);

    edge_defineProperty(this, "_renderer", void 0);

    edge_defineProperty(this, "_material", void 0);

    edge_defineProperty(this, "_materialName", void 0);

    edge_defineProperty(this, "_thresholdAngle", void 0);

    edge_defineProperty(this, "_color", void 0);

    edge_defineProperty(this, "_created", void 0);

    edge_defineProperty(this, "_needsUpdateEdges", void 0);

    edge_defineProperty(this, "_needsDrawOnce", void 0);

    edge_defineProperty(this, "_createEdges", (() => {
      const matrix = new math_lib["b" /* AffineMatrix3 */]();
      const center = new math_lib["n" /* Vector3 */]();
      const position = new math_lib["n" /* Vector3 */]();
      return (scene, sourceGeometry, sourceRenderables) => {
        const edgeMaterial = this._material;

        if (!edgeMaterial) {
          return;
        }

        const {
          instanceDataManager
        } = scene;
        const {
          elementStaging
        } = this._renderer;
        const edgeGeometry = generateEdgeGeometry(sourceGeometry, elementStaging, this._thresholdAngle);

        if (!edgeGeometry) {
          return;
        }

        for (const sourceRenderable of sourceRenderables) {
          const edgeRenderable = new resources_utils["c" /* IndustrialRenderable */](edgeGeometry, edgeMaterial);
          scene.addInstance(edgeRenderable); // Set the same matrix

          scene.getWorldMatrix(sourceRenderable, matrix);
          scene.setWorldMatrix(edgeRenderable, matrix); // Set the same external id

          edgeRenderable.externalId = sourceRenderable.externalId; // Set the same center

          const sourceGlobalIndex = Object(global_helpers["l" /* getInstanceGlobalIndex */])(instanceDataManager, sourceRenderable);
          const targetGlobalIndex = Object(global_helpers["l" /* getInstanceGlobalIndex */])(instanceDataManager, edgeRenderable); // @ts-ignore _centers private

          center.fromArrayAt(sourceGlobalIndex * 3, instanceDataManager._centers);
          instanceDataManager.storeCenter(center, targetGlobalIndex); // explosion

          scene.getInstancedAttribute(sourceRenderable, lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_1, position);
          scene.setInstancedAttribute(edgeRenderable, lib["d" /* AttributeSemantic */].INSTANCE_CUSTOM_1, position); // Ignore edge raycasting (just to be sure)

          instanceDataManager.setInstancedAttribute(edgeRenderable, global_helpers["s" /* ignoreAttribute */], 1);

          this._structure.addToGroup(edgesTag, edgeRenderable);

          this._structure.addElement(edgeRenderable.externalId, edgeRenderable);
        }
      };
    })());

    const {
      store,
      layers,
      core,
      gl,
      structure
    } = mainOptions;
    this._enabled = false;
    this._core = core;
    this._store = store;
    this._layers = layers;
    this._structure = structure;
    this._renderer = gl.renderer;
    this._material = null;
    this._materialName = defaultMaterialName;
    this._thresholdAngle = 0;
    this._color = 0;
    this._created = false;
    this._needsUpdateEdges = true;
    this._needsDrawOnce = true;
    structure.addGroup(edgesTag);

    this._addListeners();
  }

  _addListeners() {
    const {
      load,
      edges
    } = this._store;
    Object(mobx_module["h" /* reaction */])(() => load.isPreparing, isPreparing => {
      if (!isPreparing) {
        return;
      }

      this._handleModelLoaded();
    });
    Object(mobx_module["h" /* reaction */])(() => load.isLoaded, isLoaded => {
      if (isLoaded) {
        return;
      }

      this._handleModelUnloaded();
    });
    const handleChangeEdges = Object(global_helpers["I" /* updateStoreState */])(async () => {
      await this._applyOptions();
    }, edges);
    Object(mobx_module["h" /* reaction */])(() => edges.isPending, isPending => {
      if (!isPending) {
        return;
      }

      handleChangeEdges();
    });
  }

  _handleModelLoaded() {
    const prefabs = this._getEdgesPrefabs();

    this._color = 0;

    if (prefabs) {
      this._thresholdAngle = prefabs.threshold;
      this._materialName = prefabs.materialName;
      this._material = prefabs.material;
      this._needsUpdateEdges = false;
      this._created = true;

      this._prepareEdges();
    } else {
      this._thresholdAngle = 0;
      this._materialName = defaultMaterialName;
      this._material = this._createMaterial();
    }

    this._applyOptions();
  }

  _handleModelUnloaded() {
    this._material = null;
  }

  _createMaterial() {
    const material = new resources_materials["c" /* IndustrialUnlitMeshMaterial */]({
      name: this._materialName,
      color: new math_lib["k" /* RGBColor */](0, 0, 0)
    });

    this._core.addResource('material', this._materialName, material);

    return material;
  }

  _getEdgesPrefabs() {
    if (!this._core.hasResource('extras', 'edges')) {
      return null;
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


    const {
      materialName,
      threshold
    } = this._core.getResource('extras', 'edges');

    const material = this._core.getResource('material', materialName);

    return {
      materialName,
      material,
      threshold
    };
  }

  _prepareEdges() {
    const scene = this._layers.layer3dMain.scene;

    if (!scene) {
      return;
    }

    const allRenderables = this._structure.getAllElements();

    for (const renderable of allRenderables) {
      if (renderable.material.name !== this._materialName) {
        continue;
      }

      scene.instanceDataManager.setInstancedAttribute(renderable, global_helpers["s" /* ignoreAttribute */], 1);

      this._structure.addElement(renderable.externalId, renderable);
    }
  }

  get enabled() {
    return this._enabled;
  }

  enable() {
    this._setVisibility(true);

    this._enabled = true;
  }

  disable() {
    this._setVisibility(false);

    this._enabled = false;
  }

  async _applyOptions() {
    const {
      enabled,
      thresholdAngle,
      color
    } = this._store.edges;

    this._setThresholdAngle(thresholdAngle);

    this._setColor(color);

    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }

    await this._update();
  }

  _setVisibility(visible) {
    if (!this._material) {
      return;
    }

    Object(global_helpers["C" /* setMaterialVisibility */])(this._material, visible, edgesTag);
    this._needsDrawOnce = true;
  }

  _setThresholdAngle(angle) {
    if (angle === this._thresholdAngle) {
      return;
    }

    this._thresholdAngle = angle;
    this._needsUpdateEdges = true;
    this._needsDrawOnce = true;
  }

  _setColor(color) {
    if (!this._material) {
      return;
    }

    if (color === this._color) {
      return;
    }

    const hexColor = parseInt(color, 16);

    this._material.color.fromPackedInteger(hexColor);

    this._color = color;
    this._needsDrawOnce = true;
  }

  async _update() {
    if (this._needsUpdateEdges && this._enabled) {
      await this._updateEdges();
    }

    if (this._needsDrawOnce) {
      this._layers.layer3dMain.setNeedsDrawOnce(edgesTag);
    }
  }

  async _updateEdges() {
    const scene = this._layers.layer3dMain.scene;

    if (!scene) {
      return;
    }

    if (this._created) {
      this._removeEdges();
    }

    const structure = this._structure;
    /* prepare renderablesByGeometries map */

    const loadingGeometries = [];
    const renderablesByGeometries = new Map();

    for (const renderable of structure.getAllElements()) {
      let renderables = renderablesByGeometries.get(renderable.geometry);

      if (!renderables) {
        renderables = [];
        renderablesByGeometries.set(renderable.geometry, renderables);
      }

      renderables.push(renderable);
    }
    /* create edges */


    await Object(global_helpers["A" /* iterateAsync */])(renderablesByGeometries.entries(), renderablesByGeometries.size, ([geometry, renderables]) => {
      if (!geometry.unloaded) {
        this._createEdges(scene, geometry, renderables);

        return;
      }

      const promise = waitGeometryLoading(geometry).then(() => {
        this._createEdges(scene, geometry, renderables);

        this._layers.renderLayer(edgesTag, this._layers.layer3dMain, {
          culling: true,
          sort: true
        });
      });
      loadingGeometries.push(promise);
    });

    this._layers.renderLayer(edgesTag, this._layers.layer3dMain, {
      culling: true,
      sort: true
    });

    await Promise.all(loadingGeometries);
    this._created = true;
    this._needsUpdateEdges = false;
  }

  _removeEdges() {
    const structure = this._structure;
    const currentEdges = structure.getGroup(edgesTag);

    if (!currentEdges) {
      return;
    }

    for (const renderable of currentEdges) {
      structure.removeElement(renderable);
    }

    this._layers.renderLayer(edgesTag, this._layers.layer3dMain, {
      culling: true,
      sort: true
    });

    this._created = false;
    this._needsUpdateEdges = true;
  }

}, edge_temp), (edge_applyDecoratedDescriptor(edge_class.prototype, "_updateEdges", [utils["d" /* waitPreviousExecution */]], Object.getOwnPropertyDescriptor(edge_class.prototype, "_updateEdges"), edge_class.prototype)), edge_class);

// CONCATENATED MODULE: ./src/features/sectoring/sectoring-module/utils.ts
function beautifyNumber(num) {
  return Math.round(num).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
}
// EXTERNAL MODULE: ./src/global-helpers/transform.ts
var global_helpers_transform = __webpack_require__(22);

// CONCATENATED MODULE: ./src/features/sectoring/sectoring-module/level.ts
function level_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const WEIGHT = 0.025;
class level_Level {
  constructor(options) {
    level_defineProperty(this, "_scene", void 0);

    level_defineProperty(this, "_renderer", void 0);

    level_defineProperty(this, "_lineSize", void 0);

    level_defineProperty(this, "_textSize", void 0);

    level_defineProperty(this, "_position", void 0);

    level_defineProperty(this, "_height", void 0);

    level_defineProperty(this, "_bbox", void 0);

    level_defineProperty(this, "_lineMaterial", void 0);

    level_defineProperty(this, "_textMaterial", void 0);

    level_defineProperty(this, "_minUv", void 0);

    level_defineProperty(this, "_maxUv", void 0);

    level_defineProperty(this, "_scale", void 0);

    level_defineProperty(this, "_posIndex", void 0);

    level_defineProperty(this, "_lineSubMesh", void 0);

    level_defineProperty(this, "_leftTextSubMesh", void 0);

    level_defineProperty(this, "_rightTextSubMesh", void 0);

    const {
      scene,
      lineMaterial,
      textMaterial,
      renderer,
      height,
      minUv,
      maxUv,
      bbox,
      scale
    } = options;
    this._scene = scene;
    this._renderer = renderer;
    this._lineMaterial = lineMaterial;
    this._textMaterial = textMaterial;
    this._minUv = minUv;
    this._maxUv = maxUv;
    this._scale = scale;
    this._lineSize = new math_lib["m" /* Vector2 */]();
    this._textSize = new math_lib["m" /* Vector2 */]();
    this._position = new math_lib["n" /* Vector3 */]();
    this._height = height;
    this._bbox = bbox.clone();

    this._position.copy(bbox.max).add(bbox.min).multiplyNumber(0.5);

    this._position.y = height * 0.001;

    this._createMeshes();
  }

  _createMeshes() {
    const bbox = this._bbox;
    const scene = this._scene;
    const renderer = this._renderer;
    this._posIndex = 0;
    this._lineSize.x = (bbox.max.x - bbox.min.x) * 0.6;
    this._lineSize.y = (bbox.max.z - bbox.min.z) * 0.6;

    this._textSize.copy(this._maxUv).subtract(this._minUv).multiplyNumber(0.5 * this._scale);

    const COS45 = Math.cos(Math.PI / 4);
    const scale = new math_lib["n" /* Vector3 */](1, 1, 1);
    const position = new math_lib["n" /* Vector3 */]();
    const orientation = new math_lib["i" /* Quaternion */]();
    position.copy(this._position);
    this._lineSubMesh = this._createLineMesh(renderer, this._lineMaterial);
    scene.addInstance(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

    const textMesh = this._createTextMesh(renderer, this._textMaterial, this._minUv, this._maxUv);

    position.copy(this._position);
    position.x -= this._lineSize.x - this._textSize.x;
    position.z -= this._lineSize.y;
    this._leftTextSubMesh = textMesh;
    scene.addInstance(this._leftTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));
    position.copy(this._position);
    position.x += this._lineSize.x;
    position.z += this._lineSize.y - this._textSize.x;
    orientation.set(COS45, 0, COS45, 0);
    this._rightTextSubMesh = textMesh.clone();
    scene.addInstance(this._rightTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));
  }

  updateBbox(bbox) {
    if (bbox.equals(this._bbox)) {
      return false;
    }

    this._bbox = bbox.clone();

    this._position.copy(bbox.max).add(bbox.min).multiplyNumber(0.5);

    this._position.y = this._height * 0.001;

    this._scene.deleteInstance(this._lineSubMesh);

    this._scene.deleteInstance(this._leftTextSubMesh);

    this._scene.deleteInstance(this._rightTextSubMesh);

    this._createMeshes();

    return true;
  }

  get renderables() {
    return [this._lineSubMesh, this._leftTextSubMesh, this._rightTextSubMesh];
  }

  updateCameraDirection(cameraAxis) {
    // Calculate Dot(Camera.zAxis, AABB.xzAxis)
    // Search two maximum values and calculate needed corner
    // Result write to posIndex and compare with old value
    const axis = new math_lib["n" /* Vector3 */]();
    const scale = new math_lib["n" /* Vector3 */](1, 1, 1);
    const position = new math_lib["n" /* Vector3 */]();
    const orientation = new math_lib["i" /* Quaternion */]();
    axis.set(0, 0, -1);
    const dot0 = cameraAxis.dot(axis);
    axis.set(1, 0, 0);
    const dot1 = cameraAxis.dot(axis);
    axis.set(0, 0, 1);
    const dot2 = cameraAxis.dot(axis);
    axis.set(-1, 0, 0);
    const dot3 = cameraAxis.dot(axis);
    let posIndex = 0;

    if (dot1 <= 0 && dot2 <= 0) {
      posIndex = 1;
    } else if (dot2 <= 0 && dot3 <= 0) {
      posIndex = 2;
    } else if (dot3 <= 0 && dot0 <= 0) {
      posIndex = 3;
    }

    if (this._posIndex === posIndex) {
      return false;
    }

    this._posIndex = posIndex;
    const COS45 = Math.cos(Math.PI / 4); // If posIndex not equal with old value, then apply changes

    switch (posIndex) {
      case 1:
        position.copy(this._position);
        position.x += this._lineSize.x;
        position.z -= this._lineSize.y - this._textSize.x;
        orientation.set(COS45, 0, COS45, 0);

        this._scene.setWorldMatrix(this._leftTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        position.x -= this._lineSize.x - this._textSize.x;
        position.z += this._lineSize.y;
        orientation.set(0, 0, 1, 0);

        this._scene.setWorldMatrix(this._rightTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        orientation.set(1, 0, 0, 0);
        scale.set(1, 1, -1);

        this._scene.setWorldMatrix(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        break;

      case 2:
        position.copy(this._position);
        position.x += this._lineSize.x - this._textSize.x;
        position.z += this._lineSize.y;
        orientation.set(0, 0, 1, 0);

        this._scene.setWorldMatrix(this._leftTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        position.x -= this._lineSize.x;
        position.z -= this._lineSize.y - this._textSize.x;
        orientation.set(COS45, 0, -COS45, 0);

        this._scene.setWorldMatrix(this._rightTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        orientation.set(1, 0, 0, 0);
        scale.set(-1, 1, -1);

        this._scene.setWorldMatrix(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        break;

      case 3:
        position.copy(this._position);
        position.x -= this._lineSize.x;
        position.z += this._lineSize.y - this._textSize.x;
        orientation.set(COS45, 0, -COS45, 0);

        this._scene.setWorldMatrix(this._leftTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        position.x += this._lineSize.x - this._textSize.x;
        position.z -= this._lineSize.y;
        orientation.set(1, 0, 0, 0);

        this._scene.setWorldMatrix(this._rightTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        orientation.set(1, 0, 0, 0);
        scale.set(-1, 1, 1);

        this._scene.setWorldMatrix(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        break;

      default:
        position.copy(this._position);
        position.x -= this._lineSize.x - this._textSize.x;
        position.z -= this._lineSize.y;
        orientation.set(1, 0, 0, 0);

        this._scene.setWorldMatrix(this._leftTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        position.x += this._lineSize.x;
        position.z += this._lineSize.y - this._textSize.x;
        orientation.set(COS45, 0, COS45, 0);

        this._scene.setWorldMatrix(this._rightTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        position.copy(this._position);
        orientation.set(1, 0, 0, 0);
        scale.set(1, 1, 1);

        this._scene.setWorldMatrix(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

        break;
    }

    return true;
  }

  _createLineMesh(renderer, material) {
    const geometry = new lib["t" /* Geometry */]();
    const vertexBufferView = new lib["pb" /* VertexBufferView */](renderer.vertexStaging, 24 * Float32Array.BYTES_PER_ELEMENT);
    const pos = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, 24); // 0

    pos[0] = -this._lineSize.x;
    pos[1] = -WEIGHT;
    pos[2] = -this._lineSize.y; // 1

    pos[3] = -this._lineSize.x;
    pos[4] = WEIGHT;
    pos[5] = -this._lineSize.y; // 2

    pos[6] = this._lineSize.x;
    pos[7] = -WEIGHT;
    pos[8] = -this._lineSize.y; // 3

    pos[9] = this._lineSize.x;
    pos[10] = WEIGHT;
    pos[11] = -this._lineSize.y; // 4

    pos[12] = this._lineSize.x;
    pos[13] = -WEIGHT;
    pos[14] = this._lineSize.y; // 5

    pos[15] = this._lineSize.x;
    pos[16] = WEIGHT;
    pos[17] = this._lineSize.y; // 6

    pos[18] = -this._lineSize.x;
    pos[19] = -WEIGHT;
    pos[20] = this._lineSize.y; // 7

    pos[21] = -this._lineSize.x;
    pos[22] = WEIGHT;
    pos[23] = this._lineSize.y;
    const positionAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 3,
      countElements: 8,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].POSITION,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC3,
      stride: 12,
      type: Float32Array
    });
    const indexBufferView = new lib["pb" /* VertexBufferView */](renderer.elementStaging, 12 * Uint8Array.BYTES_PER_ELEMENT);
    const ind = new Uint8Array(indexBufferView.view.buffer, indexBufferView.view.byteOffset, 12);
    ind.set([0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4]);
    const indices = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
      countComponents: 1,
      countElements: 12,
      normalized: false,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].NONE,
      vertexData: indexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].SCALAR,
      stride: 1,
      type: Uint8Array
    });
    const submesh = new resources_utils["c" /* IndustrialRenderable */](geometry, material);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
    geometry.indices = indices;
    positionAttribute.release();
    indices.release();
    geometry.release();
    vertexBufferView.release();
    indexBufferView.release();
    return submesh;
  }

  _createTextMesh(renderer, material, minUv, maxUv) {
    const geometry = new lib["t" /* Geometry */]();
    const vertexBufferView = new lib["pb" /* VertexBufferView */](renderer.vertexStaging, 20 * Float32Array.BYTES_PER_ELEMENT);
    const vertex = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, 20); // 0

    vertex[0] = -this._textSize.x;
    vertex[1] = WEIGHT;
    vertex[2] = 0;
    vertex[3] = minUv.x;
    vertex[4] = maxUv.y; // 1

    vertex[5] = -this._textSize.x;
    vertex[6] = this._textSize.y * 2 + WEIGHT;
    vertex[7] = 0;
    vertex[8] = minUv.x;
    vertex[9] = minUv.y; // 2

    vertex[10] = this._textSize.x;
    vertex[11] = this._textSize.y * 2 + WEIGHT;
    vertex[12] = 0;
    vertex[13] = maxUv.x;
    vertex[14] = minUv.y; // 3

    vertex[15] = this._textSize.x;
    vertex[16] = WEIGHT;
    vertex[17] = 0;
    vertex[18] = maxUv.x;
    vertex[19] = maxUv.y;
    const positionAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 3,
      countElements: 4,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].POSITION,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC3,
      stride: 20,
      type: Float32Array
    });
    const uvAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 2,
      countElements: 4,
      offset: 12,
      semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC2,
      stride: 20,
      type: Float32Array
    });
    const indexBufferView = new lib["pb" /* VertexBufferView */](renderer.elementStaging, 6 * Uint8Array.BYTES_PER_ELEMENT);
    const ind = new Uint8Array(indexBufferView.view.buffer, indexBufferView.view.byteOffset, 6);
    ind.set([0, 1, 2, 0, 2, 3]);
    const indices = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
      countComponents: 1,
      countElements: 6,
      normalized: false,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].NONE,
      vertexData: indexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].SCALAR,
      stride: 1,
      type: Uint8Array
    });
    const submesh = new resources_utils["c" /* IndustrialRenderable */](geometry, material);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
    geometry.indices = indices;
    positionAttribute.release();
    uvAttribute.release();
    indices.release();
    geometry.release();
    vertexBufferView.release();
    indexBufferView.release();
    return submesh;
  }

}
// CONCATENATED MODULE: ./src/features/sectoring/sectoring-module/axis.ts
function sectoring_module_axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const axis_WEIGHT = 0.015;
const LINES = [4, 0.4, 0.2, 0.4];
class sectoring_module_axis_Axis {
  constructor(options) {
    sectoring_module_axis_defineProperty(this, "_textSize", void 0);

    sectoring_module_axis_defineProperty(this, "_lineSubMesh", void 0);

    sectoring_module_axis_defineProperty(this, "_endTextSubMesh", void 0);

    sectoring_module_axis_defineProperty(this, "_startTextSubmesh", void 0);

    const {
      lineMaterial,
      textMaterial,
      renderer,
      minUv,
      maxUv,
      scene,
      path
    } = options;
    this._textSize = new math_lib["m" /* Vector2 */]();

    this._textSize.copy(maxUv).subtract(minUv).multiplyNumber(0.5 * options.scale);

    const scale = new math_lib["n" /* Vector3 */](1, 1, 1);
    const position = new math_lib["n" /* Vector3 */]();
    const orientation = new math_lib["i" /* Quaternion */]();
    this._lineSubMesh = this._createLineMesh(renderer, lineMaterial, path);
    scene.addInstance(this._lineSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));

    const textMesh = this._createTextMesh(renderer, textMaterial, minUv, maxUv);

    const vector = new math_lib["n" /* Vector3 */]();
    const zAxis = new math_lib["n" /* Vector3 */](0, 0, 1);
    vector.x = path[0].x - path[1].x;
    vector.z = path[0].y - path[1].y;
    vector.normalize();
    orientation.fromRotationBetween(zAxis, vector);
    vector.multiplyNumber(this._textSize.x);
    position.x = path[0].x + vector.x;
    position.z = path[0].y + vector.z;
    position.y = 0;
    this._startTextSubmesh = textMesh;
    scene.addInstance(this._startTextSubmesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));
    vector.x = path[path.length - 1].x - path[path.length - 2].x;
    vector.z = path[path.length - 1].y - path[path.length - 2].y;
    vector.normalize();
    orientation.fromRotationBetween(zAxis, vector);
    vector.multiplyNumber(this._textSize.x);
    position.x = path[path.length - 1].x + vector.x;
    position.z = path[path.length - 1].y + vector.z;
    position.y = 0;
    this._endTextSubMesh = textMesh.clone();
    scene.addInstance(this._endTextSubMesh, Object(global_helpers_transform["a" /* getMatrixFromTransforms */])(position, orientation, scale));
  }

  get renderables() {
    return [this._lineSubMesh, this._endTextSubMesh, this._startTextSubmesh];
  }

  _cLine(conf) {
    const length = conf.start.distance(conf.end);
    const vector = new math_lib["m" /* Vector2 */]();

    if (LINES[conf.isLine] - conf.offset < length) {
      vector.copy(conf.end).subtract(conf.start).multiplyNumber((LINES[conf.isLine] - conf.offset) / length).add(conf.start);

      if (conf.isLine % 2 === 0) {
        this._addLineData(conf.pos, conf.ind, conf.start, vector);
      }

      conf.isLine = (conf.isLine + 1) % LINES.length;
      conf.offset = 0;
      conf.start.copy(vector);

      this._cLine(conf);
    } else {
      if (conf.isLine % 2 === 0) {
        this._addLineData(conf.pos, conf.ind, conf.start, conf.end);
      }

      conf.offset += length;
    }
  }

  _createLineMesh(renderer, material, path) {
    const geometry = new lib["t" /* Geometry */]();
    const posArray = [];
    const indArray = [];
    const conf = {
      pos: posArray,
      ind: indArray,
      offset: 0,
      isLine: 0,
      start: new math_lib["m" /* Vector2 */](),
      end: new math_lib["m" /* Vector2 */]()
    };

    for (let it = 0; it < path.length - 1; it++) {
      conf.start.copy(path[it]);
      conf.end.copy(path[it + 1]);

      this._cLine(conf);
    }

    const length = indArray.length / 6;
    const vertexBufferView = new lib["pb" /* VertexBufferView */](renderer.vertexStaging, 12 * Float32Array.BYTES_PER_ELEMENT * length);
    const pos = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, 12 * length);
    pos.set(posArray);
    const indexBufferView = new lib["pb" /* VertexBufferView */](renderer.elementStaging, 6 * Uint8Array.BYTES_PER_ELEMENT * length);
    const ind = new Uint8Array(indexBufferView.view.buffer, indexBufferView.view.byteOffset, 6 * length);
    ind.set(indArray);
    const positionAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 3,
      countElements: 4 * length,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].POSITION,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC3,
      stride: 12,
      type: Float32Array
    });
    const indices = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
      countComponents: 1,
      countElements: 6 * length,
      normalized: false,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].NONE,
      vertexData: indexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].SCALAR,
      stride: 1,
      type: Uint8Array
    });
    const submesh = new resources_utils["c" /* IndustrialRenderable */](geometry, material);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
    geometry.indices = indices;
    positionAttribute.release();
    indices.release();
    geometry.release();
    vertexBufferView.release();
    indexBufferView.release();
    return submesh;
  }

  _addLineData(positions, indices, start, end) {
    const index = indices.length / 6;
    const normal = new math_lib["n" /* Vector3 */]();
    normal.x = end.y - start.y;
    normal.y = 0;
    normal.z = start.x - end.x;
    normal.normalize().multiplyNumber(axis_WEIGHT);
    positions.push(start.x - normal.x);
    positions.push(0);
    positions.push(start.y - normal.z);
    positions.push(start.x + normal.x);
    positions.push(0);
    positions.push(start.y + normal.z);
    positions.push(end.x + normal.x);
    positions.push(0);
    positions.push(end.y + normal.z);
    positions.push(end.x - normal.x);
    positions.push(0);
    positions.push(end.y - normal.z);
    indices.push(index * 4);
    indices.push(index * 4 + 1);
    indices.push(index * 4 + 2);
    indices.push(index * 4);
    indices.push(index * 4 + 2);
    indices.push(index * 4 + 3);
  }

  _createTextMesh(renderer, material, minUv, maxUv) {
    const geometry = new lib["t" /* Geometry */]();
    const vertexBufferView = new lib["pb" /* VertexBufferView */](renderer.vertexStaging, 20 * Float32Array.BYTES_PER_ELEMENT);
    const vertex = new Float32Array(vertexBufferView.view.buffer, vertexBufferView.view.byteOffset, 20); // 0

    vertex[0] = -this._textSize.x;
    vertex[1] = 0;
    vertex[2] = -this._textSize.y;
    vertex[3] = minUv.x;
    vertex[4] = minUv.y; // 1

    vertex[5] = -this._textSize.x;
    vertex[6] = 0;
    vertex[7] = this._textSize.y;
    vertex[8] = minUv.x;
    vertex[9] = maxUv.y; // 2

    vertex[10] = this._textSize.x;
    vertex[11] = 0;
    vertex[12] = this._textSize.y;
    vertex[13] = maxUv.x;
    vertex[14] = maxUv.y; // 3

    vertex[15] = this._textSize.x;
    vertex[16] = 0;
    vertex[17] = -this._textSize.y;
    vertex[18] = maxUv.x;
    vertex[19] = minUv.y;
    const positionAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 3,
      countElements: 4,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].POSITION,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC3,
      stride: 20,
      type: Float32Array
    });
    const uvAttribute = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].FLOAT,
      countComponents: 2,
      countElements: 4,
      offset: 12,
      semantic: lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0,
      vertexData: vertexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].VEC2,
      stride: 20,
      type: Float32Array
    });
    const indexBufferView = new lib["pb" /* VertexBufferView */](renderer.elementStaging, 6 * Uint8Array.BYTES_PER_ELEMENT);
    const ind = new Uint8Array(indexBufferView.view.buffer, indexBufferView.view.byteOffset, 6);
    ind.set([0, 1, 2, 0, 2, 3]);
    const indices = new lib["mb" /* VertexAttribute */]({
      componentType: lib["n" /* DataType */].UNSIGNED_BYTE,
      countComponents: 1,
      countElements: 6,
      normalized: false,
      offset: 0,
      semantic: lib["d" /* AttributeSemantic */].NONE,
      vertexData: indexBufferView,
      elementType: lib["nb" /* VertexAttributeType */].SCALAR,
      stride: 1,
      type: Uint8Array
    });
    const submesh = new resources_utils["c" /* IndustrialRenderable */](geometry, material);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].POSITION, positionAttribute);
    geometry.attributes.set(lib["d" /* AttributeSemantic */].TEX_COORD_CHANNEL_0, uvAttribute);
    geometry.indices = indices;
    positionAttribute.release();
    uvAttribute.release();
    indices.release();
    geometry.release();
    vertexBufferView.release();
    indexBufferView.release();
    return submesh;
  }

}
// CONCATENATED MODULE: ./src/features/sectoring/sectoring-module/index.ts
function sectoring_module_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







const TEXT_SIZE = 32;
const FONT = `${TEXT_SIZE - 6}px Arial`;
class sectoring_module_Sectoring {
  constructor(renderer) {
    sectoring_module_defineProperty(this, "_renderer", void 0);

    sectoring_module_defineProperty(this, "_axes", void 0);

    sectoring_module_defineProperty(this, "_levels", void 0);

    sectoring_module_defineProperty(this, "_lineMaterial", void 0);

    sectoring_module_defineProperty(this, "_textMaterial", void 0);

    sectoring_module_defineProperty(this, "_texture", void 0);

    sectoring_module_defineProperty(this, "_color", void 0);

    sectoring_module_defineProperty(this, "_ctx", void 0);

    sectoring_module_defineProperty(this, "_canvasSize", void 0);

    sectoring_module_defineProperty(this, "_numTiles", void 0);

    this._renderer = renderer;
    this._color = 0;
    this._axes = new Set();
    this._levels = new Set();
    this._canvasSize = 256;
    this._numTiles = this._canvasSize / TEXT_SIZE;
    const canvas = document.createElement('canvas');
    canvas.width = this._canvasSize;
    canvas.height = this._canvasSize;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
      throw new Error('Sectoring 2d context is failed');
    }

    this._ctx = ctx;
    this._texture = new lib["gb" /* Texture */]({
      width: this._canvasSize,
      height: this._canvasSize,
      dynamic: true,
      anisotropyDegree: 4,
      format: lib["N" /* PixelDataFormat */].RGBA,
      bindingPoint: lib["gb" /* Texture */].BindingPoint.TEXTURE_2D,
      levelsData: [new lib["hb" /* TextureLevelData */]({
        width: this._canvasSize,
        height: this._canvasSize,
        data: this._ctx.canvas
      })]
    });
    this._lineMaterial = new resources_materials["c" /* IndustrialUnlitMeshMaterial */]({
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(this._color)
    });
    this._textMaterial = new resources_materials["c" /* IndustrialUnlitMeshMaterial */]({
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(this._color),
      colorMap: this._texture,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND
    });
    this.setVisibility(false);
  }

  setColor(color) {
    this._color = parseInt(color, 16);

    this._lineMaterial.color.fromPackedInteger(this._color);

    this._textMaterial.color.fromPackedInteger(this._color);
  }

  _addAxis(scene, index, title, path) {
    const x = index % (this._numTiles / 2) * TEXT_SIZE * 2 / this._canvasSize;

    const y = (this._numTiles - Math.floor(index / (this._numTiles / 2)) * 2 - 2) * TEXT_SIZE / this._canvasSize;

    const size = 1 / this._numTiles;
    const minUv = new math_lib["m" /* Vector2 */](x, y);
    const maxUv = new math_lib["m" /* Vector2 */](x + size * 2, y + size * 2);

    this._fillAxisText(index, title);

    const axis = new sectoring_module_axis_Axis({
      scene,
      lineMaterial: this._lineMaterial,
      textMaterial: this._textMaterial,
      renderer: this._renderer,
      minUv,
      maxUv,
      path,
      scale: this._numTiles
    });

    this._axes.add(axis);
  }

  _addLevel(scene, index, height, bbox) {
    const x = index % (this._numTiles / 4) * TEXT_SIZE * 4 / this._canvasSize;

    const y = Math.floor(index / (this._numTiles / 4)) * TEXT_SIZE / this._canvasSize;

    const size = 1 / this._numTiles;
    const minUv = new math_lib["m" /* Vector2 */](x, y);
    const maxUv = new math_lib["m" /* Vector2 */](x + size * 4, y + size);

    this._fillLevelText(index, height);

    const level = new level_Level({
      scene,
      lineMaterial: this._lineMaterial,
      textMaterial: this._textMaterial,
      renderer: this._renderer,
      height,
      minUv,
      maxUv,
      bbox,
      scale: this._numTiles
    });

    this._levels.add(level);
  }

  setVisibility(value) {
    this._lineMaterial.visible = value;
    this._textMaterial.visible = value;
  }

  updateBbox(bbox) {
    let updatedAny = false;

    for (const level of this._levels) {
      const levelUpdated = level.updateBbox(bbox);
      updatedAny = updatedAny || levelUpdated;
    }

    return updatedAny;
  }

  updateCameraDirection(cameraAxis) {
    let updatedAny = false;

    for (const level of this._levels) {
      const levelUpdated = level.updateCameraDirection(cameraAxis);
      updatedAny = updatedAny || levelUpdated;
    }

    return updatedAny;
  }

  get renderables() {
    const axes = this._axes;
    const levels = this._levels;
    return {
      *[Symbol.iterator]() {
        for (const axis of axes) {
          for (const renderable of axis.renderables) {
            yield renderable;
          }
        }

        for (const level of levels) {
          for (const renderable of level.renderables) {
            yield renderable;
          }
        }
      }

    };
  }

  create(scene, json, bbox) {
    this._calcTextureSize(json.levels.length, json.axes.length);

    this._ctx.clearRect(0, 0, this._canvasSize, this._canvasSize);

    for (let it = 0; it < json.axes.length; it++) {
      const path = [];
      path.length = 0;

      for (const el of json.axes[it].path) {
        path.push(new math_lib["m" /* Vector2 */](el.x * 0.001, el.y * 0.001));
      }

      this._addAxis(scene, it, json.axes[it].name, path);
    }

    for (let it = 0; it < json.levels.length; it++) {
      this._addLevel(scene, it, json.levels[it].elevation, bbox);
    }

    this._texture.needsUpdate = true;
    return this.renderables;
  }

  clear() {
    this._axes.clear();

    this._levels.clear();
  }

  _calcTextureSize(numLevels, numAxes) {
    const size = Math.ceil(Math.sqrt((numLevels + numAxes) * 4) / 4) * 4;
    const levelsLines = Math.ceil(numLevels * 4 / size);
    const axesLines = Math.ceil(numAxes * 2 / size) * 2;

    if (size >= levelsLines + axesLines) {
      this._canvasSize = size * TEXT_SIZE;
    } else {
      this._canvasSize = size * 2 * TEXT_SIZE;
    }

    this._numTiles = this._canvasSize / TEXT_SIZE;
    this._ctx.canvas.width = this._canvasSize;
    this._ctx.canvas.height = this._canvasSize;
    this._texture.width = this._canvasSize;
    this._texture.height = this._canvasSize;

    this._texture.updateLevels(levelsData => {
      levelsData[0].width = this._canvasSize;
      levelsData[0].height = this._canvasSize;
      return true;
    });
  }

  _fillLevelText(index, height) {
    this._ctx.fillStyle = '#FFFFFF';
    this._ctx.strokeStyle = '#FFFFFF';
    this._ctx.font = FONT;
    this._ctx.textAlign = 'left';
    const heightText = beautifyNumber(height);

    this._ctx.fillText(height >= 0 ? '+' + heightText : heightText, index % (this._numTiles / 4) * TEXT_SIZE * 4, Math.floor(index / (this._numTiles / 4)) * TEXT_SIZE + TEXT_SIZE - 7);
  }

  _fillAxisText(index, title) {
    this._ctx.fillStyle = '#FFFFFF';
    this._ctx.strokeStyle = '#FFFFFF';
    this._ctx.lineWidth = 2;
    this._ctx.font = FONT;
    this._ctx.textAlign = 'center';
    const x = index % (this._numTiles / 2) * TEXT_SIZE * 2;
    const y = (this._numTiles - Math.floor(index / (this._numTiles / 2)) * 2 - 2) * TEXT_SIZE;

    this._ctx.beginPath();

    this._ctx.arc(x + TEXT_SIZE, y + TEXT_SIZE, TEXT_SIZE - 3, 0, 2 * Math.PI);

    this._ctx.stroke();

    this._ctx.save();

    this._ctx.rect(x, y, TEXT_SIZE * 2, TEXT_SIZE * 2);

    this._ctx.clip();

    this._ctx.fillText(title, x + TEXT_SIZE, y + TEXT_SIZE * 1.5 - 7);

    this._ctx.restore();
  }

}
// CONCATENATED MODULE: ./src/features/sectoring/index.ts
function features_sectoring_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const sectoring_$rendererTag = Symbol('sectoring');
class sectoring_SectoringController {
  constructor({
    core,
    store,
    layers,
    renderer,
    structure,
    controls,
    resources
  }) {
    features_sectoring_defineProperty(this, "_sectoring", void 0);

    features_sectoring_defineProperty(this, "_cameraAxis", void 0);

    features_sectoring_defineProperty(this, "_controls", void 0);

    features_sectoring_defineProperty(this, "_store", void 0);

    features_sectoring_defineProperty(this, "_core", void 0);

    features_sectoring_defineProperty(this, "_layers", void 0);

    features_sectoring_defineProperty(this, "_structure", void 0);

    features_sectoring_defineProperty(this, "_resources", void 0);

    features_sectoring_defineProperty(this, "_created", void 0);

    this._core = core;
    this._store = store;
    this._layers = layers;
    this._structure = structure;
    this._controls = controls;
    this._resources = resources;
    this._created = false;
    this._sectoring = new sectoring_module_Sectoring(renderer);
    this._cameraAxis = new math_lib["n" /* Vector3 */]();

    this._sectoring.setVisibility(store.sectoring.enabled);

    this._sectoring.setColor(store.sectoring.color);

    this._addListeners();
  }

  _addListeners() {
    const store = this._store;
    const layers = this._layers;

    this._resources.onLoadChunk.subscribe(() => {
      this._updateBbox();
    });

    Object(mobx_module["h" /* reaction */])(() => store.sectoring.enabled, enabled => {
      if (!this._created) {
        this._createGrid();
      }

      this._updateBbox();

      this._sectoring.setVisibility(enabled);

      layers.renderLayer(sectoring_$rendererTag, this._layers.layer3dMain);
    });
    Object(mobx_module["h" /* reaction */])(() => store.sectoring.color, color => {
      this._sectoring.setColor(color);

      if (!store.sectoring.enabled) {
        return;
      }

      layers.renderLayer(sectoring_$rendererTag, this._layers.layer3dMain);
    });
    Object(mobx_module["h" /* reaction */])(() => store.load.isLoaded, isLoaded => {
      if (!isLoaded) {
        // Unloaded
        this._sectoring.clear();

        this._created = false;
        return;
      }

      if (!store.sectoring.enabled) {
        return;
      } // Just loaded


      this._createGrid();
    });

    this._controls.camera.onEarlyUpdateEnd.subscribe(() => {
      const updated = this._updateLevelsByCamera();

      if (!updated || !store.sectoring.enabled || !layers.layer3dMain.scene) {
        return;
      }

      layers.renderLayer(sectoring_$rendererTag, layers.layer3dMain, {
        culling: true,
        sort: true
      });
    });
  }

  _updateBbox() {
    const updated = this._sectoring.updateBbox(this._structure.getBBox());

    if (!updated) {
      return;
    }

    const layers = this._layers;

    this._updateLevelsByCamera();

    Object(global_helpers["t" /* ignoreRaycast */])(layers.layer3dMain.scene, this._sectoring.renderables, true);

    if (!this._store.sectoring.enabled) {
      return;
    }

    layers.renderLayer(sectoring_$rendererTag, layers.layer3dMain, {
      culling: true,
      sort: true
    });
  }

  _createGrid() {
    const layers = this._layers;
    const structure = this._structure;
    const scene = layers.layer3dMain.scene;

    if (!scene) {
      throw new Error('Main scene not create');
    }

    this._created = true;
    let axes = [];
    let levels = [];

    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      axes = this._core.getResource('extras', 'axes');
    } catch (e) {//
    }

    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      levels = this._core.getResource('extras', 'levels');
    } catch (e) {//
    }

    const extras = {
      axes,
      levels
    };

    const renderables = this._sectoring.create(scene, extras, this._structure.getBBox());

    this._updateLevelsByCamera();

    Object(global_helpers["t" /* ignoreRaycast */])(scene, renderables, true);

    if (!structure.hasGroup('sectoring')) {
      structure.addGroup('sectoring');
    }

    structure.addToGroup('sectoring', renderables);
    layers.renderLayer(sectoring_$rendererTag, layers.layer3dMain, {
      culling: true,
      sort: true
    });
  }

  _updateLevelsByCamera() {
    this._layers.layer3dService.look.worldMatrix.axisZPaste(this._cameraAxis);

    return this._sectoring.updateCameraDirection(this._cameraAxis);
  }

}
// CONCATENATED MODULE: ./src/features/move-camera/index.ts
function move_camera_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const animationName = 'move camera feature';
const {
  UPDATE_LOCAL: move_camera_UPDATE_LOCAL,
  UPDATE_WORLD: move_camera_UPDATE_WORLD
} = lib["jb" /* Transform */].StateMask;
class move_camera_MoveCamera {
  constructor(options) {
    move_camera_defineProperty(this, "_layers", void 0);

    move_camera_defineProperty(this, "_controls", void 0);

    move_camera_defineProperty(this, "_structure", void 0);

    move_camera_defineProperty(this, "_cameraAnimation", void 0);

    move_camera_defineProperty(this, "_axesStore", void 0);

    move_camera_defineProperty(this, "_filterRenderable", renderable => {
      // Not hidden
      return !this._structure.hasGroup('filter') || !this._structure.hasInGroup('filter', renderable);
    });

    const {
      store,
      layers,
      controls,
      structure,
      customAnimationManager
    } = options;
    this._layers = layers;
    this._controls = controls;
    this._structure = structure;
    this._cameraAnimation = customAnimationManager.create(animationName);
    this._axesStore = store.axes;
  }

  getCameraPosition() {
    const {
      cameraTransform,
      target
    } = this._controls;
    return {
      position: this._axesStore.getExternalPosition(cameraTransform.position),
      target: this._axesStore.getExternalPosition(target)
    };
  }

  async moveCameraToPosition(params, time, external = false) {
    const {
      position,
      target
    } = params;
    const {
      _controls,
      _cameraAnimation
    } = this;
    const {
      cameraTransform
    } = _controls;
    const duration = time / 1000;

    if (cameraTransform.position.equals(params.position) && _controls.target.equals(params.target)) {
      return;
    }

    _cameraAnimation.setChannels([{
      source: cameraTransform.position,
      target: external ? this._axesStore.getInternalPosition(position) : position,
      onLateUpdate: () => {
        cameraTransform.state = move_camera_UPDATE_LOCAL | move_camera_UPDATE_WORLD;
      },
      duration
    }, {
      source: _controls.target,
      target: external ? this._axesStore.getInternalPosition(target) : target,
      duration
    }]);

    this._layers.list.forEach(layer => layer.setNeedsDrawPermanent(animationName, true));

    if (this._controls.enabled) {
      this._controls.disable();
    }

    await _cameraAnimation.play();

    this._layers.list.forEach(layer => layer.setNeedsDrawPermanent(animationName, false));

    this._layers.list.forEach(layer => layer.setNeedsDrawOnce(animationName));

    if (this._controls.enabled) {
      this._controls.enable();
    }

    await this._layers.waitRenderEnd();
  }

  async fitCameraToNodes(ids, animationDuration = 0) {
    const scene = this._layers.layer3dMain.scene;

    if (!scene) {
      throw new Error('Main sene doesn\'t exist');
    }

    const {
      _controls
    } = this;
    const res = cameraLookAt({
      cameraNode: _controls.cameraNode,
      cameraTarget: _controls.target,
      renderables: ids ? this._structure.get(ids) : this._structure.getAllElements(),
      filterRenderable: this._filterRenderable
    });
    await this.moveCameraToPosition(res, animationDuration);
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/procedural-geometry/src/index.js + 8 modules
var procedural_geometry_src = __webpack_require__(29);

// CONCATENATED MODULE: ./src/features/section-box/plane.ts





class plane_Plane extends wg_object_WgObject {
  constructor(options) {
    const {
      parentNode,
      vertexStaging,
      elementStaging
    } = options;
    const material = new lib["lb" /* UnlitMeshMaterial */]({
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(0xb5b5b5),
      opacity: 0.2,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND
    });
    material.depthTest = false;
    material.depthWrite = false;
    super({
      parentNode,
      material,
      name: 'gizmoPlane'
    });

    this._create({
      vertexStaging,
      elementStaging
    });

    Object(global_helpers["u" /* ignoreRaycastNode */])(this.node, true);
  }

  _create({
    vertexStaging,
    elementStaging
  }) {
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);

    if (!transform) {
      throw new Error('Transform is null');
    }

    this.transform = transform;
    const plane = Object(procedural_geometry_src["c" /* createPlaneMesh */])({
      vertexStaging,
      elementStaging,
      material: this._material
    });
    this.node.attach(plane);
  }

  setSize(size) {
    this.setTransform({
      scale: size
    });
  }

}
// CONCATENATED MODULE: ./src/features/section-box/hitbox.ts
function hitbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






class hitbox_HitBox extends wg_object_WgObject {
  constructor(options) {
    const {
      parentNode,
      vertexStaging,
      elementStaging,
      picker,
      name = '',
      isTransparent = true,
      hoverable = true
    } = options;
    const material = new lib["lb" /* UnlitMeshMaterial */]({
      color: new math_lib["k" /* RGBColor */](Math.random(), Math.random(), Math.random()),
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      opacity: 0.5
    });
    super({
      parentNode,
      material,
      name
    });

    hitbox_defineProperty(this, "_picker", void 0);

    hitbox_defineProperty(this, "onEnter", void 0);

    hitbox_defineProperty(this, "onLeave", void 0);

    this._create({
      vertexStaging,
      elementStaging
    });

    this._picker = picker;

    if (isTransparent) {
      Object(global_helpers["D" /* setNodeRaycastTransparent */])(this.node, true);
    }

    this.onEnter = new global_helpers["b" /* Event */]();
    this.onLeave = new global_helpers["b" /* Event */]();

    if (hoverable) {
      this._addListeners();
    }

    this.setVisibility(false);
    Object.seal(this);
  }

  _addListeners() {
    this._picker.onLeave.subscribe(this.node, () => this.onLeave.emit(0));

    this._picker.onEnter.subscribe(this.node, () => this.onEnter.emit(0));
  }

  _create({
    vertexStaging,
    elementStaging
  }) {
    const box = Object(procedural_geometry_src["a" /* createBoxMesh */])({
      vertexStaging,
      elementStaging,
      material: this._material
    });
    this.node.attach(box);
  }

  setSize(size) {
    const fullSize = size.clone();

    if (fullSize.x < 0.1) {
      fullSize.x = 0.1;
    }

    if (fullSize.y < 0.1) {
      fullSize.y = 0.1;
    }

    if (fullSize.z < 0.1) {
      fullSize.z = 0.1;
    }

    this.setTransform({
      scale: fullSize
    });
  }

}
// CONCATENATED MODULE: ./src/features/section-box/axis.ts
function section_box_axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const axis_CYLINDER_UP = new math_lib["n" /* Vector3 */](0, 1, 0);
class section_box_axis_Axis extends wg_object_WgObject {
  constructor(options) {
    const {
      vertexStaging,
      elementStaging,
      parentNode,
      name,
      position,
      tipLength,
      lineLength,
      color,
      picker,
      radius,
      direction = axis_CYLINDER_UP
    } = options;
    const material = new lib["lb" /* UnlitMeshMaterial */]({
      name: `drag-control-material-${name}`,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      opacity: 0.5,
      color
    });
    super({
      parentNode,
      material,
      name
    });

    section_box_axis_defineProperty(this, "_name", void 0);

    section_box_axis_defineProperty(this, "_radius", void 0);

    section_box_axis_defineProperty(this, "_tipLenght", void 0);

    section_box_axis_defineProperty(this, "_lineLength", void 0);

    section_box_axis_defineProperty(this, "_picker", void 0);

    section_box_axis_defineProperty(this, "_direction", void 0);

    section_box_axis_defineProperty(this, "hitBox", void 0);

    this._tipLenght = tipLength;
    this._lineLength = lineLength;
    this._name = name;
    this._picker = picker;
    this._radius = radius;
    this._direction = new math_lib["n" /* Vector3 */]();
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);

    if (!transform) {
      throw new Error('Transform is null');
    }

    this.transform = transform;
    this.setTransform({
      position
    });
    this.updateDirection(direction);

    this._create({
      vertexStaging,
      elementStaging
    });
  }

  _createHitBox({
    vertexStaging,
    elementStaging
  }) {
    this.hitBox = new hitbox_HitBox({
      vertexStaging,
      elementStaging,
      parentNode: this.node,
      picker: this._picker,
      isTransparent: false
    });
    const length = this._tipLenght + this._lineLength;
    this.hitBox.setSize(new math_lib["n" /* Vector3 */](this._radius * 2, length, this._radius * 2));

    if (this.hitBox.transform) {
      this.hitBox.transform.position.y += length / 2;
    }
  }

  _create({
    vertexStaging,
    elementStaging
  }) {
    const material = this._material;
    const cylinder = createUnlitCylinderMesh({
      vertexStaging,
      elementStaging,
      material,
      radiusTop: this._radius * 0.1,
      radiusBottom: this._radius,
      height: this._tipLenght
    });
    const cylinderTransform = new lib["jb" /* Transform */]({
      position: new math_lib["n" /* Vector3 */](0, this._lineLength + this._tipLenght / 2, 0)
    });
    const cylinderNode = this.node.createChild({
      name: `${this._name}_arrow_tip`
    });
    cylinderNode.attach(cylinder);
    cylinderNode.attach(cylinderTransform);
    const line = createUnlitCylinderMesh({
      vertexStaging,
      elementStaging,
      material,
      radiusTop: this._radius * 0.4,
      radiusBottom: this._radius * 0.4,
      height: this._lineLength
    });
    const lineTransform = new lib["jb" /* Transform */]({
      position: new math_lib["n" /* Vector3 */](0, this._lineLength / 2, 0)
    });
    const lineNode = this.node.createChild({
      name: `${this._name}_arrow_line`
    });
    lineNode.attach(line);
    lineNode.attach(lineTransform);

    this._createHitBox({
      vertexStaging,
      elementStaging
    });
  }

  getDirection() {
    return this._direction;
  }

  updateDirection(direction) {
    const orientation = new math_lib["i" /* Quaternion */]().rotateBetween(axis_CYLINDER_UP, direction.normalize());
    this.setTransform({
      orientation
    });

    this._direction.copy(direction);
  }

  setVisibility(isVisible) {
    super.setVisibility(isVisible);
    this.hitBox.setVisibility(false);
  }

  setColor(color) {
    this._material.color.copy(color);
  }

}
// CONCATENATED MODULE: ./src/features/section-box/scaling.ts
function scaling_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const PX_AXIS_NAME = 'WG_PX';
const PY_AXIS_NAME = 'WG_PY';
const PZ_AXIS_NAME = 'WG_PZ';
const NX_AXIS_NAME = 'WG_PX';
const NY_AXIS_NAME = 'WG_PY';
const NZ_AXIS_NAME = 'WG_PZ';
const scaling_xAxis = new math_lib["n" /* Vector3 */](1, 0, 0);
const scaling_yAxis = new math_lib["n" /* Vector3 */](0, 1, 0);
const scaling_zAxis = new math_lib["n" /* Vector3 */](0, 0, 1);
class scaling_ScalingAxes {
  constructor(options) {
    scaling_defineProperty(this, "_cameraTransform", void 0);

    scaling_defineProperty(this, "_dragger", void 0);

    scaling_defineProperty(this, "_camera", void 0);

    scaling_defineProperty(this, "_picker", void 0);

    scaling_defineProperty(this, "_pxAxisPlane", void 0);

    scaling_defineProperty(this, "_pxAxis", void 0);

    scaling_defineProperty(this, "_pyAxisPlane", void 0);

    scaling_defineProperty(this, "_pyAxis", void 0);

    scaling_defineProperty(this, "_pzAxisPlane", void 0);

    scaling_defineProperty(this, "_pzAxis", void 0);

    scaling_defineProperty(this, "_nxAxisPlane", void 0);

    scaling_defineProperty(this, "_nxAxis", void 0);

    scaling_defineProperty(this, "_nyAxisPlane", void 0);

    scaling_defineProperty(this, "_nyAxis", void 0);

    scaling_defineProperty(this, "_nzAxisPlane", void 0);

    scaling_defineProperty(this, "_nzAxis", void 0);

    scaling_defineProperty(this, "_axesWithPlanes", void 0);

    scaling_defineProperty(this, "_hoveredAxisPlane", void 0);

    scaling_defineProperty(this, "_position", void 0);

    scaling_defineProperty(this, "_size", void 0);

    scaling_defineProperty(this, "onDragStart", void 0);

    scaling_defineProperty(this, "onDragMove", void 0);

    scaling_defineProperty(this, "onDragEnd", void 0);

    scaling_defineProperty(this, "onEnter", void 0);

    scaling_defineProperty(this, "onLeave", void 0);

    scaling_defineProperty(this, "_handleDragMove", ({
      device
    }) => {
      if (device.ndc) {
        this._dragger.move(device.ndc);
      }

      this._setRestrictionsByScalingArrows();

      this.onDragMove.emit();
    });

    scaling_defineProperty(this, "_handleDragEnd", () => {
      this.onDragEnd.emit();
    });

    scaling_defineProperty(this, "_handleUpdateCamera", () => {
      for (const {
        axis
      } of this._axesWithPlanes) {
        const scaleNumber = this._cameraTransform.position.distance(axis.transform.position) / 64;
        axis.setTransform({
          scaleNumber
        });
      }
    });

    const {
      elementStaging,
      vertexStaging,
      parentNode,
      picker,
      dragger,
      cameraNode
    } = options;
    this._dragger = dragger;
    this._picker = picker;
    const [cameraTransform, camera] = cameraNode.getComponents([lib["jb" /* Transform */], lib["f" /* Camera */]]);

    if (!camera || !cameraTransform) {
      throw new Error('Scaling constructor error');
    }

    this._camera = camera;
    this._cameraTransform = cameraTransform;
    const defaultAxisOptions = {
      elementStaging,
      vertexStaging,
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(0x9F9F9F),
      picker,
      parentNode,
      tipLength: 2,
      lineLength: 1
    };
    {
      const position = scaling_xAxis;
      this._pxAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](1, 0, 0),
        name: PX_AXIS_NAME,
        radius: 0.6
      });
      this._pxAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._pxAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](0, -1, 0, 1)
      });
    }
    {
      const position = scaling_yAxis;
      this._pyAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](0, 1, 0),
        name: PY_AXIS_NAME,
        radius: 0.6
      });
      this._pyAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._pyAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](1, -1, 0, 0)
      });
    }
    {
      const position = scaling_zAxis;
      this._pzAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](0, 0, 1),
        name: PZ_AXIS_NAME,
        radius: 0.6
      });
      this._pzAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._pzAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](0, 1, 0, 0)
      });
    }
    {
      const position = scaling_xAxis.clone().negate();
      this._nxAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](-1, 0, 0),
        name: NX_AXIS_NAME,
        radius: 0.6
      });
      this._nxAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._nxAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](0, -1, 0, 1)
      });
    }
    {
      const position = scaling_yAxis.clone().negate();
      this._nyAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](0, -1, 0),
        name: NY_AXIS_NAME,
        radius: 0.6
      });
      this._nyAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._nyAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](1, -1, 0, 0)
      });
    }
    {
      const position = scaling_zAxis.clone().negate();
      this._nzAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
        position,
        direction: new math_lib["n" /* Vector3 */](0, 0, -1),
        name: NZ_AXIS_NAME,
        radius: 0.6
      });
      this._nzAxisPlane = new plane_Plane({
        parentNode,
        elementStaging,
        vertexStaging
      });

      this._nzAxisPlane.setTransform({
        position,
        orientation: new math_lib["i" /* Quaternion */](0, 1, 0, 0)
      });
    }
    this._axesWithPlanes = [{
      axis: this._pxAxis,
      plane: this._pxAxisPlane
    }, {
      axis: this._nxAxis,
      plane: this._nxAxisPlane
    }, {
      axis: this._pzAxis,
      plane: this._pzAxisPlane
    }, {
      axis: this._nzAxis,
      plane: this._nzAxisPlane
    }, {
      axis: this._pyAxis,
      plane: this._pyAxisPlane
    }, {
      axis: this._nyAxis,
      plane: this._nyAxisPlane
    }];
    this._hoveredAxisPlane = null;
    this._position = new math_lib["n" /* Vector3 */]();
    this._size = new math_lib["n" /* Vector3 */]();
    this.onDragStart = new global_helpers["b" /* Event */]();
    this.onDragMove = new global_helpers["b" /* Event */]();
    this.onDragEnd = new global_helpers["b" /* Event */]();
    this.onEnter = new global_helpers["b" /* Event */]();
    this.onLeave = new global_helpers["b" /* Event */]();

    this._addListeners();

    Object.seal(this);
  }

  recreate({
    vertexStaging,
    elementStaging
  }) {
    this._axesWithPlanes.forEach(({
      axis,
      plane
    }) => {
      axis.recreate({
        vertexStaging,
        elementStaging
      });
      plane.recreate({
        vertexStaging,
        elementStaging
      });
    });
  }

  _addListeners() {
    this._camera.onEarlyUpdateEnd.subscribe(this._handleUpdateCamera);

    const picker = this._picker;

    this._axesWithPlanes.forEach((axisWithPlane, index) => {
      const {
        node: axisNode
      } = axisWithPlane.axis;
      picker.onPick.subscribe(axisNode, () => this.onEnter.emit(index));
      picker.onEnter.subscribe(axisNode, () => this.onEnter.emit(index));
      picker.onLeave.subscribe(axisNode, () => this.onLeave.emit(index));
      picker.onMissTarget.subscribe(axisNode, () => this.onLeave.emit(index));
      picker.onDragStart.subscribe(axisNode, ({
        hitPosition,
        target
      }) => this._handleDragStart({
        hitPosition,
        target,
        index
      }));
      picker.onDragMove.subscribe(axisNode, this._handleDragMove);
      picker.onDragEnd.subscribe(axisNode, this._handleDragEnd);
    });
  }

  hover(index) {
    this._hoveredAxisPlane = this._axesWithPlanes[index];

    this._hoveredAxisPlane.axis.setMaterialOpacity(1.0);

    this._hoveredAxisPlane.plane.setVisibility(true);
  }

  unHover() {
    if (!this._hoveredAxisPlane) {
      return;
    }

    this._hoveredAxisPlane.axis.setMaterialOpacity(0.5);

    this._hoveredAxisPlane.plane.setVisibility(false);

    this._hoveredAxisPlane = null;
  }

  _handleDragStart({
    target,
    hitPosition,
    index
  }) {
    const cameraPosition = this._cameraTransform.position.clone();

    this._camera.worldMatrix.axisZPaste(cameraPosition);

    switch (target) {
      case this._pxAxis.node:
      case this._nxAxis.node:
        this._updateDraggerNormal(cameraPosition, scaling_yAxis, scaling_zAxis);

        this._dragger.useAxis = ['X'];
        break;

      case this._pyAxis.node:
      case this._nyAxis.node:
        this._updateDraggerNormal(cameraPosition, scaling_xAxis, scaling_zAxis);

        this._dragger.useAxis = ['Y'];
        break;

      case this._pzAxis.node:
      case this._nzAxis.node:
        this._updateDraggerNormal(cameraPosition, scaling_xAxis, scaling_yAxis);

        this._dragger.useAxis = ['Z'];
        break;

      default:
        return;
    }

    const viewPositionV3 = hitPosition.clone().applyHomogeneousMatrix(this._camera.viewProjectionMatrix);
    const viewPositionV2 = new math_lib["m" /* Vector2 */](viewPositionV3.x, viewPositionV3.y);

    this._dragger.start(target, viewPositionV2);

    this.onDragStart.emit(index);
  }

  _updateDraggerNormal(camForward, firstAxis, secondAxis) {
    if (Math.abs(camForward.dot(firstAxis)) > Math.abs(camForward.dot(secondAxis))) {
      this._dragger.normal = firstAxis;
    } else {
      this._dragger.normal = secondAxis;
    }
  }

  _adjustAxisRestriction(axis, negativeAxis, positiveAxis) {
    if (this._size[axis] < 0) {
      this._size[axis] = 0;

      if (this._dragger.node === positiveAxis.node) {
        this._position[axis] = negativeAxis.transform.position[axis];
      } else {
        this._position[axis] = positiveAxis.transform.position[axis];
      }

      return;
    }

    this._position[axis] = (positiveAxis.transform.position[axis] + negativeAxis.transform.position[axis]) / 2;
  }

  _setRestrictionsByScalingArrows() {
    this._size.x = (this._pxAxis.transform.position.x - this._nxAxis.transform.position.x) / 2;
    this._size.y = (this._pyAxis.transform.position.y - this._nyAxis.transform.position.y) / 2;
    this._size.z = (this._pzAxis.transform.position.z - this._nzAxis.transform.position.z) / 2;

    this._adjustAxisRestriction('x', this._nxAxis, this._pxAxis);

    this._adjustAxisRestriction('y', this._nyAxis, this._pyAxis);

    this._adjustAxisRestriction('z', this._nzAxis, this._pzAxis);
  }

  setSize(size) {
    for (const axisPlane of [this._pxAxisPlane, this._nxAxisPlane]) {
      const _size = size.clone();

      _size.z = size.x;
      _size.x = size.z;
      axisPlane.setSize(_size);
    }

    for (const axisPlane of [this._pyAxisPlane, this._nyAxisPlane]) {
      const _size = size.clone();

      _size.z = size.y;
      _size.y = size.z;
      axisPlane.setSize(_size);
    }

    for (const axisPlane of [this._pzAxisPlane, this._nzAxisPlane]) {
      const _size = size.clone().multiplyNumber(2);

      axisPlane.setSize(_size);
    }

    this._size.copy(size);
  }

  getSize() {
    return this._size;
  }

  setTransform({
    position
  }) {
    this._position.copy(position);

    for (const {
      axis,
      plane
    } of this._axesWithPlanes) {
      axis.setTransform({
        position
      });
      plane.setTransform({
        position
      });
    }

    this._pxAxis.transform.position.x += this._size.x;
    this._pxAxisPlane.transform.position.x += this._size.x;
    this._nxAxis.transform.position.x -= this._size.x;
    this._nxAxisPlane.transform.position.x -= this._size.x;
    this._pyAxis.transform.position.y += this._size.y;
    this._pyAxisPlane.transform.position.y += this._size.y;
    this._nyAxis.transform.position.y -= this._size.y;
    this._nyAxisPlane.transform.position.y -= this._size.y;
    this._pzAxis.transform.position.z += this._size.z;
    this._pzAxisPlane.transform.position.z += this._size.z;
    this._nzAxis.transform.position.z -= this._size.z;
    this._nzAxisPlane.transform.position.z -= this._size.z;
  }

  getPosition() {
    return this._position;
  }

  setVisibility(isVisible) {
    this._axesWithPlanes.forEach(({
      axis,
      plane
    }) => {
      axis.setVisibility(isVisible);

      if (!isVisible) {
        plane.setVisibility(false);
      }
    });
  }

}
// CONCATENATED MODULE: ./src/features/section-box/dragger.ts
function dragger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const {
  UPDATE_LOCAL: dragger_UPDATE_LOCAL,
  UPDATE_WORLD: dragger_UPDATE_WORLD
} = lib["jb" /* Transform */].StateMask;
const ndcVector = new math_lib["n" /* Vector3 */]();

function project(camera, ndc, ray) {
  const invProjectionMatrix = camera.projectionMatrix.clone().invert();
  ndcVector.set(ndc.x, ndc.y, -1);
  ray.origin.copy(ndcVector);
  ray.direction.set(0, 0, 1);
  ray.applyHomogeneousMatrix(invProjectionMatrix);
  return ray.applyAffineMatrix(camera.worldMatrix);
}

const tempRay = new math_lib["l" /* Ray3 */]();
const tempVec = new math_lib["n" /* Vector3 */]();
class dragger_Dragger {
  constructor(camera, cameraTransform, normal) {
    dragger_defineProperty(this, "_normal", void 0);

    dragger_defineProperty(this, "_node", void 0);

    dragger_defineProperty(this, "_deltaPos", void 0);

    dragger_defineProperty(this, "_startPosZ", void 0);

    dragger_defineProperty(this, "_camera", void 0);

    dragger_defineProperty(this, "_cameraTransform", void 0);

    dragger_defineProperty(this, "_useX", void 0);

    dragger_defineProperty(this, "_useY", void 0);

    dragger_defineProperty(this, "_useZ", void 0);

    dragger_defineProperty(this, "_position", void 0);

    this._normal = new math_lib["n" /* Vector3 */](0, 0, 1);
    this._node = null;
    this._deltaPos = new math_lib["n" /* Vector3 */]();
    this._startPosZ = 1;
    this._camera = camera;
    this._cameraTransform = cameraTransform;
    this._useX = true;
    this._useY = true;
    this._useZ = true;
    this._position = new math_lib["n" /* Vector3 */]();

    if (normal) {
      this._normal.copy(normal);
    }
  }

  get position() {
    return this._position;
  }

  get node() {
    return this._node;
  }

  set normal(normal) {
    this._normal.copy(normal);
  }

  set useAxis(axises) {
    this._useX = axises.includes('X');
    this._useY = axises.includes('Y');
    this._useZ = axises.includes('Z');
  }

  start(node, ndc) {
    this._node = node;
    const [transform] = node.getComponents([lib["jb" /* Transform */]]);

    if (transform) {
      project(this._camera, ndc, tempRay);
      tempVec.copy(transform.position).subtract(tempRay.origin);

      const denominator = this._normal.dot(tempVec) / this._normal.dot(tempRay.direction);

      tempVec.copy(tempRay.direction).multiplyNumber(denominator).add(tempRay.origin);

      this._deltaPos.copy(transform.position).subtract(tempVec);

      this._startPosZ = tempVec.distance(this._cameraTransform.position);

      this._position.copy(transform.position);
    }
  }

  move(ndc) {
    if (!this._node) {
      return;
    }

    const [transform] = this._node.getComponents([lib["jb" /* Transform */]]);

    if (transform) {
      project(this._camera, ndc, tempRay);
      tempVec.copy(transform.position).subtract(tempRay.origin);

      const denominator = this._normal.dot(tempVec) / this._normal.dot(tempRay.direction);

      if (denominator < 0.0001) {
        return;
      }

      tempVec.copy(tempRay.direction).multiplyNumber(denominator).add(tempRay.origin);

      const distance = tempVec.distance(this._cameraTransform.position) / this._startPosZ;

      if (this._useX) {
        transform.position.x = tempVec.x + this._deltaPos.x * distance;
      }

      if (this._useY) {
        transform.position.y = tempVec.y + this._deltaPos.y * distance;
      }

      if (this._useZ) {
        transform.position.z = tempVec.z + this._deltaPos.z * distance;
      }

      transform.state = dragger_UPDATE_LOCAL | dragger_UPDATE_WORLD;

      this._position.copy(transform.position);
    }
  }

}
// CONCATENATED MODULE: ./src/features/section-box/gizmo.ts
function section_box_gizmo_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const DRAG_AXIS_TIP_LENGTH = 4;
const DRAG_AXIS_LINE_LENGTH = 4;
const DRAG_AXIS_SIZE = DRAG_AXIS_TIP_LENGTH + DRAG_AXIS_LINE_LENGTH;
const X_AXIS_NAME = 'WG_DX';
const Y_AXIS_NAME = 'WG_DY';
const Z_AXIS_NAME = 'WG_DZ';
class section_box_gizmo_Gizmo {
  constructor(options) {
    section_box_gizmo_defineProperty(this, "_dragger", void 0);

    section_box_gizmo_defineProperty(this, "_picker", void 0);

    section_box_gizmo_defineProperty(this, "_camera", void 0);

    section_box_gizmo_defineProperty(this, "_cameraTransform", void 0);

    section_box_gizmo_defineProperty(this, "_dxAxis", void 0);

    section_box_gizmo_defineProperty(this, "_dyAxis", void 0);

    section_box_gizmo_defineProperty(this, "_dzAxis", void 0);

    section_box_gizmo_defineProperty(this, "_axes", void 0);

    section_box_gizmo_defineProperty(this, "_hoveredAxis", void 0);

    section_box_gizmo_defineProperty(this, "_position", void 0);

    section_box_gizmo_defineProperty(this, "_xDirection", new math_lib["n" /* Vector3 */]());

    section_box_gizmo_defineProperty(this, "_yDirection", new math_lib["n" /* Vector3 */]());

    section_box_gizmo_defineProperty(this, "_zDirection", new math_lib["n" /* Vector3 */]());

    section_box_gizmo_defineProperty(this, "onDragStart", void 0);

    section_box_gizmo_defineProperty(this, "onDragMove", void 0);

    section_box_gizmo_defineProperty(this, "onDragEnd", void 0);

    section_box_gizmo_defineProperty(this, "onEnter", void 0);

    section_box_gizmo_defineProperty(this, "onLeave", void 0);

    section_box_gizmo_defineProperty(this, "hitbox", void 0);

    section_box_gizmo_defineProperty(this, "_handleDragStart", ({
      target,
      hitPosition,
      index
    }) => {
      const cameraPosition = this._cameraTransform.position.clone();

      this._camera.worldMatrix.axisZPaste(cameraPosition);

      const getAxisNameByDirection = direction => {
        if (Math.abs(direction.x) === 1 && direction.y === 0 && direction.z === 0) {
          return 'X';
        }

        if (direction.x === 0 && Math.abs(direction.y) === 1 && direction.z === 0) {
          return 'Y';
        }

        if (direction.x === 0 && direction.y === 0 && Math.abs(direction.z) === 1) {
          return 'Z';
        }

        throw new Error('Unexpected axis direction');
      };

      switch (target) {
        case this._dxAxis.node:
          this._setCorrectNormal(cameraPosition, this._yDirection, this._zDirection);

          this._dragger.useAxis = [getAxisNameByDirection(this._dxAxis.getDirection())];
          break;

        case this._dyAxis.node:
          this._setCorrectNormal(cameraPosition, this._xDirection, this._zDirection);

          this._dragger.useAxis = [getAxisNameByDirection(this._dyAxis.getDirection())];
          break;

        case this._dzAxis.node:
          this._setCorrectNormal(cameraPosition, this._xDirection, this._yDirection);

          this._dragger.useAxis = [getAxisNameByDirection(this._dzAxis.getDirection())];
          break;

        default:
          return;
      }

      const viewPositionV3 = hitPosition.clone().applyHomogeneousMatrix(this._camera.viewProjectionMatrix);
      const viewPositionV2 = new math_lib["m" /* Vector2 */](viewPositionV3.x, viewPositionV3.y);

      this._dragger.start(target, viewPositionV2);

      this.onDragStart.emit(index);
    });

    section_box_gizmo_defineProperty(this, "_handleDragMove", ({
      device
    }) => {
      this._dragger.move(device.ndc);

      this.setTransform({
        position: this._dragger.position
      });
      this.onDragMove.emit();
    });

    section_box_gizmo_defineProperty(this, "_handleDragEnd", ({
      device
    }) => {
      this._dragger.move(device.ndc);

      this.setTransform({
        position: this._dragger.position
      });
      this.onDragEnd.emit();
    });

    section_box_gizmo_defineProperty(this, "_handleUpdateCamera", () => {
      const draggingScale = this._cameraTransform.position.distance(this._dxAxis.transform.position) / 64;

      for (const axis of this._axes) {
        axis.setTransform({
          scaleNumber: draggingScale
        });
      }

      const hitBoxScale = new math_lib["n" /* Vector3 */](draggingScale, draggingScale, draggingScale).multiplyNumber(DRAG_AXIS_SIZE * 2);
      this.hitbox.setSize(hitBoxScale);
    });

    const {
      elementStaging,
      vertexStaging,
      parentNode,
      picker,
      dragger,
      cameraNode,
      colors,
      basisMatrix
    } = options;
    this._dragger = dragger;
    this._picker = picker;
    const [cameraTransform, camera] = cameraNode.getComponents([lib["jb" /* Transform */], lib["f" /* Camera */]]);

    if (!camera || !cameraTransform) {
      throw new Error('Gizmo constructor error');
    }

    this._camera = camera;
    this._cameraTransform = cameraTransform;
    const defaultAxisOptions = {
      elementStaging,
      vertexStaging,
      parentNode,
      picker,
      tipLength: DRAG_AXIS_TIP_LENGTH,
      lineLength: DRAG_AXIS_LINE_LENGTH
    };
    this._dxAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
      position: new math_lib["n" /* Vector3 */](),
      color: colors.x,
      name: X_AXIS_NAME,
      radius: 0.4
    });
    this._dyAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
      position: new math_lib["n" /* Vector3 */](),
      color: colors.y,
      name: Y_AXIS_NAME,
      radius: 0.4
    });
    this._dzAxis = new section_box_axis_Axis({ ...defaultAxisOptions,
      position: new math_lib["n" /* Vector3 */](),
      color: colors.z,
      name: Z_AXIS_NAME,
      radius: 0.4
    });
    this._axes = [this._dxAxis, this._dyAxis, this._dzAxis];
    this._hoveredAxis = null;
    this._position = new math_lib["n" /* Vector3 */]();
    this.onDragStart = new global_helpers["b" /* Event */]();
    this.onDragMove = new global_helpers["b" /* Event */]();
    this.onDragEnd = new global_helpers["b" /* Event */]();
    this.onEnter = new global_helpers["b" /* Event */]();
    this.onLeave = new global_helpers["b" /* Event */]();
    this.hitbox = new hitbox_HitBox({
      vertexStaging,
      elementStaging,
      parentNode,
      picker
    });
    this.setVisibility(false);
    this.setBasis(basisMatrix);

    this._addListeners();
  }

  hoverAll() {
    for (const axis of this._axes) {
      axis.setMaterialOpacity(0.5);
    }
  }

  unHoverAll() {
    for (const axis of this._axes) {
      axis.setMaterialOpacity(0.2);
    }
  }

  hover(index) {
    this.unHover();
    this._hoveredAxis = this._axes[index];

    this._hoveredAxis.setMaterialOpacity(1.0);
  }

  unHover() {
    if (!this._hoveredAxis) {
      return;
    }

    this._hoveredAxis.setMaterialOpacity(0.5);

    this._hoveredAxis = null;
  }

  recreate({
    vertexStaging,
    elementStaging
  }) {
    this._axes.forEach(axis => axis.recreate({
      vertexStaging,
      elementStaging
    }));

    this.hitbox.recreate({
      elementStaging,
      vertexStaging
    });
  }

  _addListeners() {
    this._camera.onEarlyUpdateEnd.subscribe(this._handleUpdateCamera);

    const picker = this._picker;

    this._axes.forEach((axis, index) => {
      picker.onEnter.subscribe(axis.node, () => this.onEnter.emit(index));
      picker.onLeave.subscribe(axis.node, () => this.onLeave.emit(index));
      picker.onPick.subscribe(axis.node, () => this.onEnter.emit(index));
      picker.onMissTarget.subscribe(axis.node, () => this.onLeave.emit(index));
      picker.onDragStart.subscribe(axis.node, ({
        hitPosition,
        target
      }) => this._handleDragStart({
        hitPosition,
        target,
        index
      }));
      picker.onDragMove.subscribe(axis.node, this._handleDragMove);
      picker.onDragEnd.subscribe(axis.node, this._handleDragEnd);
    });
  }

  _setCorrectNormal(camForward, firstAxis, secondAxis) {
    if (Math.abs(camForward.dot(firstAxis)) > Math.abs(camForward.dot(secondAxis))) {
      this._dragger.normal = firstAxis;
    } else {
      this._dragger.normal = secondAxis;
    }
  }

  setTransform({
    position
  }) {
    this._position.copy(position);

    for (const dragAxis of this._axes) {
      dragAxis.setTransform({
        position
      });
    }

    this.hitbox.setTransform({
      position
    });
  }

  getPosition() {
    return this._position;
  }

  setVisibility(isVisible) {
    this._axes.forEach(axis => axis.setVisibility(isVisible));
  }

  setBasis(basisMatrix) {
    // Need transpose because axisXPaste/axisYPaste/axisZPaste returns rows not columns
    const transposedBasisMatrix = basisMatrix.clone().transpose();
    const xDirection = transposedBasisMatrix.axisXPaste(new math_lib["n" /* Vector3 */]());
    const yDirection = transposedBasisMatrix.axisYPaste(new math_lib["n" /* Vector3 */]());
    const zDirection = transposedBasisMatrix.axisZPaste(new math_lib["n" /* Vector3 */]());

    this._xDirection.copy(xDirection);

    this._yDirection.copy(yDirection);

    this._zDirection.copy(zDirection);

    this._axes[0].updateDirection(xDirection);

    this._axes[1].updateDirection(yDirection);

    this._axes[2].updateDirection(zDirection);
  }

  setColors(colors) {
    this._axes[0].setColor(colors.x);

    this._axes[1].setColor(colors.y);

    this._axes[2].setColor(colors.z);
  }

}
// CONCATENATED MODULE: ./src/features/section-box/bbox.ts
function bbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






class bbox_BBox extends wg_object_WgObject {
  constructor(options) {
    const {
      parentNode,
      vertexStaging,
      elementStaging,
      picker
    } = options;
    const material = new lib["z" /* LineMaterial */]({
      name: 'line-box-material',
      opacity: 0.3,
      // alphaMode: Material.AlphaMode.BLEND,
      color: new math_lib["k" /* RGBColor */]().fromPackedInteger(0x9F9F9F)
    });
    super({
      name: '',
      parentNode,
      material
    });

    bbox_defineProperty(this, "hitBox", void 0);

    this.hitBox = new hitbox_HitBox({
      vertexStaging,
      elementStaging,
      parentNode,
      picker,
      name: 'HitBoxOfSectionBox',
      hoverable: false
    });

    this._create({
      vertexStaging,
      elementStaging
    });
  }

  _create({
    vertexStaging,
    elementStaging
  }) {
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);

    if (!transform) {
      throw new Error('Transform is null');
    }

    this.transform = transform;
    const material = this._material;

    this._createLine(new math_lib["n" /* Vector3 */](1, 1, -1), new math_lib["i" /* Quaternion */](), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, -1, -1), new math_lib["i" /* Quaternion */](), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](-1, 1, -1), new math_lib["i" /* Quaternion */](), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](-1, -1, -1), new math_lib["i" /* Quaternion */](), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, -1, 1), new math_lib["i" /* Quaternion */](0.707, 0.707, 0, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, -1, -1), new math_lib["i" /* Quaternion */](0.707, 0.707, 0, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](-1, -1, 1), new math_lib["i" /* Quaternion */](0.707, 0.707, 0, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](-1, -1, -1), new math_lib["i" /* Quaternion */](0.707, 0.707, 0, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, 1, 1), new math_lib["i" /* Quaternion */](0.707, 0, 0.707, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, 1, -1), new math_lib["i" /* Quaternion */](0.707, 0, 0.707, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, -1, 1), new math_lib["i" /* Quaternion */](0.707, 0, 0.707, 0), material, vertexStaging, elementStaging);

    this._createLine(new math_lib["n" /* Vector3 */](1, -1, -1), new math_lib["i" /* Quaternion */](0.707, 0, 0.707, 0), material, vertexStaging, elementStaging);
  }

  _createLine(position, orientation, material, vertexStaging, elementStaging) {
    const line = Object(procedural_geometry_src["b" /* createLine */])({
      vertexStaging,
      material,
      length: 2
    });
    const transform = new lib["jb" /* Transform */]({
      position,
      orientation
    });
    const node = this.node.createChild({
      name: 'line'
    });
    node.attach(line);
    node.attach(transform);
  }

  setTransform(transform) {
    super.setTransform(transform);
    this.hitBox.setTransform(transform);
  }

  setSize(size) {
    this.setTransform({
      scale: size
    });
  }

}
// CONCATENATED MODULE: ./src/features/section-box/index.ts
function features_section_box_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const section_box_$rendererTag = Symbol('sectionBox');
class section_box_SectionBox {
  constructor(options) {
    features_section_box_defineProperty(this, "_sectionBoxContainer", void 0);

    features_section_box_defineProperty(this, "_hitboxHovered", void 0);

    features_section_box_defineProperty(this, "_structure", void 0);

    features_section_box_defineProperty(this, "_scaling", void 0);

    features_section_box_defineProperty(this, "_controls", void 0);

    features_section_box_defineProperty(this, "_dragger", void 0);

    features_section_box_defineProperty(this, "_center", void 0);

    features_section_box_defineProperty(this, "_picker", void 0);

    features_section_box_defineProperty(this, "_layers", void 0);

    features_section_box_defineProperty(this, "_store", void 0);

    features_section_box_defineProperty(this, "_gizmo", void 0);

    features_section_box_defineProperty(this, "_core", void 0);

    features_section_box_defineProperty(this, "_bbox", void 0);

    features_section_box_defineProperty(this, "_size", void 0);

    features_section_box_defineProperty(this, "_min", void 0);

    features_section_box_defineProperty(this, "_max", void 0);

    features_section_box_defineProperty(this, "_handleSectionBoxEnter", () => {
      this._hitboxHovered = true;

      this._updateVisibility();

      this._bbox.setMaterialOpacity(1.0);

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleSectionBoxLeave", () => {
      if (!this._store.sectionBox.enabled) {
        return;
      }

      this._hitboxHovered = false;

      this._updateVisibility();

      this._bbox.setMaterialOpacity(0.5);

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleScalingEnter", id => {
      this._gizmo.unHover();

      this._scaling.unHover();

      this._scaling.hover(id);

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleScalingLeave", () => {
      this._scaling.unHover();

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleScalingStart", () => {
      this._startUpdating();
    });

    features_section_box_defineProperty(this, "_handleScalingMove", () => {
      this._size.copy(this._scaling.getSize());

      this._center.copy(this._scaling.getPosition());

      this._min.copy(this._center).subtract(this._size);

      this._max.copy(this._center).add(this._size);

      this._updateVisual();
    });

    features_section_box_defineProperty(this, "_handleScalingEnd", () => {
      this._endUpdating();
    });

    features_section_box_defineProperty(this, "_handleGizmoEnter", id => {
      this._gizmo.hover(id);

      this._scaling.unHover();

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleGizmoLeave", () => {
      this._gizmo.unHover();

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleHitBoxGizmoEnter", () => {
      this._gizmo.hoverAll();

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleHitBoxGizmoLeave", () => {
      this._gizmo.unHoverAll();

      this._updateLayers();
    });

    features_section_box_defineProperty(this, "_handleGizmoStart", () => {
      this._startUpdating();
    });

    features_section_box_defineProperty(this, "_handleGizmoMove", () => {
      this._center.copy(this._gizmo.getPosition());

      this._min.copy(this._center).subtract(this._size);

      this._max.copy(this._center).add(this._size);

      this._updateVisual();
    });

    features_section_box_defineProperty(this, "_handleGizmoEnd", () => {
      this._center.copy(this._gizmo.getPosition());

      this._min.copy(this._center).subtract(this._size);

      this._max.copy(this._center).add(this._size);

      this._updateVisual();

      this._endUpdating();
    });

    features_section_box_defineProperty(this, "_unHoverAll", () => {
      this._gizmo.unHover();

      this._scaling.unHover();
    });

    features_section_box_defineProperty(this, "_updateVisual", () => {
      this._bbox.setSize(this._size);

      this._bbox.hitBox.setSize(this._size.clone().multiplyNumber(2.5));

      this._scaling.setSize(this._size);

      for (const object of [this._gizmo, this._bbox, this._scaling]) {
        object.setTransform({
          position: this._center
        });
      }

      this._updateMaterials();
    });

    const {
      core,
      controls,
      layers,
      picker,
      store,
      structure
    } = options;
    this._dragger = new dragger_Dragger(controls.camera, controls.cameraTransform, new math_lib["n" /* Vector3 */](0, 1, 0));
    this._structure = structure;
    this._controls = controls;
    this._picker = picker;
    this._layers = layers;
    this._core = core;
    this._store = store;
    this._size = new math_lib["n" /* Vector3 */](1, 1, 1);
    this._center = new math_lib["n" /* Vector3 */]();
    this._min = new math_lib["n" /* Vector3 */](-1, -1, -1);
    this._max = new math_lib["n" /* Vector3 */](1, 1, 1);

    if (!layers.layer3dService.scene) {
      throw new Error('Service scene does\'nt exist');
    }

    this._sectionBoxContainer = layers.layer3dService.scene.root.createChild({
      name: 'section-box-container'
    });
    const {
      elementStaging,
      vertexStaging
    } = layers.layer3dService.renderer;
    this._gizmo = new section_box_gizmo_Gizmo({
      elementStaging,
      vertexStaging,
      cameraNode: controls.cameraNode,
      picker,
      dragger: this._dragger,
      basisMatrix: this._store.axes.coordinateSystemMatrix,
      colors: this._store.axes.axesColors,
      parentNode: this._sectionBoxContainer
    });
    this._scaling = new scaling_ScalingAxes({
      elementStaging,
      vertexStaging,
      cameraNode: controls.cameraNode,
      picker,
      dragger: this._dragger,
      parentNode: this._sectionBoxContainer
    });
    this._bbox = new bbox_BBox({
      parentNode: this._sectionBoxContainer,
      elementStaging,
      vertexStaging,
      picker
    });
    this._hitboxHovered = false;

    this._updateVisibility();

    this._updateLayers();

    this._addListeners();
  }

  _addListeners() {
    this._gizmo.onDragStart.subscribe(id => {
      this._handleGizmoEnter(id);

      this._handleGizmoStart();
    });

    this._gizmo.onDragMove.subscribe(this._handleGizmoMove);

    this._gizmo.onDragEnd.subscribe(this._handleGizmoEnd);

    this._gizmo.onEnter.subscribe(this._handleGizmoEnter);

    this._gizmo.onLeave.subscribe(this._handleGizmoLeave);

    this._gizmo.hitbox.onEnter.subscribe(this._handleHitBoxGizmoEnter);

    this._gizmo.hitbox.onLeave.subscribe(this._handleHitBoxGizmoLeave);

    this._picker.onDeHover.subscribe(this._unHoverAll);

    this._scaling.onDragStart.subscribe(id => {
      this._handleScalingEnter(id);

      this._handleScalingStart();
    });

    this._scaling.onDragMove.subscribe(this._handleScalingMove);

    this._scaling.onDragEnd.subscribe(this._handleScalingEnd);

    this._scaling.onEnter.subscribe(this._handleScalingEnter);

    this._scaling.onLeave.subscribe(this._handleScalingLeave);

    this._picker.onEnter.subscribe(this._sectionBoxContainer, this._handleSectionBoxEnter);

    this._picker.onLeave.subscribe(this._sectionBoxContainer, this._handleSectionBoxLeave);

    Object(mobx_module["h" /* reaction */])(() => this._store.axes.coordinateSystemMatrix, coordinateSystemMatrix => {
      this._gizmo.setBasis(coordinateSystemMatrix);

      if (this._store.sectionBox.enabled) {
        this._layers.layer3dService.setNeedsDrawOnce(section_box_$rendererTag);
      }
    });
    Object(mobx_module["c" /* autorun */])(() => {
      this._gizmo.setColors(this._store.axes.axesColors);

      this._layers.layer3dService.setNeedsDrawOnce(section_box_$rendererTag);
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.hover.hoveredObject, hoveredObject => {
      if (hoveredObject) {
        this._unHoverAll();
      }
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.hover.measuredHover, measureHovered => {
      if (measureHovered) {
        this._unHoverAll();

        this._updateLayers();
      }
    });
    Object(mobx_module["h" /* reaction */])(() => this._store.sectionBox.restrictions, sectionBox => {
      if (!this._store.sectionBox.enabled) {
        return;
      }

      this._setBox(sectionBox); // Origin Restrictions { min: Vector3|null; max: Vector3|null }

    });
    Object(mobx_module["h" /* reaction */])(() => this._store.sectionBox.enabled, () => {
      this._updateVisibility(true); // Once enabled, force to show arrows and gizmos IV-724


      this._updateLayers(true);
    });

    this._layers.layer3dService.onStagingsRecreated.subscribe(({
      elementStaging,
      vertexStaging
    }) => {
      this._bbox.recreate({
        elementStaging,
        vertexStaging
      });

      this._bbox.hitBox.recreate({
        elementStaging,
        vertexStaging
      });

      this._gizmo.recreate({
        elementStaging,
        vertexStaging
      });

      this._scaling.recreate({
        elementStaging,
        vertexStaging
      });

      this._updateVisibility();

      this._updateLayers();
    });
  } // Section box handlers:


  _setBox(box) {
    const {
      min,
      max
    } = box;
    const size = new math_lib["n" /* Vector3 */]();
    const center = new math_lib["n" /* Vector3 */](); // size components must be positive values

    size.copy(max).subtract(min).multiplyNumber(0.5).abs();
    center.copy(max).add(min).multiplyNumber(0.5);

    this._size.copy(size);

    this._center.copy(center);

    this._min.copy(this._center).subtract(this._size);

    this._max.copy(this._center).add(this._size);

    this._updateVisual();

    this._updateLayers(true);
  }

  _updateMaterials() {
    const min = this._store.sectionBox.enabled ? this._min : new math_lib["n" /* Vector3 */]();
    const max = this._store.sectionBox.enabled ? this._max : new math_lib["n" /* Vector3 */]();

    for (const material of this._core.getResourceMap('material').values()) {
      if (!(material instanceof resources_materials["b" /* IndustrialPbrMeshMaterial */] || material instanceof resources_materials["c" /* IndustrialUnlitMeshMaterial */])) {
        continue;
      }

      material.boxOccluderMin = min;
      material.boxOccluderMax = max;
    } // Update points materials


    const points = this._structure.getGroup('points');

    if (!points) {
      return;
    }

    for (const point of points) {
      const material = point.material;
      material.boxOccluderMin = min;
      material.boxOccluderMax = max;
    }

    this._layers.layer3dPoints.setNeedsDrawOnce(section_box_$rendererTag);
  }

  _startUpdating() {
    this._controls.disable();

    this._layers.layer3dMain.setNeedsDrawPermanent(section_box_$rendererTag, true);

    this._layers.layer3dService.setNeedsDrawPermanent(section_box_$rendererTag, true);
  }

  _endUpdating() {
    this._controls.enable();

    this._layers.layer3dMain.setNeedsDrawPermanent(section_box_$rendererTag, false);

    this._layers.layer3dService.setNeedsDrawPermanent(section_box_$rendererTag, false);

    this._layers.layer3dMain.setNeedsDrawOnce(section_box_$rendererTag);

    this._layers.layer3dService.setNeedsDrawOnce(section_box_$rendererTag);

    this._store.sectionBox.updateRestrictions(this._min, this._max);
  }

  _updateVisibility(forceToolsVisiblity = false) {
    Object(global_helpers["u" /* ignoreRaycastNode */])(this._sectionBoxContainer, !this._store.sectionBox.enabled);
    const isToolsVisible = forceToolsVisiblity || !src.desktop || this._hitboxHovered;

    this._gizmo.setVisibility(this._store.sectionBox.enabled && isToolsVisible);

    this._scaling.setVisibility(this._store.sectionBox.enabled && isToolsVisible);

    this._bbox.setVisibility(this._store.sectionBox.enabled);

    this._updateMaterials();
  }

  _updateLayers(main = false) {
    if (main) {
      this._layers.layer3dMain.setNeedsDrawOnce(section_box_$rendererTag);
    }

    this._layers.layer3dService.setNeedsDrawOnce(section_box_$rendererTag);
  }

}
// CONCATENATED MODULE: ./src/features/performance/utils.ts
function performance_utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FrameRate {
  constructor(length = 20) {
    performance_utils_defineProperty(this, "_frames", []);

    performance_utils_defineProperty(this, "_length", void 0);

    performance_utils_defineProperty(this, "_cursor", 0);

    performance_utils_defineProperty(this, "_filterBuffer", [0, 0, 0]);

    this._length = length;
  }

  get frames() {
    return this._frames;
  }

  push(value) {
    this._frames[this._cursor++] = value;
    this._cursor %= this._length;
  }

  get averageTime() {
    return this._frames.reduce((sum, val) => sum + val) / this._frames.length;
  }

  get averageRate() {
    return 1000 / this.averageTime;
  }

  get filteredTime() {
    const arr = this._frames;
    const framesSum = arr.reduce((sum, val, i) => {
      this._filterBuffer[0] = arr[(arr.length + i - 1) % arr.length];
      this._filterBuffer[1] = val;
      this._filterBuffer[2] = arr[(i + 1) % arr.length];

      this._filterBuffer.sort();

      return sum + this._filterBuffer[1];
    });
    return framesSum / arr.length;
  }

}
// EXTERNAL MODULE: ./src/global-helpers/math.ts
var math = __webpack_require__(73);

// CONCATENATED MODULE: ./src/features/performance/index.ts
function performance_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types */



const DRAWCALLS_MIN_LIMIT = 256;
const MAX_IDLE_FRAME = 1000 / 60; //   144 ,       60

class performance_Performance {
  constructor({
    layers,
    store
  }) {
    performance_defineProperty(this, "_layers", void 0);

    performance_defineProperty(this, "_store", void 0);

    performance_defineProperty(this, "_lastTime", 0);

    performance_defineProperty(this, "_lastLayerState", DrawingState.IDLE);

    performance_defineProperty(this, "_idleRate", new FrameRate());

    performance_defineProperty(this, "_drawRate", new FrameRate(10));

    performance_defineProperty(this, "_optimalDrawcalls", 0);

    performance_defineProperty(this, "_lastGoodDrawcalls", 0);

    performance_defineProperty(this, "_onDrawStart", time => {
      if (this._store.load.isLoaded === false) {
        return;
      }

      if (this._store.renderer.progressiveRenderer.enabled === false) {
        return;
      }

      if (this._store.renderer.progressiveRendererAuto === false) {
        return;
      }

      const frameTime = time - this._lastTime;
      this._lastTime = time;
      const drawingState = this._lastLayerState;
      const mainLayer = this._layers.layer3dMain;
      this._lastLayerState = mainLayer.drawingState;

      if (drawingState === DrawingState.IDLE) {
        this._idleRate.push(frameTime);
      }

      if (drawingState === DrawingState.DRAWING) {
        this._drawRate.push(frameTime);

        const avgTime = Math.max(this._idleRate.averageTime, MAX_IDLE_FRAME);
        const avgDrawing = this._drawRate.filteredTime;

        if (avgTime > 100) {
          return;
        } //  IDLE  ,      


        const {
          progressiveRenderer
        } = this._store.renderer;
        let {
          maxDrawcalls
        } = progressiveRenderer;
        const GOOD_FPS = avgTime * 1.01;

        if (avgDrawing < GOOD_FPS) {
          //    (  ),    
          this._optimalDrawcalls = 0;
          this._lastGoodDrawcalls = Object(math["a" /* clamp */])(maxDrawcalls, DRAWCALLS_MIN_LIMIT, this.totalDrawcalls);
          maxDrawcalls += Math.ceil(this.totalDrawcalls / 1000);
        }

        const BAD_FPS = avgTime * 1.5;

        if (GOOD_FPS <= avgDrawing && avgDrawing < BAD_FPS) {
          //     ,    ,     
          if (!this._optimalDrawcalls) {
            this._optimalDrawcalls = this._lastGoodDrawcalls;
            maxDrawcalls = this._optimalDrawcalls;
          }
        }

        if (avgDrawing > BAD_FPS) {
          //   ,   
          maxDrawcalls--;
        }

        const EXTREMELY_BAD_FPS = avgTime * 2;

        if (avgDrawing > EXTREMELY_BAD_FPS) {
          //   ,    
          this._optimalDrawcalls = 0;

          if (this._lastGoodDrawcalls > maxDrawcalls * 0.8) {
            // this._lastGoodDrawcalls = 0;
            this._lastGoodDrawcalls = Math.floor(this._lastGoodDrawcalls * 0.8);
          }

          maxDrawcalls = this._lastGoodDrawcalls;
        }

        progressiveRenderer.maxDrawcalls = Object(math["a" /* clamp */])(maxDrawcalls, DRAWCALLS_MIN_LIMIT, this.totalDrawcalls);

        this._store.renderer.setProgressiveRenderer(progressiveRenderer);
      }
    });

    this._layers = layers;
    this._store = store;

    this._addListeners();
  }

  _addListeners() {
    this._layers.onDrawStart.subscribe(this._onDrawStart);
  }

  get totalDrawcalls() {
    var _this$_layers;

    return (_this$_layers = this._layers) === null || _this$_layers === void 0 ? void 0 : _this$_layers.layer3dMain.queueLength;
  }

}
// CONCATENATED MODULE: ./src/features/navigation-cube/arrow.ts
function arrow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const arrow_Axis = {
  X: new math_lib["n" /* Vector3 */](1, 0, 0),
  Y: new math_lib["n" /* Vector3 */](0, 1, 0),
  Z: new math_lib["n" /* Vector3 */](0, 0, 1)
};
const axisOrientation = new math_lib["i" /* Quaternion */]().fromRotation(Math.PI / 4, arrow_Axis.Y);
const $arrowVisibility = Symbol('arrowVisibility');

class arrow_Arrow extends wg_object_WgObject {
  constructor(options) {
    const {
      name,
      position,
      orientation,
      color,
      picker,
      radius,
      height,
      parentNode,
      vertexStaging,
      elementStaging,
      onClick,
      view,
      size,
      disabled = false
    } = options;
    const material = new lib["lb" /* UnlitMeshMaterial */]({
      name: `arrow-material-${name}`,
      alphaMode: lib["D" /* Material */].AlphaMode.BLEND,
      cullFace: lib["D" /* Material */].CullFace.BACK,
      opacity: 0.5,
      color
    });
    super({
      parentNode,
      material,
      name
    });

    arrow_defineProperty(this, "name", void 0);

    arrow_defineProperty(this, "view", void 0);

    arrow_defineProperty(this, "_picker", void 0);

    arrow_defineProperty(this, "_radius", void 0);

    arrow_defineProperty(this, "_height", void 0);

    arrow_defineProperty(this, "_disabled", void 0);

    arrow_defineProperty(this, "_visible", void 0);

    this._picker = picker;
    this._radius = radius;
    this._height = height;
    this._disabled = disabled;
    this._visible = false;
    this.name = name;
    this.view = view;
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);
    this.transform = transform;
    const scale = new math_lib["n" /* Vector3 */](size, size, size);
    orientation.preMultiplyQuaternion(axisOrientation);
    this.setTransform({
      position,
      orientation,
      scale
    });

    this._create({
      vertexStaging,
      elementStaging
    });

    this._picker.onPick.subscribe(this.node, onClick);

    Object.seal(this);
  }

  get disabled() {
    return this._disabled;
  }

  set disabled(value) {
    if (value) {
      this._visible = false;
      this.setVisibility(false);
    }

    this._disabled = value;
  }

  _create(stagings) {
    const {
      vertexStaging,
      elementStaging
    } = stagings;
    const cylinder = createUnlitCylinderMesh({
      material: this._material,
      radiusTop: this._radius * 0.01,
      radiusBottom: this._radius,
      radialSegments: 4,
      height: this._height,
      vertexStaging,
      elementStaging
    });
    const [transform] = this.node.getComponents([lib["jb" /* Transform */]]);
    this.transform = transform;
    this.node.attach(cylinder);
    this.setVisibility(false, $arrowVisibility);
  }

  unsubscribe() {
    this._picker.onPick.unsubscribeTarget(this.node);
  }

  show() {
    if (this._visible || this._disabled) {
      return;
    }

    this._visible = true;
    this.setVisibility(true, $arrowVisibility);
  }

  hide() {
    if (!this._visible || this._disabled) {
      return;
    }

    this._visible = false;
    this.setVisibility(false, $arrowVisibility);
  }

}


// CONCATENATED MODULE: ./src/features/navigation-cube/view.ts
let View;

(function (View) {
  View["TOP"] = "o_top";
  View["BOTTOM"] = "o_bottom";
  View["LEFT"] = "o_left";
  View["RIGHT"] = "o_right";
  View["FRONT"] = "o_front";
  View["BACK"] = "o_back";
  View["EDGE_TOP_LEFT"] = "o_top_left";
  View["EDGE_TOP_RIGHT"] = "o_top_right";
  View["EDGE_TOP_FRONT"] = "o_top_front";
  View["EDGE_TOP_BACK"] = "o_top_back";
  View["EDGE_BOTTOM_LEFT"] = "o_bottom_left";
  View["EDGE_BOTTOM_RIGHT"] = "o_bottom_right";
  View["EDGE_BOTTOM_FRONT"] = "o_bottom_front";
  View["EDGE_BOTTOM_BACK"] = "o_bottom_back";
  View["EDGE_LEFT_FRONT"] = "o_left_front";
  View["EDGE_RIGHT_FRONT"] = "o_right_front";
  View["EDGE_LEFT_BACK"] = "o_left_back";
  View["EDGE_RIGHT_BACK"] = "o_right_back";
  View["CORNER_TOP_LEFT_FRONT"] = "o_top_left_front";
  View["CORNER_TOP_RIGHT_FRONT"] = "o_top_right_front";
  View["CORNER_TOP_LEFT_BACK"] = "o_top_left_back";
  View["CORNER_TOP_RIGHT_BACK"] = "o_top_right_back";
  View["CORNER_BOTTOM_LEFT_FRONT"] = "o_bottom_left_front";
  View["CORNER_BOTTOM_RIGHT_FRONT"] = "o_bottom_right_front";
  View["CORNER_BOTTOM_LEFT_BACK"] = "o_bottom_left_back";
  View["CORNER_BOTTOM_RIGHT_BACK"] = "o_bottom_right_back";
})(View || (View = {}));

const conjugatedViews = {
  [View.TOP]: new Set([View.LEFT, View.BACK, View.RIGHT, View.FRONT]),
  [View.BOTTOM]: new Set([View.LEFT, View.FRONT, View.RIGHT, View.BACK]),
  [View.LEFT]: new Set([View.BACK, View.TOP, View.FRONT, View.BOTTOM]),
  [View.RIGHT]: new Set([View.FRONT, View.TOP, View.BACK, View.BOTTOM]),
  [View.BACK]: new Set([View.RIGHT, View.TOP, View.LEFT, View.BOTTOM]),
  [View.FRONT]: new Set([View.LEFT, View.TOP, View.RIGHT, View.BOTTOM])
};
// CONCATENATED MODULE: ./src/features/navigation-cube/models/navigation-cube.glb
/* harmony default export */ var navigation_cube = ("data:model/gltf-binary;base64,Z2xURgIAAADsqQAA5EwAAEpTT057ImFzc2V0Ijp7InZlcnNpb24iOiIyLjAifSwiZXh0ZW5zaW9uc1VzZWQiOlsiS0hSX21hdGVyaWFsc191bmxpdCIsIldHX21hdGVyaWFsX2RlcHRoX3Byb3BlcnRpZXMiLCJXR19jbGVhcl9jb2F0Il0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI2LCJ0eXBlIjoiVkVDMiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI2LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI2LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MywiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjcyLCJ0eXBlIjoiU0NBTEFSIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6NDIsInR5cGUiOiJWRUMyIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo1LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6NDIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo2LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6NDIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo3LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTIwLCJ0eXBlIjoiU0NBTEFSIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMyIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3Ijo5LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoxMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEyLCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MTEsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozMCwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MTIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxMiwidHlwZSI6IlZFQzIiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjEzLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoxNCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEyLCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MTUsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozMCwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MTYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOSwidHlwZSI6IlZFQzIiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjE3LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTksInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoxOCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE5LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MTksImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo1MSwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxMzAsInR5cGUiOiJWRUMyIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoyMSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjIyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTMwLCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MjMsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNzgsInR5cGUiOiJTQ0FMQVIiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjI0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MzY0LCJ0eXBlIjoiVkVDMiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MjUsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjozNjQsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjoyNiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjM2NCwidHlwZSI6IlZFQzMiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjI3LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTAxNCwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MjgsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo5LCJ0eXBlIjoiVkVDMiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MjksImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo5LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo5LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzEsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoyNCwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4LCJ0eXBlIjoiVkVDMiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzMsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzQsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4LCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzUsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMiwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxMiwidHlwZSI6IlZFQzIiLCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlclZpZXciOjM3LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXJWaWV3IjozOCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEyLCJ0eXBlIjoiVkVDMyIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MzksImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxOCwidHlwZSI6IlNDQUxBUiIsImJ5dGVPZmZzZXQiOjB9XSwiYnVmZmVycyI6W3sibmFtZSI6ImJ1ZmZlcnMvbWFpbiIsImJ5dGVMZW5ndGgiOjIzNzg4fV0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjgsImJ5dGVMZW5ndGgiOjIwOCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjozMTIsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjIwOH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjozMTIsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjUyMH0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjE0NCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6ODMyfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6OCwiYnl0ZUxlbmd0aCI6MzM2LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0Ijo5NzZ9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6NTA0LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjoxMzEyfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjUwNCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MTgxNn0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjI0MCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6MjMyMH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjgsImJ5dGVMZW5ndGgiOjk2LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjoyNTYwfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjE0NCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MjY1Nn0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNDQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjI4MDB9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo2MCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6Mjk0NH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjgsImJ5dGVMZW5ndGgiOjk2LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjozMDA0fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjE0NCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MzEwMH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNDQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjMyNDR9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo2MCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6MzM4OH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjgsImJ5dGVMZW5ndGgiOjE1MiwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MzQ0OH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoyMjgsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjM2MDB9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6MjI4LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjozODI4fSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MTAyLCJ0YXJnZXQiOjM0OTYzLCJieXRlT2Zmc2V0Ijo0MDU2fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6OCwiYnl0ZUxlbmd0aCI6MTA0MCwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6NDE2MH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNTYwLCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0Ijo1MjAwfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjE1NjAsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjY3NjB9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo3NTYsInRhcmdldCI6MzQ5NjMsImJ5dGVPZmZzZXQiOjgzMjB9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjo4LCJieXRlTGVuZ3RoIjoyOTEyLCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0Ijo5MDc2fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjQzNjgsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjExOTg4fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjQzNjgsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjE2MzU2fSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MjAyOCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6MjA3MjR9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjo4LCJieXRlTGVuZ3RoIjo3MiwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MjI3NTJ9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6MTA4LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjoyMjgyNH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxMDgsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjIyOTMyfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6NDgsInRhcmdldCI6MzQ5NjMsImJ5dGVPZmZzZXQiOjIzMDQwfSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6OCwiYnl0ZUxlbmd0aCI6NjQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjIzMDg4fSx7ImJ1ZmZlciI6MCwiYnl0ZVN0cmlkZSI6MTIsImJ5dGVMZW5ndGgiOjk2LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjoyMzE1Mn0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjo5NiwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MjMyNDh9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjoyNCwidGFyZ2V0IjozNDk2MywiYnl0ZU9mZnNldCI6MjMzNDR9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjo4LCJieXRlTGVuZ3RoIjo5NiwidGFyZ2V0IjozNDk2MiwiYnl0ZU9mZnNldCI6MjMzNjh9LHsiYnVmZmVyIjowLCJieXRlU3RyaWRlIjoxMiwiYnl0ZUxlbmd0aCI6MTQ0LCJ0YXJnZXQiOjM0OTYyLCJieXRlT2Zmc2V0IjoyMzQ2NH0seyJidWZmZXIiOjAsImJ5dGVTdHJpZGUiOjEyLCJieXRlTGVuZ3RoIjoxNDQsInRhcmdldCI6MzQ5NjIsImJ5dGVPZmZzZXQiOjIzNjA4fSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MzYsInRhcmdldCI6MzQ5NjMsImJ5dGVPZmZzZXQiOjIzNzUyfV0sIm1hdGVyaWFscyI6W3sibmFtZSI6Im1hdF9jb21wYXMiLCJhbHBoYU1vZGUiOiJCTEVORCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMjM5MjE1Njg2Mjc0NTA5ODEsMC4yMzkyMTU2ODYyNzQ1MDk4MSwwLjIzOTIxNTY4NjI3NDUwOTgxLDAuMzJdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e319LCJlbWlzc2l2ZUZhY3RvciI6WzAsMCwwXSwiZG91YmxlU2lkZWQiOmZhbHNlfSx7Im5hbWUiOiJtYXRfdGV4dCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNDksMC40OSwwLjQ5LDFdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e319LCJlbWlzc2l2ZUZhY3RvciI6WzAsMCwwXSwiYWxwaGFNb2RlIjoiT1BBUVVFIiwiZG91YmxlU2lkZWQiOmZhbHNlfSx7Im5hbWUiOiJtYXRfaW52aXMiLCJhbHBoYU1vZGUiOiJCTEVORCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMjQsMC4yNCwwLjI0LDAuMzJdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e30sIldHX21hdGVyaWFsX2RlcHRoX3Byb3BlcnRpZXMiOnsid3JpdGUiOmZhbHNlfX0sImVtaXNzaXZlRmFjdG9yIjpbMCwwLDBdLCJkb3VibGVTaWRlZCI6ZmFsc2V9LHsibmFtZSI6Im1hdF9ncmF5IiwiYWxwaGFNb2RlIjoiQkxFTkQiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjUyLDAuNTIsMC41MiwwLjM3XSwiZXh0ZW5zaW9ucyI6eyJXR19jbGVhcl9jb2F0Ijp7fX0sIm1ldGFsbGljRmFjdG9yIjoxLCJyb3VnaG5lc3NGYWN0b3IiOjF9LCJleHRlbnNpb25zIjp7IktIUl9tYXRlcmlhbHNfdW5saXQiOnt9LCJXR19tYXRlcmlhbF9kZXB0aF9wcm9wZXJ0aWVzIjp7IndyaXRlIjpmYWxzZX19LCJlbWlzc2l2ZUZhY3RvciI6WzAsMCwwXSwiZG91YmxlU2lkZWQiOmZhbHNlfSx7Im5hbWUiOiJtYXRfd2hpdGUiLCJhbHBoYU1vZGUiOiJCTEVORCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNjIsMC42MiwwLjYyLDAuNTRdLCJleHRlbnNpb25zIjp7IldHX2NsZWFyX2NvYXQiOnt9fSwibWV0YWxsaWNGYWN0b3IiOjEsInJvdWdobmVzc0ZhY3RvciI6MX0sImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e30sIldHX21hdGVyaWFsX2RlcHRoX3Byb3BlcnRpZXMiOnsid3JpdGUiOmZhbHNlfX0sImVtaXNzaXZlRmFjdG9yIjpbMCwwLDBdLCJkb3VibGVTaWRlZCI6ZmFsc2V9XSwibWVzaGVzIjpbeyJuYW1lIjoib19jb21wYXNfbnciLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozLCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MiwiUE9TSVRJT04iOjEsIlRFWENPT1JEXzAiOjB9LCJtYXRlcmlhbCI6MCwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX2NvbXBhc19udyIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjMsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjoyLCJQT1NJVElPTiI6MSwiVEVYQ09PUkRfMCI6MH0sIm1hdGVyaWFsIjowLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fY29tcGFzX253IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MywiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjIsIlBPU0lUSU9OIjoxLCJURVhDT09SRF8wIjowfSwibWF0ZXJpYWwiOjAsIm1vZGUiOjR9XX0seyJuYW1lIjoib19jb21wYXNfbnciLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozLCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MiwiUE9TSVRJT04iOjEsIlRFWENPT1JEXzAiOjB9LCJtYXRlcmlhbCI6MCwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RleHRfcyIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjcsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjo2LCJQT1NJVElPTiI6NSwiVEVYQ09PUkRfMCI6NH0sIm1hdGVyaWFsIjoxLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fdGV4dF9lIiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MTEsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjoxMCwiUE9TSVRJT04iOjksIlRFWENPT1JEXzAiOjh9LCJtYXRlcmlhbCI6MSwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RleHRfbiIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjE1LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MTQsIlBPU0lUSU9OIjoxMywiVEVYQ09PUkRfMCI6MTJ9LCJtYXRlcmlhbCI6MSwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RleHRfdyIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjE5LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MTgsIlBPU0lUSU9OIjoxNywiVEVYQ09PUkRfMCI6MTZ9LCJtYXRlcmlhbCI6MSwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RleHRfYm90dG9tIiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MjMsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjoyMiwiUE9TSVRJT04iOjIxLCJURVhDT09SRF8wIjoyMH0sIm1hdGVyaWFsIjoxLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fdGV4dCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjI3LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MjYsIlBPU0lUSU9OIjoyNSwiVEVYQ09PUkRfMCI6MjR9LCJtYXRlcmlhbCI6MSwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzEsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozMCwiUE9TSVRJT04iOjI5LCJURVhDT09SRF8wIjoyOH0sIm1hdGVyaWFsIjoyLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozMSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjMwLCJQT1NJVElPTiI6MjksIlRFWENPT1JEXzAiOjI4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozMSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjMwLCJQT1NJVElPTiI6MjksIlRFWENPT1JEXzAiOjI4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozMSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjMwLCJQT1NJVElPTiI6MjksIlRFWENPT1JEXzAiOjI4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fbGVmdF9mcm9udCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjM1LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MzQsIlBPU0lUSU9OIjozMywiVEVYQ09PUkRfMCI6MzJ9LCJtYXRlcmlhbCI6MywibW9kZSI6NH1dfSx7Im5hbWUiOiJvX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozNSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM0LCJQT1NJVElPTiI6MzMsIlRFWENPT1JEXzAiOjMyfSwibWF0ZXJpYWwiOjMsIm1vZGUiOjR9XX0seyJuYW1lIjoib190b3BfbGVmdF9mcm9udCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjM5LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MzgsIlBPU0lUSU9OIjozNywiVEVYQ09PUkRfMCI6MzZ9LCJtYXRlcmlhbCI6NCwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RvcF9sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzksImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozOCwiUE9TSVRJT04iOjM3LCJURVhDT09SRF8wIjozNn0sIm1hdGVyaWFsIjo0LCJtb2RlIjo0fV19LHsibmFtZSI6Im9fdG9wX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozOSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM4LCJQT1NJVElPTiI6MzcsIlRFWENPT1JEXzAiOjM2fSwibWF0ZXJpYWwiOjQsIm1vZGUiOjR9XX0seyJuYW1lIjoib190b3BfbGVmdF9mcm9udCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjM5LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MzgsIlBPU0lUSU9OIjozNywiVEVYQ09PUkRfMCI6MzZ9LCJtYXRlcmlhbCI6NCwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozNSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM0LCJQT1NJVElPTiI6MzMsIlRFWENPT1JEXzAiOjMyfSwibWF0ZXJpYWwiOjMsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozMSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjMwLCJQT1NJVElPTiI6MjksIlRFWENPT1JEXzAiOjI4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozMSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjMwLCJQT1NJVElPTiI6MjksIlRFWENPT1JEXzAiOjI4fSwibWF0ZXJpYWwiOjIsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fbGVmdF9mcm9udCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjM1LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MzQsIlBPU0lUSU9OIjozMywiVEVYQ09PUkRfMCI6MzJ9LCJtYXRlcmlhbCI6MywibW9kZSI6NH1dfSx7Im5hbWUiOiJvX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozNSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM0LCJQT1NJVElPTiI6MzMsIlRFWENPT1JEXzAiOjMyfSwibWF0ZXJpYWwiOjMsIm1vZGUiOjR9XX0seyJuYW1lIjoib19sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzUsImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozNCwiUE9TSVRJT04iOjMzLCJURVhDT09SRF8wIjozMn0sIm1hdGVyaWFsIjozLCJtb2RlIjo0fV19LHsibmFtZSI6Im9fdG9wX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozOSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM4LCJQT1NJVElPTiI6MzcsIlRFWENPT1JEXzAiOjM2fSwibWF0ZXJpYWwiOjQsIm1vZGUiOjR9XX0seyJuYW1lIjoib190b3BfbGVmdF9mcm9udCIsInByaW1pdGl2ZXMiOlt7ImluZGljZXMiOjM5LCJhdHRyaWJ1dGVzIjp7Ik5PUk1BTCI6MzgsIlBPU0lUSU9OIjozNywiVEVYQ09PUkRfMCI6MzZ9LCJtYXRlcmlhbCI6NCwibW9kZSI6NH1dfSx7Im5hbWUiOiJvX3RvcF9sZWZ0X2Zyb250IiwicHJpbWl0aXZlcyI6W3siaW5kaWNlcyI6MzksImF0dHJpYnV0ZXMiOnsiTk9STUFMIjozOCwiUE9TSVRJT04iOjM3LCJURVhDT09SRF8wIjozNn0sIm1hdGVyaWFsIjo0LCJtb2RlIjo0fV19LHsibmFtZSI6Im9fdG9wX2xlZnRfZnJvbnQiLCJwcmltaXRpdmVzIjpbeyJpbmRpY2VzIjozOSwiYXR0cmlidXRlcyI6eyJOT1JNQUwiOjM4LCJQT1NJVElPTiI6MzcsIlRFWENPT1JEXzAiOjM2fSwibWF0ZXJpYWwiOjQsIm1vZGUiOjR9XX1dLCJub2RlcyI6W3sibmFtZSI6IlJvb3ROb2RlIiwidHJhbnNsYXRpb24iOlswLDAsMF0sInJvdGF0aW9uIjpbMCwwLDAsMV0sInNjYWxlIjpbMSwxLDFdLCJjaGlsZHJlbiI6WzExLDEwLDksOCw3LDYsNSw0LDMsMiwxXX0seyJuYW1lIjoib19jb21wYXNfbmUiLCJ0cmFuc2xhdGlvbiI6WzAsLTAuMDAxMjIyNzg3ODkwNTgzMjgsMS40Mzk3NzE2MzUyNDc2N2UtMTBdLCJyb3RhdGlvbiI6Wy0wLjUsLTAuNSwtMC41LDAuNV0sInNjYWxlIjpbMTAwLDEwMCwxMDBdLCJtZXNoIjowfSx7Im5hbWUiOiJvX2NvbXBhc19zZSIsInRyYW5zbGF0aW9uIjpbMCwtMC4wMDEyMjI3ODc4OTA1ODMyOCwxLjQzOTc3MTYzNTI0NzY3ZS0xMF0sInJvdGF0aW9uIjpbMy4wOTA4NjE5NjYzNzA1NGUtOCwwLjcwNzEwNjc2OTA4NDkzLDAuNzA3MTA2NzY5MDg0OTMsLTMuMDkwODYxOTY2MzcwNTRlLThdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwibWVzaCI6MX0seyJuYW1lIjoib19jb21wYXNfc3ciLCJ0cmFuc2xhdGlvbiI6WzcuMjMxNDQyNDIyNDA5NTNlLTM0LC0wLjAwMTIyMjc4Nzg5MDU4MzI4LDEuNDM5NzcxNjM1MjQ3NjdlLTEwXSwicm90YXRpb24iOlstMC41LDAuNSwwLjUsMC41XSwic2NhbGUiOlsxMDAsMTAwLDEwMF0sIm1lc2giOjJ9LHsibmFtZSI6Im9fY29tcGFzX253IiwidHJhbnNsYXRpb24iOlswLC0wLjAwMTIyMjc4Nzg5MDU4MzI4LDEuNDM5NzcxNjM1MjQ3NjdlLTEwXSwicm90YXRpb24iOlstMC43MDcxMDY3NjkwODQ5MywwLDAsMC43MDcxMDY3NjkwODQ5M10sInNjYWxlIjpbMTAwLDEwMCwxMDBdLCJtZXNoIjozfSx7Im5hbWUiOiJvX3RleHRfcyIsInRyYW5zbGF0aW9uIjpbMCwwLDAuOTg5OTk5OTQ5OTMyMDk4XSwicm90YXRpb24iOlstMC43MDcxMDY3NjkwODQ5MywwLDAsMC43MDcxMDY3NjkwODQ5M10sInNjYWxlIjpbMTI5Ljg3ODM4NzQ1MTE3MiwxMjkuODc4Mzg3NDUxMTcyLDEwMF0sIm1lc2giOjR9LHsibmFtZSI6Im9fdGV4dF9lIiwidHJhbnNsYXRpb24iOlswLjk4OTk5OTk0OTkzMjA5OCwwLDBdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjc2OTA4NDkzLDAsMCwwLjcwNzEwNjc2OTA4NDkzXSwic2NhbGUiOlsxMjkuODc4Mzg3NDUxMTcyLDEyOS44NzgzODc0NTExNzIsMTAwXSwibWVzaCI6NX0seyJuYW1lIjoib190ZXh0X24iLCJ0cmFuc2xhdGlvbiI6WzAsMCwtMC45ODk5OTk5NDk5MzIwOThdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjc2OTA4NDkzLDAsMCwwLjcwNzEwNjc2OTA4NDkzXSwic2NhbGUiOlsxMjkuODc4Mzg3NDUxMTcyLDEyOS44NzgzODc0NTExNzIsMTAwXSwibWVzaCI6Nn0seyJuYW1lIjoib190ZXh0X3ciLCJ0cmFuc2xhdGlvbiI6Wy0wLjk4OTk5OTk0OTkzMjA5OCwwLDBdLCJyb3RhdGlvbiI6Wy0wLjcwNzEwNjc2OTA4NDkzLDYuMTgxNzIzOTMyNzQxMDhlLTgsNi4xODE3MjM5MzI3NDEwOGUtOCwwLjcwNzEwNjc2OTA4NDkzXSwic2NhbGUiOlsxMjkuODc4Mzg3NDUxMTcyLDEyOS44NzgzODc0NTExNzIsMTAwXSwibWVzaCI6N30seyJuYW1lIjoib190ZXh0X2JvdHRvbSIsInRyYW5zbGF0aW9uIjpbMCwwLjUsMF0sInJvdGF0aW9uIjpbLTAuNzA3MTA2NzY5MDg0OTMsMCwwLDAuNzA3MTA2NzY5MDg0OTNdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwibWVzaCI6OH0seyJuYW1lIjoib190ZXh0IiwidHJhbnNsYXRpb24iOlswLDAuNSwwXSwicm90YXRpb24iOlstMC43MDcxMDY3NjkwODQ5MywwLDAsMC43MDcxMDY3NjkwODQ5M10sInNjYWxlIjpbMTAwLDEwMCwxMDBdLCJtZXNoIjo5fSx7Im5hbWUiOiJkX3ZpcyIsInRyYW5zbGF0aW9uIjpbMCwwLjUsMF0sInJvdGF0aW9uIjpbLTAuNzA3MTA2NzY5MDg0OTMsMCwwLDAuNzA3MTA2NzY5MDg0OTNdLCJzY2FsZSI6WzEwMCwxMDAsMTAwXSwiY2hpbGRyZW4iOlsxMl19LHsibmFtZSI6ImRfc2VsZWN0IiwidHJhbnNsYXRpb24iOlswLDAsMF0sInJvdGF0aW9uIjpbMCwwLDAsMV0sInNjYWxlIjpbMSwxLDFdLCJjaGlsZHJlbiI6WzM4LDM3LDM2LDM1LDM0LDMzLDMyLDMxLDMwLDI5LDI4LDI3LDI2LDI1LDI0LDIzLDIyLDIxLDIwLDE5LDE4LDE3LDE2LDE1LDE0LDEzXX0seyJuYW1lIjoib190b3AiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwMjk5OTk5NzkzMDYwMTI0LC0xLjQ5MDExNjAzMDU2NjkyZS05LDAuMDAzOTk5OTk4MzI3MzQ0NjZdLCJyb3RhdGlvbiI6Wy0wLjQ5OTk5OTg4MDc5MDcxLDAuNDk5OTk5OTcwMTk3Njc4LC0wLjUwMDAwMDExOTIwOTI5LDAuNTAwMDAwMDU5NjA0NjQ1XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjEwfSx7Im5hbWUiOiJvX2JvdHRvbSIsInRyYW5zbGF0aW9uIjpbMC4wMDI5OTk5OTg4NjE5MjM4MSwyLjk4MDIzMjE3MjE1NjE1ZS0xMCwtMC4wMDQwMDAwMDAxODk5ODk4MV0sInJvdGF0aW9uIjpbLTAuNDk5OTk5OTcwMTk3Njc4LDAuNTAwMDAwMDU5NjA0NjQ1LDAuNSwtMC40OTk5OTk5NDAzOTUzNTVdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MTF9LHsibmFtZSI6Im9fdG9wX2xlZnQiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwNDAwMDAwMDY1NTY1MTA5LC0wLjAwMzAwMDAwMDcyNDU2ODk2LDAuMDAzOTk5OTk5NzI0MzI4NTJdLCJyb3RhdGlvbiI6WzAuNTAwMDAwMDU5NjA0NjQ1LDAuNDk5OTk5OTEwNTkzMDMzLDAuNSwtMC41XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjEyfSx7Im5hbWUiOiJvX2xlZnQiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwNDAwMDAwMDE4OTk4OTgxLDIuOTgwMjMyMTcyMTU2MTVlLTEwLC0wLjAwMjk5OTk5OTU2MDQxNTc0XSwicm90YXRpb24iOls0LjM1Nzg4MTkyMTQ3MDY1ZS0zMyw0LjM1Nzg4MjI4ODgxMjYzZS0zMywtMC43MDcxMDY4Mjg2ODk1NzUsMC43MDcxMDY3MDk0ODAyODZdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MTN9LHsibmFtZSI6Im9fYm90dG9tX2xlZnQiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwNDAwMDAwMDE4OTk4OTgxLC0wLjAwMjk5OTk5ODg2MTkyMzgxLC0wLjAwMzk5OTk5Nzg2MTY4MzM3XSwicm90YXRpb24iOlstMy4wOTA4NjIzMjE2NDE5MWUtOCwwLjcwNzEwNjcwOTQ4MDI4NiwwLjcwNzEwNjgyODY4OTU3NSwzLjA5MDg2MTYxMTA5OTE3ZS04XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjE0fSx7Im5hbWUiOiJvX3JpZ2h0IiwidHJhbnNsYXRpb24iOlswLjAwMzk5OTk5OTcyNDMyODUyLC0yLjk4MDIzMjE3MjE1NjE1ZS0xMCwtMC4wMDMwMDAwMDA3MjQ1Njg5Nl0sInJvdGF0aW9uIjpbMCwwLDAuNzA3MTA2NzY5MDg0OTMsMC43MDcxMDY3NjkwODQ5M10sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoxNX0seyJuYW1lIjoib19ib3R0b21fcmlnaHQiLCJ0cmFuc2xhdGlvbiI6WzAuMDAzOTk5OTk5NzI0MzI4NTIsLTAuMDAyOTk5OTk5NTYwNDE1NzQsLTAuMDAzOTk5OTk5MjU4NjY3MjNdLCJyb3RhdGlvbiI6WzAuNTAwMDAwMDU5NjA0NjQ1LC0wLjQ5OTk5OTk3MDE5NzY3OCwtMC41MDAwMDAwNTk2MDQ2NDUsLTAuNDk5OTk5OTcwMTk3Njc4XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjE2fSx7Im5hbWUiOiJvX3RvcF9yaWdodCIsInRyYW5zbGF0aW9uIjpbMC4wMDM5OTk5OTkyNTg2NjcyMywtMC4wMDMwMDAwMDExOTAyMzAyNSwwLjAwMzk5OTk5OTcyNDMyODUyXSwicm90YXRpb24iOlstMC43MDcxMDY4Mjg2ODk1NzUsMCwwLDAuNzA3MTA2NzA5NDgwMjg2XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjE3fSx7Im5hbWUiOiJvX3JpZ2h0X2JhY2siLCJ0cmFuc2xhdGlvbiI6WzAuMDAzOTk5OTk4MzI3MzQ0NjYsMC4wMDM5OTk5OTkyNTg2NjcyMywtMC4wMDMwMDAwMDA3MjQ1Njg5Nl0sInJvdGF0aW9uIjpbMCwwLDAuNzA3MTA2NzY5MDg0OTMsMC43MDcxMDY3NjkwODQ5M10sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoxOH0seyJuYW1lIjoib19ib3R0b21fcmlnaHRfYmFjayIsInRyYW5zbGF0aW9uIjpbMC4wMDM5OTk5OTkyNTg2NjcyMywwLjAwMjk5OTk5OTA5NDc1NDQ2LC0wLjAwNDAwMDAwMDE4OTk4OTgxXSwicm90YXRpb24iOlstMS4xNTIwMjMyNTkwMTAwOWUtNywwLjcwNzEwNjc2OTA4NDkzLDAuNzA3MTA2NzY5MDg0OTMsLTEuMTUyMDIzMTg3OTU1ODJlLTddLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MTl9LHsibmFtZSI6Im9fYm90dG9tX2xlZnRfYmFjayIsInRyYW5zbGF0aW9uIjpbLTAuMDA0MDAwMDAwNjU1NjUxMDksMC4wMDI5OTk5OTk1NjA0MTU3NCwtMC4wMDM5OTk5OTc4NjE2ODMzN10sInJvdGF0aW9uIjpbMC41MDAwMDAwNTk2MDQ2NDUsMC40OTk5OTk5MTA1OTMwMzMsMC41LC0wLjVdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MjB9LHsibmFtZSI6Im9fdG9wX3JpZ2h0X2JhY2siLCJ0cmFuc2xhdGlvbiI6WzAuMDAzOTk5OTk5NzI0MzI4NTIsMC4wMDM5OTk5OTkyNTg2NjcyMywwLjAwMjk5OTk5ODE2MzQzMTg4XSwicm90YXRpb24iOlswLDAsMSwtNy41NDk3OTAxMjY0MDQzM2UtOF0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoyMX0seyJuYW1lIjoib190b3BfbGVmdF9iYWNrIiwidHJhbnNsYXRpb24iOlstMC4wMDM5OTk5OTk3MjQzMjg1MiwwLjAwNDAwMDAwMDE4OTk4OTgxLDAuMDAyOTk5OTk5NTYwNDE1NzRdLCJyb3RhdGlvbiI6WzQuMzU3ODgxOTIxNDcwNjVlLTMzLDQuMzU3ODgyMjg4ODEyNjNlLTMzLC0wLjcwNzEwNjgyODY4OTU3NSwwLjcwNzEwNjcwOTQ4MDI4Nl0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoyMn0seyJuYW1lIjoib19sZWZ0X2JhY2siLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwMzk5OTk5OTcyNDMyODUyLDAuMDAzOTk5OTk5NzI0MzI4NTIsLTAuMDAyOTk5OTk4ODYxOTIzODFdLCJyb3RhdGlvbiI6WzAsMCwxLDcuNTQ5NzkwMTI2NDA0MzNlLThdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MjN9LHsibmFtZSI6Im9fdG9wX2JhY2siLCJ0cmFuc2xhdGlvbiI6WzAuMDAzMDAwMDAwMDI2MDc3MDMsMC4wMDM5OTk5OTkyNTg2NjcyMywwLjAwMzk5OTk5OTcyNDMyODUyXSwicm90YXRpb24iOlswLjUwMDAwMDA1OTYwNDY0NSwwLjQ5OTk5OTk3MDE5NzY3OCwtMC40OTk5OTk5NzAxOTc2NzgsLTAuNV0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoyNH0seyJuYW1lIjoib19iYWNrIiwidHJhbnNsYXRpb24iOlstNy40NTA1ODAxNTI4MzQ2MmUtMTAsMC4wMDM5OTk5OTkyNTg2NjcyMywtMC4wMDMwMDAwMDA3MjQ1Njg5Nl0sInJvdGF0aW9uIjpbMCwwLDEsNy41NDk3OTAxMjY0MDQzM2UtOF0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoyNX0seyJuYW1lIjoib19ib3R0b21fYmFjayIsInRyYW5zbGF0aW9uIjpbMC4wMDI5OTk5OTgxNjM0MzE4OCwwLjAwMzk5OTk5OTcyNDMyODUyLC0wLjAwMzk5OTk5OTI1ODY2NzIzXSwicm90YXRpb24iOlswLjcwNzEwNjk0Nzg5ODg2NSw3LjMwNTU0NTMyNDI0MzIxZS04LC0wLjcwNzEwNjU5MDI3MDk5Niw3LjMwNTU0ODg3Njk1Njg5ZS04XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjI2fSx7Im5hbWUiOiJvX2Zyb250IiwidHJhbnNsYXRpb24iOlstMS4zNDExMDQ0NDk3MTQ2OWUtOSwtMC4wMDQwMDAwMDA2NTU2NTEwOSwtMC4wMDI5OTk5OTk1NjA0MTU3NF0sInJvdGF0aW9uIjpbMCwwLDAsMV0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjoyN30seyJuYW1lIjoib19ib3R0b21fZnJvbnQiLCJ0cmFuc2xhdGlvbiI6WzAuMDAyOTk5OTk3Njk3NzcwNiwtMC4wMDQwMDAwMDAxODk5ODk4MSwtMC4wMDM5OTk5OTc4NjE2ODMzN10sInJvdGF0aW9uIjpbLTAuNDk5OTk5OTcwMTk3Njc4LDAuNDk5OTk5OTcwMTk3Njc4LDAuNTAwMDAwMDU5NjA0NjQ1LC0wLjVdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6Mjh9LHsibmFtZSI6Im9fdG9wX2Zyb250IiwidHJhbnNsYXRpb24iOlswLjAwMjk5OTk5OTU2MDQxNTc0LC0wLjAwNDAwMDAwMDY1NTY1MTA5LDAuMDAzOTk5OTk5NzI0MzI4NTJdLCJyb3RhdGlvbiI6WzAsLTAuNzA3MTA2NzA5NDgwMjg2LDAsMC43MDcxMDY4Mjg2ODk1NzVdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6Mjl9LHsibmFtZSI6Im9fcmlnaHRfZnJvbnQiLCJ0cmFuc2xhdGlvbiI6WzAuMDAzOTk5OTk3ODYxNjgzMzcsLTAuMDA0MDAwMDAwNjU1NjUxMDksLTAuMDAyOTk5OTk5NTYwNDE1NzRdLCJyb3RhdGlvbiI6WzAsMCwwLDFdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MzB9LHsibmFtZSI6Im9fbGVmdF9mcm9udCIsInRyYW5zbGF0aW9uIjpbLTAuMDA0MDAwMDAwMTg5OTg5ODEsLTAuMDA0MDAwMDAwMTg5OTg5ODEsLTAuMDAyOTk5OTk3Njk3NzcwNl0sInJvdGF0aW9uIjpbNC4zNTc4ODE5MjE0NzA2NWUtMzMsNC4zNTc4ODIyODg4MTI2M2UtMzMsLTAuNzA3MTA2ODI4Njg5NTc1LDAuNzA3MTA2NzA5NDgwMjg2XSwic2NhbGUiOlsxLDEsMV0sIm1lc2giOjMxfSx7Im5hbWUiOiJvX2JvdHRvbV9sZWZ0X2Zyb250IiwidHJhbnNsYXRpb24iOlstMC4wMDMwMDAwMDA3MjQ1Njg5NiwtMC4wMDQwMDAwMDA2NTU2NTEwOSwtMC4wMDM5OTk5OTc4NjE2ODMzN10sInJvdGF0aW9uIjpbMCwtMC43MDcxMDY3MDk0ODAyODYsMCwwLjcwNzEwNjgyODY4OTU3NV0sInNjYWxlIjpbMSwxLDFdLCJtZXNoIjozMn0seyJuYW1lIjoib19ib3R0b21fcmlnaHRfZnJvbnQiLCJ0cmFuc2xhdGlvbiI6WzAuMDAyOTk5OTk3Njk3NzcwNiwtMC4wMDQwMDAwMDExMjEzMTIzOCwtMC4wMDM5OTk5OTkyNTg2NjcyM10sInJvdGF0aW9uIjpbMC41LDAuNSwwLjUsMC40OTk5OTk5NzAxOTc2NzhdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MzN9LHsibmFtZSI6Im9fdG9wX3JpZ2h0X2Zyb250IiwidHJhbnNsYXRpb24iOlswLjAwMzk5OTk5OTI1ODY2NzIzLC0wLjAwNDAwMDAwMDY1NTY1MTA5LDAuMDAyOTk5OTk4MTYzNDMxODhdLCJyb3RhdGlvbiI6WzAsMCwwLjcwNzEwNjc2OTA4NDkzLDAuNzA3MTA2NzY5MDg0OTNdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MzR9LHsibmFtZSI6Im9fdG9wX2xlZnRfZnJvbnQiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwNDAwMDAwMDE4OTk4OTgxLC0wLjAwMzk5OTk5OTcyNDMyODUyLDAuMDAzMDAwMDAwNzI0NTY4OTZdLCJyb3RhdGlvbiI6WzAsMCwwLDFdLCJzY2FsZSI6WzEsMSwxXSwibWVzaCI6MzV9XSwic2NlbmVzIjpbeyJuYW1lIjoiUm9vdCBTY2VuZSIsIm5vZGVzIjpbMF19XSwic2NlbmUiOjB97FwAAEJJTgAAAEA/2ImdPQAAQD/YiR0+AACAP9iJnT0AAIA/2IkdPgAAgD/ETmw+AABAP8RObD4AAIA/2ImdPgAAQD/YiZ0+AACAP07sxD4AAEA/xE7sPgAAgD/ETuw+AABAP07sxD4AAIA/ntgJPwAAQD/YiR0/AACAP9iJHT8AAEA/ntgJPwAAQD8UOzE/AACAPxQ7MT8AAEA/T+xEPwAAgD9P7EQ/AACAP4qdWD8AAEA/ip1YPwAAgD/FTmw/AABAP8VObD8AAEA/AACAPwAAgD8AAIA/YQTnum3FIzwAAAAAc301u/v8HzwAAAAAD6PbuiK0GzwAAAAAtowsu2UbGDwAAAAAa35pu2LvEjwAAAAAipd1u16MGjwAAAAAiAKSu809DDwAAAAAPpOZuwCCEzwAAAAAwMKtu2kYBDwAAAAATw/Su77uADwAAAAAR7bHu5Up9TsAAAAAjsO2u47wCjwAAAAAUJjfu16Y3zsAAAAAt+4AvF4P0jsAAAAAiin1u1W2xzsAAAAAIi7ruzAu6zsAAAAAiPAKvJ7DtjsAAAAAYxgEvM/CrTsAAAAA+4ETvFGTmTsAAAAAyT0MvJkCkjsAAAAAXu8SvI9+aTsAAAAAWowavK+XdTsAAAAAYhsYvNyMLDsAAAAA+PwfvJx9NTsAAAAAa8UjvLME5zoAAAAAILQbvF2j2zoAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAwACAAEAAQAEAAMABAABAAUABgAEAAcABwAEAAUABwAIAAYACAAJAAoACAAHAAsACQAMAAoACQAIAAsADAANAA4ADAAJAA8ADQAMAA8ADgAQABEAEAAOAA0AEQASABMAEgAUABMAEgARABAAFAASABUAFQAWABQAFgAVABcAFgAYABkAGAAWABcAAAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/ShPvOYtnUDqJZ9Aup12MObexWTq0sdkurreNOeB3Ezrdd5Muo5t+OBvGXToVxt0uuKKUOF2RGDpYkZguRhPvOdZ6BjrTeoYuGRZquerDUzriw9MuZtaLuPweFTr3HpUu8wzauVjcODpQ3Lgu4fEmuaCaCzqYmosuOOIJuotUETqBVJEuDwVeuf1V+TnuVXkuFhATugDdwjnr3EIuTBNvue7z0Tne81Eu2A8KutxsSTmzbMktwgVLuUWwozk2sCMuwKfkuc3KhTiFygUtHpnWuNnpgDnN6QAux4mhudeX3LfMmFys1/fdNwoZSDn1GMgtpN4puSmYv7hcmD+ts3M2OWFeDjlSXo4tmU2Ft0c5GLlcOZitNJSoOVxPkDhHTxAtcCTrOKlHU7m7R9Ot9RnsOYUjvbeuIz2sIYJUOThdj7lAXQ+uS/sNOtfRHLnc0ZytFIN4ObQwxLm8MESusP4WOpZHqbmXRymu8zNmOV0n7rllJ26uLl4rOYJ2B7qGdoeudouFOL9GErrERpKuJAo6OVSSVbpYktWu77jLOTB5PLozebyuOQ4KOnmpEbp7qZGu66KxuGA1FrpmNZaupKW8uBjGXboext2u6YStuabaDrqv2o6uboaxubnHWbrCx9muvv4WutIV+rnmFXquwf4WuuV4TLrveMyuAAAAAAAAALQAAIA/BzxXqQAAALQAAIA/pqowqQAAALQAAIA/rcmUqf///7MAAIA/fmhKqQAAALQAAIA/AAAAAAAAALQAAIA/WQNdqQAAALQAAIA/b5LJqQAAALQAAIA/4S8lqQIAALQAAIA/yhOcqQEAALQAAIA/LCeMqQIAALQAAIA/OhocqQEAALQAAIA/O1tvqQAAALQAAIA/OYtjqQAAALQAAIA/q6aEqf///7MAAIA/ylWFqf7//7MAAIA/8Z6Pqfz//7MAAIA/m7iOqfz//7MAAIA/VHqEqf3//7MAAIA/Kd+Hqf///7MAAIA/wFODqf7//7MAAIA/JHGDqf7//7MAAIA/k4xsqQAAALQAAIA/s5uJqQAAALQAAIA/EFpeqQIAALQAAIA/ds5vqQIAALQAAIA/K8BeqQIAALQAAIA/oSNtqQIAALQAAIA//gaHqQAAALQAAIA/fMeQqQAAALQAAIA/nxRzqfz//7MAAIA/qxmGqf3//7MAAIA/Mp6iqQEAALQAAIA/kyiBqQAAALQAAIA/7ylYqQEAALQAAIA/ucZ7qQEAALQAAIA/s9uEqf///7MAAIA/iTOTqQAAALQAAIA/1rKIqQAAALQAAIA/ifSHqQEAALQAAIA/SQFbqQAAALQAAIA/N+oiqQAAALQAAIA/AAABAAIAAQADAAQAAgAFAAAAAwAGAAcABAACAAEABgAIAAkABwAEAAMACAAKAAsACQAHAAYACgAMAA0ACwAJAAgADQALAAoADQAMAA4ADgAPAA0ADgAQABEAEQAQABIAEQAPAA4AEgATABEAEwASABQAFAAVABMAFQAUABYAFgAXABUAFwAWABgAGAAZABcAGQAYABoAGgAbABkAGwAaABwAHAAdABsAHQAcAB4AHwAgACEAHwAiACMAHgAjAB0AIwAeAB8AIQAiAB8AIQAgACQAJAAlACEAJQAkACYAJgAnACUAJwAmACgAKAApACcAAAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/hvkAOhniEbof4pGujb48uRTiEbof4pGuoPkAunxNVrqJTdauhPkAOoRNVrqJTdaufb48uR4O2bhwDlmtdb48ufvbHjnS254tkvkAuoRNVjp3TdYuZr48uRbiEToL4pEujvkAOhDiEToL4pEukPkAOnxNVjp3TdYuhTjyOUcO2bhwDlmthzjyOebbHjnS254tn/FyqQAAALQAAIA/eTJ7qQAAALQAAIA/zpFuqQAAALQAAIA/AudzqQAAALQAAIA/vcdyqQAAALQAAIA/NiZdqQAAALQAAIA/Q+FlqQAAALQAAIA/UYdyqQAAALQAAIA/ofFyqQAAALQAAIA/AudzqQAAALQAAIA/pDh5qQAAALQAAIA/pDh5qQAAALQAAIA/AAABAAIAAgADAAAAAgAEAAUAAgABAAQABgAHAAgACAAJAAYABAAKAAsABQAGAAIABQAHAAYACwAFAAQAAAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/VO0aOntNVjp3TdYu65OjOX1NVjp3TdYu15OjOcKUurnPlDque1V0OXZ5LLmUeayt64loufDvJTnC76UtZnljOYFNVrqJTdau4d5guYJNVjp3TdYu+5OjuZIkwTl7JEEuRe0aOoVNVrqJTdauXO0auoVNVjp3TdYuae0auntNVrqJTdauD5SjuX1NVrqJTdaup2yOqQAAALQAAIA/hF6PqQAAALQAAIA/aN6zqQAAALQAAIA/DAaXqQAAALQAAIA/j8G0qQMAALQAAIA/oAOjqQEAALQAAIA/MFhGqQAAALQAAIA/kv9qqQAAALQAAIA/Y06YqQEAALQAAIA/lj5qqQAAALQAAIA/GG+OqQAAALQAAIA/f16PqQAAALQAAIA/AAABAAIAAwAEAAUAAwAGAAcAAgAIAAAABQACAAMABQAIAAIABwAJAAoABwAEAAMABwAGAAkACgALAAcAAAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD9hNRa6dE1WuolN1q5HY7S5OJwHukuch66kpbm5HgZyuWkG8q3NMS66jE1WOndN1i7HEc65ik1WOndN1i5SK745DhqIuScaCK77nLs5X/IGumzyhq5eNRY6fU1WuolN1q7hMS46gk1WOndN1i4FTtM5gk1WOndN1i6Fq0w4hDWjuaI1I64pP5s5gPecuZv3HK4zUds4nIKnOX2CJy4Uxl05e01WuolN1q5SKDC3PcrcuLjKXK3XXbu4noKnOX2CJy4PlY25wASKueQECq4Kk4y4staludLWJa6ugG25d01WuolN1q4EYmmpAQAAtAAAgD/kvG2pAAAAtAAAgD+JMXWpAAAAtAAAgD+OZI+pAAAAtAAAgD/oWpOpAAAAtAAAgD8Gp6GnAAAAtAAAgD9WSU6pAAAAtAAAgD9maQ+pAQAAtAAAgD8AAAAAAAAAtAAAgD8AAAAAAAAAtAAAgD+4IVmpAAAAtAAAgD+wCXSpAAAAtAAAgD/Qo0KpAAAAtAAAgD89iF2pAQAAtAAAgD8F90Cp////swAAgD/0KYGpAAAAtAAAgD9sFaGp////swAAgD++KI6pAAAAtAAAgD9kDGipAQAAtAAAgD8AAAEAAgACAAMAAAACAAQAAwAFAAYABwAIAAkABQAKAAsADAAKAA0ABgAOAA8AEAAMAA4ACgAMAA8ADgAQABEADgARABAAAQABABIAEQABAAAAEgAGAAsACgAHAAYADQAHAAgABQAAAAAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/ffU4O9BJUzoL16O7MxhKO89JUzoL16O7c29MO6l5/7kL16O7IdFbO8vFpzkL16O7dAhjO29i07gN16O7zPVUOzBRWboL16O7Qis+OzBRWboN16O7XnFoO8rFpzkL16O7kIN5O655/7kN16O7jwuHu+JJUzoL16O7TAl6u3I6EToN16O7TAl6u10RrjgN16O7ilhtu+FJUzoN16O7a/dru3A6EToN16O7cPdru3E6EToN16O7PXRbu2kBSToL16O7M+VcuweombkN16O7RwBgu3QxZrkN16O7h6lWuzXrhbgN16O70hRMu+8sP7kN16O7x2NHu3kexbkN16O7TAl6u6mdGboN16O7Gdttu6mdGboN16O7wnxruyBRWboN16O7jwuHux1RWboN16O7TAl6uzdVHrkN16O7eMNLu5hsZDcN16O7e8xau9R7VzkN16O7lGpYu1ASojkN16O7V49lu/1zMbkN16O7uz1iu7PT7DgN16O7GdttuzpVHrkN16O7YYVtu1gRrjgN16O7LlJcu4lBUboN16O7LqRluzfTFboN16O7hRVgu7QdC7oN16O7fQ9Qu261P7oN16O70u9cu7Wc9LkN16O7wGddu/Nx/TkN16O7B4BjuyZQDDoN16O7zJZNu+RcMjoL16O79bBFuw+jBzoL16O7/a5Zu4WD1DkN16O7B2VDuz7vdDkL16O7M3NwuspJUzoN16O7698dusdJUzoN16O7698dumh4FroN16O7+zscO3PJeDkO16O79kwvO0eRwDkQ16O7wLIyO3avIrcP16O7YVYYO7xk2DkO16O7LvglO3LVJToP16O7e5ERO6+DCDoO16O7Ul7SOmvVJToN16O7nDLuOvgvTjoO16O7syv7OrmDCDoP16O75qHtOr1k2DkP16O7vdblOpDJeDkP16O7vbS/OjmRwDkN16O7zGDjOpeuIrcP16O7Kem4OqOvIrcP16O7s9blOrKPhrkP16O7uLS/Oje8yrkS16O74aHtOseP4rkP16O77nYdOyavIrcO16O79kwvO0e8yrkN16O79jscO6KPhrkO16O7LvglO+XqKroN16O7YVYYO7WP4rkO16O7Cg4YO3RFU7oN16O7e5EROy2ZDboO16O7TF7SOvDqKroS16O7riv7OjaZDboP16O7Cw4YO/cvTjoO16O7q5MHOz8sEjoO16O7rZMHO6ZPWzoO16O7p5MHOyFlYLoP16O7q5MHO7xBF7oP16O7jzLuOn1FU7oS16O7cNCyui5RWboP16O7cNCyunV4FroP16O7M3NwunJ4FroP16O79sgiuS5RWboN16O79sgiuWt4FroN16O7BSwBOsZJUzoO16O7TL9TOsVJUzoN16O7TL9TOmt4FroN16O7ZiXzumrJeDkN16O7cAPNukGRwDkP16O73DfGuhmwIrcN16O7mfD6urVk2DkN16O7AK3fum/VJToN16O7Mz0Eu62DCDoN16O7hZ8su2fVJToL16O7YbUeu/UvTjoN16O71DgYu7aDCDoO16O7u/0eu7hk2DkO16O7T+Miu4bJeDkN16O7T/Q1uzWRwDkL16O7Rx4kuzuvIrcN16O7GVo5u0ewIrcN16O7VOMiu7ePhrkN16O7UvQ1uzu8yrkP16O7vf0eu8yP4rkN16O7gK/wusmvIrcN16O7cAPNuk68yrkL16O7cCXzuqePhrkN16O7AK3fuufqKroL16O7mfD6uryP4rkN16O7R4H7undFU7oL16O7Mz0Euy+ZDboN16O7h58su/TqKroP16O71zgYuzmZDboN16O7R4H7uvQvTjoN16O7AjsOuzwsEjoN16O7AjsOu6RPWzoN16O7BTsOuyRlYLoN16O7AjsOu79BF7oN16O7ZrUeu4BFU7oP16O7cOU/ODBRWboP16O7HuU/OHd4FroP16O7BSwBOnV4FroQ16O7fXakOi9RWboN16O7fXakOm14FroN16O7CntxOzNRWboN16O7e1eEOzNRWboL16O73Ex8O8xJUzoL16O7iwuHO8tJUzoL16O7j/Rbu/VyyLkN16O7YVdJu6v9GboN16O7taN7NKpMZzMAAIC/AAAAAAAAAAAAAIC/hw2ONUk1mDQAAIC/VKJJtdkHkDUAAIC/L0qxtYcORDUAAIC/gUE5NbVR+DQAAIC/vUP1NW68GzUAAIC/0IG8NOTetDUAAIC/YFzgNeY9EzQAAIC/Uoi7tY/dBDUAAIC/mZexte2FoDQAAIC/cQxCtYPPSDQAAIC/UzkoNUixwjQAAIC/h8dHNabyNjUAAIC/AAAAAAAAAAAAAIC/jVihNbchzTUAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/KG5wtFRXoTMAAIC/AAAAAAAAAAAAAIC/fo+ANfj7JzUAAIC/AAAAAAAAAAAAAIC/d8vENQXl+TQAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/N1KnNekR1zUAAIC/V9k5NXMhFDYAAIC/i+KmNUcxyTUAAIC/UL7mNR5TOTUAAIC/AivhNYBQTDUAAIC/1SEKNv0eZDUAAIC/vCIRNeGDBDQAAIC/AAAAAAAAAAAAAIC/+e5VNpUwhDYAAIC/f69JtjbLnrUAAIC/E5tetgeGiLUAAIC/0dvNtRuBx7UAAIC/8igutnxjYLUAAIC/2YAutow2kTQAAIC/S+CAtdhVd7QAAIC/0PRntr7A5zUAAIC/jOiXtTOYjDUAAIC/tN2etFFILzYAAIC/21dctr+hCTYAAIC/2T4ctsGJ1zUAAIC/zx9RtvKqKTYAAIC/AAAAAAAAAAAAAIC/8OCFK8UABTYAAIC/0D4cNsyJ1zUAAIC/2h9RNuCqKTYAAIC/01dcNtehCTYAAIC/2+n2tVl8pSwAAIC/X9anNR0FA7YAAIC/rboCNZiDpLUAAIC/T2bRNVeosrUAAIC/vlfcNbihibUAAIC/mw5HNv6ngrUAAIC/KJouNp1mnLUAAIC/XmZRNmGoMjYAAIC/eAUCNlkGbjYAAIC/XEaOtf3u0zQAAIC/CsxfNevJdTUAAIC/AAAAAAAAAAAAAIC/ORafNi6kha0AAIC/d2xuNmfJdTUAAIC/vd9LNrYdIjYAAIC/s7WuNNggGbUAAIC/AAAAAAAAAAAAAIC/CFwGNkky2bMAAIC/FNg0NTd6/DQAAIC/AAAAAAAAAAAAAIC/oEQjNteDBDQAAIC/6vf9NQAAAAAAAIC/S3mjNuAkwjYAAIC/1z4cthOK17UAAIC/Bc1CtnTqbLUAAIC/m6a/tCSBx7UAAIC/UPT/tdOAyzQAAIC/+Py8tVXLsjUAAIC/AAAAAAAAAAAAAIC/0/RntrLA5zUAAIC/ouiXtSKYjDUAAIC/l92etFVILzYAAIC/h7RStodIfTUAAIC/bE3ptYVGAbUAAIC/E9Ijthp5iDUAAIC/AAAAAAAAAAAAAIC/iaa/NCiBxzUAAIC/0D4cNs2J1zUAAIC/2h9RNuCqKTYAAIC/1FdcNtShCTYAAIC/AAAAAAAAAAAAAIC/rx/RNceqqbUAAIC/sj6cNZ6JV7UAAIC/T2bRNViosrUAAIC/vFfcNbihibUAAIC/0d/LNc0dorUAAIC/oAWCNUcG7rUAAIC/XWZRNmGoMjYAAIC/dwUCNlkGbjYAAIC/AAAAAAAAAAAAAIC//stfNe/JdTUAAIC/AAAAAAAAAAAAAIC/YqFuNjWkBa0AAIC/AtsINlIIFTUAAIC/tN9LNsMdIjYAAIC/13MYtQYbtLUAAIC/f/iytcpT26sAAIC/hosvNlg0iLUAAIC/Bg90Nb0c2DQAAIC/AAAAAAAAAAAAAIC/wJqUNXo51bQAAIC/sbQBNjD/ibQAAIC/x7+ZNKclDjMAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAABAAIAAwAEAAUAAgAGAAAABQAGAAIABQACAAMABAAHAAgABAADAAcACQAKAAsACgAJAAwADAANAA4ADAAOAAoADQAMAA8AEAARABIAEAATABQAFQAWABcAGAAZABUAGAAJAAsAGgAbABwAGwAaABIAHQAeABIAHQAfACAAEgARAB0AEgATABAAEgAeABsAIQAiACMAIgAhABcAFwAYABUAFwAWACIAIwAkACEAJAAjACUAJgAnAA8AKAApACoADwAnAA0ADwAoACYAKgAmACgAHAArABoAHAAqACkAKQArABwAIAAeAB0ACwAZABgACwAgAB8AHwAZAAsALAAtAC4ALwAwADEAMAAvADIAMgAzADAAMwAyADQANQA2ADcAOAA5ADoAOgA1ADgAOQA7ADwAPAA6ADkAPAA7AD0APQA+ADwAPgA9AD8AMQBAAC8AMQBBAEIAQQBDAEQAQgBAADEAQwBFAEYARABCAEEAPwBHAD4ARwA/AEgANABJADMASQA0AEoANgBLAEoANwA4ADUASgBLAEkASgA3ADYARQBMAE0ARgBEAEMATQBGAEUATQBMAE4ASABOAEcATgBIAE0ATwBQAFEAUgBPAFEALgBRACwALgBTAFIAUQAuAFIAVABVAFYAVwBYAFkAWABXAFoAWgBbAFgAWwBaAFwAXQBeAF8AYABhAGIAYgBdAGAAYQBjAGQAZABjAGUAZABiAGEAZQBmAGQAZgBlAGcAWQBoAFcAWQBpAGoAaQBrAGwAagBoAFkAawBtAG4AbABqAGkAZwBvAGYAbwBnAHAAXABxAFsAcQBcAHIAXgBzAHIAXwBgAF0AcgBzAHEAcgBfAF4AbQB0AHUAbgBsAGsAdQBuAG0AdQB0AHYAcAB2AG8AdgBwAHUAdwB4AHkAegB3AHkAVgB7AHoAVgB5AFQAeQBWAHoACAB8AAQAfQB8AAgAfQAIAH4AfgB/AH0AFACAABAAFACBACUAJQCBACQAJQCAABQAAAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8KNvc5KYOjO7fjv7lHGcg5K4OjOyHhNLrNnC04K4OjOyDhNLoA5w06KYOjO2YT77jSM346KYOjO2YT77g4PEU6KYOjO1mvKTozW3o6K4OjO965dzochYg6KYOjO7jjv7n9qbw6KYOjOyLhNLqCp5Q6KYOjOyLhNLrKUhm7K4OjO+O5dzpMf/K6K4OjOyl0UDkcQA27K4OjO7jqLDnXrDG7LIOjO+a5dzpMf/K6K4OjO+v10jgKfhm7K4OjOxvhNLqzjzO7LIOjOxvhNLoA7J+6K4OjO0JdJLoF7J+6K4OjO867sbm9fIe6K4OjO9n+1bl7U4S6K4OjO4+MNbrrGl66K4OjO16j5bkpJFG6K4OjO7srO7oKIiq6K4OjOxuM0bnX0/65K4OjO42JLbqkLQa6K4OjO8VAl7kp8oa5K4OjO+73BLoK2eK5K4OjO7gx6LgF7J+6K4OjO0wTbzrmC4a6K4OjOzUAezrCcYW6K4OjO6SiMTr2+gS6K4OjO1e+bjr2Jym6K4OjOzs0LDo9H126K4OjOxk9NzrC0425K4OjO2tlQjrXrwW6K4OjO48+DTrr4fy4K4OjO/U29jkUhOK5K4OjO0WjuznN1I64K4OjOx6E1TgKcdW5K4OjO72LBTn1sPO4K4OjOzA7hLmHajA7LIOjOxThNLq2XBw7LIOjO0aj5bm0XBw7LIOjO81qCjjyqw87LIOjOxXhNLrZSg47LIOjO0ej5bnUSg47LIOjO0ej5blKj/s6K4OjO5uYKro4cf46LIOjO6R51jl10Nw6LoOjOyZonDlhbtM6LoOjOw/4ADqwUwI7LIOjO1zqrznh+fE6LYOjO9yYPDmyXBw7LIOjO3gGODp/LhA7LIOjO3sGODon0A07LIOjO+65dzqEajA7LIOjO+G5dzq2XBw7LIOjO0/8iznCLdw6LoOjO+u41jjHP/o6LYOjO0exu7j4e/U6LYOjO3CBSrnA4gc7LIOjO6SLlTmCLhA7LIOjO0/8iznJ2A87LIOjOylqCjgikQQ7LIOjO+tRTjYmS/06LIOjO1eqbzqT9wc7LIOjOwU8NDrqaAI7LIOjO4+GKTrFxeQ6LYOjOzMeXjp1hv46LIOjOzO3GDpSdv86LIOjO1KgwLlw0wU7LYOjO7vO27lr1N86LYOjOxX0E7q9CNA6LYOjO5J00rnKBPg6LYOjO+uxl7necMs6LYOjOwCY9rjzj/w6LIOjO02iAjqMVdc6LYOjO3BmODqCwLE6DhNUOgnXoztSo2U6DxNUOgnXozv7UZs6SzoROgnXozuFkrA6SzoROgnXozuugcQ6ffkLOgnXozszo9Y6FA5LOgnXozsAbdI6x775OQnXozvHlfE656UwOgjXoztuqdo6EyHKOQnXozuhnfE6SxUNuQjXozuyHwE7aVRcOAjXozu9f9o6idUQOQnXozvcGNI6FkwkOAnXozvhgMQ66QzKtwnXozt9HdY6O9iGuQnXozsc47E6gfBAuAnXozuh6K86lc+duQjXozv4UZs6ePBAuAjXoztMo2U674dYugjXozv4UZs68odYugjXozv4UZs6ks+duQjXozuH7AM7KTWXOQjXoztrYd06JhOMOQnXoztcQs26/YdYug/Xozu4+KO6/IdYug/Xozuz+KO6PToROg/XoztHBqA5KOGGuQrXozsFRxw6uQ3LuQ3XoztH3ik6jt8stw3XoztS2YA5N+HiuQrXozv15+05nhMrugrXozuPZBU56MENugrXoztmYPi5qxMrug3XozszD4m5O25Tug3XozuZVSq59MENug3XozsAUou5QeHiuQ3Xozt7fqq5LuGGuQ/XoztSgyG6tw3LuQ3XoztSVrS5Et4stw/XoztwGi+6vN8stw/Xozukfqq5hSZ4OQ/XoztSgyG6yT/AORLXozsAUou5UxPYOQ/XozsA3qk5tNwstwrXozsURxw6xj/AOQrXozs9BqA5hiZ4OQrXozvr5+05sKwlOgnXozuF2YA5WBPYOQrXozuFLX05RQdOOgnXozukZBU5+VoIOgrXozs9YPi5tKwlOhLXozuZVSq5/1oIOg/XozvCLX05K25TugrXozuuhye3gWoXugrXozsehSe33Y1gugrXozuPgie36iZbOg3XozuPgie3iQMSOg3XozsfD4m5RwdOOg/XozuX7AO7BhNUOg/XozuX7AO7RDoROg/XoztXQs26SjoROg/Xozu4w1K6BxNUOg/Xozu4w1K6RToROg/XozsK16M7kFevOClsFboK16M7QVRFODTGXboK16M7AiykOWI2V7oK16M7y0f8uDdEC7oK16M7bXWHuUX+T7oK16M7v+SGud7h27kK16M7QSYAumf7JroK16M7JjyvuUCgfbkK16M7wKiruQVsdjkK16M7LaolusrFszkK16M7jpEzumYmvbcL16M7vBF5ues72jkL16M78y36uYCRIToL16M7mES9uBLvCjoL16M7VZNuuRxaTjoL16M7CxjsOPNrFToL16M7BhUOOinmSjoL16M7z5asOamkWDoL16M7AimxOWQfDjoK16M7G5sOuMJDBzkK16M7G5sOuEcfBLkK16M7X3OAOUcfBLkK16M7X3OAOeg7DroK16M7qqcPOjTgQroL16M7qqcPOsJDBzkK16M76bG7ucK1+7YK16M7wU0muvLOxrkL16M7zFEAOw+yVjoL16M7RiPYOg+yVjoL16M7RiPYOh7eKTkL16M7RiPYOkc03LgK16M7d8hNOvDoVboK16M7jWSPOvDoVboL16M7jWSPOkc03LgL16M7d8hNOg+yVjoK16M7bZupup+iFDoK16M7rNd0up+iFDoK16M7rNd0ug+yVjoK16M7aYDSup+iFDoJ16M7aYDSui4QE7oJ16M7bZupui4QE7oK16M7ANgAuw+yVjoK16M7ANgAu5+iFDoQ16M7+yUpu9joVboP16M7AnURu9joVboQ16M7jn4iu7gIjLkQ16M79yI4u+nal7kQ16M7LYgvuz0YeDkQ16M7AbEzu673KTkQ16M7Stsmu4/ivzYQ16M78mofux6VtzgQ16M7NY8au8w1WjkQ16M7YCw6u2Zq9TgQ16M7MkAwuwpzH7gQ16M7tJxCu8Lo1TgQ16M7k/FGux+0ELkQ16M7UAk+u3vJOLkQ16M7rsRKu8Lo1TgQ16M7rsRKux+0ELkQ16M7RQkpu6So3rgQ16M7hJMbu3jRFzoQ16M74gkzu+QPBjoQ16M7QhAuu3WJsTkQ16M7cNQYuzPywDkQ16M7/rQvu0+jUDoQ16M7ncc/uyayVjoQ16M7+fVBu2TZEzoQ16M7IGgju3h/PDoQ16M71wRfuyuyVjoQ16M7rsRKu2TZEzoF16M7F8UrO9foVboF16M76WlAO9foVboF16M76WlAO2TZEzoG16M7rHkOOyayVjoG16M7rXkOO2TZEzoG16M7F8UrO2nZEzoG16M7VLVdOyuyVjoG16M7VLVdO2nZEzoQ16M72QRfu9joVboQ16M7sMRKu9joVboJ16O7+CvWOsXoVboJ16O7+CvWOge0ELoJ16O7Q04YOwe0ELoK16O7EqmiOsXoVboK16O7LohzOlt9EboJ16O7LohzOlLo1bgK16O7C76GOcXoVboK16O7C76GOVt9EboK16O7EqmiOjuyVjoJ16O7LohzOs9GEjoJ16O7C76GOc9GEjoJ16O7C76GOTuyVjoH16O7SsSUuj2yVjoN16O7gjUxuT2yVjoG16O7wi78udJGEjoN16O7SsSUutJGEjoJ16O7VAyQur0jGrkJ16O7VAyQugA03DgH16O7wi78uQA03DgJ16O7GUD4usLoVboJ16O738QQu8LoVboJ16O738QQu3vZEzoK16O7Qqm9uj2yVjoK16O7Pam9unvZEzoK16O7GUD4unvZEzoH16O7ShAuuz2yVjoH16O7ShAuu3vZEzoJ16O7gjUxucToVboJ16O7ri78ucToVboH16O7wi78ub0jGrlhspy66yqku8voVbrhoFq66yqku8zoVbqKY4+67Sqku6QIjLlcrLq67Sqku9Lal7nHdqm67Sqku2sYeDlwyLG67Sqku+H3KTkAHZi67Sqku1LovzZSPIm67Sqku4WVtziuCX+67SqkuwA2Wjkuv7667Sqku8xq9TjS5qq67Sqku1JyH7jXn8+67SqkuzPp1TiUSdi67Sqku/CzELkPeca67Sqku0fJOLnH79+67Sqkuynp1TjH79+67Sqku/CzELn2eJy67Sqku1Ko3rh2jYG67Sqku4LRFzozerC67Sqku/APBjrwhqa67Sqku4+JsTmZHni67Sqku03ywDlr0Km67Sqku1yjUDqp9cm67SqkuzOyVjphUs667Sqku3DZEzquNpG67Sqku4V/PDoNOAS77SqkuzWyVjrH79+67Sqku3PZEzqCyxy77SqkuzWyVjpPGly77SqkuziyVjrPp0e76yqku81GEjqCyxy77Sqku8pGEjp9Jx+77Sqku9IjGrl9Jx+77Sqku9cz3DjPp0e76yqku9cz3DgFKio76yqku9PoVbrXzj476yqku9ToVbrXzj476yqku2nZEzrHNv467Sqkuy6yVjoZpdk67Sqkuy6yVjoXpdk67Sqku2HLublCpJQ67Sqkuy6yVjoh24c67Sqku+vtwTlSL8066yqku9LoVbrHNv466yqku9LoVbpcYoI56yqku8KigbkfdQ067Sqku0LPxblSDBs66yqkuzMzorQza0Y56yqku9ei3bkKRNA56yqku2t0KLrCObQ46yqku7ciC7oUAgu66Sqku3J0KLoKs6a56iqkuwbPULoenWW56yqku8AiC7rC9ai56yqku9ei3bl7Isi56iqku8aigbkzVTC66Sqku0bPxbk9+tG56yqku/YoorRm7D266yqku/YoorSkIsi56yqku7NRgTlHVTC67SqkuzV+xTnr9ai56yqku8VR3TkUOow56yqku/YoorQkdQ066iqkuy5+xTlcYoI56yqku6tRgTkARNA56iqku+RLKDpHa0Y56yqku71R3TnC5UE56iqku3imUDrCObQ46yqkuzD6CjofAgu67Sqku+tLKDpwnWW56yqkuzj6CjrX5UE56yqkuwDPULpSgIu46iqku0nLFLpSgIu46iqku6ruXbpSgIu46yqkuyTGXTpSgIu46yqku8KiFDoes6a57Sqku4CmUDoLFwE7MtYFOgjXoztSmsm6K4OjOxzhNLpMf/K6K4OjOxzhNLpSmsm6K4OjO+G5dzpSf/K6K4OjO+O5dzoF7J+6K4OjO/vbHjr1Ble6K4OjO30EfjprjQk6KYOjO965dzoJ16O7LohzOuFuIDkK16O7kHiWOVLo1bgJ16O7kHiWOeFuIDkJ16O7wcAsO8XoVboK16O7Q04YOzuyVjoK16O7wcAsOzuyVjqZ3gw77SqkuyuyVjqZ3gw77Sqku2nZEzoFKio77Sqku2vZEzpCGlw76yqkuyuyVjpCGlw76yqku2nZEzrhkkY67SqkuzCyVjrhkkY67Sqku8/oVboh24c67Sqku9DoVboPOAS77Sqku8roVbrM79+67Sqku8roVbpPGly76yqku8foVbrSp0e76yqku8foVbrPp0e76yqku9IjGrkL16M7jWSPOh7eKTkL16M7jWSPOg+yVjoL16M7zFEAO/DoVboL16M7RiPYOvDoVboL16M7BhUOOlfw9jkL16M7SeLmOADGXToJ16M7rNd0uvDoVboK16M7rNd0ui4QE7oJ16M7ANgAu/DoVboJ16M7ANgAuy4QE7rzkYM1AACAP+m6y6/0w+IqAACAP9/p9jXQwDU1AACAP3W2ZDXmD0I1AACAP6S6E7MTlvW0AACAP6AKqbQecZa1AACAP0CA+bTJu8q1AACAP0LHX7UAAAAAAACAPwAAAABUyWi0AACAPxvSPbQAAAAAAACAPwAAAAAlabQ1AACAP21qqjQAAAAAAACAPwAAAABWbZM0AACAP9VCozFATNc1AACAP7teyzQAAAAAAACAPwAAAAD106g1AACAPzOOk7SZHck1AACAP1zGr7QAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAACA/4S1AACAP9+6sbMAAAAAAACAPwAAAAAQ5Zc0AACAPyO++rWopnY1AACAP3EdG7Y96m82AACAPzzekDWEWoo2AACAP3ioojWZd2s2AACAP5H11TWNNwQ2AACAP9LrBzZOK2E2AACAPzV5OTUAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAACeh8A1AACAPy5HUrUX00U2AACAP2+gozN4Tc40AACAP2+CM7ULXp41AACAPyZWETUAAAAAAACAPwAAAAAAAAAAAACAPwAAAAB9iik2AACAP7xmljSH+sI1AACAPy9fpzQAAAAAAACAPwAAAABlJKQ1AACAP46Fz7RhJQ42AACAP07y1bQ0mCc2AACAP+vAubQq/pk1AACAP0lbM7Y/V621AACAP//JlbYbqig2AACAP6NEx7UAAAAAAACAPwAAAACEPvo1AACAP1Tlp7WkSJq0AACAP/zIo7UO/342AACAP000QrOyORc2AACAPwqnLDUAAAAAAAAAAAAAgD84QqKzxIngtAAAgD8+JtO0A93/tAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD+776A1KLcKtAAAgD83C7E17b/tNAAAgD9RTAk2rikONQAAgD+D6eI1yAxDNQAAgD/npQw2Ae4KtQAAgD/iEu014h46tQAAgD9oa+01fblEtQAAgD/Ltro11VzmtAAAgD++Bfe0owB3tQAAgD+fTZ40qb2+tAAAgD9jwbq131UXtgAAgD9K4KO1hN6WtQAAgD9CtrS025NBtQAAgD/yQ200u/y7swAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD9nb/c1WzyoMgAAgD/Vqvc1yN6FsgAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8jIHe29hlMNQAAgD9CFmy2O5MEtQAAgD/D20224QCFNQAAgD//8/+1rYDLtAAAgD/2/Ly17cuytQAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD9sPUI2nK77tAAAgD+ALls26j6jtQAAgD8/NZq0KJ8UtgAAgD9aYJ61RxaMtgAAgD+dNrW1ltxKtgAAgD8AAAAAAAAAAAAAgD8kWacryAAFtgAAgD/IPhw2monXtQAAgD/MH1E24KoptgAAgD/fV1w20aEJtgAAgD/a6Xa2UURerAAAgD850ha1HPfvNQAAgD+IwrW1E/tiNQAAgD/Mz+U0CAeGNQAAgD9Qu7g0CxIjNQAAgD+2NXU2JxgRNAAAgD9HsHs2jfCwtAAAgD9Qg342g2FUtQAAgD9LB642f9FKNQAAgD8AAAAAAAAAAAAAgD+wIks24YFBtQAAgD87Fh82VDCyLAAAgD8n+bI2AAAAAAAAgD9eitY2DQaVNAAAgD/YQag2sOKoNQAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/QlwBtaiWtrUAAIA/d7oatQKRhbUAAIA/AAAAAAAAAAAAAIA/i74VtY9kkbUAAIA/k7QrtQWoTbUAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/r5gBtTfLDbUAAIA/AAAAAAAAAAAAAIA/bdawtbM22bQAAIA/NS2/tK/Ui7QAAIA/CYx9tORIv7QAAIA/oNCYtdpyN7UAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/+7+YtLrXP7UAAIA/AAAAAAAJYbUAAIA/KZYVtSs0i7QAAIA/HXxwtP/XoLMAAIA/AAAAABMgvbMAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAABYgvbMAAIA/AAAAABMgvbMAAIA/h4Dos0FXgbQAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/WxGbNfN2ZbQAAIA/wEzdNYS8o7QAAIA/x7u2NKczh7MAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/piKRNMqDhLMAAIA/AAAAAAAAAAAAAIA/1RbMNVjZL7YAAIA/w7WuM+AgGTQAAIA/AAAAAAAAAAAAAIA/Z2tsNU0WgbQAAIA/NlcstAwF/LQAAIA/hfgytQAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/U4c+tJQrYbQAAIC/KDo+tAjbzzQAAIC/xyoONWfyKTUAAIC/5CQ8tZ4F9zMAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/ex2ctQWvKrUAAIC/9792tdsHn7UAAIC/R8MHte1eyrQAAIC/BJoitQAAAAAAAIC/yNg/Nju7ozYAAIC/MY66tl+kcLYAAIC/kfbDtpIsHbYAAIC/u+eYNrRBGTcAAIC/KXOBNQAAAAAAAIC/KXOBNQAAAAAAAIC/NvyotsAF9zMAAIC/qCKRtMyDhLMAAIC/AAAAAAAAAAAAAIC/g5/ptRB9M7UAAIC/srWutMcgGTUAAIC/AAAAAAAAAAAAAIC/uKimtY7PKTUAAIC/1reytTimejQAAIC/hviytQAAAAAAAIC/X6yetSdTtjQAAIC/AAAAALYpbzUAAIC/NW4dtmDY/bQ6CcEyAACAv2RNkrVw+nuqAACAv5C+kbU1hgwzAACAv4DPPLXk+ugyAACAv+NF1bQAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAArgjm1AACAv4cwFLXbIWE1AACAv2iqkbU2CWM1AACAvyBVhrX5pXS1AACAvwAAAAApc4G1AACAvwAAAAApc4G1AACAvwAAAABylH81AACAvwAAAACnIpE0AACAv8uDhLMAAAAAAACAvwAAAAAW79U1AACAv7YwBLZGp3Q0AACAv8mwaLMAAAAAAACAvwAAAAAiTXW0AACAv/eiObXA4JQyAACAv+Lq77OgCK40AACAv3Mzl7M/SNS0AACAv4RllLUWcA41AACAv85BgrXcPpy1AACAvwGKVzX1zMK1AACAv7Xq7DT74AUqAACAv9EAhTUw9H+1AACAv4GBS7Tn/Dy1AACAv5XLMrWTLtu1AACAvzY/I7XL9Ge2AACAv3TA57Wm6Je1AACAv/6XjLV43J60AACAv1tIL7Z7tFK2AACAvyxJfbV/yc21AACAv6EdILV2LQ+2AACAv5HY5LUAAAAAAACAv3v4obXo0Uk0AACAv6X6AbbUPpw1AACAv8yJV7XcH9E1AACAv+CqqbXbV9w1AACAv9ehibUAAAAAAACAvwAAAADUH9E1AACAv/CqqTXWPpw1AACAv+KJVzVkZtE1AACAv2GosjXRV9w1AACAv9qhiTXo38s1AACAv78dojWvBYI1AACAv0oG7jVoZtE1AACAv2mosrWTBYI1AACAv1gG7rVzPcK1AACAv16ve7RTeTa1AACAv7BFq7VBFp+1AACAvwAAAABGFh82AACAvwAAAAB3ebY1AACAv56MyyvF38s1AACAv9MdorXdtN81pdBINQAAgD8AAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAACnZAS1AACAPzGpC7UAAIC/sWaLtTBeSTQAAIC/nfJvNGc27jUAAIC/AAAAAN3cHDYAAIC/N/0qtPwQebQAAIC/VKk9syA+yLQAAIC/AAAAAPi3w7S/tS40AACAv9ggmTQAAAAAAACAvwAAAAALXIY1AACAv4sxWTPp17Q0AACAv5Z5fLQAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAACOLGk0AACAv3Z92bMAAAAAAACAvwAAAACV+Vg0AACAv4DCRrQAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/uggHteCiPrUAAIA/7zhetd7cnLUAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAEAAgAAAAMABAAEAAUABgAEAAcAAAAIAAkABwAIAAcABAAGAAgABAAKAAsADAAMAA0ACgAMAA4ADwAPABAADAARABIAEwATABQAEQAUABMAFQAVABYAFAAWABUAFwAXABgAFgAYABcAGQAZABoAGAAaABkAGwAcAB0AHgAfACAAIQAgAB8AIgAiACMAIAAjACIAJAAkACUAIwAlACQAJgAmACcAJQAnACYAKAAbACgAGgAoABsAJwApACoAKwAqACkALAAsAC0AKgAsAC4ALQAuACwALwAwADEAMgAwADMANAA1ADYANwA4ADkANQA4ACkAKwA6ADsAPAA7ADoANAA9AD4APwA9AEAANAA0ADEAMAA0AEAAOwA0ADMAPQBBAEIAQwBCAEEANwA3ADYAQgA3ADgANQBDAEQAQQBEAEMARQBGAEcALwBIAEkASgAvAEgARgAvAEcALgBKAEYASAA8AEsAOgA8AEoASQBJAEsAPAA/AEAAPQArAD8APgArADkAOAA+ADkAKwAyAEwAMAAyAE0ARQBFAE0ARABFAEwAMgBOAE8AUABOAFEAUgBSAFMATgBTAFIAVABUAFUAUwBVAFQAVgBXAFgAWQBaAFsAXABcAFcAWgBbAF0AXgBeAFwAWwBeAF0AXwBgAGEAYgBgAGIAXwBQAFEATgBfAGIAXgBfAE8AYABPAF8AUABYAGMAZABZAFoAVwBlAGYAZwBoAGkAagBpAGgAawBrAGwAaQBsAGsAbQBuAG8AcABxAHIAcwBzAG4AcQByAHQAdQB1AHQAdgB1AHMAcgB2AHcAdQB3AHYAeABqAHkAaABqAHoAewB6AHwAfQB7AHkAagB8AH4AfwB9AHsAegB4AIAAdwCAAHgAgQBtAIIAbACCAG0AgwBvAIQAgwBwAHEAbgCDAIQAggCDAHAAbwB+AIUAhgB/AH0AfACGAH8AfgCGAIUAhwCBAIcAgACHAIEAhgCIAIkAigCLAIgAigBnAIwAiwBnAIoAZQCKAGcAiwCNAI4AjwCOAI0AkACQAJEAjgCRAJAAkgCSAJMAkQCTAJIAlACVAJYAlwCWAJUAmACYAJkAlgCZAJgAmgCaAJsAmQCbAJoAnACdAJ4AnwCgAKEAogCPAKMAjQCPAKQAowCjAKQApQCiAKUAoAClAKIAowCXAKYAlQCmAJcApwCUAKcAkwCnAJQApgCoAKkAqgCoAKoAqwCsAK0ArgCvAKwArgCwALEAsgCzALAAsgCzALQAtQC2ALcAswCyALYAswC4ALkAugC6ALsAuAC8AL0AvgC8AL8AwAC+AL8AvAC9AMEAwgDDAMQAxQDDAMYAxwDCAL4AvQDIAMIAxQC7ALoAyADFALsAyADFAMEAwwDFAMIAwQDJAMoAywDAAMsAvADLAMwAyQDLAMAAzADNAM4AzwDKANAAzQDKAMkA0ADOANEA0gDPAMoAzQDSAM8AzgDTANQA1QDWANcA2ADZANYA2ADVANgA0wDVANoA2QDYANUA2QDGANEA2wDGANIA0QDHAMQAwwDbANwAxwDbAMcAxgDdAN4A3wDgAOEA4gDhAOAA4wDjAOQA4QDlAOAA4gDlAOYA5wDnAOgA5QDpAOoA6wDrAOwA6QDtAO4A7wDwAPEA8gDzAPQA9QD2APMA9QDyAPcA9gDyAPUA8AD1APIA9gD4APkA+gDqAPgA+gDvAOsA6gDvAPoA7QD6AO8A6gD7APwA/QD9AP4A+wD/AAABAQH/AAIBAwEBAQIB/wAAAQQBBQEGAQcBCAEGAQkBCgEFAQEBAAELAQUBCAH+AP0ACwEIAf4ACwEIAQQBBgEIAQUBBAEMAQ0BDgEDAQ4B/wAOAQMBDwEOAQ8BDAEQAREBEgENAQwBEwENARMBEAERARQBFQESAQ0BEAEVARIBEQEWARcBGAEYARkBFgEaARsBHAEdAR4BHwEgASEBIgEjASQBJQEiASYBIAElASIBIwElASYBIgEnASgBKQEoAScBKgEqASsBKAErASoBLAEtAS4BLwEwATEBMgEyAS0BMAExATMBNAE0ATMBNQE0ATIBMQE1ATYBNAE2ATUBNwEpATgBJwEpATkBOgE5ATsBPAE6ATgBKQE7AT0BPgE8AToBOQE3AT8BNgE/ATcBQAEsAUEBKwFBASwBQgEuAUMBQgEvATABLQFCAS8BLgFCAUMBQQE9AUQBRQE+ATwBOwFFAUQBRgFFAT4BPQFAAUYBPwFGAUABRQFkAFkAWABWAGQAYwBWAEcBVQBjAEcBVgBIAUkBDgBKAUgBDgALAEsBSgEOAAwACwAOAAsASgEeAEwBHAAhAB4AHQAhAE0BHwAdAE0BIQBOAQUAAwBOAQYABQADAAAAAgADAAIATgHiAE8B5QBPAeYA5QBPAeIAUAFQAVEBTwHfAFIB3QBSAd8AUwFTAVQBUgFVAVYBVwFYAVUBVwEfAVkBWAEfAVcBHQFXAR8BWAEkAVoBWwEkASMBWgFbAVwBJAEJARQBXQEJARUBFAEKAQcBBgFdAQoBCQFdAV4BCgFfAWABYQEXAV8BYQEcAWEBGgEcARgBFwFhARwBFwFiAWMBrwCqAGIBrgCrAGQBqACrAGUBZAGuAGIBrwCuAKsAqgCfAGYBnQCcAJ8AngCcAGcBmwCeAGcBnABoAWkBtQBqAWgBtQC0AGsBagG1ALAAswC1ALQAagEAAIA/AAAAAAAAAD8AAAAAAAAAPwAAAD8AAIA/AAAAPwAAAAAAAAAAAAAAAAAAAD8AAAA/AACAPwAAgD8AAIA/AAAAAAAAgD+hm0Q7bhKDuqKbxDsAAAAAbhKDuqKbxDsAAAAAbhKDuqKbRDuhm0Q7bhKDuqKbRDuhm0S7bhKDuqKbxDuhm0S7bhKDuqKbRDsAAAAAbhKDugAAAAChm0Q7bhKDugAAAAChm0S7bhKDugAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAEAAgAAAAIAAwABAAQABQABAAUAAgADAAIABgADAAYABwACAAgABgACAAUACAAAAIA/AAAAAAAAAAAAAIA/AACAPwAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAIA/AACAPwAAAAAAAAAAbxKDOm8Sgzqim8Q7bxKDOm8Sg7oAAAAAbxKDOm8SgzoAAAAAbxKDOm8Sg7qim8Q7bxKDOm8Sg7qim8Q7bxKDum8Sg7oAAAAAbxKDOm8Sg7oAAAAAbxKDum8Sg7qim8Q7AACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAABAAIAAwABAAAABAAFAAYABwAFAAQAAACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AACAPwAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAIA/AACAPwAAgD8AAAAAAAAAAAAAgD8AAIA/AACAPwAAAAAAAAAAbxKDum8Sg7pvEgM7bxKDum8SgzpvEgM7bxKDum8SgzoAAAAAbxKDum8Sg7oAAAAAbxKDOm8Sg7pvEgM7bxKDum8Sg7pvEgM7bxKDum8Sg7oAAAAAbxKDOm8Sg7oAAAAAbxKDOm8SgzpvEgM7bxKDum8Sg7pvEgM7bxKDOm8Sg7pvEgM7bxKDum8SgzpvEgM7AACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAALAAkA");
// CONCATENATED MODULE: ./src/features/navigation-cube/index.ts
function features_navigation_cube_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // @ts-expect-error no types







const {
  UPDATE_LOCAL: navigation_cube_UPDATE_LOCAL,
  UPDATE_WORLD: navigation_cube_UPDATE_WORLD
} = lib["jb" /* Transform */].StateMask;
const $navigationCube = Symbol('navigationCube');
// doesn't work in orthographic projection
const CAMERA_DISTANCE = 4;
const $cubeVisibility = Symbol('cubeVisibility');
class features_navigation_cube_NavigationCube {
  constructor(options) {
    features_navigation_cube_defineProperty(this, "_layers", void 0);

    features_navigation_cube_defineProperty(this, "_store", void 0);

    features_navigation_cube_defineProperty(this, "_picker", void 0);

    features_navigation_cube_defineProperty(this, "_controls", void 0);

    features_navigation_cube_defineProperty(this, "_moveCamera", void 0);

    features_navigation_cube_defineProperty(this, "_scene", void 0);

    features_navigation_cube_defineProperty(this, "_camera", void 0);

    features_navigation_cube_defineProperty(this, "_cameraNode", void 0);

    features_navigation_cube_defineProperty(this, "_cameraTransform", void 0);

    features_navigation_cube_defineProperty(this, "_arrows", void 0);

    features_navigation_cube_defineProperty(this, "_arrowsAreHidden", void 0);

    features_navigation_cube_defineProperty(this, "_arrowsDisplayThreshold", void 0);

    features_navigation_cube_defineProperty(this, "_view", void 0);

    features_navigation_cube_defineProperty(this, "_glbUrl", void 0);

    features_navigation_cube_defineProperty(this, "_boxOffsetY", void 0);

    features_navigation_cube_defineProperty(this, "_pivot", void 0);

    features_navigation_cube_defineProperty(this, "_updateViewport", () => {
      const {
        position,
        offset,
        size
      } = this._store.navigationCube;
      const {
        width,
        height
      } = this._store.window.size;
      const aaPixelRatio = this._store.renderer.antialiasing.pixelRatio;
      const fullWidth = width * aaPixelRatio;
      const fullHeight = height * aaPixelRatio;
      const viewportSize = Math.min(Math.abs(size * aaPixelRatio), fullWidth, fullHeight);
      let viewportOffsetX = Math.abs(offset.x * aaPixelRatio);
      let viewportOffsetY = Math.abs(offset.y * aaPixelRatio);

      if (viewportSize + viewportOffsetX > fullWidth) {
        viewportOffsetX = fullWidth - viewportSize;
      }

      if (viewportSize + viewportOffsetY > fullHeight) {
        viewportOffsetY = fullHeight - viewportSize;
      }

      const viewport = {
        x: 0,
        y: 0,
        width: viewportSize,
        height: viewportSize,
        fullWidth,
        fullHeight
      };

      switch (position) {
        case 'TOP_LEFT':
          viewport.x = viewportOffsetX;
          viewport.y = Math.round(fullHeight - viewportSize) - viewportOffsetY;
          break;

        case 'TOP_RIGHT':
          viewport.x = Math.round(fullWidth - viewportSize) - viewportOffsetX;
          viewport.y = Math.round(fullHeight - viewportSize) - viewportOffsetY;
          break;

        case 'BOTTOM_LEFT':
          viewport.x = viewportOffsetX;
          viewport.y = viewportOffsetY;
          break;

        case 'BOTTOM_RIGHT':
          viewport.x = Math.round(fullWidth - viewportSize) - viewportOffsetX;
          viewport.y = viewportOffsetY;
          break;

        default:
          break;
      }

      this._layers.layer3dNavigationCube.viewport = viewport;

      this._layers.layer3dNavigationCube.setNeedsDrawOnce($navigationCube);
    });

    features_navigation_cube_defineProperty(this, "_handlePick", async event => {
      await this._setView(event.hitTarget.name);
    });

    features_navigation_cube_defineProperty(this, "_getCurrentView", (() => {
      const direction = new math_lib["n" /* Vector3 */]();

      const closeToZero = v => Math.abs(v) / direction.length < this._arrowsDisplayThreshold;

      return () => {
        const {
          target
        } = this._controls;
        const {
          position
        } = this._controls.cameraTransform;
        const {
          x,
          y,
          z
        } = direction.copy(target).subtract(position);
        let view = null;

        if (closeToZero(x) && closeToZero(y)) {
          view = z > 0 ? View.BACK : View.FRONT;
        }

        if (closeToZero(x) && closeToZero(z)) {
          view = y > 0 ? View.BOTTOM : View.TOP;
        }

        if (closeToZero(y) && closeToZero(z)) {
          view = x > 0 ? View.LEFT : View.RIGHT;
        }

        return view;
      };
    })());

    const {
      layers,
      picker,
      store,
      controls,
      moveCamera,
      boxOffsetY = 0,
      pivot = new math_lib["n" /* Vector3 */](0, 0, 0)
    } = options;
    this._store = store;
    this._picker = picker;
    this._layers = layers;
    this._controls = controls;
    this._moveCamera = moveCamera;
    this._scene = null;
    this._camera = null;
    this._cameraNode = null;
    this._cameraTransform = null;
    this._arrows = new Map();
    this._arrowsAreHidden = true;
    this._arrowsDisplayThreshold = 0.05;
    this._view = null;
    this._boxOffsetY = boxOffsetY;
    this._pivot = pivot;
    this._glbUrl = Object(global_helpers["j" /* getBinAssetBlobUrl */])(navigation_cube);
    const {
      elementStaging,
      vertexStaging
    } = layers.layer3dService.renderer;

    this._create({
      elementStaging,
      vertexStaging
    });

    this._addListeners();
  }

  _addListeners() {
    const {
      navigationCube,
      controls
    } = this._store;
    Object(mobx_module["h" /* reaction */])(() => navigationCube.enabled, enabled => {
      if (!this._scene) {
        return;
      }

      Object(global_helpers["E" /* setNodeVisibilityTraverse */])(this._scene.root, enabled, $cubeVisibility);

      this._calcCameraTransform();

      this._layers.layer3dNavigationCube.setNeedsDrawOnce($navigationCube);
    });
    Object(mobx_module["h" /* reaction */])(() => navigationCube.position, this._updateViewport);
    Object(mobx_module["h" /* reaction */])(() => navigationCube.offset, this._updateViewport);
    Object(mobx_module["h" /* reaction */])(() => navigationCube.size, this._updateViewport);
    Object(mobx_module["h" /* reaction */])(() => controls.rotation, ({
      maxPolarAngle
    }) => {
      this._setArrowEnabled(View.BOTTOM, maxPolarAngle >= Math.PI);
    });

    this._controls.onAfterUpdate.subscribe(isChanged => {
      if (!isChanged) {
        return;
      }

      const view = this._getCurrentView();

      if (view) {
        this._view = view;

        this._showArrowsByView(view);
      } else {
        this._hideAllArrows();
      }
    });

    this._controls.camera.onEarlyUpdateEnd.subscribe(() => {
      this._calcCameraTransform();
    });

    this._layers.layer3dNavigationCube.onStagingsRecreated.subscribe(stagings => {
      this._create(stagings);
    });

    this._layers.layer3dNavigationCube.onUpdateSize(this._updateViewport);
  }

  _calcCameraTransform() {
    if (!this._cameraTransform || !this._camera) {
      return;
    }

    this._camera.aspect = 1;
    this._camera.needsUpdateProjection = true;

    this._cameraTransform.orientation.copy(this._controls.cameraTransform.orientation);

    this._cameraTransform.position.set(0, 0, CAMERA_DISTANCE).applyQuaternion(this._cameraTransform.orientation).add(this._pivot);

    this._cameraTransform.state = navigation_cube_UPDATE_LOCAL | navigation_cube_UPDATE_WORLD;
  }

  async _create(stagings) {
    await this._importCube(stagings);

    this._createArrows(stagings);

    Object(global_helpers["E" /* setNodeVisibilityTraverse */])(this._scene.root, this._store.navigationCube.enabled, $cubeVisibility);
  }

  _setArrowEnabled(view, enabled) {
    const arrow = this._arrows.get(view);

    if (!arrow) {
      return;
    }

    arrow.disabled = !enabled;

    if (enabled && this._view) {
      arrow.show();
    }

    this._layers.layer3dNavigationCube.setNeedsDrawOnce($navigationCube);
  }

  _createArrows({
    elementStaging,
    vertexStaging
  }) {
    if (!this._scene) {
      return;
    }

    const boxOffsetY = this._boxOffsetY;
    const cubeSize = 1;
    const halfSize = cubeSize / 2;
    const offset = 0.2;
    const arrowsData = [{
      type: 'bottom',
      view: View.BOTTOM,
      position: [0, -offset + boxOffsetY, 0],
      orientation: [0, arrow_Axis.X],
      disabled: this._store.controls.rotation.maxPolarAngle <= Math.PI / 2
    }, {
      type: 'right',
      view: View.RIGHT,
      position: [offset + halfSize, halfSize + boxOffsetY, 0],
      orientation: [Math.PI / 2, arrow_Axis.Z]
    }, {
      type: 'top',
      view: View.TOP,
      position: [0, cubeSize + offset + boxOffsetY, 0],
      orientation: [Math.PI, arrow_Axis.Z]
    }, {
      type: 'left',
      view: View.LEFT,
      position: [-(offset + halfSize), halfSize + boxOffsetY, 0],
      orientation: [-Math.PI / 2, arrow_Axis.Z]
    }, {
      type: 'front',
      view: View.FRONT,
      position: [0, halfSize + boxOffsetY, halfSize + offset],
      orientation: [-Math.PI / 2, arrow_Axis.X]
    }, {
      type: 'back',
      view: View.BACK,
      position: [0, halfSize + boxOffsetY, -(halfSize + offset)],
      orientation: [Math.PI / 2, arrow_Axis.X]
    }];

    for (const {
      type,
      view,
      position,
      orientation,
      disabled
    } of arrowsData) {
      const [angle, axis] = orientation;
      const arrow = new arrow_Arrow({
        name: 'nvc_arrow_' + type,
        position: new math_lib["n" /* Vector3 */](...position),
        orientation: new math_lib["i" /* Quaternion */]().fromRotation(angle, axis),
        color: new math_lib["k" /* RGBColor */]().fromPackedInteger(0x9E9E9E),
        parentNode: this._scene.root,
        onClick: () => this._setView(view),
        picker: this._picker,
        radius: 1,
        height: 1,
        size: 0.15,
        view,
        vertexStaging,
        elementStaging,
        disabled
      });

      this._arrows.set(view, arrow);
    }
  }

  _unsubscribe() {
    if (!this._scene) {
      return;
    }

    this._picker.onPick.unsubscribeTarget(this._scene.root);

    if (this._arrows.size) {
      this._arrows.forEach(arrow => arrow.unsubscribe());
    }
  }

  async _importCube({
    elementStaging,
    vertexStaging
  }) {
    this._unsubscribe();

    const {
      componentClasses
    } = this._layers;
    this._layers.layer3dNavigationCube.scene = new lib["Y" /* Scene */]({
      config: {
        componentClasses
      }
    });
    this._scene = null;
    this._cameraNode = null;
    this._cameraTransform = null;
    const gltfLoader = new gltf_importer_lib["b" /* GLTFImporter */]({
      createScene: (maxSceneNodes, batchMap) => {
        return new lib["Y" /* Scene */]({
          maxSceneNodes,
          batchMap,
          config: {
            componentClasses
          }
        });
      },
      attributeMemoryManager: vertexStaging,
      indexMemoryManager: elementStaging,
      materialFactory: new lib["E" /* MaterialFactory */]()
    });
    const assets = await gltfLoader.import(this._glbUrl);
    const [scene] = assets.scenes;
    scene.retain();
    assets.dispose();

    if (scene === undefined) {
      throw new Error('No scene cube');
    }

    this._camera = new lib["f" /* Camera */]({
      name: 'navigationCubeCamera',
      zfar: 10,
      znear: 0.1,
      orthographicProjection: {
        xmag: 3,
        ymag: 3
      }
    });
    this._camera.projectionType = lib["f" /* Camera */].ProjectionTypes.ORTHOGRAPHIC;
    this._scene = scene;
    scene.name = 'Navigation cube';

    this._prepareBoxCube(scene);

    this._layers.layer3dNavigationCube.scene = scene;
    this._cameraTransform = new lib["jb" /* Transform */]({
      position: new math_lib["n" /* Vector3 */](0, 0, CAMERA_DISTANCE)
    });
    const cameraNode = scene.root.createChild({
      name: 'NavigationCubeCameraNode'
    });
    cameraNode.attach(this._camera);
    cameraNode.attach(this._cameraTransform);
    this._cameraNode = cameraNode;
    this._camera.xmag = 2.45;
    this._camera.ymag = 2.45;
    const pickRootNode = scene.root;

    this._picker.onPick.subscribe(pickRootNode, this._handlePick);
  }

  _prepareBoxCube(scene) {
    if (!this._boxOffsetY) {
      return;
    }

    const cubeNodeNames = new Set(['d_vis', 'o_text', 'o_text_bottom']);
    const cubeNodes = [];
    scene.traverse(node => {
      if (cubeNodeNames.has(node.name)) {
        cubeNodes.push(node);
      }

      return true;
    });
    cubeNodes.forEach(node => {
      const [transform] = node.getComponents([lib["jb" /* Transform */]]);

      if (!transform) {
        return;
      }

      transform.position.y += this._boxOffsetY;
      transform.state = navigation_cube_UPDATE_LOCAL | navigation_cube_UPDATE_WORLD;
    });
  }

  _hideAllArrows() {
    if (this._arrowsAreHidden) {
      return;
    }

    this._arrowsAreHidden = true;

    this._arrows.forEach(arrow => arrow.hide());
  }

  _showArrowsByView(view) {
    // @ts-ignore conjugatedViews doesn't have all View keys
    const views = conjugatedViews[view];

    if (!views) {
      return;
    }

    for (const sideView of views) {
      const arrow = this._arrows.get(sideView);

      if (!arrow) {
        continue;
      }

      arrow.show();
    }

    this._arrowsAreHidden = false;
  }

  async _setView(view) {
    const target = this._controls.target.clone();

    const position = this._controls.cameraTransform.position.clone();

    const dist = target.distance(position);
    const dist2 = dist * Math.sqrt(2) / 2;
    const dist3 = dist * Math.sqrt(3) / 3;

    switch (view) {
      // SIMPLE
      case View.TOP:
        position.set(0, dist, 0).add(target);
        break;

      case View.BOTTOM:
        position.set(0, -dist, 0).add(target);
        break;

      case View.LEFT:
        position.set(-dist, 0, 0).add(target);
        break;

      case View.RIGHT:
        position.set(dist, 0, 0).add(target);
        break;

      case View.FRONT:
        position.set(0, 0, dist).add(target);
        break;

      case View.BACK:
        position.set(0, 0, -dist).add(target);
        break;
      // TOP

      case View.EDGE_TOP_FRONT:
        position.set(0, dist2, dist2).add(target);
        break;

      case View.EDGE_TOP_BACK:
        position.set(0, dist2, -dist2).add(target);
        break;

      case View.EDGE_TOP_LEFT:
        position.set(-dist2, dist2, 0).add(target);
        break;

      case View.EDGE_TOP_RIGHT:
        position.set(dist2, dist2, 0).add(target);
        break;

      case View.CORNER_TOP_LEFT_FRONT:
        position.set(-dist3, dist3, dist3).add(target);
        break;

      case View.CORNER_TOP_RIGHT_FRONT:
        position.set(dist3, dist3, dist3).add(target);
        break;

      case View.CORNER_TOP_LEFT_BACK:
        position.set(-dist3, dist3, -dist3).add(target);
        break;

      case View.CORNER_TOP_RIGHT_BACK:
        position.set(dist3, dist3, -dist3).add(target);
        break;
      // BOTTOM

      case View.EDGE_BOTTOM_FRONT:
        position.set(0, -dist2, dist2).add(target);
        break;

      case View.EDGE_BOTTOM_BACK:
        position.set(0, -dist2, -dist2).add(target);
        break;

      case View.EDGE_BOTTOM_LEFT:
        position.set(-dist2, -dist2, 0).add(target);
        break;

      case View.EDGE_BOTTOM_RIGHT:
        position.set(dist2, -dist2, 0).add(target);
        break;

      case View.CORNER_BOTTOM_LEFT_FRONT:
        position.set(-dist3, -dist3, dist3).add(target);
        break;

      case View.CORNER_BOTTOM_RIGHT_FRONT:
        position.set(dist3, -dist3, dist3).add(target);
        break;

      case View.CORNER_BOTTOM_LEFT_BACK:
        position.set(-dist3, -dist3, -dist3).add(target);
        break;

      case View.CORNER_BOTTOM_RIGHT_BACK:
        position.set(dist3, -dist3, -dist3).add(target);
        break;
      // EDGE

      case View.EDGE_LEFT_FRONT:
        position.set(-dist2, 0, dist2).add(target);
        break;

      case View.EDGE_RIGHT_FRONT:
        position.set(dist2, 0, dist2).add(target);
        break;

      case View.EDGE_LEFT_BACK:
        position.set(-dist2, 0, -dist2).add(target);
        break;

      case View.EDGE_RIGHT_BACK:
        position.set(dist2, 0, -dist2).add(target);
        break;

      default:
        return;
    }

    this._hideAllArrows();

    await this._moveCamera.moveCameraToPosition({
      position,
      target
    }, 500);

    this._layers.layer3dNavigationCube.setNeedsDrawOnce($navigationCube);

    this._view = view;

    this._showArrowsByView(view);
  }

}
// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/vectors.js
var vectors = __webpack_require__(8);

// EXTERNAL MODULE: /home/kirill/projects/industrial/node_modules/@wgetemp/math/lib/matrices.js
var matrices = __webpack_require__(82);

// CONCATENATED MODULE: ./src/features/distance-calculator/distance-module/utils.ts


const utils_EPS = 0.0000001;
const plVec1 = new vectors["b" /* Vector3 */]();
const plVec2 = new vectors["b" /* Vector3 */]();
function pointToLine(result, point, start, end) {
  plVec1.copy(end).subtract(start);
  plVec2.copy(point).subtract(start);
  let t = plVec2.dot(plVec1) / plVec1.dot(plVec1);
  t = Math.min(Math.max(t, 0), 1);
  const distance = plVec1.multiplyNumber(t).add(start).distance(point);

  if (distance > result.distance) {
    return;
  }

  result.distance = distance;
  result.start.copy(point);
  result.end.copy(plVec1);
}
const ptVec1 = new vectors["b" /* Vector3 */]();
const ptVec2 = new vectors["b" /* Vector3 */]();
const ptVec3 = new vectors["b" /* Vector3 */]();
const ptVec4 = new vectors["b" /* Vector3 */]();
function pointToTriangle(result, point, vert0, vec0, vec1, normal, matrix) {
  ptVec3.copy(point).subtract(vert0);
  const t = normal.dot(ptVec3);
  ptVec4.copy(normal).multiplyNumber(t);
  ptVec3.subtract(ptVec4);
  ptVec4.copy(ptVec3).add(vert0);
  ptVec3.applyLinearMatrix(matrix);
  ptVec1.copy(vert0).add(vec0);
  ptVec2.copy(vert0).add(vec1);

  if (ptVec3.x < 0) {
    // calc edge v0-v1
    pointToLine(result, point, vert0, ptVec2);
  } else if (ptVec3.y < 0) {
    // calc edge v0-v2
    pointToLine(result, point, vert0, ptVec1);
  } else if (ptVec3.x + ptVec3.y > 1) {
    // calc edge v1-v2
    pointToLine(result, point, ptVec1, ptVec2);
  } else {
    // calc in triangle
    const distance = ptVec4.distance(point);

    if (distance > result.distance) {
      return;
    }

    result.distance = distance;
    result.start.copy(point);
    result.end.copy(ptVec4);
  }
}
const uVec = new vectors["b" /* Vector3 */]();
const vVec = new vectors["b" /* Vector3 */]();
const wVec = new vectors["b" /* Vector3 */]();
function edgeToEdge(result, start0, end0, start1, end1) {
  uVec.copy(end0).subtract(start0);
  vVec.copy(end1).subtract(start1);
  const c = uVec.dot(uVec);
  const d = vVec.dot(vVec);
  const e = uVec.dot(vVec);
  const factor = e * e - c * d;

  if (Math.abs(factor) < utils_EPS) {
    // Parallel lines
    const lengthFactor = 1 / uVec.dot(uVec);
    let distance = 0;
    vVec.copy(start1).subtract(start0);
    const start = uVec.dot(vVec) * lengthFactor;

    if (start >= 0 && start <= 1) {
      distance = uVec.multiplyNumber(start).add(start0).distance(start1);

      if (distance > result.distance) {
        return;
      }

      result.distance = distance;
      result.start.copy(uVec);
      result.end.copy(start1);
      return;
    }

    vVec.copy(end1).subtract(start0);
    const end = uVec.dot(vVec) * lengthFactor;

    if (end >= 0 && end <= 1) {
      distance = uVec.multiplyNumber(end).add(start0).distance(end1);

      if (distance > result.distance) {
        return;
      }

      result.distance = distance;
      result.start.copy(uVec);
      result.end.copy(end1);
      return;
    }

    const length = uVec.length;
    const tStart = start > 0 ? start - length : Math.abs(start);
    const tEnd = end > 0 ? end - length : Math.abs(end);

    if (tStart > tEnd) {
      if (end > 0) {
        uVec.copy(end0);
      } else {
        uVec.copy(start0);
      }

      vVec.copy(end1);
    } else {
      if (start > 0) {
        uVec.copy(end0);
      } else {
        uVec.copy(start0);
      }

      vVec.copy(start1);
    }

    distance = uVec.distance(vVec);

    if (distance > result.distance) {
      return;
    }

    result.distance = distance;
    result.start.copy(uVec);
    result.end.copy(vVec);
  } else {
    // Skew lines
    wVec.copy(start0).subtract(start1);
    const a = wVec.dot(uVec);
    const b = wVec.dot(vVec);
    const t = Math.min(Math.max((a * d - b * e) / factor, 0), 1);
    const s = Math.min(Math.max((a * e - b * c) / factor, 0), 1);
    uVec.multiplyNumber(t).add(start0);
    vVec.multiplyNumber(s).add(start1);
    const distance = uVec.distance(vVec);

    if (distance > result.distance) {
      return;
    }

    result.distance = distance;
    result.start.copy(uVec);
    result.end.copy(vVec);
  }
}
const etVec1 = new vectors["b" /* Vector3 */]();
const etVec2 = new vectors["b" /* Vector3 */]();
function edgeToTriangle(result, start, end, vert0, vec0, vec1, normal, matrix) {
  // intersection point
  const startDist = etVec1.copy(start).subtract(vert0).dot(normal);
  const endDist = etVec1.copy(end).subtract(vert0).dot(normal);

  if (Math.abs(startDist) + Math.abs(endDist) > utils_EPS) {
    if (startDist * endDist < 0) {
      etVec1.copy(end).subtract(start).multiplyNumber(startDist / (startDist - endDist)).add(start);
      pointToTriangle(result, etVec1, vert0, vec0, vec1, normal, matrix);
    }
  } // edge to triangle edges


  etVec1.copy(vert0).add(vec0);
  etVec2.copy(vert0).add(vec1);
  edgeToEdge(result, start, end, vert0, etVec1);
  edgeToEdge(result, start, end, etVec1, etVec2);
  edgeToEdge(result, start, end, etVec2, vert0);
}
const ttVec1 = new vectors["b" /* Vector3 */]();
const ttVec2 = new vectors["b" /* Vector3 */]();
const ttNormal = new vectors["b" /* Vector3 */]();
const ttLinMatrix = new matrices["d" /* LinearMatrix3 */]();
function triangleToTriangle(result, vert0, vert1, vert2, vert3, vert4, vert5) {
  // quick check
  const dist = vert0.distance(vert3) - Math.max(vert0.distance(vert1), vert0.distance(vert2), vert1.distance(vert2)) - Math.max(vert3.distance(vert4), vert3.distance(vert5), vert4.distance(vert5));

  if (dist > result.distance) {
    return;
  } // Edges first triangle with second triangle


  ttVec1.copy(vert4).subtract(vert3);
  ttVec2.copy(vert5).subtract(vert3);
  ttNormal.copy(ttVec1).cross(ttVec2);

  if (ttNormal.length < utils_EPS) {
    return;
  }

  ttNormal.normalize();
  ttLinMatrix.axisXCopy(ttVec1).axisYCopy(ttVec2).axisZCopy(ttNormal).invert(); // points

  pointToTriangle(result, vert0, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  pointToTriangle(result, vert1, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  pointToTriangle(result, vert2, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix); // edges

  edgeToTriangle(result, vert0, vert1, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  edgeToTriangle(result, vert1, vert2, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  edgeToTriangle(result, vert2, vert0, vert3, ttVec1, ttVec2, ttNormal, ttLinMatrix); // Edges second triangle with first triangle

  ttVec1.copy(vert1).subtract(vert0);
  ttVec2.copy(vert2).subtract(vert0);
  ttNormal.copy(ttVec1).cross(ttVec2);

  if (ttNormal.length < utils_EPS) {
    return;
  }

  ttNormal.normalize();
  ttLinMatrix.axisXCopy(ttVec1).axisYCopy(ttVec2).axisZCopy(ttNormal).invert(); // points

  pointToTriangle(result, vert3, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  pointToTriangle(result, vert4, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  pointToTriangle(result, vert5, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix); // edges

  edgeToTriangle(result, vert3, vert4, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  edgeToTriangle(result, vert4, vert5, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);
  edgeToTriangle(result, vert5, vert3, vert0, ttVec1, ttVec2, ttNormal, ttLinMatrix);
}
// EXTERNAL MODULE: ./src/global-helpers/worker.ts
var worker = __webpack_require__(83);

// EXTERNAL MODULE: ./src/features/distance-calculator/distance-module/calculate-parts.worker.ts
var calculate_parts_worker = __webpack_require__(242);
var calculate_parts_worker_default = /*#__PURE__*/__webpack_require__.n(calculate_parts_worker);

// CONCATENATED MODULE: ./src/features/distance-calculator/distance-module/index.ts


 // @ts-ignore worker-loader import


const tmpVec0 = new vectors["b" /* Vector3 */]();
const tmpVec1 = new vectors["b" /* Vector3 */]();
const tmpVec2 = new vectors["b" /* Vector3 */]();
const tmpVec3 = new vectors["b" /* Vector3 */]();
const tmpVec4 = new vectors["b" /* Vector3 */]();
const tmpVec5 = new vectors["b" /* Vector3 */]();
function calculateDistance(result, pos0, idx0, mat0, pos1, idx1, mat1) {
  for (let i = 0; i < idx0.length; i += 3) {
    for (let j = 0; j < idx1.length; j += 3) {
      tmpVec0.set(pos0[idx0[i + 0] * 3], pos0[idx0[i + 0] * 3 + 1], pos0[idx0[i + 0] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec1.set(pos0[idx0[i + 1] * 3], pos0[idx0[i + 1] * 3 + 1], pos0[idx0[i + 1] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec2.set(pos0[idx0[i + 2] * 3], pos0[idx0[i + 2] * 3 + 1], pos0[idx0[i + 2] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec3.set(pos1[idx1[j + 0] * 3], pos1[idx1[j + 0] * 3 + 1], pos1[idx1[j + 0] * 3 + 2]).applyAffineMatrix(mat1);
      tmpVec4.set(pos1[idx1[j + 1] * 3], pos1[idx1[j + 1] * 3 + 1], pos1[idx1[j + 1] * 3 + 2]).applyAffineMatrix(mat1);
      tmpVec5.set(pos1[idx1[j + 2] * 3], pos1[idx1[j + 2] * 3 + 1], pos1[idx1[j + 2] * 3 + 2]).applyAffineMatrix(mat1);
      triangleToTriangle(result, tmpVec0, tmpVec1, tmpVec2, tmpVec3, tmpVec4, tmpVec5);
    }
  }

  return result;
}
async function calculateDistanceAsync(result, pos0, idx0, mat0, pos1, idx1, mat1) {
  for (let i = 0; i < idx0.length; i += 3) {
    for (let j = 0; j < idx1.length; j += 3) {
      tmpVec0.set(pos0[idx0[i + 0] * 3], pos0[idx0[i + 0] * 3 + 1], pos0[idx0[i + 0] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec1.set(pos0[idx0[i + 1] * 3], pos0[idx0[i + 1] * 3 + 1], pos0[idx0[i + 1] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec2.set(pos0[idx0[i + 2] * 3], pos0[idx0[i + 2] * 3 + 1], pos0[idx0[i + 2] * 3 + 2]).applyAffineMatrix(mat0);
      tmpVec3.set(pos1[idx1[j + 0] * 3], pos1[idx1[j + 0] * 3 + 1], pos1[idx1[j + 0] * 3 + 2]).applyAffineMatrix(mat1);
      tmpVec4.set(pos1[idx1[j + 1] * 3], pos1[idx1[j + 1] * 3 + 1], pos1[idx1[j + 1] * 3 + 2]).applyAffineMatrix(mat1);
      tmpVec5.set(pos1[idx1[j + 2] * 3], pos1[idx1[j + 2] * 3 + 1], pos1[idx1[j + 2] * 3 + 2]).applyAffineMatrix(mat1);
      triangleToTriangle(result, tmpVec0, tmpVec1, tmpVec2, tmpVec3, tmpVec4, tmpVec5);

      if ((i * idx1.length + j) % 100000 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  }

  return result;
}
async function calculateDistanceThreads(threadsNumber, entryResult, pos0, idx0, mat0, pos1, idx1, mat1) {
  const calculateDistanceParts = Object(worker["a" /* createWorker */])(calculate_parts_worker_default.a);
  const tasks = [];

  for (let threadIndex = 0; threadIndex < threadsNumber; threadIndex++) {
    const task = calculateDistanceParts(threadIndex, threadsNumber, entryResult, pos0, idx0, mat0, pos1, idx1, mat1);
    tasks.push(task);
  }

  const partResults = await Promise.all(tasks); // Choose result with minimum distance

  let bestResult = partResults[0];

  for (let i = 1; i < partResults.length; i++) {
    if (partResults[i].distance < bestResult.distance) {
      bestResult = partResults[i];
    }
  }

  return bestResult;
}
// CONCATENATED MODULE: ./src/features/distance-calculator/index.ts
function distance_calculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const THREADS_NUMBER = 4;

async function waitRenderableReady(renderable) {
  if (!renderable.geometry.unloaded) {
    return;
  }

  return new Promise(resolve => renderable.geometry.onLoad.subscribe(resolve));
}

class distance_calculator_DistanceCalculator {
  constructor({
    structure,
    layers
  }) {
    distance_calculator_defineProperty(this, "_structure", void 0);

    distance_calculator_defineProperty(this, "_layers", void 0);

    this._structure = structure;
    this._layers = layers;
  }

  async calculate(id0, id1) {
    const scene = this._layers.layer3dMain.scene;

    if (!scene) {
      throw new Error('Scene doesn\'t exists');
    }

    let result = {
      distance: Infinity,
      start: new math_lib["n" /* Vector3 */](),
      end: new math_lib["n" /* Vector3 */]()
    };

    const renderables0 = this._structure.get(id0);

    const renderables1 = this._structure.get(id1);

    let matrix0;
    let matrix1;

    for (const renderable0 of renderables0) {
      if (renderable0.geometry.primitiveType !== lib["O" /* PrimitiveType */].TRIANGLES) {
        continue;
      }

      await waitRenderableReady(renderable0);

      for (const renderable1 of renderables1) {
        if (renderable1.geometry.primitiveType !== lib["O" /* PrimitiveType */].TRIANGLES) {
          continue;
        }

        await waitRenderableReady(renderable1); // Suppose that all renderables0 have the same matrix. Same situation for renderables1

        if (!matrix0) {
          matrix0 = scene.getWorldMatrix(renderable0);
        }

        if (!matrix1) {
          matrix1 = scene.getWorldMatrix(renderable1);
        }

        result = await calculateDistanceThreads(THREADS_NUMBER, result, renderable0.geometry.attributes.get(lib["d" /* AttributeSemantic */].POSITION).view, renderable0.geometry.indices.view, matrix0, renderable1.geometry.attributes.get(lib["d" /* AttributeSemantic */].POSITION).view, renderable1.geometry.indices.view, matrix1);
      }
    }

    if (result.distance === Infinity) {
      throw new Error('Objects do not have triangulated geometry');
    }

    return result;
  }

}
// CONCATENATED MODULE: ./src/app.ts
function app_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






























const nullPosition = new math_lib["n" /* Vector3 */]();
const app_packageInfo = package_0;
class app_App {
  // services
  // features
  // DOM containers
  constructor(container, apiEvents) {
    app_defineProperty(this, "core", void 0);

    app_defineProperty(this, "store", void 0);

    app_defineProperty(this, "structure", void 0);

    app_defineProperty(this, "resources", void 0);

    app_defineProperty(this, "controls", void 0);

    app_defineProperty(this, "customAnimationManager", void 0);

    app_defineProperty(this, "environment", void 0);

    app_defineProperty(this, "layers", void 0);

    app_defineProperty(this, "picker", void 0);

    app_defineProperty(this, "input", void 0);

    app_defineProperty(this, "gl", void 0);

    app_defineProperty(this, "measure", void 0);

    app_defineProperty(this, "moveCamera", void 0);

    app_defineProperty(this, "filter", void 0);

    app_defineProperty(this, "edgeGeometry", void 0);

    app_defineProperty(this, "points", void 0);

    app_defineProperty(this, "color", void 0);

    app_defineProperty(this, "sectionBox", void 0);

    app_defineProperty(this, "explode", void 0);

    app_defineProperty(this, "navigationCube", void 0);

    app_defineProperty(this, "sectoring", void 0);

    app_defineProperty(this, "axes", void 0);

    app_defineProperty(this, "distanceCalculator", void 0);

    app_defineProperty(this, "logger", void 0);

    app_defineProperty(this, "performance", void 0);

    app_defineProperty(this, "container", void 0);

    app_defineProperty(this, "apiEvents", void 0);

    app_defineProperty(this, "_needsHoverUpdate", false);

    app_defineProperty(this, "_mainLoop", time => {
      this.gl.time.update();

      if (this.store.stats.works) {
        if (this.store.stats.needsUpdate !== this.layers.layer3dMain.needsDraw) {
          this.store.stats.setNeedsUpdate(this.layers.layer3dMain.needsDraw);
        }
      }

      this.layers.draw(time);

      if (this.store.load.isLoaded) {
        this.picker.pick();
      }

      if (this.layers.layer3dMain.drawingState === DrawingState.DRAWING) {
        this._needsHoverUpdate = true;
      }

      if (this.layers.layer3dMain.drawingState === DrawingState.IDLE && this._needsHoverUpdate && this.store.load.isLoaded) {
        this.picker.hover();
        this._needsHoverUpdate = false;
      }

      requestAnimationFrame(this._mainLoop);
    });

    app_defineProperty(this, "_handleLoadChunk", async () => {
      this.layers.setNeedsUpdate(layers_Layers.NeedsUpdate.SORT_MAP);
      this.layers.setNeedsUpdate(layers_Layers.NeedsUpdate.LOADED_CHUNK);
      await this.layers.renderLayer($loadedChunkLayerTag, this.layers.layer3dMain, {
        sort: true,
        culling: true
      });
      await this.layers.renderLayer($loadedChunkLayerTag, this.layers.layer3dColored, {
        culling: true
      });
    });

    app_defineProperty(this, "_handleClickMainLayer", event => {
      const {
        device,
        hitPosition,
        hitNormal,
        hitId
      } = event;

      if (!device.position || hitId === undefined) {
        return;
      }

      this.store.click.click(hitId, hitPosition, device.position.clone(), hitNormal);
      this.store.select.clickToObject(hitId);
    });

    app_defineProperty(this, "_handleMissClickMainLayer", event => {
      const {
        device
      } = event;

      if (!device || !device.position) {
        return;
      }

      this.store.click.click(null, null, device.position.clone(), null);
      this.store.select.clickToObject(null);
    });

    // eslint-disable-next-line no-console
    console.log(`${app_packageInfo.name}@${app_packageInfo.version} %c${ false ? undefined : ''}`, 'color: blue');

    if (!Object(global_helpers["g" /* detectWebGl */])()) {
      throw new Error('Can\'t initialize WebGL');
    }

    if (!(container instanceof HTMLElement)) {
      throw new Error('First argument should be HTMLElement');
    }

    this.container = container;
    this.apiEvents = apiEvents;

    if (container.children.length > 0) {
      console.warn('Container DOM element should be empty');
    }

    const structure = new structure_Structure();
    this.structure = structure;
    const store = new store_Store({
      structure,
      apiEvents
    });
    this.store = store;
    const gl = new gl_GL({
      container,
      store
    });
    this.gl = gl;
    const core = new lib["j" /* Core */]({
      domContainer: container,
      renderer: gl.renderer
    });
    this.core = core;
    core.regSystem(new lib["r" /* DrawSystem */](core));
    core.regSystem(new lib["c" /* AnimationSystem */](core));
    core.regSystem(new lib["g" /* CameraSystem */](core));
    core.regSystem(new lib["l" /* CubeCameraSystem */](core));
    core.regSystem(new lib["x" /* LightSystem */](core));
    core.regSystem(new lib["G" /* MeshSystem */](core));
    core.regSystem(new lib["A" /* LineSystem */](core));
    core.regSystem(new lib["eb" /* SpriteSystem */](core));
    core.regSystem(new lib["rb" /* VisibilitySystem */](core));
    core.regSystem(new lib["kb" /* TransformSystem */](core));
    core.regComponent(lib["jb" /* Transform */]);
    core.regComponent(lib["F" /* Mesh */]);
    core.regComponent(lib["cb" /* Sprite */]);
    core.regComponent(lib["w" /* Light */]);
    core.regComponent(lib["f" /* Camera */]);
    core.regComponent(lib["e" /* Bone */]);
    core.regComponent(lib["k" /* CubeCamera */]);
    core.regComponent(lib["J" /* NodeAnimation */]);
    core.regComponent(lib["qb" /* Visibility */]);
    core.regComponent(lib["y" /* Line */]);
    const resources = new core_resources["c" /* default */]({
      core,
      gl,
      structure,
      store
    });
    this.resources = resources;
    const input = new input_Input({
      domElement: container
    });
    this.input = input;
    const {
      customAttributes,
      renderer
    } = gl;
    const serviceScene = new lib["Y" /* Scene */]({
      name: 'Service Scene',
      config: {
        componentClasses: [...this.core.getComponentClassList()]
      }
    });
    const pointScene = new core_resources["a" /* IndustrialDotScene */]({
      name: 'Point Scene',
      config: {
        customAttributes,
        componentClasses: []
      }
    });
    const controls = new controls_Controls({
      input,
      store,
      time: gl.time,
      canvas: gl.canvas,
      node: serviceScene.root.createChild({
        name: 'Camera'
      })
    });
    this.controls = controls;
    const customAnimationManager = new global_helpers["a" /* CustomAnimationManager */]({
      scene: serviceScene
    });
    this.customAnimationManager = customAnimationManager;
    const layers = new layers_Layers({
      core,
      gl,
      store,
      structure,
      serviceScene,
      controls,
      pointScene,
      apiEvents
    });
    this.layers = layers;
    const picker = new picker_Picker({
      input,
      layers
    });
    this.picker = picker;
    this.environment = new core_environment_Environment({
      core,
      container,
      store,
      layers
    }); // Features:

    this.measure = new measure_Measure({
      container,
      layers,
      store,
      input,
      picker,
      apiEvents
    });
    this.moveCamera = new move_camera_MoveCamera({
      store,
      layers,
      controls,
      structure,
      customAnimationManager
    });
    this.filter = new filter_Filter({
      layers,
      store,
      structure
    });
    this.edgeGeometry = new edge_EdgeGeometry({
      layers,
      gl,
      store,
      core,
      structure
    });
    this.points = new points_Points({
      core,
      layers,
      canvas3dElement: gl.canvas,
      controls,
      store,
      structure,
      renderer,
      scene: pointScene
    });
    this.color = new color_Color({
      layers,
      store,
      structure
    });
    this.sectionBox = new section_box_SectionBox({
      layers,
      controls,
      core,
      store,
      picker,
      structure
    });
    this.explode = new explode_Explode({
      store,
      structure,
      layers,
      apiEvents
    });
    this.navigationCube = new features_navigation_cube_NavigationCube({
      store,
      controls,
      layers,
      picker,
      moveCamera: this.moveCamera,
      pivot: new math_lib["n" /* Vector3 */](0, 0.5, 0)
    });
    this.sectoring = new sectoring_SectoringController({
      core,
      renderer,
      store,
      layers,
      structure,
      controls,
      resources
    });
    this.axes = new axes_AxesFeature({
      core,
      store,
      layers,
      controls
    });
    this.distanceCalculator = new distance_calculator_DistanceCalculator({
      structure,
      layers
    });
    this.logger = new logger_Logger({
      renderer,
      store
    });
    this.performance = new performance_Performance({
      layers,
      store
    });

    this._addListeners(); // Start loop


    core.fireSystemEvent('onLoopStart');

    this._mainLoop(0);
  }

  async loadModel(modelPath, options) {
    this.controls.setDefaultOptions();
    this.store.load.setStatus(LOADING_STATE.LOADING);
    this.store.load.setUrl(modelPath);

    try {
      this.structure.reset();
      this.layers.layer3dMain.renderQueue.length = 0;
      const scene = await this.resources.loadModel(modelPath, options);
      this.layers.setMainScene(scene);
      await this.environment.updateScene(); // Reset last model render queues:

      this.layers.renderLayer('load', this.layers.layer3dMain, {
        culling: true,
        sort: true
      });
      this.layers.layer3dColored.renderQueue.length = 0;
      this.store.load.setStatus(LOADING_STATE.PREPARING);
      const bbox = this.structure.getBBox();
      this.controls.setBBox(bbox);
      await this.moveCamera.fitCameraToNodes(null);
    } catch (catchedError) {
      this.store.load.setStatus(LOADING_STATE.NONE);
      console.error(catchedError);
      throw new Error(`Can't load model "${modelPath}". ${catchedError.message}`);
    }

    this.store.load.setStatus(LOADING_STATE.LOADED);
  }

  _addListeners() {
    this.gl.canvas.addEventListener('mousemove', () => {
      this._needsHoverUpdate = true;
    });
    this.resources.onLoadChunk.subscribe(this._handleLoadChunk);
    this.controls.onActiveChange.subscribe(isActive => {
      this.layers.list.forEach(layer => layer.setNeedsDrawPermanent(controls_Controls.tag, isActive));
    });
    this.controls.onFovChange.subscribe(() => {
      this.layers.list.forEach(layer => layer.setNeedsDrawOnce(controls_Controls.tag));
    });
    const cameraPosition = {
      x: 0,
      y: 0,
      z: 0
    };
    const cameraTarget = {
      x: 0,
      y: 0,
      z: 0
    };
    this.controls.onAfterUpdate.subscribe(async hasChanged => {
      if (!hasChanged) {
        return;
      } // Wait to update camera system


      await this.layers.waitRenderEnd();
      this.apiEvents.fireEvent('camera.update', {
        type: 'camera.update',
        position: Object(global_helpers["q" /* getVector3Like */])(this.controls.cameraTransform.position, cameraPosition),
        target: Object(global_helpers["q" /* getVector3Like */])(this.controls.target, cameraTarget)
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this.store.controls.actions, () => {
      this.apiEvents.fireEvent('controls.update', {
        type: 'controls.update',
        zooming: this.store.controls.isZooming,
        rotating: this.store.controls.isRotating,
        panning: this.store.controls.isPanning
      });
    });
    this.picker.onMissClick.subscribe(this._handleMissClickMainLayer);
    Object(mobx_module["h" /* reaction */])(() => this.store.load.progress, data => {
      this.apiEvents.fireEvent('progress', {
        type: 'progress',
        loaded: data.loaded,
        total: data.total,
        chunksLoaded: data.chunksLoaded,
        chunksTotal: data.chunksTotal
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this.store.load.isLoaded, isLoaded => {
      if (!isLoaded) {
        this.layers.layer3dMain.scene = new lib["q" /* DotScene */]({
          config: {
            componentClasses: []
          }
        });
        return;
      }

      const serviceScene = this.layers.layer3dService.scene;

      if (!serviceScene) {
        return;
      }

      this.picker.onHover.subscribe(null, event => {
        if (event.hitId === undefined) {
          return;
        }

        this.store.hover.setHover(event.hitId, event.hitPosition);
      });
      this.picker.onDeHover.subscribe(() => {
        this.store.hover.setHover(null, nullPosition);
      });
      this.picker.onHover.subscribe(serviceScene.root, event => {
        if (event.hitTarget && Object(global_helpers["y" /* isNodeRaycastTransparent */])(event.hitTarget)) {
          return;
        } // Reset hover if we didn't hover something on the service scene?


        this.store.hover.setHover(null, nullPosition);
      });
      this.picker.onPick.subscribe(null, this._handleClickMainLayer);
    });
    Object(mobx_module["h" /* reaction */])(() => this.store.select.isSelecting, isSelecting => {
      if (!isSelecting) {
        return;
      }

      const idSet = new Set();

      for (const renderable of this.structure.getGroupStrict('select')) {
        idSet.add(this.structure.getElementId(renderable));
      }

      this.apiEvents.fireEvent('select', {
        type: 'select',
        ids: [...idSet]
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this.store.click.clicking, data => {
      const {
        coordinateSystemMatrix
      } = this.store.axes;

      if (data.position) {
        data.position.multiplyLinearMatrix(coordinateSystemMatrix);
      }

      if (data.normal) {
        data.normal.multiplyLinearMatrix(coordinateSystemMatrix);
      }

      this.apiEvents.fireEvent('click', {
        type: 'click',
        ...data
      });
    });
    Object(mobx_module["h" /* reaction */])(() => this.store.window.size, async ({
      width,
      height
    }) => {
      const devicePixelRatio = this.gl.renderer.pixelRatio;
      const deviceWidth = width * devicePixelRatio;
      const deviceHeight = height * devicePixelRatio;

      if (this.controls) {
        this.controls.updateDeviceSize(deviceWidth, deviceHeight);
      }

      this.gl.updateBrowserSize(width, height);
      this.layers.updateDeviceSize(deviceWidth, deviceHeight);
      await this.layers.waitRenderEnd();
      this.apiEvents.fireEvent('resize', {
        type: 'resize',
        width,
        height
      });
    });
  }

  async waitStoreReady(store) {
    if (store.isReady) {
      return Promise.resolve();
    }

    if (store.isError) {
      return Promise.reject(store.error);
    }

    return new Promise((resolve, reject) => {
      Object(mobx_module["l" /* when */])(() => store.isReady, () => resolve());
      Object(mobx_module["l" /* when */])(() => store.isError, () => reject(store.error));
    });
  }

}

/***/ }),
/* 251 */,
/* 252 */,
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IndustrialViewer", function() { return _api__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _api__WEBPACK_IMPORTED_MODULE_0__) if(["default","IndustrialViewer"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _api__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* eslint-disable no-undef */

/* harmony default export */ __webpack_exports__["default"] = (_api__WEBPACK_IMPORTED_MODULE_0__["default"]);


window.industrialViewer = window.industrialViewer || {};
window.industrialViewer.default = _api__WEBPACK_IMPORTED_MODULE_0__["default"];

/***/ }),
/* 254 */,
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TupleMap; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

class Node extends Map {
  constructor() {
    super();
    this.key = null;
    this.value = undefined;
    this.previous = null;
    this.next = null;
  }

}

class TupleMap {
  constructor(entries) {
    this._size = 0;
    this._root = new Node();
    this._first = null;
    this._last = null;

    if (entries !== undefined) {
      for (const _ref of entries) {
        var _ref2 = _slicedToArray(_ref, 2);

        const key = _ref2[0];
        const value = _ref2[1];
        this.set(key, value);
      }
    }
  }

  get size() {
    return this._size;
  }

  set(key, value) {
    // eslint-disable-next-line no-param-reassign
    key = [...key];
    let node = this._root;

    for (const subkey of key) {
      let child = node.get(subkey);

      if (child === undefined) {
        child = new Node();
        node.set(subkey, child);
      }

      node = child;
    }

    if (node.key === null) {
      const last = this._last;

      if (last === null) {
        this._first = node;
        this._last = node;
      } else {
        last.next = node;
        node.previous = last;
        this._last = node;
      }

      ++this._size;
    }

    node.key = key;
    node.value = value;
  }

  has(key) {
    let node = this._root;

    for (const subkey of key) {
      const child = node.get(subkey);

      if (child === undefined) {
        return false;
      }

      node = child;
    }

    return node.key !== null;
  }

  get(key) {
    let node = this._root;

    for (const subkey of key) {
      const child = node.get(subkey);

      if (child === undefined) {
        return;
      }

      node = child;
    }

    if (node.key === null) {
      return;
    }

    return node.value;
  }

  _delete(node, key) {
    const it = key.next();

    if (it.done) {
      if (node.key !== null) {
        const previous = node.previous,
              next = node.next;

        if (previous === null) {
          this._first = next;
        } else {
          previous.next = next;
        }

        if (next === null) {
          this._last = previous;
        } else {
          next.previous = previous;
        }

        --this._size;
      }

      node.key = null;
      node.value = null;
      return;
    }

    const subkey = it.value;
    const child = node.get(subkey);

    if (child === undefined) {
      return;
    }

    this._delete(child, key);

    if (child.key === null && child.size === 0) {
      node.delete(subkey);
    }
  }

  delete(key) {
    this._delete(this._root, key[Symbol.iterator]());
  }

  clear() {
    this._size = 0;
    const root = this._root;
    root.clear();
    root.key = null;
    root.value = null;
    root.previous = null;
    root.next = null;
    this._first = null;
    this._last = null;
  }

  forEach(callback, thisArg) {
    for (let node = this._first; node !== null; node = node.next) {
      if (this._first === null) {
        break;
      }

      callback.call(thisArg, node.value, node.key.slice(), this);
    }
  }

  *keys() {
    for (let node = this._first; node !== null; node = node.next) {
      if (this._first === null) {
        break;
      }

      yield node.key.slice();
    }
  }

  *values() {
    for (let node = this._first; node !== null; node = node.next) {
      if (this._first === null) {
        break;
      }

      yield node.value;
    }
  }

  *entries() {
    for (let node = this._first; node !== null; node = node.next) {
      if (this._first === null) {
        break;
      }

      yield [node.key.slice(), node.value];
    }
  }

  [Symbol.iterator]() {
    return this.entries();
  }

}

/***/ }),
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DefaultMap; });
class DefaultMap {
  constructor(getDefaultValue, entries, Base = Map) {
    this._base = new Base(entries);
    this.getDefaultValue = getDefaultValue;
  }

  get size() {
    return this._base.size;
  }

  set(key, value) {
    this._base.set(key, value);
  }

  has(key) {
    return this._base.has(key);
  }

  get(key) {
    const base = this._base;
    let value = base.get(key);

    if (value === undefined && !base.has(key)) {
      value = this.getDefaultValue(key);
      base.set(key, value);
    }

    return value;
  }

  delete(key) {
    this._base.delete(key);
  }

  clear() {
    this._base.clear();
  }

  forEach(callback, thisArg) {
    this._base.forEach(callback, thisArg);
  }

  keys() {
    return this._base.keys();
  }

  values() {
    return this._base.values();
  }

  entries() {
    return this._base.entries();
  }

  [Symbol.iterator]() {
    return this._base[Symbol.iterator]();
  }

}

/***/ })
/******/ ]);
});